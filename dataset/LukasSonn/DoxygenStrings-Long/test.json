[
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void IncremenetVersion(trUtil::VersionUtil &ver)\r\n{\r\n    trUtil::Console::TextColor(trUtil::Console::TXT_COLOR::BRIGHT_YELLOW);\r\n    std::cerr << TR_CURRENT_VERSION << ver.GetVersionString() << std::endl;\r\n    \r\n    ver.IncrementVersion();\r\n    ver.SaveVersionFile();\r\n\r\n    std::cerr << TR_NEW_VERSION << ver.GetVersionString() << std::endl;\r\n    trUtil::Console::TextColor(trUtil::Console::TXT_COLOR::DEFAULT);\r\n}\r\n",
        "answer": "/** @brief Increments the version in the version file. Build version gets incremented by 1 YYMM gets set to the current year and month.\n*\n* This function increments the version in the version file, sets the build version to the current year and month, and saves the new version to the file.\n*\n* @param ver The version util object that contains the current version information.\n*/\nvoid IncremenetVersion(trUtil::VersionUtil &ver)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isPindelSVIdentifier( string identifier )\n{\n   if (identifier == \"D\" || identifier == \"I\" || identifier == \"LI\" || identifier == \"TD\" || identifier == \"INV\" ) {\n      return true;\n   } else {\n      return false;\n   }\n}\n",
        "answer": "/** @brief Checks if a string represents a valid SV type in pindel output files.\n*\n*  This function takes a string as input and checks if it is a valid SV type identifier used in pindel output files.\n*  The valid SV types are: D, I, LI, TD, and INV.\n*\n* @param[in] identifier A string representing the SV type.\n* @return True if the input string is a valid SV type identifier, false otherwise.\n*/\nbool isPindelSVIdentifier(string identifier) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "alpinocorpus_reader alpinocorpus_open_recursive(char const *path)\n{\n#if defined(USE_DBXML)\n    alpinocorpus::CorpusReader *reader = 0;\n\n    try {\n        reader = alpinocorpus::CorpusReaderFactory::openRecursive(path);\n    } catch (std::exception const &) {\n        return NULL;\n    }\n\n    return new alpinocorpus_reader_t(reader);\n#else\n    return NULL;\n#endif\n}\n",
        "answer": "/** @brief Open an Alpino treebank. Returns NULL if the corpus could not be opened. After using the reader, close it with alpinocorpus_close() to free up resources.\n*\n* This function opens an Alpino treebank and returns a pointer to the reader object. If the corpus could not be opened, this function returns NULL. It is important to note that after using the reader, you should close it with alpinocorpus_close() to free up resources.\n*\n* @param path The path to the Alpino treebank file or directory.\n* @return A pointer to the alpinocorpus_reader object if successful, NULL otherwise.\n*/\nalpinocorpus_reader alpinocorpus_open_recursive(char const *path)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tclass Mem\r\n\t{\r\n\tprotected:\r\n\t\tinline static void *MemAlloc( size_t size) {\r\n\t\t\treturn Trap::Mem_Alloc( size, __FILE__, __LINE__);\r\n\t\t}\r\n\r\n\t\tinline static void MemFree( void *mem )\t{\r\n\t\t\tTrap::Mem_Free(mem, __FILE__, __LINE__);\r\n\t\t}\r\n\t};\r\n",
        "answer": "/** @brief Allocates memory from the pool.\n*\n*  This function allocates a block of memory from the pool.\n*\n* @param size The size of the block to allocate.\n* @return A pointer to the allocated memory block.\n*/\n/** @brief Frees memory from the pool.\n*\n*  This function frees a block of memory from the pool.\n*\n* @param mem A pointer to the memory block to free.\n*/\ninline static void MemFree( void *mem )\t"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void svc_end() {\n    for(int i=0; i<n_monitors; ++i) {\n      stat_windows->at(i)->free_all();\n      delete stat_windows->at(i);\n    }\n    delete stat_windows;\n    St->wait();\n    delete St;\n    delete C;\n  }\n",
        "answer": "/** @brief Service end.\n*\n*  This function is called after the service has ended (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @param n_monitors The number of monitors to free.\n* @param stat_windows A pointer to a vector of pointers to windows that need to be freed.\n* @param St A pointer to the service thread.\n* @param C A pointer to the service client.\n* @return Should not return.\n*/\nvoid svc_end(int n_monitors, std::vector<Window*>* stat_windows, ServiceThread* St, ServiceClient* C) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n        printf(\"C received %ld tasks\\n\",received);\n    }\n",
        "answer": "/** @brief Service end.\n*\n*  This function is called after EOS arrived (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @param received The number of tasks received by the service.\n* @return Should not return.\n*/\nvoid svc_end(long received) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int create_input_buffer(int nentries, bool fixedsize=true) {\n        return ff_minode::create_input_buffer(nentries, fixedsize);\n    }\n",
        "answer": "/** @brief Creates an input buffer for the multi-input node.\n*\n*  This function creates an input buffer for the multi-input node, which can be used to store data that will be processed by the node. The buffer is created with a specified number of entries and can optionally have a fixed size.\n*\n* @param nentries The number of entries in the input buffer.\n* @param fixedsize Whether the input buffer should have a fixed size (default: true).\n* @return The ID of the created input buffer.\n*/\nint create_input_buffer(int nentries, bool fixedsize=true) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n\tprintf(\"Collector init Id= %d\\n\", transp->getProcId());\n\tff_dnode<COMM2>::init(name, address, nHosts, transp, RECEIVER, transp->getProcId());  \n\treturn 0;\n    }\n",
        "answer": "/** @brief Initializes the collector.\n*\n* This function initializes the collector by printing a message to the console and calling the `ff_dnode<COMM2>::init` function with the appropriate arguments.\n*\n* @param name The name of the collector.\n* @param address The address of the collector.\n* @param nHosts The number of hosts in the system.\n* @param transp The transport object used for communication.\n* @param RECEIVER The receiver ID for the collector.\n* @param procId The process ID of the collector.\n* @return 0 if initialization was successful, -1 otherwise.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n        return ff_setPriority(priority_level);\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n*  This function initializes the service by setting its priority level using the `ff_setPriority` function.\n*\n* @return The return value of `ff_setPriority`.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n        printf(\"Collector: woken-up\\n\");\n        ntasks=0;\n        return 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @return 0 on success, non-zero error code on failure.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "     void svc_end() {\n        printf(\"E%ld terminating\\n\",id);\n    }\n",
        "answer": "/** @brief Service end.\n*\n*  This function is called after EOS arrived (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n        if (ffalloc.registerAllocator()<0) {\n            error(\"Emitter, registerAllocator fails\\n\");\n            return -1;\n        }\n        return 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function initializes the service by registering the allocator with the fffalloc module.\n* If the registration fails, an error message is printed and -1 is returned. Otherwise, 0 is returned.\n*\n* @return Should not return\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n        printf(\"Emitter svc_end() called\\n\");\n    }\n",
        "answer": "/** @brief Emitter service end.\n*\n*  This function is called after the emitter has finished its work and before shutting down the runtime support.\n*  It can be used for housekeeping tasks such as cleaning up resources or logging statistics.\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n        printf(\"Emitter: going to sleep\\n\");\n    }\n",
        "answer": "/** @brief Service Endpoint.\n*\n*  This is the endpoint for your service.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n\tprintf(\"Emitter2 init Id= %d\\n\", transp->getProcId());\n\tff_dnode<COMM1>::init(name, address, 1, transp, RECEIVER, transp->getProcId());  \n\treturn 0;\n    }\n",
        "answer": "/** @brief svc_init function.\n*\n* This is the initialization function for the service.\n* It prints a message to the console with the process ID, and then initializes the node with the given name, address, and transport protocol.\n*\n* @param name The name of the node.\n* @param address The address of the node.\n* @param transp The transport protocol used by the node.\n* @return 0 if initialization is successful, -1 otherwise.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n        if (!ffalloc) return -1;\n        if (ffalloc->registerAllocator()<0) {\n            error(\"MU, registerAllocator fails\\n\");\n            return -1;\n        }\n        return 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @return 0 on success, -1 on failure\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n        std::cout << \"firstStage ending (\" << get_my_id() << \")\\n\";\n    }\n",
        "answer": "/** @brief Service end function.\n*\n*  This function is called after the service has ended (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n\tprintf(\"InOut0 ending\\n\");\n    }\n",
        "answer": "/** @brief Service end function.\n*\n*  This function is called after the service has ended (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() { eossent=false; return 0;}\n",
        "answer": "/** @brief Service initialization.\n*\n* This function initializes the service and sets up any necessary resources.\n* It is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream.\n*\n* @return 0 if successful, non-zero otherwise\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n\tff_dnode<zmq1_1>::init(name, address, 1,transp,false, 0);  \n\tprintf(\"Node0 start\\n\");\n\tff::ffTime(START_TIME);\n\treturn 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @param name The name of the service.\n* @param address The address of the service.\n* @param transp The transport protocol used by the service.\n* @return 0 if successful, -1 otherwise.\n*/\nint svc_init(const char *name, const char *address, int transp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n\tprintf(\"Time= %f ms\\n\", ff::ffTime(STOP_TIME));\n    }\n",
        "answer": "/** @brief Service end.\n*\n*  This function is called after EOS arrived (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n\tff_dnode<COMM>::init(name, address,1, transp,SENDER, 0, callback);  \t\n\treturn 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @param name The name of the service.\n* @param address The address of the service.\n* @param transp The transport protocol used by the service.\n* @param SENDER The sender of the service.\n* @param callback A function pointer to a callback function that will be called when an item is received from the input stream.\n* @return 0 if successful, -1 otherwise.\n*/\nint svc_init(const char *name, const char *address, int transp, SENDER sender, void (*callback)(void)) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n\tff_dnode<COMM>::init(name, address,1, transp, RECEIVER, 0);  \n\treturn 0;\n    }\n",
        "answer": "/** @brief svc_init() function.\n*\n* This function is called after run-time initialization (e.g. thread spawning) but before starting to get items from the input stream (can be useful for initializing parallel activities, e.g. manual thread pinning that cannot be done in the constructor because threads still do not exist).\n*\n* @param name The name of the node.\n* @param address The address of the node.\n* @param transp The transport protocol used by the node.\n* @param RECEIVER The receiver object for the node.\n* @return 0 if successful, -1 otherwise.\n*/\nint svc_init(const char *name, const char *address, int transp, void *RECEIVER) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n        if (!ffalloc) return -1;\n        if (ffalloc->register4free()<0) {\n            error(\"MU, register4free fails\\n\");\n            return -1;\n        }\n        return 0;\n    }\n",
        "answer": "/** @brief Service initialization.\n*\n* This function initializes the service by registering it with the free file allocator.\n*\n* @return 0 on success, -1 on failure.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() { counter_in=0; return 0;}\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function is called after run-time initialization (e.g. thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @return 0 on success, non-zero error code otherwise.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        int svc_init() {\n            return 0;\n        }\n",
        "answer": "/** @brief Initializes the service.\n*\n*  This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @return 0 if successful, non-zero otherwise\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int   svc_init() { \n        if (ffalloc.register4free()<0) {\n            error(\"register4free fails\\n\");\n            return -1;\n        }\n        \n        return 0; \n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n*  This function initializes the service by registering it with the free\n*  memory allocator and returning an error code if the registration fails.\n*\n* @return 0 on success, -1 on failure\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n        printf(\"thread %d running on cpu %d\\n\", get_my_id(), ff_getMyCore());\n        return 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @return 0 on success, non-zero error code on failure\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void unmarshalling(svector<msg_t*>* const v[], const int vlen, void *& task) {\n        assert(vlen==1 && v[0]->size()==2); \n\tff_task_t* t =static_cast<ff_task_t*>(v[0]->operator[](0)->getData());\n        t->task   =static_cast<double*>(v[0]->operator[](1)->getData());\n\ttask=t;\n    }\n",
        "answer": "/** @brief Unmarshalling function.\n*\n* This function is called once when all frames composing the message have been received by the run-time. Within that method, it is possible to convert or re-arrange all the frames back to their original data or object layout.\n* v is a vector of messages, vlen is the length of the vector, and task is a pointer to the task.\n*\n* @param[in] v A vector of pointers to msg_t objects.\n* @param[in] vlen The length of the vector v.\n* @param[out] task A pointer to the task object.\n*/\nvoid unmarshalling(svector<msg_t*>* const v[], const int vlen, void *& task) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n\tdelete [] myt;\n\tprintf(\"Worker: computed %d tasks\\n\", cnt);\n    }\n",
        "answer": "/** @brief Service end.\n*\n*  This function is called after EOS arrived (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() { std::cout << \"[Worker\" << tag << \"] \" << ff_node::get_my_id() << \" started\\n\"; return 0; } \n",
        "answer": "/** @brief Initializes the service.\n*\n*  This function is called after run-time initialization (e.g., thread spawning) but before starting to get items from the input stream. It can be useful for initializing parallel activities, such as manual thread pinning that cannot be done in the constructor because threads still do not exist.\n*\n* @return Should not return\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n        printf(\"Worker %ld gets %ld tasks\\n\", get_my_id(), ntasks);\n    }\n",
        "answer": "/** @brief Service end.\n*\n*  This function is called after EOS arrived (logical termination) but before shutting down runtime support (can be useful for housekeeping).\n*\n* @param ntasks The number of tasks that the worker has processed.\n* @return Should not return.\n*/\nvoid svc_end(long ntasks) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int svc_init() {\n\tmyt = new double[taskSize*taskSize];\n\tassert(myt);\n\tc = new double[taskSize*taskSize];\n\tassert(c);\n\tfor(unsigned j=0;j<(taskSize*taskSize);++j)\n\t    c[j] = j*1.0;\t\n\treturn 0;\n    }\n",
        "answer": "/** @brief Initializes the service.\n*\n* This function initializes the service by creating two arrays of doubles,\n* one with size taskSize*taskSize and the other with size taskSize. It then\n* sets all elements in the first array to 0 and all elements in the second\n* array to their index multiplied by 1.0.\n*\n* @return 0 on success, -1 on failure.\n*/\nint svc_init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void svc_end() {\n        printf(\"Worker2 %ld got EOS\\n\", get_my_id());\n    }\n",
        "answer": "/** @brief Service Endpoint.\n*\n*  This is the endpoint for your service.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid svc_end() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void cc_sched_destruct(cc_sched * sched) { assert(FALSE); }\n",
        "answer": "/** @brief Destruct the scheduler.\n*\n* This method will block until all currently executing jobs have finished. Any remaining scheduled jobs will be cancelled. Note that this differs from Coin-2. To emulate Coin-2 behavior, call cc_sched_wait_all() before calling this method.\n*\n* @param sched The scheduler to destruct.\n* @return Should not return.\n*/\nvoid cc_sched_destruct(cc_sched * sched) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Result UpdateLANInfo(LANInfo& info, bool& updated)\n{\n    LANInfo latest;\n    Result result = GetLANInfo(latest);\n\n    updated = (latest.Gateway != info.Gateway) ||\n        (latest.Localhost != info.Localhost);\n    info = latest;\n\n    return result;\n}\n",
        "answer": "/** @brief Updates the LAN information for a client.\n*\n*  This function is used to update the LAN information for a client. It takes in a reference to a LANInfo object and a boolean flag indicating whether the information has been updated or not. The function returns a Result object, which can be used to check if the operation was successful.\n*\n* @param info A reference to the LANInfo object that needs to be updated.\n* @param updated A boolean flag indicating whether the information has been updated or not.\n* @return A Result object indicating the success or failure of the operation.\n*/\nResult UpdateLANInfo(LANInfo& info, bool& updated)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_bCanFakeDeath = true;\n        m_bFakeDeath    = false;\n\n        m_creature->SetStandState(UNIT_STAND_STATE_STAND);\n        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);\n        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function is used to reset combat variables for an AI creature. It is called by default on creature evade and respawn, and is usually also called in the constructor of the AI.\n*\n* @param m_creature The creature whose combat variables are being reset.\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiEnrageTimer = 6*MINUTE*IN_MILLISECONDS;\n        m_uiPyrogenicsTimer     = 20000;\n        m_uiFlameTouchedTimer   = 30000;\n        m_uiConflagrationTimer  = urand(25000, 30000);\n        m_uiBlazeTimer          = 1000;\n        m_uiFlameSearTimer      = 5000;\n        m_bDidIntro = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables and is called by default on creature evade and respawn. In most scripts, it is also called in the constructor of the AI.\n*\n* @param m_uiEnrageTimer The timer for enrage.\n* @param m_uiPyrogenicsTimer The timer for pyrogenics.\n* @param m_uiFlameTouchedTimer The timer for flame touched.\n* @param m_uiConflagrationTimer The timer for conflagration.\n* @param m_uiBlazeTimer The timer for blaze.\n* @param m_uiFlameSearTimer The timer for flame sear.\n* @param m_bDidIntro A boolean indicating whether the intro has been done or not.\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiLastSuperSpell      = urand(SUPER_FLAME_WREATH, SUPER_ARCANE_EXPL);\n        m_uiLastNormalSpell     = urand(0, 2);\n\n        m_uiSecondarySpellTimer = 5000;\n        m_uiNormalCastTimer     = 0;\n        m_uiSuperCastTimer      = 35000;\n        m_uiManaRecoveryTimer   = 0;\n        m_uiManaRecoveryStage   = 0;\n        m_uiBerserkTimer        = 12*MINUTE*IN_MILLISECONDS;\n\n        m_bElementalsSpawned    = false;\n        m_bIsDrinking           = false;\n        m_bDrinkInturrupted     = false;\n\n        SetCombatMovement(true);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function resets all combat-related variables to their default values. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiStingerSprayTimer   = urand(20000, 30000);\n        m_uiPoisonStingerTimer  = 5000;\n        m_uiSummonSwarmerTimer  = 5000;\n        m_uiSwarmerAttackTimer  = 60000;\n        m_uiParalyzeTimer       = 15000;\n        m_uiLashTimer           = urand(5000, 8000);\n        m_uiTrashTimer          = urand(3000, 6000);\n\n        m_bHasFrenzy            = false;\n\n        m_uiPhase = PHASE_AIR;\n        SetCombatMovement(false);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function resets the combat variables for the AI, usually called by default on creature evade and respawn.\n*  In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiInciteChaosTimer = 50000;\n        m_uiChargeTimer      = urand(30000, 37000);\n        m_uiKnockbackTimer   = urand(10000, 14000);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This function is used to reset combat variables for an AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_uiInciteChaosTimer The timer for inciting chaos.\n* @param m_uiChargeTimer The timer for charging.\n* @param m_uiKnockbackTimer The timer for knockback.\n*\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiShootTimer          = 1000;\n        m_uiPummelTimer         = 7000;\n        m_uiKnockAwayTimer      = 11000;\n        m_uiSummonRiflemanTimer = 15000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement Usally used to reset combat variables Called by default on creature evade and respawn In most scripts also called in the constructor of the AI\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiArcaneMissilesTimer = 4500;\n        m_uiShadowShieldTimer = 12000;\n        m_uiCurseTimer = 2000;\n        m_uiTeleportTimer = 16000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiEventCounter = 1;\n\n        m_uiSeepingFogTimer = urand(15000, 20000);\n        m_uiNoxiousBreathTimer = 8000;\n        m_uiTailsweepTimer = 4000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_statAuraGuid.Clear();\n\n        AggroYellTimer = 5000;\n        FixateTimer = 5000;\n        EnrageTimer = 30000;\n        SoulDrainTimer = 150000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This function is used to reset combat variables for an AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiWaterBoltVolleyTimer = 35000;\n        m_uiTidalSurgeTimer      = urand(15000, 20000);\n        m_uiHealTimer            = 55000;\n        m_uiCycloneTimer         = urand(10000, 15000);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @param m_uiWaterBoltVolleyTimer The timer for water bolt volleys.\n* @param m_uiTidalSurgeTimer The timer for tidal surges.\n* @param m_uiHealTimer The timer for heals.\n* @param m_uiCycloneTimer The timer for cyclones.\n*\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        boss_thaddiusAddsAI::Reset();\n        m_uiStaticFieldTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);\n        m_uiMagneticPullTimer = 20*IN_MILLISECONDS;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts it is also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiMortalWoundTimer  = 10000;\n        m_uiDecimateTimer     = 110000;\n        m_uiEnrageTimer       = 25000;\n        m_uiSummonTimer       = 6000;\n        m_uiRoarTimer         = 15000;\n        m_uiZombieSearchTimer = 3000;\n\n        m_uiBerserkTimer      = MINUTE*8*IN_MILLISECONDS;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiBloodboilTimer      = 10000;\n        m_uiBloodboilCount      = 0;\n        m_uiAcidGeyserTimer     = 1000;\n        m_uiAcidicWoundTimer    = 6000;\n        m_uiArcingSmashTimer    = 19000;\n        m_uiFelAcidTimer        = 25000;\n        m_uiEjectTimer          = 10000;\n        m_uiStrikeTimer         = 15000;\n        m_uiPhaseChangeTimer    = MINUTE*IN_MILLISECONDS;\n        m_uiBerserkTimer        = 10*MINUTE*IN_MILLISECONDS;\n\n        m_bIsPhase1             = true;\n    }\n",
        "answer": "/**\n* @brief Resets combat variables.\n*\n* This function resets all combat-related variables to their default values. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiManaBurnTimer   = urand(4000, 10000);\n        m_uiSleepTimer      = urand(10000, 18000);\n        m_uiEarthShockTimer = urand(7000, 14000);\n        m_uiIllusionsTimer  = urand(10000, 18000);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiArcingSmashTimer    = urand(8000, 14000);\n        m_uiMightyBlowTimer     = urand(15000, 25000);\n        m_uiWhirlwindTimer      = 30000;\n        m_uiChargeTimer         = 2000;\n        m_uiFearTimer           = urand(10000, 25000);\n        m_uiCouncilDeathCount   = 0;\n        m_bPhase2               = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function resets combat variables to their initial values, usually called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiCurseOfBloodTimer = 5000;\n        m_uiIllusionTimer = 15000;\n        m_uiBanishTimer = urand(9000, 13000);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This function resets the combat variables for an AI.\n* It is called by default on creature evade and respawn,\n* and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiShadowVolleyTimer   = 1000;\n        m_uiBurningNovaTimer    = 15000;\n        m_uiCorruptionTimer     = 5000;\n        m_uiFirenovaTimer       = 0;\n        m_uiKilledAdds          = 0;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. Usally used to reset combat variables Called by default on creature evade and respawn In most scripts also called in the constructor of the AI\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_bEnraged = false;\n\n        m_uiMortalWoundTimer = urand(8000, 10000);\n        m_uiSandTrapTimer    = urand(5000, 10000);\n        m_uiTrashTimer       = urand(1000, 5000);\n        m_uiWideSlashTimer   = urand(10000, 15000);\n        m_uiTrapTriggerTimer = 0;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiBanishTimer     = 10000;\n        m_uiWhirlwindTimer  = 18500;\n        m_uiInnerDemonTimer = 27500;\n        m_uiSwitchTimer     = 60000;\n        m_uiChaosBlastTimer = 0;\n        m_uiFinalFormTimer  = 0;\n        m_uiEnrageTimer     = 10*MINUTE*IN_MILLISECONDS;\n\n        m_bDemonForm        = false;\n        m_bIsFinalForm      = false;\n\n        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);\n        SetCombatMovement(true);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_uiBanishTimer     The timer for the banish ability.\n* @param m_uiWhirlwindTimer  The timer for the whirlwind ability.\n* @param m_uiInnerDemonTimer The timer for the inner demon ability.\n* @param m_uiSwitchTimer     The timer for the switch ability.\n* @param m_uiChaosBlastTimer The timer for the chaos blast ability.\n* @param m_uiFinalFormTimer  The timer for the final form ability.\n* @param m_uiEnrageTimer     The timer for the enrage ability.\n* @param m_bDemonForm        A boolean indicating whether the demon form is active or not.\n* @param m_bIsFinalForm      A boolean indicating whether the final form is active or not.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiBerserkTimer    = 20*MINUTE*IN_MILLISECONDS;\n        m_uiQuakeTimer      = 30000;\n        m_uiBlazeTimer      = urand(10000, 15000);\n        m_uiBlastNovaTimer  = 60000;\n        m_uiCleaveTimer     = 15000;\n        m_uiTransitionTimer = 0;\n        m_uiTransitionCount = 0;\n        m_uiDebrisTimer     = urand(20000, 30000);\n\n        m_bIsPhase3         = false;\n\n        SetCombatMovement(true);\n\n        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function resets the combat variables for the AI, including timers and flags. It is called by default on creature evade and respawn, and is usually also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiWatchTimer          = 33000;\n        m_uiCleaveTimer         = 7000;\n        m_uiWhirlwindTimer      = 20000;\n        m_uiFearTimer           = 1000;\n        m_uiMortalStrikeTimer   = 1000;\n        m_uiCheckTimer          = 1000;\n\n        m_uiKillCount           = 0;\n\n        m_fTargetThreat         = 0.0f;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiTrampleTimer            = 9000;\n        m_uiManaDrainTimer          = 3000;\n        m_uiSummonManaFiendsTimer   = 90000;\n        m_uiCheckoutManaTimer       = 1500;\n        m_uiPhase                   = PHASE_ATTACKING;\n        m_creature->SetPower(POWER_MANA, 0);\n        m_creature->SetMaxPower(POWER_MANA, 0);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is an internal function that every AI must implement. It is usually called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_uiTrampleTimer The timer for the trample ability.\n* @param m_uiManaDrainTimer The timer for the mana drain ability.\n* @param m_uiSummonManaFiendsTimer The timer for summoning mana fiends.\n* @param m_uiCheckoutManaTimer The timer for checking mana.\n* @param m_uiPhase The current phase of combat.\n* @param m_creature The creature that is being reset.\n*\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiChangeFormTimer         = 45000;\n        m_uiBrutalSwipeTimer        = 12000;\n        m_uiMangleTimer             = 15000;\n        m_uiSurgeTimer              = 20000;\n        m_uiLaceratingSlashTimer    = 6000;\n        m_uiRendFleshTimer          = 6000;\n        m_uiDeafeningRoarTimer      = 20000;\n        m_uiBerserkTimer            = 10*MINUTE*IN_MILLISECONDS;\n        m_bIsInBearForm             = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiToxicVolleyTimer   = 7000;\n        m_uiUppercutTimer      = 16000;\n        m_uiSummonTimer         = 19000;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This is a SD2 internal function, that every AI must implement.\n* Usally used to reset combat variables Called by default on creature evade and respawn In most scripts also called in the constructor of the AI\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiBlastWaveTimer = 20000;\n        m_uiShoutTimer     = 2000;\n        m_uiCleaveTimer    = 6000;\n        m_uiKnockawayTimer = 12000;\n        m_bSummoned = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This function is used to reset combat variables for an AI. It is called by default on creature evade and respawn, and in most scripts it is also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        DespawnEssences();\n\n        SoulDeathCount = 0;\n        Phase = 0;\n        SummonEssenceTimer = 8000;\n        DespawnEssenceTimer = 2000;\n        SoulCount = 0;\n        SummonSoulTimer = 1000;\n        AnimationTimer = 8000;\n\n        IsDead = false;\n        EndingPhase = false;\n\n        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);\n        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);\n        m_creature->HandleEmote(EMOTE_ONESHOT_NONE);\n        m_creature->GetMotionMaster()->Clear(false);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is an internal function that every AI must implement. It is usually called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiWhirlWindTimer = 30000;\n        m_uiWhirlWindRandomTimer = urand(3000, 7000);\n        m_uiWhirlWindEndTimer = 15000;\n        m_uiAggroResetTimer = urand(45000, 55000);\n        m_uiAggroResetEndTimer = 5000;\n        m_uiEnrageHardTimer = 10*60000;\n\n        m_bIsWhirlWind = false;\n        m_bAggroReset = false;\n        m_bIsEnraged = false;\n        m_bIsEnragedHard = false;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiCarnivorousBiteTimer    = urand(4000, 7000);\n        m_uiFocusFireTimer          = 15000;\n        m_uiAttractMagicTimer       = urand(20000, 24000);\n        m_uiFocusFireCount          = 0;\n\n        DoCastSpellIfCan(m_creature, SPELL_INHIBIT_MAGIC);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and is also called in the constructor of the AI.\n*\n* @param m_creature The creature whose combat variables are being reset.\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        boss_thaddiusAddsAI::Reset();\n        m_uiPowerSurgeTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function that every AI must implement. It is usually used to reset combat variables and is called by default on creature evade and respawn. In most scripts, it is also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiHasteTimer           = urand(15000, 23000);\n        m_uiSpellReflectionTimer = 30000;\n        m_uiMortalWoundTimer     = 8000;\n        m_uiWingBuffetTimer      = urand(25000, 35000);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is an internal function that every AI must implement. It is usually called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiMarkTimer       = 20000;\n        m_uiMeteorTimer     = 30000;\n        m_fHealthCheck      = 50.0f;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. Usally used to reset combat variables Called by default on creature evade and respawn In most scripts also called in the constructor of the AI\n*\n* @param m_uiMarkTimer The timer for marking the creature.\n* @param m_uiMeteorTimer The timer for meteors.\n* @param m_fHealthCheck The health check value.\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiAggroTimer  = 37000;\n        m_uiCleaveTimer = 5000;\n        m_uiRustTimer   = 30000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiChargeTimer     = urand(15000, 27000);\n        m_uiKnockBackTimer  = urand(8000, 20000);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function is used to reset combat variables for an AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiPoundingTimer   = 13000;\n        m_uiArcaneOrbTimer  = 3000;\n        m_uiKnockAwayTimer  = 30000;\n        m_uiBerserkTimer    = 10*MINUTE*IN_MILLISECONDS;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @param m_uiPoundingTimer The timer for the pounding attack.\n* @param m_uiArcaneOrbTimer The timer for the arcane orb attack.\n* @param m_uiKnockAwayTimer The timer for the knock away attack.\n* @param m_uiBerserkTimer The timer for the berserk state.\n*\n* @return None.\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiSurgeTimer = urand(2400, 6100);\n        m_uiMortalWoundTimer = urand(3500, 14400);\n        m_uiRetaliationTimer = 0;\n        m_uiOverpowerTimer = urand(3600, 14800);\n\n        m_bHasTaunted = false;\n        m_bYelledForHeal = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_illidanGuid.Clear();\n\n        m_bIsTrigger = false;\n\n        m_uiCheckTimer = 2000;\n        m_uiDemonFireTimer = 0;\n        m_uiDespawnTimer = 45000;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This function is used to reset combat variables for the AI.\n* It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiDespawnTimer   = 60000;\n        m_uiFireBlastTimer = 6000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiMoonFire_Timer = 3000;\n    }\n",
        "answer": "/** @brief Resets combat variables for an AI.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables and is called by default on creature evade and respawn. In most scripts, it is also called in the constructor of the AI.\n*\n* @param m_uiMoonFire_Timer The timer for the Moonfire ability.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiResetTimer = MINUTE*IN_MILLISECONDS;\n        m_uiSpearThrowTimer = 2000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This function is used to reset combat variables when a creature evades or respawns. It is called by default on creature evade and respawn, and in most scripts it is also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiDeathTimer = 2000;\n        m_bDeathYell = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiEagleSwoopTimer = 0;\n        m_uiReturnTimer     = 800;\n        m_bCanMoveToRandom  = false;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This function resets the combat variables of an AI, usually called on creature evade and respawn.\n* It is also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_bCanDoQuest       = false;\n        m_uiUnfriendlyTimer = 0;\n        m_uiFriendlyTimer   = 0;\n        m_uiPulverizeTimer  = 3000;\n        m_creature->SetStandState(UNIT_STAND_STATE_STAND);\n    }\n",
        "answer": "/** @brief Resets combat variables for the AI.\n*\n*  This function is used to reset combat variables for the AI, usually called on creature evade and respawn. It also gets called in the constructor of the AI.\n*\n* @param m_bCanDoQuest       Whether or not the AI can do quests.\n* @param m_uiUnfriendlyTimer The unfriendly timer for the AI.\n* @param m_uiFriendlyTimer   The friendly timer for the AI.\n* @param m_uiPulverizeTimer  The pulverize timer for the AI.\n* @param m_creature          The creature that the AI is controlling.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_bIsNihil                  = false;\n        m_uiNihilSpeechTimer        = 3000;\n        m_uiNihilSpeechPhase        = 0;\n\n        m_uiArcaneBlastTimer        = 7500;\n        m_uiManaBurnTimer           = 10000;\n        m_uiIntangiblePresenceTimer = 15000;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiDespawnTimer = 0;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiMyAbility = 0;\n        m_bEnraged = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement Usally used to reset combat variables Called by default on creature evade and respawn In most scripts also called in the constructor of the AI\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        if (m_creature->getFaction() != m_uiNormalFaction)\n            m_creature->setFaction(m_uiNormalFaction);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiCreditTimer = 2500;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_playerGuid.Clear();\n\n        SummonPatient_Timer = 10000;\n        SummonPatientCount = 0;\n        PatientDiedCount = 0;\n        PatientSavedCount = 0;\n\n        Patients.clear();\n        Coordinates.clear();\n\n        Event = false;\n\n        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables when a creature evades or respawns. It is also called in the constructor of the AI.\n*\n* @param m_playerGuid The player's GUID.\n* @param SummonPatient_Timer The timer for summoning patients.\n* @param SummonPatientCount The number of patients to be summoned.\n* @param PatientDiedCount The number of patients that have died.\n* @param PatientSavedCount The number of patients that have been saved.\n* @param Patients A vector of patient objects.\n* @param Coordinates A vector of coordinates for the patients.\n* @param Event A boolean indicating whether an event is currently happening.\n* @param m_creature A pointer to the creature object.\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiKnockdownTimer = 6000;\n        m_uiSnapKickTimer  = 4500;\n\n        priestess_companion_commonAI::Reset();\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_uiKnockdownTimer The timer for knockdown, set to 6000.\n* @param m_uiSnapKickTimer The timer for snap kick, set to 4500.\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiCommandAuraTimer = urand(1000, 3000);\n        m_uiBashTimer        = urand(8000, 11000);\n        m_uiStrikeTimer      = urand(2000, 5000);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function that every AI must implement. It is usually used to reset combat variables and is called by default on creature evade and respawn. In most scripts, it is also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiInfectedBiteTimer = 6500;\n        m_uiBattleCommandTimer = 8000;\n\n        m_bHasDoneConcoction = false;\n\n        DoCastSpellIfCan(m_creature, SPELL_TRASH);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function is used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_uiInfectedBiteTimer The timer for the infected bite ability.\n* @param m_uiBattleCommandTimer The timer for the battle command ability.\n* @param m_bHasDoneConcoction Whether or not the AI has done the concoction.\n* @param SPELL_TRASH The spell to cast if the AI can.\n*\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        if (!HasEscortState(STATE_ESCORT_ESCORTING))\n        {\n            m_uiOutroTimer          = 0;\n            m_uiOutroPhase          = 0;\n            m_uiSummonCount         = 0;\n\n            m_eranikusGuid.Clear();\n\n            m_uiShadesummonTimer    = 0;\n            m_uiHealTimer           = 10000;\n            m_uiStarfireTimer       = 25000;\n\n            m_bIsFirstWave          = true;\n        }\n    }\n",
        "answer": "/** @brief Resets combat variables for the AI.\n*\n*  This is an internal function that every AI must implement. It is usually called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n*  The function resets various combat-related variables, such as timers and counters, to their initial values.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiLamentEventTimer = 0;\n        m_uiSummonTimer = 0;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables. Called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @param m_uiLamentEventTimer The timer for the lament event.\n* @param m_uiSummonTimer The timer for the summon event.\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        if (!HasEscortState(STATE_ESCORT_ESCORTING))\n            m_uiEventPhase = 0;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This function is used to reset combat variables when a creature evades or respawns. It is an internal function that every AI must implement, and it is usually called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiGlobalTimer = 5000;\n\n        if (HasEscortState(STATE_ESCORT_PAUSED) && m_uiPhase == PHASE_FIGHT)\n            m_uiPhase = PHASE_COMPLETE;\n\n        if (!HasEscortState(STATE_ESCORT_ESCORTING))\n        {\n            lCreatureList.clear();\n            m_uiPhase = 0;\n            m_uiPhaseCounter = 0;\n        }\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function resets the combat variables for the AI, usually called by default on creature evade and respawn. In most scripts also called in the constructor of the AI.\n*\n* @param m_uiGlobalTimer The global timer for the AI, set to 5000.\n* @param m_uiPhase The phase of the combat, set to 0 if not escorting and to PHASE_COMPLETE if paused in phase fight.\n* @param lCreatureList The list of creatures involved in the combat, cleared if not escorting.\n* @param m_uiPhaseCounter The counter for the current phase, set to 0 if not escorting.\n*\n* @return None\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        if (m_creature->getFaction() != m_creature->GetCreatureInfo()->faction_A)\n            m_creature->setFaction(m_creature->GetCreatureInfo()->faction_A);\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n*  This function is used to reset combat variables for an AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_creature The creature whose combat variables are being reset.\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiTalk_Timer = 1000;\n    }\n",
        "answer": "/** @brief Resets combat variables for an AI.\n*\n* This is a SD2 internal function, that every AI must implement. It is usually used to reset combat variables and is called by default on creature evade and respawn. In most scripts, it is also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiShieldBashTimer = 5000;\n        m_uiRevengeTimer    = 8000;\n\n        m_creature->setFaction(FACTION_FRIENDLY);\n\n        /*if (m_pInstance)\n            m_pInstance->SetData(0, NOT_STARTED);*/\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is an internal function that every AI must implement. It is usually used to reset combat variables and is called by default on creature evade and respawn. In most scripts, it is also called in the constructor of the AI.\n*\n* @param m_uiShieldBashTimer The timer for shield bash.\n* @param m_uiRevengeTimer The timer for revenge.\n* @param m_creature The creature whose combat variables are being reset.\n* @param FACTION_FRIENDLY The faction of the creature.\n* @param NOT_STARTED The initial state of the data.\n*\n* @return Should not return\n*/\n/*if (m_pInstance)\nm_pInstance->SetData(0, NOT_STARTED);*/"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_bHasStartedEpilogue = false;\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This function is used to reset combat variables. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiCheckSpeechTimer = 2500;\n        m_uiPostEventTimer = 1000;\n        m_uiPhasePostEvent = 0;\n\n        pTorta = NULL;\n    }\n",
        "answer": "/** @brief Reset combat variables.\n*\n* This function resets the combat variables for an AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        m_uiIntroTimer = 5000;\n        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n*  This is an internal function that every AI must implement. It is usually called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @param m_uiIntroTimer The timer for the intro animation.\n* @param m_creature The creature that is being reset.\n* @return Should not return\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Reset()\n    {\n        if (!HasEscortState(STATE_ESCORT_ESCORTING))\n        {\n            if (m_creature->getStandState() == UNIT_STAND_STATE_DEAD)\n                m_creature->SetStandState(UNIT_STAND_STATE_STAND);\n\n            m_bIsPostEvent = false;\n            m_uiPostEventTimer = 1000;\n            m_uiPostEventCount = 0;\n        }\n    }\n",
        "answer": "/** @brief Resets combat variables.\n*\n* This is an internal function used to reset combat variables for the AI. It is called by default on creature evade and respawn, and in most scripts also called in the constructor of the AI.\n*\n* @return void\n*/\nvoid Reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CUDPPResult cudppSegmentedScan(const CUDPPHandle  planHandle,\n                               void               *d_out,\n                               const void         *d_idata,\n                               const unsigned int *d_iflags,\n                               size_t             numElements)\n{\n    CUDPPSegmentedScanPlan *plan =\n        (CUDPPSegmentedScanPlan*)getPlanPtrFromHandle<CUDPPSegmentedScanPlan>(planHandle);\n\n    if (plan != NULL)\n    {\n        if (plan->m_config.algorithm != CUDPP_SEGMENTED_SCAN)\n            return CUDPP_ERROR_INVALID_PLAN;\n\n        cudppSegmentedScanDispatch(d_out, d_idata, d_iflags, numElements, plan);\n        return CUDPP_SUCCESS;\n    }\n    else\n        return CUDPP_ERROR_INVALID_HANDLE;\n}\n",
        "answer": "/**\n* @brief Performs a segmented scan operation on an array of data.\n*\n* The input to a segmented scan operation is an input array of data, an input array of flags which demarcate segments, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The array of flags is the same length as the input with 1 marking the the first element of a segment and 0 otherwise. The output of segmented scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it in that segment. For instance, the output of segmented sum-scan at each element is the sum of all the input elements before that input in that segment. We support both \"exclusive\" and \"inclusive\" variants. For a segmented sum-scan, the exclusive variant computes the sum of all input elements before the current element in that segment, while the inclusive variant computes the sum of all input elements up to and including the current element, in that segment.\n*\n* @param planHandle Handle to a previously created CUDPPSegmentedScanPlan object.\n* @param d_out Pointer to the output array.\n* @param d_idata Pointer to the input data array.\n* @param d_iflags Pointer to the input flags array.\n* @param numElements The number of elements in the input and output arrays.\n*\n* @return CUDPPResult indicating the status of the operation.\n*/\nCUDPPResult cudppSegmentedScan(const CUDPPHandle planHandle, void* d_out, const void* d_idata, const unsigned int* d_iflags, size_t numElements);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void bindToProcessor(sz n)\n{\n    if(::SetThreadAffinityMask(::GetCurrentThread(), (DWORD_PTR)1 << n) == 0)\n        throw std::runtime_error(\"::SetThreadAffinityMask() failed\");\n}\n",
        "answer": "/**\n* @brief Binds the current thread to a specific hardware thread (processor).\n*\n* This function ensures that the current thread will not be swapped off of the specified hardware unit during execution.\n* By doing so, it typically reduces task switching costs and cache misses. If running a thread pool, the best performance is\n* typically achieved by evenly distributing and binding each thread across the hardware processors.\n*\n* @param n The index of the hardware thread to bind the current thread to.\n*/\nvoid bindToProcessor(sz n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired)\n{\n    unsigned int nToCheck = Params().ToCheckBlockUpgradeMajority();\n    unsigned int nFound = 0;\n    for (unsigned int i = 0; i < nToCheck && nFound < nRequired && pstart != NULL; i++)\n    {\n        if (pstart->nVersion >= minVersion)\n            ++nFound;\n        pstart = pstart->pprev;\n    }\n    return (nFound >= nRequired);\n}\n",
        "answer": "/** @brief Checks if there are enough blocks of a certain version or above in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart and going backwards.\n*\n*  This function checks if there are nRequired or more blocks of minVersion or above in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart and going backwards.\n*\n* @param minVersion The minimum version to check for.\n* @param pstart The block index to start checking from.\n* @param nRequired The number of required blocks.\n* @return True if there are nRequired or more blocks of minVersion or above in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart and going backwards.\n*/\nstatic bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        matrix_type scale_contrasts (const matrix_type& contrasts, const matrix_type& design, const size_t degrees_of_freedom)\n        {\n          assert (contrasts.cols() == design.cols());\n          const matrix_type XtX = design.transpose() * design;\n          const matrix_type pinv_XtX =  (XtX.transpose() * XtX).fullPivLu().solve (XtX.transpose());\n          matrix_type scaled_contrasts (contrasts);\n\n          for (size_t n = 0; n < size_t(contrasts.rows()); ++n) {\n            auto pinv_XtX_c = pinv_XtX * contrasts.row(n).transpose();\n            scaled_contrasts.row(n) *= std::sqrt (value_type(degrees_of_freedom) / contrasts.row(n).dot (pinv_XtX_c));\n          }\n          return scaled_contrasts;\n        }\n",
        "answer": "/**\n* @brief Scale contrasts using a design matrix and degrees of freedom.\n*\n* This function scales the contrasts in a matrix using a design matrix and degrees of freedom. The resulting scaled contrasts are returned as a new matrix.\n*\n* @param contrasts A matrix containing the contrasts to be scaled.\n* @param design A matrix containing the design information for the contrasts.\n* @param degrees_of_freedom The number of degrees of freedom for the contrasts.\n*\n* @return A new matrix containing the scaled contrasts.\n*/\nmatrix_type scale_contrasts (const matrix_type& contrasts, const matrix_type& design, const size_t degrees_of_freedom)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void setDateTimeFormat(const QString &format) {\n        dateTimeFormat = format;\n    }\n",
        "answer": "/** @brief Sets the date and time format to be used for QDateTime::toString.\n*\n*  If the provided QString is empty, Qt::TextDate is used as the default format.\n*\n* @param[in] format The desired date and time format.\n*/\nvoid setDateTimeFormat(const QString &format) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool saveLandmarks(QList<QLandmark> * landmark, QMap<int, QLandmarkManager::Error> *errorMap,\n                               QLandmarkManager::Error *error, QString *errorString) {return false;}\n",
        "answer": "/** @brief Save landmarks to the datastore.\n*\n*  This function saves a list of landmarks to the datastore and updates the identifier of each newly saved landmark with a new value.\n*  The engine emits signals to inform clients of changes to the datastore resulting from this operation.\n*\n* @param landmark A pointer to a QList of QLandmark objects to be saved.\n* @param errorMap A pointer to a QMap of integer keys and QLandmarkManager::Error values, used to store any errors that occur during the save process.\n* @param error A pointer to a QLandmarkManager::Error value, used to store the overall result of the save operation.\n* @param errorString A pointer to a QString object, used to store a human-readable description of any errors that occur during the save process.\n* @return True if the save operation was successful, false otherwise.\n*/\nbool saveLandmarks(QList<QLandmark> * landmark, QMap<int, QLandmarkManager::Error> *errorMap,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int triggerConnectedSlots(QObject* service, const QMetaObject* meta, int id, void **args)\n    {\n        Q_ASSERT(endPointType == ObjectEndPoint::Client);\n\n        const QMetaObject* parentMeta = meta->superClass();\n        if (parentMeta)\n            id = triggerConnectedSlots(service, parentMeta, id, args);\n\n        if (id < 0)\n            return id;\n\n        const int methodsThisType = meta->methodCount() - meta->methodOffset();\n        if (id >= 0 && id < methodsThisType)\n            QMetaObject::activate(service, meta, id, args);\n\n        id -= methodsThisType;\n        return id;\n    }\n",
        "answer": "/**\n* @brief Trigger connected slots.\n*\n* This function activates slots connected to a given signal, using the signal index relative to the meta object defining the signal.\n*\n* @param service The QObject that owns the signal.\n* @param meta The QMetaObject for the signal.\n* @param id The signal index relative to the meta object.\n* @param args The arguments to pass to the slot.\n* @return Should not return.\n*/\nint triggerConnectedSlots(QObject* service, const QMetaObject* meta, int id, void **args)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ConstructBitwiseFindFlags(TInt& aFindFlags,TInt& aIdentityColumnsCount,const CContactItemFieldDef* aFieldDef)\n\t{\n\tif(aFieldDef!=NULL && aFieldDef->Count()>0)\n\t\t{\n\t\tfor(TInt ii = 0;ii < aFieldDef->Count();ii++)\n\t\t\t{\n\t\t\tSetFindFlagsAndColumnsCount(aFieldDef->At(ii).iUid,aFindFlags,aIdentityColumnsCount);\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\taFindFlags |= EFindInAllFields|EFindInAnyIdentityField;\n\t\t}\n\t}\n",
        "answer": "/** @brief ConstructBitwiseFindFlags.\n*\n*  This function updates a set of find flags and an Identity table column count from the field type UIDs in the given field definition.\n*\n* @param[in,out] aFindFlags The find flags to be updated.\n* @param[in,out] aIdentityColumnsCount The Identity columns count to be updated.\n* @param[in] aFieldDef The field definition containing the UIDs.\n* @return void\n*/\nvoid ConstructBitwiseFindFlags(TInt& aFindFlags, TInt& aIdentityColumnsCount, const CContactItemFieldDef* aFieldDef)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GLDEF_C TInt E32Main()\n\t{\n    CntTest=new(ELeave) CCntTest;\n\tCntTest->ConstructL(test,KDatabaseFileName);\n\tUser::LeaveIfError(fs.Connect());\n    TRAPD(err,DoTestsL());\n\ttest(__NB_failures == 0);\n\tCntTest->EndTestLib(err);\n\tfs.Close();\n\n\treturn KErrNone;\n    }\n",
        "answer": "/** @brief Main entrypoint of the program.\n*\n*  This is the main entrypoint of the program, where the program starts executing.\n*  It creates a new instance of the CCntTest class and calls its ConstructL method with two arguments: test and KDatabaseFileName.\n*  Then it connects to the file system using the Connect method of the fs object.\n*  If there is an error, it leaves the function using the LeaveIfError macro.\n*  It then calls the DoTestsL method of the CntTest object and stores the result in the err variable.\n*  It tests whether the number of failures is equal to zero and if so, it ends the test library using the EndTestLib method of the CntTest object with the error code as an argument.\n*  Finally, it closes the file system connection using the Close method of the fs object and returns KErrNone.\n*\n* @param test The first argument to the ConstructL method of the CCntTest class.\n* @param KDatabaseFileName The second argument to the ConstructL method of the CCntTest class.\n* @return KErrNone if there is no error, or an error code otherwise.\n*/\nGLDEF_C TInt E32Main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GLDEF_C TInt E32Main()\n\t{\n\t__UHEAP_MARK;\n\tCntTest = new CCntTest;\n\tif (!CntTest)\n\t\t{\n\t\treturn KErrNoMemory;\n\t\t}\n\n\tCntTest->ConstructL(test,KDatabaseFileName);\n    TRAPD(err,DoTestsL());\n\ttest.Printf(_L(\"\\n\"));\n\tCntTest->EndTestLib(err);\n\t__UHEAP_MARKEND;\n\treturn KErrNone;\n    }\n",
        "answer": "/** @brief Entry point function for the CNTID test library.\n*\n*  This is the entrypoint for the CNTID test library, which tests the functionality of the CNTID database.\n*  It creates a new instance of the CCntTest class and calls its ConstructL method to initialize it with the test data.\n*  It then calls the DoTestsL method to perform the actual testing, and prints out the results using the Printf method.\n*  Finally, it calls the EndTestLib method to clean up any resources used by the test library.\n*\n* @return Should not return\n*/\nvoid E32Main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GLDEF_C TInt E32Main()\n\t{\n\t__UHEAP_MARK;\n\t\n    CntTest=new(ELeave) CCntTest;\n\tCntTest->ConstructL(test,KDatabaseFileName);\n    TRAPD(err,DoTestsL());\n\tCntTest->EndTestLib(err);\n\t\n\t__UHEAP_MARKEND;\n\t\n\treturn KErrNone;\n    }\n",
        "answer": "/** @brief Entry point for the application.\n*\n*  This is the entrypoint for your application.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nGLDEF_C TInt E32Main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LOCAL_C void TestGeoL(const TDesC& aGeoValue)\n\t{\n\ttest.Next(_L(\"\"));\n\n\t\n    test(DoExportTestL(aGeoValue));\n    \n    test(DoImportTestL(aGeoValue));\n\t}\n",
        "answer": "/** @brief Tests the GEO field can be added and its text can contain the GEO values of latitude and longitude. This tests all the import and export functionality of the testcase ids of GEO-1 to GEO-12  Create a contact item and export the item to a vCard, the exported item is verified. The vCard is imported and the contact item is verified. The vCard exported should have the following line. GEO:[lat],[lon] Different [lat] and [lon] values are tested.\n*\n* @param[in] aGeoValue The geo value to be tested.\n*/\nvoid TestGeoL(const TDesC& aGeoValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GLDEF_C TInt E32Main()\n\t{\n    CntTest=new(ELeave) CCntTest;\n\tCntTest->ConstructL(test,KDatabaseFileName);\n    TRAPD(err,DoTestsL());\n\ttest.Printf(_L(\"\\n\"));\n\tCntTest->EndTestLib(err);\n\n\treturn KErrNone;\n    }\n",
        "answer": "/** @brief Entry point function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nGLDEF_C TInt E32Main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GLDEF_C TInt E32Main()\n\t{\n\t__UHEAP_MARK;\n\tg_test.Start(_L(\"Speed dial test\"));\n\n\tCActiveScheduler* scheduler=new CActiveScheduler;\n\tif (scheduler)\n\t\t{\n\t\tCActiveScheduler::Install(scheduler);\n\t\tCTrapCleanup* cleanup=CTrapCleanup::New();\n\t\tif (cleanup)\n\t\t\t{\n\t\t\tTRAPD(err,DoTestL() );\n\t\t\tg_test(err == KErrNone);\n\t\t\tdelete cleanup;\n\t\t\t}\n\t\tdelete scheduler;\n\t\t}\n\tg_test.Close();\n\t__UHEAP_MARKEND;\n\treturn KErrNone;\n    }\n",
        "answer": "/** @brief Entry point for the application.\n*\n*  This is the entrypoint for your application.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid E32Main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool waitForSignal(QObject *obj, const char *signal, int timeout = 0)\n{\n    QEventLoop loop;\n    QObject::connect(obj, signal, &loop, SLOT(quit()));\n    QTimer timer;\n    QSignalSpy timeoutSpy(&timer, SIGNAL(timeout()));\n    if (timeout > 0) {\n        QObject::connect(&timer, SIGNAL(timeout()), &loop, SLOT(quit()));\n        timer.setSingleShot(true);\n        timer.start(timeout);\n    }\n    loop.exec();\n    return timeoutSpy.isEmpty();\n}\n",
        "answer": "/** @brief Waits for a signal from an object.\n*\n*  This function starts an event loop that runs until the given signal is received from the specified object. Optionally, it can return earlier on a timeout.\n*\n* @param obj The object to wait for the signal from.\n* @param signal The name of the signal to wait for.\n* @param timeout The maximum amount of time to wait for the signal, in milliseconds. If set to 0 (the default), there is no timeout and the function will wait indefinitely.\n* @return true if the signal was received before the timeout, false otherwise.\n*/\nstatic bool waitForSignal(QObject *obj, const char *signal, int timeout = 0)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "U_CFUNC UBool cmemory_cleanup(void) {\n    pContext   = NULL;\n    pAlloc     = NULL;\n    pRealloc   = NULL;\n    pFree      = NULL;\n    return TRUE;\n}\n",
        "answer": "/** @brief Heap clean up function, called from u_cleanup()\n*\n*  Clears any user heap functions from u_setMemoryFunctions()\n*  Does NOT deallocate any remaining allocated memory.\n*\n* @return TRUE if the operation was successful, FALSE otherwise.\n*/\nU_CFUNC UBool cmemory_cleanup(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ucurr_isAvailable(const UChar* isoCode, UDate from, UDate to, UErrorCode* eErrorCode) {\n    umtx_initOnce(gIsoCodesInitOnce, &initIsoCodes, *eErrorCode);\n    if (U_FAILURE(*eErrorCode)) {\n        return FALSE;\n    }\n\n    IsoCodeEntry* result = (IsoCodeEntry *) uhash_get(gIsoCodes, isoCode);\n    if (result == NULL) {\n        return FALSE;\n    } else if (from > to) {\n        *eErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n        return FALSE;\n    } else if  ((from > result->to) || (to < result->from)) {\n        return FALSE;\n    }\n    return TRUE;\n}\n",
        "answer": "/** @brief Checks the availability of an ISO 4217 3-letter code on a specified date range.\n*\n* This method checks if the given ISO 4217 3-letter code is available on the specified date range. Note: For checking availability of a currency on a specific date, specify the date on both 'from' and 'to' When 'from' is U_DATE_MIN and 'to' is U_DATE_MAX, this method checks if the specified currency is available any time. If 'from' and 'to' are same UDate value, this method checks if the specified currency is available on that date.\n*\n* @param[in] isoCode The ISO 4217 3-letter code to check availability for.\n* @param[in] from The starting date of the range to check availability for.\n* @param[in] to The ending date of the range to check availability for.\n* @param[out] eErrorCode A pointer to a UErrorCode variable that will be set if an error occurs.\n* @return TRUE if the ISO 4217 3-letter code is available on the specified date range, FALSE otherwise.\n*/\n*eErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\nreturn FALSE;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void childBoundsChanged (Component* child)\n    {\n        const int cw = child->getWidth();\n        const int ch = child->getHeight();\n\n#if JUCE_LINUX\n        XResizeWindow (display, (Window) getWindowHandle(), cw, ch);\n#else\n        setSize (cw, ch);\n#endif\n\n        if (uiResize != nullptr)\n            uiResize->ui_resize (uiResize->handle, cw, ch);\n    }\n",
        "answer": "/** @brief Called when one of this component's children is moved or resized. If the parent wants to know about changes to its immediate children (not to children of its children), this is the method to override.\n*/\nvoid childBoundsChanged (Component* child)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void systemRequestedQuit()\r\n    {\r\n        DBG (\"StandaloneFilterApplication::systemRequestedQuit\");\r\n\r\n        quit ();\r\n    }\r\n",
        "answer": "/** @brief System requested quit.\n*\n*  This function is called when the operating system is trying to close the application. If you want to send a quit signal to your app, this is the correct method to call, because it means that requests that come from the system get handled in the same way as those from your own application code. So e.g. you'd call this method from a \"quit\" item on a menu bar.\n*\n* @return Should not return\n*/\nvoid systemRequestedQuit()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AudioProcessor* JUCE_CALLTYPE createPluginFilter()\r\n{\r\n    return new Ambix_encoderAudioProcessor();\r\n}\r\n",
        "answer": "/** @brief Creates a plugin filter.\n*\n*  This function creates a new instance of the filter subclass that is being built.\n*\n* @return A pointer to the newly created filter object.\n*/\nAudioProcessor* JUCE_CALLTYPE createPluginFilter()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AudioProcessor* JUCE_CALLTYPE createPluginFilter()\r\n{\r\n    return new Ambix_vmicAudioProcessor();\r\n}\r\n",
        "answer": "/** @brief Creates a new instance of the Ambix_vmicAudioProcessor filter.\n*\n* This function is used to create a new instance of the Ambix_vmicAudioProcessor filter, which is a subclass of AudioProcessor.\n* The function returns a pointer to the newly created filter object.\n*\n* @return A pointer to the newly created Ambix_vmicAudioProcessor filter object.\n*/\nAudioProcessor* JUCE_CALLTYPE createPluginFilter()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto vec_a = args->GetInput<T>(kInputA);\n    auto vec_b = args->GetInput<T>(kInputB);\n    args->SetOutput(kOutputSum, *vec_a + *vec_b);\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n* @param args NodeArguments pointer to access input and output data\n* @return void\n*/\nvoid Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) { Initialize(args); }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n*\n* @param args NodeArguments pointer to the arguments for the node.\n*/\nvoid Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto vec_a = args->GetInput<T>(kInputA);\n    auto vec_b = args->GetInput<T>(kInputB);\n    args->SetOutput(kOutputCrossProduct, T::CrossProduct(*vec_a, *vec_b));\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n* @param args NodeArguments* pointer to the arguments for the node.\n* @return void.\n*/\nvoid Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto entity_id = args->GetInput<std::string>(kInputEntityId);\n    EntityRef entity =\n        meta_component_->GetEntityFromDictionary(entity_id->c_str());\n    assert(entity.IsValid());\n    args->SetOutput(kOutputEntity, entity);\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n* @param args NodeArguments* args : The arguments for the execution of the node.\n* @return void : Does not return anything.\n*/\nvoid Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto value = args->GetInput<int>(kInputValue);\n    args->SetOutput(kOutputValue, static_cast<float>(*value));\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n*  @param args NodeArguments* args: A pointer to the NodeArguments object containing the input and output edges for this node.\n*  @return void: The function does not return any value.\n*/\nvirtual void Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto a = args->GetInput<T>(kInputA);\n    auto b = args->GetInput<T>(kInputA);\n    args->SetOutput(kOutputMax, std::max(*a, *b));\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n*  @param args NodeArguments* pointer to the arguments for the node.\n*/\nvirtual void Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    if (args->IsInputDirty(kInputPlay)) {\n      auto handle = args->GetInput<SoundHandle>(kInputSoundHandle);\n      auto location = args->GetInput<vec3>(kInputLocation);\n      auto gain = args->GetInput<float>(kInputGain);\n      Channel channel = audio_engine_->PlaySound(*handle, *location, *gain);\n      args->SetOutput(kOutputChannel, channel);\n    }\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n*/\nvoid Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto channel = args->GetInput<Channel>(kInputChannel);\n    auto location = args->GetInput<vec3>(kInputChannel);\n    channel->SetLocation(*location);\n    args->SetOutput(kOutputChannel, *channel);\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n*  @param args NodeArguments* args: A pointer to the NodeArguments object containing the input and output edges for this node.\n*  @return void: The function does not return any value.\n*/\nvirtual void Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void Execute(NodeArguments* args) {\n    auto x = args->GetInput<float>(kInputX);\n    auto y = args->GetInput<float>(kInputY);\n    auto z = args->GetInput<float>(kInputZ);\n    auto w = args->GetInput<float>(kInputW);\n    args->SetOutput(kOutputVec, vec4(*x, *y, *z, *w));\n  }\n",
        "answer": "/** @brief Execute is called any time this node in the graph is marked dirty. This can happen in two ways. One way is that this node has a listener that has had an event broadcast to it. The other is that another node updated an output edge that this node is observing. This function is where the bulk of the interesting logic should occur in a node.\n*  @param args NodeArguments* pointer to the arguments for the node.\n*  @return void\n*/\nvirtual void Execute(NodeArguments* args) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool search(string word) {\n        return find(word, &trie_, 0, true);    \n    }\n",
        "answer": "/**\n* @brief Searches for a word in the trie.\n*\n* Returns if there is any word in the trie that equals to the given word after modifying exactly one character.\n*\n* @param word The word to search for.\n* @return True if the word is found, false otherwise.\n*/\nbool search(string word) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\n\r\nbyte OAEP_P_DEFAULT[1];\r\n\r\nvoid xorbuf(byte *buf, const byte *mask, unsigned int count)\r\n{\r\n\tif (((unsigned int)buf | (unsigned int)mask | count) % WORD_SIZE == 0)\r\n\t\tXorWords((word *)buf, (const word *)mask, count/WORD_SIZE);\r\n\telse\r\n\t{\r\n\t\tfor (unsigned int i=0; i<count; i++)\r\n\t\t\tbuf[i] ^= mask[i];\r\n\t}\r\n}\r\n\r\nvoid xorbuf(byte *output, const byte *input, const byte *mask, unsigned int count)\r\n{\r\n\tif (((unsigned int)output | (unsigned int)input | (unsigned int)mask | count) % WORD_SIZE == 0)\r\n",
        "answer": "/** @brief CryptoPP namespace.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid kernel_entrypoint()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "FillResult floodfill(const LayerStack *image, const QPoint &point, const QColor &color, int tolerance, int layer, bool merge, unsigned int sizelimit)\n{\n\tQ_ASSERT(image);\n\tQ_ASSERT(tolerance>=0);\n\n\tif(!image->getLayer(layer))\n\t\treturn FillResult();\n\n\tFloodfill fill(image, layer, merge, color, tolerance, sizelimit);\n\n\tif(point.x() >=0 && point.x() < image->width() && point.y()>=0 && point.y() < image->height())\n\t\tfill.start(point);\n\n\treturn fill.result();\n}\n",
        "answer": "/** @brief Fills an area of the layer stack with a given color.\n*\n*  This function fills an area of the layer stack with a given color, using the floodfill algorithm.\n*  The fill is constrained by the size limit and tolerance parameters. If the merge parameter is set to true,\n*  the fill will merge with existing pixels that are similar in color to the fill color.\n*\n* @param image The layer stack to be filled.\n* @param point The starting point of the fill.\n* @param color The color to be used for the fill.\n* @param tolerance The tolerance value for the floodfill algorithm.\n* @param layer The layer number to be filled.\n* @param merge Whether or not to merge with existing pixels.\n* @param sizelimit The size limit for the fill.\n* @return The result of the fill operation, including the number of pixels filled and the resulting color.\n*/\nFillResult floodfill(const LayerStack *image, const QPoint &point, const QColor &color, int tolerance, int layer, bool merge, unsigned int sizelimit)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int ph_bitcount8(uint8_t val) {\n\tint num = 0;\n\twhile (val) {\n\t\t++num;\n\t\tval &= val - 1;\n\t}\n\treturn num;\n}\n",
        "answer": "/** @brief Count number of bits set in given byte.\n*\n* This function counts the number of bits that are set to 1 in a given byte value.\n*\n* @param val - uint8_t byte value\n* @return int value for number of bits set\n*/\nint ph_bitcount8(uint8_t val) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void setOrigin (Point<int> o)\n    {\n        addTransform (AffineTransform::translation ((float) o.x, (float) o.y));\n    }\n",
        "answer": "/** @brief Moves the origin to a new position.\n*\n*  This function moves the origin to a new position relative to the current origin.\n*  The coordinates are passed as a Point<int> object, which contains the x and y coordinates of the new origin.\n*\n* @param o A Point<int> object containing the x and y coordinates of the new origin.\n*/\nvoid setOrigin (Point<int> o)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n{\n    return new GlslplugInAudioProcessor();\n}\n",
        "answer": "/** @brief Creates a new instance of the plugin filter.\n*\n* This function is used to create a new instance of the plugin filter and return it as an AudioProcessor object.\n* It is called by the host application to initialize the plugin and start processing audio.\n*\n* @return A new instance of the GlslplugInAudioProcessor class, which inherits from the AudioProcessor class.\n*/\nAudioProcessor* JUCE_CALLTYPE createPluginFilter()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool AliasesEqual(std::string a, std::string b, bool safe) {\n    if (safe) {\n        NormalizeAlias(a);\n        NormalizeAlias(b);\n    }\n\n    return a == b;\n}\n",
        "answer": "/** @brief Checks whether two aliases are equal.\n*\n*  This function compares two aliases and returns true if they are equal. The comparison is done in normalized form, unless the safe mode is off, in which case it is a byte compare.\n*\n* @param a The first alias to compare.\n* @param b The second alias to compare.\n* @param safe A boolean indicating whether or not to perform a transpose check on either side of the comparison.\n* @return True if the two aliases are equal, false otherwise.\n*/\nbool AliasesEqual(std::string a, std::string b, bool safe) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n{\n    ScriptError error;\n    CTransaction inputi(input);\n    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue, 0, 0), &error);\n    BOOST_CHECK((ret == true) == (error == SCRIPT_ERR_OK));\n\n    return error;\n}\n",
        "answer": "/** @brief Verifies script execution of the zeroth scriptPubKey of tx output and zeroth scriptSig and witness of tx input.\n*\n*  This function verifies the script execution of the zeroth scriptPubKey of the transaction output and the zeroth scriptSig and witness of the transaction input.\n*\n* @param[in] output The transaction output to be verified.\n* @param[in] input The transaction input to be verified.\n* @param[in] flags The flags used for verification.\n*\n* @return The error code if any, or SCRIPT_ERR_OK if successful.\n*/\nScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int bitcoinconsensus_verify_script(const uint8_t *scriptPubKey,\n                                   unsigned int scriptPubKeyLen,\n                                   const uint8_t *txTo, unsigned int txToLen,\n                                   unsigned int nIn, unsigned int flags,\n                                   bitcoinconsensus_error *err) {\n    if (flags & bitcoinconsensus_SCRIPT_ENABLE_SIGHASH_FORKID ||\n        flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS_DEPRECATED) {\n        return set_error(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);\n    }\n\n    CAmount am(0);\n    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen,\n                           nIn, flags, err);\n}\n",
        "answer": "/** @brief Verifies a Bitcoin transaction input against a previous transaction output.\n*\n*  This function checks if the input transaction correctly spends the output transaction\n*  specified by scriptPubKey under the additional constraints specified by flags. If not nullptr,\n*  err will contain an error/success code for the operation.\n*\n* @param[in] scriptPubKey The previous transaction output's script that encumbers the new transaction input.\n* @param[in] scriptPubKeyLen The length of scriptPubKey in bytes.\n* @param[in] txTo The transaction with the input to be checked.\n* @param[in] txToLen The length of txTo in bytes.\n* @param[in] nIn The index of the input in txTo to be checked.\n* @param[in] flags The additional constraints to verify the input against.\n* @param[out] err The error code for the operation.\n* @return 1 if the input correctly spends the output, 0 otherwise.\n*/\nint bitcoinconsensus_verify_script(const uint8_t *scriptPubKey, unsigned int scriptPubKeyLen, const uint8_t *txTo, unsigned int txToLen, unsigned int nIn, unsigned int flags, bitcoinconsensus_error *err) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ScriptError VerifyWithFlag(const CTransaction &output,\n                           const CMutableTransaction &input, int flags) {\n    ScriptError error;\n    CTransaction inputi(input);\n    bool ret = VerifyScript(\n        inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, flags,\n        TransactionSignatureChecker(&inputi, 0), &error);\n    BOOST_CHECK((ret == true) == (error == SCRIPT_ERR_OK));\n\n    return error;\n}\n",
        "answer": "/** @brief Verifies script execution of the zeroth scriptPubKey of tx output and zeroth scriptSig and witness of tx input.\n*\n*  This function verifies the script execution of the zeroth scriptPubKey of the transaction output and the zeroth scriptSig and witness of the transaction input. It returns a ScriptError object that indicates any errors that occurred during the verification process.\n*\n* @param[in] output The transaction output to be verified.\n* @param[in] input The transaction input to be verified.\n* @param[in] flags The flags used for script execution.\n*\n* @return A ScriptError object indicating any errors that occurred during the verification process.\n*/\nScriptError VerifyWithFlag(const CTransaction &output, const CMutableTransaction &input, int flags) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class Graphic {\npublic:\n    Graphic() noexcept = default;\n    Graphic(Graphic const&) = default;\n    Graphic(Graphic&&) = default;\n    Graphic& operator=(Graphic const&) = default;\n    Graphic& operator=(Graphic&&) = default;\n    virtual ~Graphic() noexcept = default;\n\n    virtual void draw() const = 0;\n    virtual void remove(Graphic*) { };\n    virtual void add(Graphic*) { };\n    virtual void get_child(int) { };\n};\n",
        "answer": "/** @brief Graphic class.\n*\n*  This is the base class for all graphics objects. It provides a common interface for drawing and manipulating graphical elements.\n*\n* @return Should not return\n*/\n/** @brief Draw the graphical element.\n*\n*  This method is used to draw the graphical element on the screen. It should be implemented by all derived classes.\n*/\n/** @brief Remove a child graphical element from this object.\n*\n*  This method removes a child graphical element from this object. It is used to remove an element from the scene.\n*\n* @param g The graphical element to be removed.\n*/\n/** @brief Add a child graphical element to this object.\n*\n*  This method adds a child graphical element to this object. It is used to add an element to the scene.\n*\n* @param g The graphical element to be added.\n*/\n/** @brief Get a child graphical element from this object.\n*\n*  This method returns a child graphical element from this object. It is used to retrieve an element from the scene.\n*\n* @param index The index of the child element to be retrieved.\n*/\nvirtual void get_child(int index) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool gzipped(const IStream::pointer &s, std::size_t offset)\n{\n    return gzipped(*s, offset);\n}\n",
        "answer": "/** @brief Check if stream is gzipped at given position.\n*\n*  This function seeks to the given position in the stream and checks if it is a valid gzip header.\n*  It does not read anything from the stream, but seeks back to its original position before returning.\n*\n* @param s The input stream to check.\n* @param offset The position in the stream to check.\n* @return True if the stream is gzipped at the given position, false otherwise.\n*/\nbool gzipped(const IStream::pointer &s, std::size_t offset)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        inline void expandBy(double x,double y,double z)\n        {\n            if(x<_min.x()) _min.x() = x;\n            if(x>_max.x()) _max.x() = x;\n\n            if(y<_min.y()) _min.y() = y;\n            if(y>_max.y()) _max.y() = y;\n\n            if(z<_min.z()) _min.z() = z;\n            if(z>_max.z()) _max.z() = z;\n        }\n",
        "answer": "/** @brief Expands the bounding box to include the given coordinate. If the box is uninitialized, set its min and max extents to osg::Vec3d(x,y,z).\n*\n* This function expands the bounding box to include the given coordinate (x, y, z) if it is outside of the current bounds. If the box is uninitialized, it sets its min and max extents to osg::Vec3d(x,y,z).\n*\n* @param x The x-coordinate of the point to be included in the bounding box.\n* @param y The y-coordinate of the point to be included in the bounding box.\n* @param z The z-coordinate of the point to be included in the bounding box.\n*/\ninline void expandBy(double x, double y, double z)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const char *NWT_GRCDataset::GetProjectionRef()\n{\n#ifdef OGR_ENABLED\n    if (pszProjection == NULL)\n    {\n        OGRSpatialReference *poSpatialRef;\n        poSpatialRef = MITABCoordSys2SpatialRef( pGrd->cMICoordSys );\n        if (poSpatialRef)\n        {\n            poSpatialRef->exportToWkt( &pszProjection );\n            poSpatialRef->Release();\n        }\n    }\n#endif\n    return ( (const char *) pszProjection );\n}\n",
        "answer": "/** @brief Get the projection reference.\n*\n*  This function returns the projection reference of a GDAL dataset. If no projection definition is available, an empty (but not NULL) string is returned.\n*\n* @return The projection reference as a string.\n*/\nconst char *NWT_GRCDataset::GetProjectionRef()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPLPrintString( char *pszDest, const char *pszSrc, int nMaxLen )\n{\n    char    *pszTemp = pszDest;\n    int     nChars = 0;\n\n    if ( !pszDest )\n        return 0;\n\n    if ( !pszSrc )\n    {\n        *pszDest = '\\0';\n        return 1;\n    }\n\n    while ( nChars < nMaxLen && *pszSrc )\n    {\n        *pszTemp++ = *pszSrc++;\n        nChars++;\n    }\n\n    return nChars;\n}\n",
        "answer": "/** @brief Copies a string from one location to another.\n*\n*  This function copies the contents of the source string, excluding the terminating null character, to the destination array.\n*\n* @param pszDest The destination array where the string will be copied.\n* @param pszSrc The source string that will be copied.\n* @param nMaxLen The maximum number of characters to copy.\n*\n* @return The number of characters copied, excluding the terminating null character.\n*/\n*pszDest = '\\0';\n*pszTemp++ = *pszSrc++;\nnChars++;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void    CPLError(CPLErr eErrClass, int err_no, const char *fmt, ...)\n{\n    va_list args;\n\n    /* Expand the error message \n     */\n    va_start(args, fmt);\n    CPLErrorV( eErrClass, err_no, fmt, args );\n    va_end(args);\n}\n",
        "answer": "/** @brief Reports an error in a manner that can be hooked and reported appropriate by different applications.\n*\n*  This function reports an error in a manner that can be hooked and reported appropriate by different applications. The effect of this function can be altered by applications by installing a custom error handling using CPLSetErrorHandler(). The eErrClass argument can have the value CE_Warning indicating that the message is an informational warning, CE_Failure indicating that the action failed, but that normal recover mechanisms will be used or CE_Fatal meaning that a fatal error has occured, and that CPLError() should not return. The default behaviour of CPLError() is to report errors to stderr, and to abort() after reporting a CE_Fatal error. It is expected that some applications will want to suppress error reporting, and will want to install a C++ exception, or longjmp() approach to no local fatal error recovery. Regardless of how application error handlers or the default error handler choose to handle an error, the error number, and message will be stored for recovery with CPLGetLastErrorNo() and CPLGetLastErrorMsg().\n*\n* @param eErrClass The class of error being reported.\n* @param err_no The error number.\n* @param fmt The format string for the error message.\n* @return Should not return.\n*/\nvoid CPLError(CPLErr eErrClass, int err_no, const char *fmt, ...);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const char* CPL_STDCALL CPLGetLastErrorMsg()\n{\n    CPLErrorContext *psCtx = CPLGetErrorContext();\n\n    return psCtx->szLastErrMsg;\n}\n",
        "answer": "/** @brief Get the last error message.\n*\n*  Fetches the last error message posted with CPLError(), that hasn't been cleared by CPLErrorReset(). The returned pointer is to an internal string that should not be altered or freed.\n*\n* @return A const char* pointer to the last error message.\n*/\nconst char* CPL_STDCALL CPLGetLastErrorMsg()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPLHashSetInsert(CPLHashSet* set, void* elt)\n{\n    CPLAssert(set != NULL);\n    void** pElt = CPLHashSetFindPtr(set, elt);\n    if (pElt)\n    {\n        if (set->fnFreeEltFunc)\n            set->fnFreeEltFunc(*pElt);\n\n        *pElt = elt;\n        return FALSE;\n    }\n\n    if (set->nSize >= 2 * set->nAllocatedSize / 3)\n    {\n        set->nIndiceAllocatedSize++;\n        CPLHashSetRehash(set);\n    }\n\n    unsigned long nHashVal = set->fnHashFunc(elt) % set->nAllocatedSize;\n#ifdef HASH_DEBUG\n    if (set->tabList[nHashVal])\n        set->nCollisions ++;\n#endif\n    set->tabList[nHashVal] = CPLListInsert(set->tabList[nHashVal], (void*) elt, 0);\n    set->nSize++;\n\n    return TRUE;\n}\n",
        "answer": "/**\n* @brief Inserts an element into a hash set. If the element was already inserted in the hash set, the previous element is replaced by the new element. If a free function was provided, it is used to free the previously inserted element.\n*\n* @param set The hash set to insert the element into.\n* @param elt The element to be inserted.\n*\n* @return TRUE if the element was successfully inserted, FALSE otherwise.\n*/\nint CPLHashSetInsert(CPLHashSet* set, void* elt) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPL_STDCALL GDALScaledProgress( double dfComplete, const char *pszMessage,\n                                    void *pData )\n\n{\n    GDALScaledProgressInfo *psInfo = (GDALScaledProgressInfo *) pData;\n    \n    /* optimization if GDALCreateScaledProgress() provided with GDALDummyProgress */\n    if( psInfo == NULL )\n        return TRUE;\n\n    return psInfo->pfnProgress( dfComplete * (psInfo->dfMax - psInfo->dfMin)\n                                + psInfo->dfMin,\n                                pszMessage, psInfo->pData );\n}\n",
        "answer": "/** @brief GDALScaledProgress function.\n*\n*  This function is used to scale the progress of a task based on the minimum and maximum values provided by GDALCreateScaledProgress().\n*\n* @param dfComplete The current completion percentage, between 0 and 1.\n* @param pszMessage A message to display along with the progress.\n* @param pData A pointer to the data structure containing the progress information.\n*\n* @return TRUE if the operation is successful, FALSE otherwise.\n*/\n/* optimization if GDALCreateScaledProgress() provided with GDALDummyProgress */\nif( psInfo == NULL )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int utf8test(const char* src, unsigned srclen) {\n  int ret = 1;\n  const char* p = src;\n  const char* e = src+srclen;\n  while (p < e) {\n    if (*p & 0x80) {\n      int len; utf8decode(p,e,&len);\n      if (len < 2) return 0;\n      if (len > ret) ret = len;\n      p += len;\n    } else {\n      p++;\n    }\n  }\n  return ret;\n}\n",
        "answer": "/** @brief Tests whether a string is valid UTF-8.\n*\n*  This function tests whether a string is valid UTF-8 by checking if each byte\n*  in the string has its most significant bit set to 0, except for the first byte\n*  which must have its most significant bit set to 1. If any of these conditions\n*  are not met, the function returns 0. Otherwise, it returns the length of the\n*  valid UTF-8 sequence.\n*\n* @param src The string to test.\n* @param srclen The length of the string to test.\n* @return The length of the valid UTF-8 sequence if the string is valid, or 0 otherwise.\n*/\nstatic int utf8test(const char* src, unsigned srclen) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CSLPartialFindString( char **papszHaystack, const char * pszNeedle )\n{\n    int i;\n    if (papszHaystack == NULL || pszNeedle == NULL)\n        return -1;\n\n    for (i = 0; papszHaystack[i] != NULL; i++) \n    {\n        if (strstr(papszHaystack[i],pszNeedle))\n            return i;\n    }\n\n    return -1;\n}\n",
        "answer": "/** @brief Find a substring within a string list. Returns the index of the entry in the string list that contains the target string as a substring. The search is case sensitive (unlike CSLFindString()).\n*/\nint CSLPartialFindString( char **papszHaystack, const char * pszNeedle )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t CPLStrlcat(char* pszDest, const char* pszSrc, size_t nDestSize)\n{\n    char* pszDestIter = pszDest;\n\n    while(nDestSize != 0 && *pszDestIter != '\\0')\n    {\n        pszDestIter ++;\n        nDestSize --;\n    }\n\n    return pszDestIter - pszDest + CPLStrlcpy(pszDestIter, pszSrc, nDestSize);\n}\n",
        "answer": "/**\n* @brief Appends a source string to a destination buffer.\n*\n* This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1 and that there is at least one byte free in pszDest, that is to say strlen(pszDest_before) < nDestSize). This function is designed to be a safer, more consistent, and less error prone replacement for strncat. Its contract is identical to libbsd's strlcat. Truncation can be detected by testing if the return value of CPLStrlcat is greater or equal to nDestSize.\n*\n* @param pszDest The destination buffer.\n* @param pszSrc The source string.\n* @param nDestSize The size of the destination buffer, in bytes.\n*\n* @return The number of characters copied from the source string, not including the terminating NUL character. If the return value is greater than or equal to nDestSize, truncation occurred.\n*/\nsize_t CPLStrlcat(char* pszDest, const char* pszSrc, size_t nDestSize);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CPLVirtualMemDeclareThread(CPLVirtualMem* ctxt)\n{\n    if( ctxt->bFileMemoryMapped )\n        return;\n#ifndef HAVE_5ARGS_MREMAP\n    assert( !ctxt->bSingleThreadUsage );\n    CPLAcquireMutex(ctxt->hMutexThreadArray, 1000.0);\n    ctxt->pahThreads = (pthread_t*) CPLRealloc(ctxt->pahThreads,\n                                (ctxt->nThreads + 1) * sizeof(pthread_t));\n    ctxt->pahThreads[ctxt->nThreads] = pthread_self();\n    ctxt->nThreads ++;\n\n    CPLReleaseMutex(ctxt->hMutexThreadArray);\n#endif\n}\n",
        "answer": "/**\n* @brief Declare that a thread will access a virtual memory mapping.\n*\n* This function must be called by a thread that wants to access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE. This function must be paired with CPLVirtualMemUnDeclareThread().\n*\n* @param ctxt The CPLVirtualMem context.\n*/\nvoid CPLVirtualMemDeclareThread(CPLVirtualMem* ctxt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int VSIUnlink( const char * pszFilename )\n\n{\n    VSIFilesystemHandler *poFSHandler = \n        VSIFileManager::GetHandler( pszFilename );\n\n    return poFSHandler->Unlink( pszFilename );\n}\n",
        "answer": "/** @brief Deletes a file object from the file system.\n*\n*  This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX unlink() function.\n*\n* @param pszFilename The name of the file to delete.\n* @return Should not return\n*/\nint VSIUnlink( const char * pszFilename )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int VSIFCloseL( VSILFILE * fp )\n\n{\n    VSIVirtualHandle *poFileHandle = (VSIVirtualHandle *) fp;\n    \n    VSIDebug1( \"VSICloseL(%p)\", fp );\n    \n    int nResult = poFileHandle->Close();\n    \n    delete poFileHandle;\n\n    return nResult;\n}\n",
        "answer": "/** @brief Closes the indicated file.\n*\n*  This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX fclose() function.\n*\n* @param[in] fp The file to close.\n* @return Should not return\n*/\nint VSIFCloseL(VSILFILE *fp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t VSIFWriteL( const void *pBuffer, size_t nSize, size_t nCount, VSILFILE *fp )\n\n{\n    VSIVirtualHandle *poFileHandle = (VSIVirtualHandle *) fp;\n    \n    return poFileHandle->Write( pBuffer, nSize, nCount );\n}\n",
        "answer": "/** @brief Writes nCount objects of nSize bytes to the indicated file at the current offset into the indicated buffer.\n*\n* This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX fwrite() call.\n*\n* @param pBuffer The buffer from which to write data.\n* @param nSize The size of each object to write, in bytes.\n* @param nCount The number of objects to write.\n* @param fp The file pointer at which to write the data.\n*\n* @return The number of objects written.\n*/\nsize_t VSIFWriteL( const void *pBuffer, size_t nSize, size_t nCount, VSILFILE *fp )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void VSIInstallCurlStreamingFileHandler(void)\n{\n    /* not supported */\n}\n",
        "answer": "/** @brief Installs a file handler that allows on-the-fly sequential reading of files streamed through HTTP/FTP web protocols.\n*\n*  This function installs a special file handler that allows on-the-fly sequential reading of files streamed through HTTP/FTP web protocols (typically dynamically generated files), without prior download of the entire file. Although this file handler is able seek to random offsets in the file, this will not be efficient. If you need efficient random access and that the server supports range dowloading, you should use the /vsicurl/ file system handler instead. Recognized filenames are of the form /vsicurl_streaming/http://path/to/remote/resource or /vsicurl_streaming/ftp://path/to/remote/resource where path/to/remote/resource is the URL of a remote resource. The GDAL_HTTP_PROXY, GDAL_HTTP_PROXYUSERPWD and GDAL_PROXY_AUTH configuration options can be used to define a proxy server. The syntax to use is the one of Curl CURLOPT_PROXY, CURLOPT_PROXYUSERPWD and CURLOPT_PROXYAUTH options. The file can be cached in RAM by setting the configuration option VSI_CACHE to TRUE. The cache size defaults to 25 MB, but can be modified by setting the configuration option VSI_CACHE_SIZE (in bytes). VSIStatL() will return the size in st_size member and file nature- file or directory - in st_mode member (the later only reliable with FTP resources for now).\n*\n* @return Should not return\n*/\n/* not supported */\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int DGNGetAssocID( DGNHandle hDGN, DGNElemCore *psElem )\n\n{\n    int iLink;\n    \n    for( iLink = 0; TRUE; iLink++ )\n    {\n        int nLinkType, nLinkSize;\n        unsigned char *pabyData;\n\n        pabyData = DGNGetLinkage( hDGN, psElem, iLink, &nLinkType, \n                                  NULL, NULL, &nLinkSize );\n        if( pabyData == NULL )\n            return -1;\n\n        if( nLinkType == DGNLT_ASSOC_ID && nLinkSize >= 8 )\n        {\n            return pabyData[4] \n                + pabyData[5] * 256 \n                + pabyData[6]*256*256\n                + pabyData[7] * 256*256*256;\n        }\n    }\n}\n",
        "answer": "/** @brief Fetch association id for an element.\n*\n* This method will check if an element has an association id, and if so returns it, otherwise returning -1. Association ids are kept as a user attribute linkage where present.\n*\n* @param hDGN The DGN handle to the file.\n* @param psElem The element for which to fetch the association id.\n* @return The association id of the element if it exists, otherwise -1.\n*/\nint DGNGetAssocID( DGNHandle hDGN, DGNElemCore *psElem )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int DGNUpdateElemCore( DGNHandle hDGN, DGNElemCore *psElement, \n                       int nLevel, int nGraphicGroup, int nColor, \n                       int nWeight, int nStyle )\n\n{\n    psElement->level = nLevel;\n    psElement->graphic_group = nGraphicGroup;\n    psElement->color = nColor;\n    psElement->weight = nWeight;\n    psElement->style = nStyle;\n\n    return DGNUpdateElemCoreExtended( hDGN, psElement );\n}\n",
        "answer": "/** @brief Updates the core values of an element.\n*\n*  This function updates the indicated values in the element and in the raw data. The updated element is not written to disk. That must be done with DGNWriteElement(). The element must have raw_data loaded.\n*\n* @param hDGN A handle to the DGN file or database.\n* @param psElement Pointer to the DGNElemCore structure that contains the element to update.\n* @param nLevel The new level value for the element.\n* @param nGraphicGroup The new graphic group value for the element.\n* @param nColor The new color value for the element.\n* @param nWeight The new weight value for the element.\n* @param nStyle The new style value for the element.\n*\n* @return Should not return\n*/\nint DGNUpdateElemCore( DGNHandle hDGN, DGNElemCore *psElement,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPL_STDCALL GDALDumpOpenDatasets( FILE *fp )\n   \n{\n    VALIDATE_POINTER1( fp, \"GDALDumpOpenDatasets\", 0 );\n\n    CPLMutexHolderD( &hDLMutex );\n\n    if (poAllDatasetMap != NULL)\n    {\n        VSIFPrintf( fp, \"Open GDAL Datasets:\\n\" );\n        std::map<GDALDataset*, GIntBig>::iterator oIter = poAllDatasetMap->begin();\n        for(; oIter != poAllDatasetMap->end(); ++oIter )\n        {\n            GDALDumpOpenDatasetsForeach(oIter->first, fp);\n        }\n        if (phSharedDatasetSet != NULL)\n        {\n            CPLHashSetForeach(phSharedDatasetSet, GDALDumpOpenSharedDatasetsForeach, fp);\n        }\n        return (int)poAllDatasetMap->size();\n    }\n    else\n    {\n        return 0;\n    }\n}\n",
        "answer": "/** @brief Dumps a list of all open datasets to the indicated text file.\n*\n* This function is primarily intended to assist in debugging \"dataset leaks\" and reference counting issues. The information reported includes the dataset name, referenced count, shared status, driver name, size, and band count.\n*\n* @param fp The text file (may be stdout or stderr) to dump the list of open datasets to.\n* @return The number of open datasets.\n*/\nint CPL_STDCALL GDALDumpOpenDatasets( FILE *fp )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void GDALDatasetSetStyleTable( GDALDatasetH hDS, OGRStyleTableH hStyleTable )\n\n{\n    VALIDATE_POINTER0( hDS, \"OGR_DS_SetStyleTable\" );\n    VALIDATE_POINTER0( hStyleTable, \"OGR_DS_SetStyleTable\" );\n    \n    ((GDALDataset *) hDS)->SetStyleTable( (OGRStyleTable *) hStyleTable);\n}\n",
        "answer": "/**\n* @brief Set the style table of a GDAL dataset.\n*\n* This function operates exactly as GDALDatasetSetStyleTableDirectly() except that it assumes ownership of the passed table.\n*\n* @param hDS The handle to the GDAL dataset.\n* @param hStyleTable The handle to the OGR style table.\n*/\nvoid GDALDatasetSetStyleTable(GDALDatasetH hDS, OGRStyleTableH hStyleTable);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int GDALReprojectionTransform( void *pTransformArg, int bDstToSrc, \n                                int nPointCount, \n                                double *padfX, double *padfY, double *padfZ,\n                                int *panSuccess )\n\n{\n    GDALReprojectionTransformInfo *psInfo = \n        (GDALReprojectionTransformInfo *) pTransformArg;\t\t\n    int bSuccess;\n\n    if( bDstToSrc )\n        bSuccess = psInfo->poReverseTransform->TransformEx( \n            nPointCount, padfX, padfY, padfZ, panSuccess );\n    else\n        bSuccess = psInfo->poForwardTransform->TransformEx( \n            nPointCount, padfX, padfY, padfZ, panSuccess );\n\n    return bSuccess;\n}\n",
        "answer": "/**\n* @brief Perform reprojection transformation.\n*\n* This function performs the reprojection transformation described in GDALCreateReprojectionTransformer().\n* It matches the GDALTransformerFunc() signature. Details of the arguments are described there.\n*\n* @param pTransformArg Pointer to a GDALReprojectionTransformInfo structure containing the transformation information.\n* @param bDstToSrc Flag indicating whether the transformation is from destination to source (TRUE) or source to destination (FALSE).\n* @param nPointCount Number of points in the input arrays.\n* @param padfX Array of x coordinates for the input points.\n* @param padfY Array of y coordinates for the input points.\n* @param padfZ Array of z coordinates for the input points (may be NULL).\n* @param panSuccess Output array indicating whether each point was successfully transformed (may be NULL).\n*\n* @return TRUE if the transformation was successful, FALSE otherwise.\n*/\nint GDALReprojectionTransform(void* pTransformArg, int bDstToSrc,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void OGRSetNonLinearGeometriesEnabledFlag(int bFlag)\n{\n    bNonLinearGeometriesEnabled = bFlag;\n}\n",
        "answer": "/** @brief Sets the flag for enabling non-linear geometries.\n*\n* This flag has only an effect on the OGR_F_GetGeometryRef(), OGR_F_GetGeomFieldRef(), OGR_L_GetGeomType(), OGR_GFld_GetType() and OGR_FD_GetGeomType() C API, and corresponding methods in the SWIG bindings. It is meant as making it simple for applications using the OGR C API not to have to deal with non-linear geometries, even if such geometries might be returned by drivers. In which case, they will be transformed into their closest linear geometry, by doing linear approximation, with OGR_G_ForceTo().\n*\n* @param bFlag The flag value to set. If true, non-linear geometries are enabled; otherwise, they are disabled.\n*/\nvoid OGRSetNonLinearGeometriesEnabledFlag(int bFlag)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_F_SetGeomFieldDirectly( OGRFeatureH hFeat, int iField,\n                                   OGRGeometryH hGeom )\n\n{\n    VALIDATE_POINTER1( hFeat, \"OGR_F_SetGeomFieldDirectly\", CE_Failure );\n\n    return ((OGRFeature *) hFeat)->SetGeomFieldDirectly(iField,\n                                                        (OGRGeometry *) hGeom);\n}\n",
        "answer": "/** @brief Updates the features geometry and operates exactly as SetGeomField(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).\n*\n*  This function updates the features geometry, and operate exactly as SetGeomField(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).\n*\n* @param hFeat The feature handle.\n* @param iField The field index.\n* @param hGeom The geometry handle.\n*\n* @return OGRERR_NONE if successful, or an error code if the operation fails.\n*/\nOGRErr OGR_F_SetGeomFieldDirectly( OGRFeatureH hFeat, int iField,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int OGR_G_Intersects( OGRGeometryH hGeom, OGRGeometryH hOtherGeom )\n\n{\n    VALIDATE_POINTER1( hGeom, \"OGR_G_Intersects\", FALSE );\n    VALIDATE_POINTER1( hOtherGeom, \"OGR_G_Intersects\", FALSE );\n\n    return ((OGRGeometry *) hGeom)->Intersects( (const OGRGeometry *) hOtherGeom );\n}\n",
        "answer": "/** @brief Determines whether two geometries intersect.\n*\n*  This function determines whether the bounding boxes of two geometries overlap. If GEOS is enabled, then this is done in a rigorous fashion using the GEOS library. Otherwise, TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.\n*\n* @param hGeom The first geometry to be tested for intersection.\n* @param hOtherGeom The second geometry to be tested for intersection.\n* @return TRUE if the geometries intersect, otherwise FALSE.\n*/\nint OGR_G_Intersects(OGRGeometryH hGeom, OGRGeometryH hOtherGeom)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRGeometryH OGR_G_Intersection( OGRGeometryH hThis, OGRGeometryH hOther )\n\n{\n    VALIDATE_POINTER1( hThis, \"OGR_G_Intersection\", NULL );\n\n    return (OGRGeometryH) \n        ((OGRGeometry *) hThis)->Intersection( (OGRGeometry *) hOther );\n}\n",
        "answer": "/** @brief Generates a new geometry which is the region of intersection of the two geometries operated on.\n*\n*  This function uses the GEOS library to perform the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.\n*\n* @param hThis The first geometry to operate on.\n* @param hOther The second geometry to operate on.\n* @return A new geometry representing the intersection of the two input geometries.\n*/\nOGRGeometryH OGR_G_Intersection( OGRGeometryH hThis, OGRGeometryH hOther )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int OGR_G_Centroid( OGRGeometryH hGeom, OGRGeometryH hCentroidPoint )\n\n{\n    VALIDATE_POINTER1( hGeom, \"OGR_G_Centroid\", OGRERR_FAILURE );\n\n    OGRGeometry *poGeom = ((OGRGeometry *) hGeom);\n    OGRPoint *poCentroid = ((OGRPoint *) hCentroidPoint);\n    \n    if( poCentroid == NULL )\n        return OGRERR_FAILURE;\n\n    if( wkbFlatten(poCentroid->getGeometryType()) != wkbPoint )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"Passed wrong geometry type as centroid argument.\" );\n        return OGRERR_FAILURE;\n    }\n\n    return poGeom->Centroid( poCentroid );\n}\n",
        "answer": "/**\n* @brief Compute the centroid of a geometry.\n*\n* This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons). This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.\n*\n* @param hGeom The handle to the geometry.\n* @param hCentroidPoint The handle to the centroid point.\n*\n* @return OGRERR_NONE if successful, or an error code if not.\n*/\nint OGR_G_Centroid(OGRGeometryH hGeom, OGRGeometryH hCentroidPoint);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRwkbGeometryType OGR_GT_GetLinear( OGRwkbGeometryType eType )\n{\n    OGRwkbGeometryType eFGType = wkbFlatten(eType);\n\n    if( OGR_GT_IsCurve(eFGType) )\n        eType = wkbLineString;\n\n    else if( OGR_GT_IsSurface(eFGType) )\n        eType = wkbPolygon;\n\n    else if( eFGType == wkbMultiCurve )\n        eType = wkbMultiLineString;\n\n    else if( eFGType == wkbMultiSurface )\n        eType = wkbMultiPolygon;\n\n    if( wkbHasZ(eType) )\n        eType = wkbSetZ(eType);\n\n    return eType;\n}\n",
        "answer": "/**\n* @brief Get the linear geometry type for a given geometry type.\n*\n* This function handles conversions between curve and surface geometries, as well as\n* preserving the Z flag.\n*\n* @param eType The input geometry type.\n*\n* @return The linear geometry type corresponding to the input type.\n*/\nOGRwkbGeometryType OGR_GT_GetLinear(OGRwkbGeometryType eType)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_L_Clip( OGRLayerH pLayerInput, \n                   OGRLayerH pLayerMethod, \n                   OGRLayerH pLayerResult, \n                   char** papszOptions, \n                   GDALProgressFunc pfnProgress, \n                   void * pProgressArg )\n\n{\n    VALIDATE_POINTER1( pLayerInput, \"OGR_L_Clip\", OGRERR_INVALID_HANDLE );\n    VALIDATE_POINTER1( pLayerMethod, \"OGR_L_Clip\", OGRERR_INVALID_HANDLE );\n    VALIDATE_POINTER1( pLayerResult, \"OGR_L_Clip\", OGRERR_INVALID_HANDLE );\n\n    return ((OGRLayer *)pLayerInput)->Clip( (OGRLayer *)pLayerMethod, (OGRLayer *)pLayerResult, papszOptions, pfnProgress, pProgressArg );\n}\n",
        "answer": "/**\n* @brief Clips features from an input layer using a method layer and stores the results in a result layer.\n*\n* The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.\n*\n* @param pLayerInput The input layer containing the features to be clipped.\n* @param pLayerMethod The method layer used to clip the features.\n* @param pLayerResult The result layer where the clipped features will be stored.\n* @param papszOptions Options for the clipping operation, such as the field names to include in the result layer.\n* @param pfnProgress A function to report progress to the user.\n* @param pProgressArg An argument to pass to the progress function.\n*\n* @return OGRERR_NONE if the operation is successful, or an error code if something goes wrong.\n*/\nOGRErr OGR_L_Clip( OGRLayerH pLayerInput,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static float CenterFromEnd(const StateCount& stateCount, int end)\n{\n\treturn (float)(end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0f;\n}\n",
        "answer": "/** @brief Calculates the center of a run of black and white pixels.\n*\n* This function takes in a count of black and white pixels, as well as an end position, and calculates the location of the center of the run.\n*\n* @param stateCount The count of black and white pixels.\n* @param end The end position of the run.\n* @return The location of the center of the run.\n*/\nstatic float CenterFromEnd(const StateCount& stateCount, int end)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int zts_socket(int socket_family, int socket_type, int protocol)\n{\n\tint socket_family_adj = platform_adjusted_socket_family(socket_family);\n\treturn !zts_ready() ? -1 : lwip_socket(socket_family_adj, socket_type, protocol);\n}\n",
        "answer": "/** @brief Create a zts_socket function.\n*\n*  This function creates a new socket for the ZTS library.\n*\n* @param socket_family The address family of the socket (e.g. AF_INET, AF_INET6).\n* @param socket_type The type of socket (e.g. SOCK_STREAM, SOCK_DGRAM).\n* @param protocol The protocol to use for the socket (e.g. IPPROTO_TCP, IPPROTO_UDP).\n*\n* @return A new socket file descriptor, or -1 if an error occurred.\n*/\nint zts_socket(int socket_family, int socket_type, int protocol)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string encapsulate_in_quotes(std::string& unprocessed_log_string) {\n  size_t start_pos = 0;\n  string encapsulated_log_string(unprocessed_log_string);\n  while((start_pos = encapsulated_log_string.find(\"\\\"\", start_pos)) != std::string::npos) {\n    encapsulated_log_string.replace(start_pos, 1, \"\\\\\\\"\");\n    start_pos += 2;\n  }\n  encapsulated_log_string =  \"\\\"\" + encapsulated_log_string + \"\\\"\";\n  return encapsulated_log_string;\n\n}\n",
        "answer": "/** @brief Encapsulates a string in quotes and escapes any existing quotes.\n*\n* This function takes a string as input, finds all occurrences of the quote character (\"),\n* and replaces them with an escaped version of the quote character (\\\"). It then adds a quote\n* at the beginning and end of the string to encapsulate it.\n*\n* @param unprocessed_log_string The input string to be processed.\n* @return A new string that is encapsulated in quotes and has all quotes escaped.\n*/\nstd::string encapsulate_in_quotes(std::string& unprocessed_log_string) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t b64Decode(const char *b64Data, size_t b64length, uint8_t *binData, size_t binLength)\n{\n    if (b64length == 0)\n        return 0;\n\n    size_t codeLength = binLength;\n    if (base64decode (b64Data, b64length, binData, &codeLength) != 0) {\n        return 0;\n    }\n    return codeLength;\n}\n",
        "answer": "/** @brief Decodes a Base64 string into binary data.\n*\n* This function decodes a Base64 string into binary data. The function accepts all valid B64 formatted strings.\n*\n* @param b64Data Pointer to the Base64 string to be decoded.\n* @param b64length Length of the Base64 string.\n* @param binData Pointer to the buffer where the binary data will be stored.\n* @param binLength Size of the buffer pointed to by binData.\n*\n* @return The length of the decoded binary data, or 0 if an error occurred.\n*/\nsize_t b64Decode(const char *b64Data, size_t b64length, uint8_t *binData, size_t binLength) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool sha256_encrypt (const std::string & input, std::string & output)\n{\n\tunsigned char sha_out[SHA256_DIGEST_LENGTH];\n\tSHA256_CTX context;\n\tif (!SHA256_Init (&context))\n\t{\n\t\treturn false;\n\t}\n\n\tif (!SHA256_Update (&context, input.c_str (), input.length ()))\n\t{\n\t\treturn false;\n\t}\n\n\tif (!SHA256_Final (sha_out, &context))\n\t{\n\t\treturn false;\n\t}\n\n\tstd::stringstream ss;\n\tfor (int i = 0; i < SHA256_DIGEST_LENGTH; i++)\n\t{\n\t\tss << std::hex << std::setw (2) << std::setfill ('0') << static_cast<int> (sha_out[i]);\n\t}\n\toutput = ss.str ();\n\n\treturn true;\n}\n",
        "answer": "/** @brief Encrypts a string using the SHA256 algorithm.\n*\n* This function utilizes the OpenSSL library to encrypt a string using the SHA256 encryption algorithm. It is useful for password encryption.\n*\n* @param input The string to be encrypted.\n* @param output The encrypted string.\n* @return true if the encryption was successful, false otherwise.\n*/\nbool sha256_encrypt(const std::string& input, std::string& output) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void AddPendingActivation(uint16_t featureId, int activationBlock, uint32_t minClientVersion, const std::string& featureName)\n{\n    DeletePendingActivation(featureId);\n\n    FeatureActivation featureActivation;\n    featureActivation.featureId = featureId;\n    featureActivation.featureName = featureName;\n    featureActivation.activationBlock = activationBlock;\n    featureActivation.minClientVersion = minClientVersion;\n\n    vecPendingActivations.push_back(featureActivation);\n\n    uiInterface.ExodusStateChanged();\n}\n",
        "answer": "/** @brief Adds a feature activation to the PendingActivations vector. If this feature was previously scheduled for activation, then the state pending objects are deleted. Adds a pending activation\n*\n*  This function adds a feature activation to the PendingActivations vector if it is not already present. If the feature was previously scheduled for activation, then the state pending objects are deleted and the new activation is added.\n*\n* @param featureId The ID of the feature to be activated.\n* @param activationBlock The block at which the feature will be activated.\n* @param minClientVersion The minimum client version required for the feature to be activated.\n* @param featureName The name of the feature being activated.\n*\n* @return void\n*/\nvoid AddPendingActivation(uint16_t featureId, int activationBlock, uint32_t minClientVersion, const std::string& featureName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void DeleteAlerts(const std::string& sender)\n{\n    for (std::vector<AlertData>::iterator it = currentExodusAlerts.begin(); it != currentExodusAlerts.end(); ) {\n        AlertData alert = *it;\n        if (sender == alert.alert_sender) {\n            PrintToLog(\"Removing deleted alert (from:%s type:%d expiry:%d message:%s)\\n\", alert.alert_sender,\n                alert.alert_type, alert.alert_expiry, alert.alert_message);\n            it = currentExodusAlerts.erase(it);\n            uiInterface.ExodusStateChanged();\n        } else {\n            it++;\n        }\n    }\n}\n",
        "answer": "/** @brief Deletes previously broadcast alerts from the sender.\n*\n*  This function deletes previously broadcast alerts from the sender. Note that this function cannot be used to delete alerts from other addresses, nor to delete system generated feature alerts.\n*\n* @param[in] sender The address of the sender whose alerts should be deleted.\n*/\nvoid DeleteAlerts(const std::string& sender)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string ReplaceStr(const std::string& findText, const std::string& replaceText, const std::string& inputStr)\n{\n    size_t start_pos = 0;\n    std::string outputStr = inputStr;\n    while((start_pos = outputStr.find(findText, start_pos)) != std::string::npos) {\n        outputStr.replace(start_pos, findText.length(), replaceText);\n        start_pos += replaceText.length();\n    }\n    return outputStr;\n}\n",
        "answer": "/** @brief Variable length find and replace. Find all iterations of findText within inputStr and replace them with replaceText.\n*\n*  This function finds all occurrences of the string \"findText\" in the input string \"inputStr\" and replaces them with the string \"replaceText\".\n*\n* @param[in] findText The string to search for in the input string.\n* @param[in] replaceText The string to replace the found occurrences with.\n* @param[in] inputStr The input string to search and replace in.\n* @return The modified output string with all occurrences of \"findText\" replaced with \"replaceText\".\n*/\nstd::string ReplaceStr(const std::string& findText, const std::string& replaceText, const std::string& inputStr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool GetBlockHash(uint256 &hashRet, int nBlockHeight) {\n    LOCK(cs_main);\n    if (chainActive.Tip() == NULL) return false;\n    if (nBlockHeight < -1 || nBlockHeight > chainActive.Height()) return false;\n    if (nBlockHeight == -1) nBlockHeight = chainActive.Height();\n    hashRet = chainActive[nBlockHeight]->GetBlockHash();\n    return true;\n}\n",
        "answer": "/** @brief Get the block hash at a given height in the active chain.\n*\n* This function returns the block hash for a given height in the active chain. If no nBlockHeight is specified, it uses the current tip of the active chain.\n*\n* @param[out] hashRet The found hash.\n* @param[in] nBlockHeight The height at which to find the hash. If not specified, the current tip of the active chain is used.\n* @return True if the hash was found, false otherwise.\n*/\nbool GetBlockHash(uint256 &hashRet, int nBlockHeight) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void registerThread(ramses::ERamsesThreadIdentifier)\n        {\n        }\n",
        "answer": "/** @brief Registers a thread with the system.\n*\n*  This method is called before reporting alive messages of a specific threadID, and it is used to register the thread with the system. Do not expect notifyThread calls for threadID before this method was invoked.\n*\n* @param[in] threadID The identifier of the thread to be registered.\n*/\nvoid registerThread(ramses::ERamsesThreadIdentifier threadID)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline int daysInYear(int y)\n{\n    return 31 * 7 + 30 * 4 + 28 + leapYear(y);\n}\n",
        "answer": "/** @brief Calculates the number of days in a year.\n*\n* This function calculates the number of days in a year based on the input parameter y, which represents the year. The calculation takes into account the number of days in each month and whether the year is a leap year or not.\n*\n* @param[in] y The year for which to calculate the number of days.\n* @return The number of days in the given year.\n*/\ninline int daysInYear(int y)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void constructBlocks(Blocks &blocks, Instructions &instructions) {\n\t/* Create the first block containing the very first instruction in this script.\n\t * Then follow the complete code flow from this instruction onwards. */\n\n\tassert(blocks.empty());\n\tif (instructions.empty())\n\t\treturn;\n\n\tblocks.push_back(Block(instructions.front().address));\n\tconstructBlocks(blocks, blocks.back(), instructions.front());\n}\n",
        "answer": "/** @brief Construct a control flow graph of interconnected blocks from this complete set of script instructions.\n*\n*  This function constructs a control flow graph of interconnected blocks from the given complete set of script instructions.\n*  It creates the first block containing the very first instruction in this script, and then follows the complete code flow from this instruction onwards.\n*\n* @param blocks The list of blocks to be constructed.\n* @param instructions The complete set of script instructions.\n* @return void\n*/\n/* Create the first block containing the very first instruction in this script.\n* Then follow the complete code flow from this instruction onwards. */\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Common::UString formatStoreState(uint32 address) {\n\treturn Common::UString::format(\"sta_%08X\", address);\n}\n",
        "answer": "/** @brief Format the store state.\n*\n*  This function formats the store state to be the name of a subroutine started with STORESTATE. Example: \"sta_000023FF\". Always exactly 12 characters long.\n*\n* @param address The address to format.\n* @return The formatted store state.\n*/\nreturn Common::UString::format(\"sta_%08X\", address);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "struct SimpleASTNode {\n  llvm::Optional<ASTKind> kind;\n  llvm::Optional<std::string> represents;\n  llvm::Optional<std::vector<SimpleASTNode>> children;\n\n  static SimpleASTNode createFrom(ASTNode const* node) {\n    SimpleASTNode simpleNode;\n    simpleNode.kind = node->getKind();\n\n    simpleNode.represents = ASTStringer::toString(node);\n\n    traverseNodeIf(node, pred::hasChildren(), [&](auto promoted) {\n      auto children = promoted->children();\n      if (!children.empty()) {\n        simpleNode.children.emplace();\n        for (auto child : children) {\n          simpleNode.children->emplace_back(createFrom(child));\n        }\n      }\n    });\n    return simpleNode;\n  }\n};\n",
        "answer": "/** @brief A simple AST node.\n*\n* This struct represents a simple AST node, with an optional kind, string representation, and children.\n*/\n/** @brief Creates a simple AST node from an AST node pointer.\n*\n* This function creates a simple AST node from an AST node pointer, using the `getKind()` and `toString()` methods to set the kind and string representation of the node, respectively. If the node has children, it recursively calls itself on each child node to create a vector of simple AST nodes representing the children.\n*\n* @param node The AST node pointer to convert to a simple AST node.\n* @return A simple AST node representing the given AST node.\n*/\nstatic SimpleASTNode createFrom(ASTNode const* node) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void writeMonitor()\n{\n    Commands::printTemperatures(false);\n}\n",
        "answer": "/** @brief Write monitored temperature to the console.\n*\n*  This function is called every 250ms to write the monitored temperature. If monitoring is disabled, the function is not called.\n*\n* @param[in] bool - Whether or not to print the temperatures.\n* @return void\n*/\nvoid writeMonitor()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M113() {\n    if (code_seen('S')) {\n      host_keepalive_interval = code_value_byte();\n      NOMORE(host_keepalive_interval, 60);\n    }\n    else {\n      SERIAL_ECHO_START;\n      SERIAL_ECHOPAIR(\"M113 S\", (unsigned long)host_keepalive_interval);\n      SERIAL_EOL;\n    }\n  }\n",
        "answer": "/** @brief Set or get Host Keepalive interval.\n*\n* This function sets or gets the host keepalive interval. If the parameter 'S' is seen, it sets the keepalive interval to the value of code_value_byte(). Otherwise, it returns the current keepalive interval.\n*\n* @param[in] S The new keepalive interval if set, or not present if get.\n* @return The current keepalive interval if set, or not present if get.\n*/\ninline void gcode_M113() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void gcode_T(uint8_t tmp_extruder) {\n\n  #if ENABLED(DEBUG_LEVELING_FEATURE)\n    if (DEBUGGING(LEVELING)) {\n      SERIAL_ECHOPAIR(\">>> gcode_T(\", tmp_extruder);\n      SERIAL_ECHOLNPGM(\")\");\n      DEBUG_POS(\"BEFORE\", current_position);\n    }\n  #endif\n\n  #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)\n\n    tool_change(tmp_extruder);\n\n  #elif HOTENDS > 1\n\n    tool_change(\n      tmp_extruder,\n      code_seen('F') ? code_value_axis_units(X_AXIS) : 0.0,\n      (tmp_extruder == active_extruder) || (code_seen('S') && code_value_bool())\n    );\n\n  #endif\n\n  #if ENABLED(DEBUG_LEVELING_FEATURE)\n    if (DEBUGGING(LEVELING)) {\n      DEBUG_POS(\"AFTER\", current_position);\n      SERIAL_ECHOLNPGM(\"<<< gcode_T\");\n    }\n  #endif\n}\n",
        "answer": "/**\n* @brief Switch tool, usually switching extruders.\n*\n* This function switches the current tool to a new one specified by the\n* parameter `tmp_extruder`. The movement feedrate and whether or not to move\n* the tool in XY after changing are also parameters that can be set.\n*\n* @param tmp_extruder The index of the new extruder to switch to.\n* @param F[units/min] The movement feedrate for the tool change.\n* @param S1 Don't move the tool in XY after changing.\n*\n* @return None\n*/\ninline void gcode_T(uint8_t tmp_extruder) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "float GetSumSerial(float *arr, size_t n) {\n  float temp = 0;\n  for (int i = 0; i < n; i++) {\n    temp += arr[i];\n  }\n  return temp;\n}\n",
        "answer": "/** @brief GetSumSerial.\n*\n*  This function calculates the sum of an array of floats in a serial manner.\n*\n* @param arr The input array of floats.\n* @param n The size of the input array.\n* @return The sum of the input array.\n*/\nfloat GetSumSerial(float *arr, size_t n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tinline const double series(const int size, const double *a, const double &x, const int n, double result=0.0)\n\t{\n\t\tfor(int i=size-1; i>=0; i--)\n\t\t\tresult += a[i]*gsl_pow_int(x,i+n);\n\t\treturn result;\n\t}\n",
        "answer": "/** @brief Sum a power series.\n*\n*  This function sums a power series backwards, since the last terms are usually smaller, and this reduces the loss in precision. It sums a[i]*x^(i+n), where n is an integer.\n*\n* @param size The number of elements in the array a.\n* @param a An array of doubles representing the coefficients of the power series.\n* @param x The value to be raised to the power of i+n.\n* @param n An integer representing the power to which x is raised.\n* @param result A double representing the current sum of the series, initialized to 0.0.\n* @return The sum of the power series a[i]*x^(i+n), where n is an integer.\n*/\ninline const double series(const int size, const double *a, const double &x, const int n, double result=0.0)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "off64_t AAsset_getRemainingLength64(AAsset* asset)\n{\n    return asset->mAsset->getRemainingLength();\n}\n",
        "answer": "/** @brief Report the total amount of asset data that can be read from the current position. Uses a 64-bit number instead of a 32-bit number as AAsset_getRemainingLength does.\n*\n* @param[in] asset The asset to get the remaining length for.\n* @return The total amount of asset data that can be read from the current position, or -1 on error.\n*/\noff64_t AAsset_getRemainingLength64(AAsset* asset)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int AndroidBitmap_lockPixels(JNIEnv* env, jobject jbitmap, void** addrPtr) {\n    if (NULL == env || NULL == jbitmap) {\n        return ANDROID_BITMAP_RESULT_BAD_PARAMETER;\n    }\n\n    SkBitmap* bm = GraphicsJNI::getNativeBitmap(env, jbitmap);\n    if (NULL == bm) {\n        return ANDROID_BITMAP_RESULT_JNI_EXCEPTION;\n    }\n\n    bm->lockPixels();\n    void* addr = bm->getPixels();\n    if (NULL == addr) {\n        bm->unlockPixels();\n        return ANDROID_BITMAP_RESULT_ALLOCATION_FAILED;\n    }\n\n    if (addrPtr) {\n        *addrPtr = addr;\n    }\n    return ANDROID_BITMAP_RESULT_SUCCESS;\n}\n",
        "answer": "/**\n* @brief Locks the pixel address of a Java bitmap object.\n*\n* This function attempts to lock the pixel address of a Java bitmap object, ensuring that the memory for the pixels will not move until the unlockPixels call and restoring the pixels if they had been previously purged. If this call succeeds, it must be balanced by a call to AndroidBitmap_unlockPixels after which time the address of the pixels should no longer be used.\n*\n* @param env The JNI environment.\n* @param jbitmap The Java bitmap object.\n* @param addrPtr A pointer to the pixel address, if successful.\n*\n* @return ANDROID_BITMAP_RESULT_SUCCESS if the pixels were successfully locked, ANDROID_BITMAP_RESULT_BAD_PARAMETER if env or jbitmap is NULL, ANDROID_BITMAP_RESULT_JNI_EXCEPTION if a JNI exception occurred, and ANDROID_BITMAP_RESULT_ALLOCATION_FAILED if the allocation failed.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t AConfiguration_getSmallestScreenWidthDp(AConfiguration* config) {\n    return config->smallestScreenWidthDp;\n}\n",
        "answer": "/** @brief Get the smallest screen width in dp units.\n*\n* This function returns the smallest screen width in dp units, or ACONFIGURATION_SMALLEST_SCREEN_WIDTH_DP_ANY if not set.\n*\n* @param config The configuration object to query.\n* @return The smallest screen width in dp units, or ACONFIGURATION_SMALLEST_SCREEN_WIDTH_DP_ANY if not set.\n*/\nint32_t AConfiguration_getSmallestScreenWidthDp(AConfiguration* config) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int ALooper_pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    sp<Looper> looper = Looper::getForThread();\n    if (looper == NULL) {\n        LOGE(\"ALooper_pollAll: No looper for this thread!\");\n        return ALOOPER_POLL_ERROR;\n    }\n\n    IPCThreadState::self()->flushCommands();\n    return looper->pollAll(timeoutMillis, outFd, outEvents, outData);\n}\n",
        "answer": "/** @brief Polls all pending callbacks until all data has been consumed or a file descriptor is available with no callback.\n*\n* This function will never return ALOOPER_POLL_CALLBACK.\n*\n* @param timeoutMillis The timeout in milliseconds, -1 for infinite.\n* @param outFd The file descriptor that is ready.\n* @param outEvents The events that are available on the file descriptor.\n* @param outData The data associated with the callback.\n* @return ALOOPER_POLL_CALLBACK if a callback was executed, ALOOPER_POLL_ERROR if an error occurred, or ALOOPER_POLL_TIMEOUT if the timeout expired.\n*/\nint ALooper_pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int ALooper_pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    sp<Looper> looper = Looper::getForThread();\n    if (looper == NULL) {\n        ALOGE(\"ALooper_pollAll: No looper for this thread!\");\n        return ALOOPER_POLL_ERROR;\n    }\n\n    IPCThreadState::self()->flushCommands();\n    return looper->pollAll(timeoutMillis, outFd, outEvents, outData);\n}\n",
        "answer": "/** @brief Polls all pending callbacks until all data has been consumed or a file descriptor is available with no callback.\n*\n* This function will never return ALOOPER_POLL_CALLBACK.\n*\n* @param timeoutMillis The timeout in milliseconds, -1 for infinite.\n* @param outFd The file descriptor that is ready.\n* @param outEvents The events that are available on the file descriptor.\n* @param outData The data associated with the callback.\n* @return ALOOPER_POLL_CALLBACK if a callback was executed, ALOOPER_POLL_ERROR if an error occurred, or ALOOPER_POLL_TIMEOUT if no events were available within the specified timeout.\n*/\nint ALooper_pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Variant::VariantType VariantTypeFromType(unsigned char)\n{\n   return Variant::typeUInt8;\n}\n",
        "answer": "/** @brief Function to get the variant type from an unsigned char.\n*\n*  This function takes in an unsigned char and returns the corresponding variant type.\n*\n* @param[in] type The unsigned char representing the type of the variant.\n* @return The variant type corresponding to the input unsigned char.\n*/\nVariant::VariantType VariantTypeFromType(unsigned char type)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t checkCallEvents(const shared_ptr<EventLog>& log,\n                         uint32_t connId,\n                         EventType callType,\n                         const string& callName) {\n  uint32_t callId = checkCallHandlerEvents(log, connId, callType, callName);\n  checkCallPostHandlerEvents(log, connId, callId, callName);\n\n  return callId;\n}\n",
        "answer": "/** @brief Checks for events that should be logged when a call is made.\n*\n* This function calls checkCallHandlerEvents() followed by checkCallPostHandlerEvents().\n* It returns the call ID allocated by the server.\n*\n* @param log A shared pointer to an EventLog object.\n* @param connId The connection ID for the call.\n* @param callType The type of the call (e.g., \"incoming\", \"outgoing\").\n* @param callName The name of the call (e.g., \"call1234567890\").\n* @return The call ID allocated by the server.\n*/\nuint32_t checkCallEvents(const shared_ptr<EventLog>& log,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int pdo_cassandra_handle_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_value TSRMLS_DC)\n{\n\tpdo_cassandra_db_handle *H = static_cast <pdo_cassandra_db_handle *>(dbh->driver_data);\n\n\tswitch (attr) {\n\n\t\tcase PDO_ATTR_SERVER_VERSION:\n\t\t{\n\t\t\tstd::string version;\n\t\t\tH->client->describe_version(version);\n\t\t\tZVAL_STRING(return_value, version.c_str(), 1);\n\t\t}\n\t\tbreak;\n\n\t\tcase PDO_ATTR_CLIENT_VERSION:\n\t\t\tZVAL_STRING(return_value, PHP_PDO_CASSANDRA_EXTVER, 1);\n\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n",
        "answer": "/** @brief This function handles the get attribute functionality for the PDO Cassandra driver.\n*\n*  This function is responsible for handling the get attribute functionality for the PDO Cassandra driver. It takes in a database handle, an attribute to retrieve, and a return value.\n*\n* @param dbh The database handle.\n* @param attr The attribute to retrieve.\n* @param return_value The return value.\n* @return Should not return.\n*/\nstatic int pdo_cassandra_handle_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_value TSRMLS_DC)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string parseJSONLine(const std::string& line) {\n\tstd::string error;\n\tpicojson::value value;\n\tpicojson::parse(value, line.begin(), line.end(), &error);\n\tif (!error.empty()) {\n\t\tLOG(ERROR) << \"Unable to parse sign line json '\" << line << \"': \" << error << \".\";\n\t\treturn \"\";\n\t}\n\ttry {\n\t\treturn extractTextFromJSON(value);\n\t} catch (std::runtime_error& e) {\n\t\tLOG(ERROR) << \"Invalid json sign line (\" << e.what() << \"): \"  << line;\n\t}\n\treturn \"\";\n}\n",
        "answer": "/** @brief Parses a sign line in the json sign line format.\n*\n*  This function parses the json with the picojson library and uses the extractTextFromJSON function to extract the actual text.\n*\n* @param[in] line The line of JSON data to be parsed.\n* @return A string containing the extracted text, or an empty string if there was an error.\n*/\nstd::string parseJSONLine(const std::string& line) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isOutTTY() {\n#ifdef OS_WIN\n\treturn _isatty(_fileno(stdout));\n#else\n\treturn isatty(fileno(stdout));\n#endif\n}\n",
        "answer": "/** @brief Checks if stdout is connected to a terminal.\n*\n*  This function checks whether the standard output stream is connected to a terminal. It does this by calling the appropriate system-specific functions, either `isatty` on Linux/Unix or `_isatty` on Windows.\n*\n* @return A boolean value indicating whether stdout is connected to a terminal.\n*/\nbool isOutTTY() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main( int argc, char ** argv ) {\n\tshark::Shark::info( std::cout );\n\n}\n",
        "answer": "/** @brief Main entrypoint for the Shark program.\n*\n*  This is the main entrypoint for the Shark program, which is a free software\n*  distributed under the terms of the GNU Lesser General Public License as published by\n*  the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n*  Shark is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n*\n* @param argc The number of command-line arguments passed to the program.\n* @param argv An array of strings containing the command-line arguments passed to the program.\n* @return 0 on success, non-zero on failure.\n*/\nint main( int argc, char ** argv ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class rand_rehasher\n{\n\tlong *rehash_map;\n\tlong rehash_zero;\n\tlong st;\n\tlong range;\npublic:\n\trand_rehasher(long st, long n) {\n\t\tsrandom(time(NULL));\n\t\tthis->range = n - st;\n\t\tthis->st = st;\n\t\trehash_map = new long[range];\n\t\tmemset(rehash_map, 0, sizeof(rehash_map[0]) * range);\n\t\trehash_zero = random() % range + st;\n\t}\n\n\t~rand_rehasher() {\n\t\tdelete rehash_map;\n\t}\n\n\tlong rehash(long v) {\n\t\tassert(v >= st && v < st + range);\n\t\tif (v == 0)\n\t\t\treturn rehash_zero;\n\t\telse if (rehash_map[v - st] == 0) {\n\t\t\trehash_map[v - st] = random() % range + st;\n\t\t}\n\t\treturn rehash_map[v - st];\n\t}\n};\n",
        "answer": "/** @brief A class for rehashing a sequence of numbers while preserving their frequency.\n*\n*  This class takes a sequence of numbers and rehashes them into another sequence, but the frequency of each number is preserved.\n*  The rehashed sequence is generated using a random mapping, where each number is mapped to a new number in the range [st, n).\n*\n* @param st The starting value of the sequence (inclusive)\n* @param n The ending value of the sequence (exclusive)\n*/\nclass rand_rehasher"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int emu_setrenderplanes(lua_State *L) {\r\n\tbool sprites = (lua_toboolean( L, 1 ) == 1);\r\n\tbool background = (lua_toboolean( L, 2 ) == 1);\r\n\tFCEUI_SetRenderPlanes(sprites, background);\r\n\treturn 0;\r\n}\r\n",
        "answer": "/** @brief Set rendering planes.\n*\n* This function sets the rendering planes for the emulator.\n* It accepts two boolean values, one for sprites and one for background,\n* and enables or disables them accordingly.\n*\n* @param L The Lua state.\n* @return 0 if successful, -1 otherwise.\n*/\nstatic int emu_setrenderplanes(lua_State *L) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BLARGG_EXPORT int fex_err_code( fex_err_t err )\r\n{\r\n\tint code = err_code( err );\r\n\treturn (code >= 0 ? code : fex_err_generic);\r\n}\r\n",
        "answer": "/** @brief Returns the error code for a given FEX error.\n*\n* This function takes an FEX error and returns its corresponding error code. If the error is NULL, it returns fex_ok. If the error is not a valid FEX error, it returns fex_err_generic.\n*\n* @param err The FEX error to get the error code for.\n*\n* @return The error code for the given FEX error.\n*/\nBLARGG_EXPORT int fex_err_code( fex_err_t err )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BLARGG_EXPORT fex_err_t   fex_data            ( fex_t* fe, const void** data_out )  { return fe->data( data_out ); }\r\n",
        "answer": "/** @brief Returns a pointer to the current file's data in memory.\n*\n*  This function returns a pointer to the current file's data in memory. The pointer is valid until fex_next(), fex_rewind(), fex_seek_arc(), or fex_close() is called. The pointer must NOT be freed(); library frees it automatically. If error, sets *out to NULL.\n*\n* @param fe A pointer to the fex_t struct representing the file.\n* @param data_out A pointer to a const void* that will hold the address of the current file's data in memory.\n* @return BLARGG_EXPORT fex_err_t   fex_data            ( fex_t* fe, const void** data_out )  { return fe->data( data_out ); }\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "measurement_t measure_vector_quantize_04(uint64_t size)\n{\n    return measure_vector_quantize<CloverVector4>(size);\n}\n",
        "answer": "/** @brief Measure the time it takes to quantize a vector of 4 elements.\n*\n* This function measures the time it takes to quantize a vector of 4 elements using the CloverVector4 class.\n*\n* @param size The number of elements in the vector.\n*\n* @return A measurement_t object containing the elapsed time and other relevant information.\n*/\nmeasurement_t measure_vector_quantize_04(uint64_t size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool CheckFinalTx(const CTransaction &tx, int flags = -1) {\n    auto &config = GetConfig();\n    CValidationState state;\n    return ContextualCheckTransactionForCurrentBlock(\n        config, tx, state, config.GetChainParams().GetConsensus(), flags);\n}\n",
        "answer": "/** @brief Checks the final transaction for current block.\n*\n*  This function checks the final transaction for the current block. It is deprecated and is still provided in this header file for a sane migration path away from it. Or maybe we'll just blackhole the wallet at some point.\n*\n* @param tx The transaction to check.\n* @param flags The flags to use when checking the transaction.\n* @return True if the transaction is valid, false otherwise.\n*/\nbool CheckFinalTx(const CTransaction &tx, int flags = -1) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool get_target_extruder_from_command(int code) {\n  if (code_seen('T')) {\n    short t = code_value_short();\n    if (t >= EXTRUDERS) {\n      SERIAL_ECHO_START;\n      SERIAL_CHAR('M');\n      SERIAL_ECHO(code);\n      SERIAL_ECHOPAIR(\" \" MSG_INVALID_EXTRUDER \" \", t);\n      SERIAL_EOL;\n      return true;\n    }\n    target_extruder = t;\n  }\n  else\n    target_extruder = active_extruder;\n\n  return false;\n}\n",
        "answer": "/** @brief Get the target extruder from a command.\n*\n* This function sets the target extruder based on the T parameter or the active extruder.\n* It returns true if the target is invalid, and false otherwise.\n*\n* @param code The code to check for the T parameter.\n* @return True if the target is invalid, false otherwise.\n*/\nbool get_target_extruder_from_command(int code) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M665() {\n    if (code_seen('L')) delta_diagonal_rod = code_value();\n    if (code_seen('R')) delta_radius = code_value();\n    if (code_seen('S')) delta_segments_per_second = code_value();\n    if (code_seen('A')) delta_diagonal_rod_trim_tower_1 = code_value();\n    if (code_seen('B')) delta_diagonal_rod_trim_tower_2 = code_value();\n    if (code_seen('C')) delta_diagonal_rod_trim_tower_3 = code_value();\n    recalc_delta_settings(delta_radius, delta_diagonal_rod);\n  }\n",
        "answer": "/** @brief Set delta configurations.\n*\n*  This function sets the delta configurations for L = diagonal rod R = delta radius S = segments per second A = Alpha (Tower 1) diagonal rod trim B = Beta (Tower 2) diagonal rod trim C = Gamma (Tower 3) diagonal rod trim.\n*\n* @param[in] code_value The value of the parameter.\n* @return None\n*/\ninline void gcode_M665() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void gcode_M410() { stepper.quick_stop(); }\n",
        "answer": "/** @brief G-code M410 handler.\n*\n*  This function handles the G-code command M410, which aborts all planned moves.\n*  It will stop the carriages mid-move, so most likely they will be out of sync with the stepper position after this.\n*\n* @return Should not return\n*/\ninline void gcode_M410() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void move(const Node &source,\n          const Group &destination,\n          const property::LinkCreationList &lcpl,\n          const property::LinkAccessList &lapl)\n{\n  move(source, destination, source.link().path().name(), lcpl, lapl);\n}\n",
        "answer": "/** @brief Moves an object from one group to another.\n*\n* This function moves an object from one group to another. The moved object will appear as /recorded/detectors/data. If an object of the same name already exists, an exception will be thrown. In all cases, the source object as well as the destination group must exist.\n*\n* @param[in] source The source node that contains the object to be moved.\n* @param[in] destination The destination group where the object will be moved to.\n* @param[in] lcpl The link creation property list.\n* @param[in] lapl The link access property list.\n* @return void\n*/\nvoid move(const Node &source, const Group &destination, const property::LinkCreationList &lcpl, const property::LinkAccessList &lapl)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void try_deadlock() {\n    for (uint32_t i = 0; i < get_repeat_times(); ++i) {\n      LOG(INFO) << \" ======= try_deadlock test ======== \";\n      try_deadlock_main();\n    }\n  }\n",
        "answer": "/** @brief Try Deadlock Test.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid try_deadlock() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int op(int *n, int *m, double* b, double* c)\n{\n    aa->MatrixMultiply(*m, b, c);\n    return 0;\n}\n",
        "answer": "/** @brief User supplied routine used by Davidson method.\n*\n*  This function is used by the Davidson method to perform a matrix multiplication.\n*  It takes two matrices, n and m, and multiplies them together using the MatrixMultiply function.\n*  The result of the multiplication is stored in the c matrix.\n*\n* @param[in] n The first matrix to be multiplied.\n* @param[in] m The second matrix to be multiplied.\n* @param[out] b The input vector for the multiplication.\n* @param[out] c The output vector of the multiplication.\n* @return 0 if successful, non-zero otherwise.\n*/\nint op(int *n, int *m, double* b, double* c)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void eval(const SeExprVarNode* /*node*/,\n                      SeVec3d& result)\n    {\n        SeExprInternal::AutoLock<SeExprInternal::Mutex> locker(_lock);\n        if (!_varSet) {\n            _param->getValue(_value);\n            _varSet = true;\n        } else {\n            result[0] = _value;\n        }\n    }\n",
        "answer": "/** @brief Evaluates the expression and sets the result.\n*\n*  This function evaluates the expression and sets the result in the provided SeVec3d object.\n*  It also handles caching of the variable set to improve performance.\n*\n* @param node The parse tree node where the evaluation is occurring.\n* @param result The SeVec3d object where the result will be stored.\n*/\nvoid eval(const SeExprVarNode* /*node*/, SeVec3d& result)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void FreeIpoptProblem(IpoptProblem ipopt_problem)\n{\n  delete [] ipopt_problem->x_L;\n  delete [] ipopt_problem->x_U;\n  if (ipopt_problem->m>0) {\n    delete [] ipopt_problem->g_L;\n    delete [] ipopt_problem->g_U;\n  }\n\n  ipopt_problem->app = NULL;\n\n  delete ipopt_problem;\n}\n",
        "answer": "/** @brief Free a previously created IpoptProblem.\n*\n* This method frees a previously created IpoptProblem, making it unusable for further optimization.\n* It deletes the arrays x_L, x_U, g_L, and g_U if they exist, and sets the app pointer to NULL before deleting the problem itself.\n*\n* @param[in] ipopt_problem The IpoptProblem to free.\n*/\nvoid FreeIpoptProblem(IpoptProblem ipopt_problem)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void testQuadratic(Vec3 coeff, Vec<2,Complex> expected) {\n    Vec<2,Complex> found;\n    PolynomialRootFinder::findRoots(coeff, found);\n    ASSERT((equal2(expected[0], found[0]) && equal2(expected[1], found[1])) || (equal2(expected[0], found[1]) && equal2(expected[1], found[0])))\n}\n",
        "answer": "/** @brief Tests the PolynomialRootFinder::findRoots function.\n*\n* This function tests the PolynomialRootFinder::findRoots function by passing it a polynomial with real coefficients and comparing the found roots to the expected ones.\n*\n* @param coeff The polynomial coefficients.\n* @param expected The expected roots of the polynomial.\n*/\nvoid testQuadratic(Vec3 coeff, Vec<2,Complex> expected) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void doRealizeTime(MultibodySystem& system, State& state) {\n    state.invalidateAllCacheAtOrAbove(Stage::Time);\n    system.realize(state, Stage::Time);\n}\n",
        "answer": "/** @brief Realizes the time stage of a multibody system.\n*\n* This function realizes the time stage of a multibody system by invalidating all cache entries at or above the specified stage and then realizing the system to the specified stage.\n*\n* @param[in,out] system The multibody system to be realized.\n* @param[in,out] state The state of the system to be realized.\n*/\nvoid doRealizeTime(MultibodySystem& system, State& state) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static char _encode_char_rolling_offset(char data_char, char key_char)\n{\n\tif(!isalpha(data_char) || !isalpha(key_char))\n\t\treturn data_char;\n\tsize_t range_size = 'z'-'a'+1;\n\tif(isupper(data_char))\n\t\treturn 'A'+((data_char-'A')+(toupper(key_char)-'A'))%range_size;\n\tif(islower(data_char))\n\t\treturn 'a'+((data_char-'a')+(tolower(key_char)-'a'))%range_size;\n\treturn 'A';\n}\n",
        "answer": "/** @brief Encode a character with a rolling offset.\n*\n*  This function takes a data character and a key character, and returns the encoded\n*  character using a rolling offset. The rolling offset is calculated by taking the\n*  difference between the ASCII values of the data character and the key character,\n*  and then wrapping around to the beginning of the alphabet if necessary.\n*\n* @param data_char The data character to be encoded.\n* @param key_char The key character used for encoding.\n* @return The encoded character.\n*/\nstatic char _encode_char_rolling_offset(char data_char, char key_char)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    ssize_t write(const void* buffer, size_t size) {\n        if (connected()) {\n             size_t n = SERIAL_PORT_USBVIRTUAL.write(static_cast<const uint8_t*>(buffer), size);\n#if !MBED_CONF_PLATFORM_STDIO_BUFFERED_SERIAL\n             SERIAL_PORT_USBVIRTUAL.flush();\n#endif\n            return n;\n        } else {\n            return 0;\n        }\n    }\n",
        "answer": "/**\n* @brief Writes a buffer to a file.\n*\n* This function writes a buffer to a file, acting as a FileHandle. If the\n* connection is not established, it returns 0. Otherwise, it returns the number\n* of bytes written.\n*\n* @param buffer The buffer to write.\n* @param size The size of the buffer.\n* @return The number of bytes written, or 0 if the connection is not established.\n*/\nssize_t write(const void* buffer, size_t size) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "MBED_WEAK bool core_util_atomic_cas_u32(volatile uint32_t* ptr, uint32_t* expectedCurrentValue, uint32_t desiredValue)\n{\n    return core_util_atomic_cas(ptr, expectedCurrentValue, desiredValue);\n}\n",
        "answer": "/** @brief Atomic compare and set.\n*\n*  This function compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.\n*\n* @param ptr A pointer to the memory location to be modified.\n* @param expectedCurrentValue The expected current value of the memory location.\n* @param desiredValue The new value to be stored in the memory location.\n* @return true if the operation was successful, false otherwise.\n*/\nMBED_WEAK bool core_util_atomic_cas_u32(volatile uint32_t* ptr, uint32_t* expectedCurrentValue, uint32_t desiredValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\r\n#include \"serpentp.h\"\r\n\r\nNAMESPACE_BEGIN(CryptoPP)\r\n\r\nvoid Serpent_KeySchedule(word32 *k, unsigned int rounds, const byte *userKey, size_t keylen)\r\n{\r\n\tFixedSizeSecBlock<word32, 8> k0;\r\n",
        "answer": "/** @brief Serpent key schedule function.\n*\n* This function is used to generate the round keys for the Serpent block cipher.\n* It takes a user-provided key and expands it into a set of round keys using the\n* key schedule algorithm defined in the Serpent specification.\n*\n* @param k Pointer to an array of 32-bit words that will hold the generated round keys.\n* @param rounds The number of rounds to generate keys for. This should be a multiple of 16.\n* @param userKey Pointer to the user-provided key.\n* @param keylen The length of the user-provided key in bytes.\n*/\nvoid Serpent_KeySchedule(word32 *k, unsigned int rounds, const byte *userKey, size_t keylen)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid addEventList ( unsigned int count, Event *events ) {}\n",
        "answer": "/** @brief Adds a list of events to the instrumentation model.\n*\n*  Each of (specific) instrumentation modules have to implement this function in order to be consistent with the instrumentation model. This function includes several events in a row to facilitate implementation in which several events occurs at the same time (i.e. same timestamp).\n*\n* @param count The number of events to add.\n* @param events An array of Event objects to add.\n*/\nvoid addEventList(unsigned int count, Event *events) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "      virtual void initialize( void ) {}\n",
        "answer": "/** @brief Initialize the instrumentation module.\n*\n*  This is a pure virtual function that must be implemented by each specific instrumentation module.\n*  It is used to initialize the module and prepare it for use.\n*\n* @return void\n*/\nvirtual void initialize(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "      virtual void disable() { std::cerr << \"Disabling tasksim instrumentation not supported\" << std::endl; exit(1); }\n",
        "answer": "/** @brief Disable tasksim instrumentation.\n*\n*  This function disables the tasksim instrumentation for a specific instrumentation module.\n*  Each of (specific) instrumentation modules have to implement this function in order to be consistent with the instrumentation model.\n*\n* @return Should not return\n*/\nvoid disable() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void task_b ( void *args )\n{\n   debug( \"Task B\" );\n   int i;\n   task_data_t *hargs = (task_data_t * ) args;\n\n   for ( i = hargs->loop_info.lower; i < hargs->loop_info.upper; i += hargs->loop_info.step) {\n      LockBlock lock( l );\n      A[i]=0;\n      memoryFence();\n   }\n}\n",
        "answer": "/** @brief Task B kernel entrypoint.\n*\n*  This is the entrypoint for task B, which sets all elements to zero.\n*\n* @param args Pointer to a task_data_t structure containing loop information.\n* @return Should not return\n*/\nvoid task_b ( void *args )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void esp_end()\n{\n\tif (esp::_paused) return;\n\t\n\tif (!esp::_thread_context){\n\t\tesp_thread_init();\n\t}\n\tesp::_thread_context->End();\n}\n",
        "answer": "/** @brief Ends the last declared profiling zone by popping the top of the interval stack and emitting the corresponding ZONE_INTERVAL event.\n*\n*  This function ends the last declared profiling zone by popping the top of the interval stack and emitting the corresponding ZONE_INTERVAL event.\n*\n* @return Should not return\n*/\nvoid esp_end()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static TIMER_FUNC(clif_clearunit_delayed_sub){\n\tstruct block_list *bl = (struct block_list *)data;\n\tclif_clearunit_area(bl, (clr_type) id);\n\ters_free(delay_clearunit_ers,bl);\n\treturn 0;\n}\n",
        "answer": "/** @brief A static function that is used to make monsters with player-sprites disappear after dying like normal monsters.\n*\n* This function is called when a monster with a player-sprite dies, and it is used to clear the unit from the client's screen.\n* It takes two arguments: `bl` which is a pointer to a `struct block_list`, and `id` which is an integer representing the type of clearing that should be done.\n* The function first calls `clif_clearunit_area(bl, (clr_type) id)` to clear the unit from the client's screen.\n* It then frees the memory allocated for the delay using `ers_free(delay_clearunit_ers, bl)`.\n* Finally, it returns 0 to indicate that the function was successful.\n*/\nstatic TIMER_FUNC(clif_clearunit_delayed_sub)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_fixpos(struct block_list *bl)\n{\n\tunsigned char buf[10];\n\tnullpo_retv(bl);\n\n\tWBUFW(buf,0) = 0x88;\n\tWBUFL(buf,2) = bl->id;\n\tWBUFW(buf,6) = bl->x;\n\tWBUFW(buf,8) = bl->y;\n\tclif_send(buf, packet_len(0x88), bl, AREA);\n\n\tif( disguised(bl) ) {\n\t\tWBUFL(buf,2) = -bl->id;\n\t\tclif_send(buf, packet_len(0x88), bl, SELF);\n\t}\n}\n",
        "answer": "/** @brief Moves a character to x,y.\n*\n*  This function visually moves a character to the specified coordinates (x,y). If the target cell isn't walkable, the character doesn't move at all. If the character is sitting it will stand up (ZC_STOPMOVE).\n*\n* @param bl The block list of the character to be moved.\n* @return Void.\n*/\nvoid clif_fixpos(struct block_list *bl)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_arrow_fail(struct map_session_data *sd,int type) {\n\tint fd;\n\n\tnullpo_retv(sd);\n\n\tfd=sd->fd;\n\tWFIFOHEAD(fd, packet_len(0x013b));\n\tWFIFOW(fd,0) = 0x013b;\n\tWFIFOW(fd,2) = type;\n\tWFIFOSET(fd, packet_len(0x013b));\n}\n",
        "answer": "/**\n* @brief Sends an arrow failure message to the client.\n*\n* This function sends a packet with the specified type to the client, indicating that the\n* ammunition action has failed. The type parameter specifies the reason for the failure.\n*\n* @param sd Pointer to the map session data structure.\n* @param type The type of arrow failure message to send.\n*/\nvoid clif_arrow_fail(struct map_session_data *sd, int type) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_traderequest(struct map_session_data* sd, const char* name)\n{\n\tint fd = sd->fd;\n\n#if PACKETVER < 6\n\tWFIFOHEAD(fd,packet_len(0xe5));\n\tWFIFOW(fd,0) = 0xe5;\n\tsafestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);\n\tWFIFOSET(fd,packet_len(0xe5));\n#else\n\tstruct map_session_data* tsd = map_id2sd(sd->trade_partner);\n\tif( !tsd ) return;\n\n\tWFIFOHEAD(fd,packet_len(0x1f4));\n\tWFIFOW(fd,0) = 0x1f4;\n\tsafestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);\n\tWFIFOL(fd,26) = tsd->status.char_id;\n\tWFIFOW(fd,30) = tsd->status.base_level;\n\tWFIFOSET(fd,packet_len(0x1f4));\n#endif\n}\n",
        "answer": "/**\n* @brief Sends a trade request packet to the client.\n*\n* This function sends a trade request packet to the client, which will open a trade request window from character 'name'.\n* The packet format is as follows:\n* - 0xE5 (for PACKETVER < 6) or 0x1F4 (for PACKETVER >= 6)\n* - Name of the character sending the request (24 bytes)\n* - Character ID of the target character (if PACKETVER >= 6)\n* - Base level of the target character (if PACKETVER >= 6)\n*\n* @param sd The map session data for the client.\n* @param name The name of the character sending the request.\n*/\nvoid clif_traderequest(struct map_session_data* sd, const char* name);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_skillinfo(struct map_session_data *sd,int skill_id, int inf)\n{\n\tconst int fd = sd->fd;\n\tuint16 idx = skill_get_index(skill_id);\n\tif (!idx)\n\t\treturn;\n\n\tWFIFOHEAD(fd,packet_len(0x7e1));\n\tWFIFOW(fd,0) = 0x7e1;\n\tWFIFOW(fd,2) = skill_id;\n\tWFIFOL(fd,4) = inf?inf:skill_get_inf(skill_id);\n\tWFIFOW(fd,8) = sd->status.skill[idx].lv;\n\tWFIFOW(fd,10) = skill_get_sp(skill_id,sd->status.skill[idx].lv);\n\tWFIFOW(fd,12) = skill_get_range2(&sd->bl,skill_id,sd->status.skill[idx].lv,false);\n\tif( sd->status.skill[idx].flag == SKILL_FLAG_PERMANENT )\n\t\tWFIFOB(fd,14) = (sd->status.skill[idx].lv < skill_tree_get_max(skill_id, sd->status.class_))? 1:0;\n\telse\n\t\tWFIFOB(fd,14) = 0;\n\tWFIFOSET(fd,packet_len(0x7e1));\n}\n",
        "answer": "/**\n* @brief Updates a skill in the skill tree (ZC_SKILLINFO_UPDATE2).\n*\n* 07e1 <skill id>=\"\">.W <type>.L <level>.W <sp cost>=\"\">.W <attack range>=\"\">.W <upgradable>.B\n*\n* @param sd The map session data for the player.\n* @param skill_id The ID of the skill to update.\n* @param inf The information about the skill to update.\n*/\nvoid clif_skillinfo(struct map_session_data *sd, int skill_id, int inf) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_item_skill(struct map_session_data *sd,uint16 skill_id,uint16 skill_lv)\n{\n\tint fd;\n\n\tnullpo_retv(sd);\n\n\tfd=sd->fd;\n\tWFIFOHEAD(fd,packet_len(0x147));\n\tWFIFOW(fd, 0)=0x147;\n\tWFIFOW(fd, 2)=skill_id;\n\tWFIFOW(fd, 4)=skill_get_inf(skill_id);\n\tWFIFOW(fd, 6)=0;\n\tWFIFOW(fd, 8)=skill_lv;\n\tWFIFOW(fd,10)=skill_get_sp(skill_id,skill_lv);\n\tWFIFOW(fd,12)=skill_get_range2(&sd->bl,skill_id,skill_lv,false);\n\tsafestrncpy(WFIFOCP(fd,14),skill_get_name(skill_id),NAME_LENGTH);\n\tWFIFOB(fd,38)=0;\n\tWFIFOSET(fd,packet_len(0x147));\n}\n",
        "answer": "/**\n* @brief Notify an auto-casted skill (ZC_AUTORUN_SKILL).\n*\n* This function notifies the client that a skill has been automatically casted.\n* It sends the skill ID, level, and other relevant information to the client.\n*\n* @param sd The map session data for the player who casted the skill.\n* @param skill_id The ID of the skill that was casted.\n* @param skill_lv The level of the skill that was casted.\n*/\nvoid clif_item_skill(struct map_session_data *sd, uint16 skill_id, uint16 skill_lv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_send_petstatus(struct map_session_data *sd)\n{\n\tint fd;\n\tstruct s_pet *pet;\n\n\tnullpo_retv(sd);\n\tnullpo_retv(sd->pd);\n\n\tfd=sd->fd;\n\tpet = &sd->pd->pet;\n\tWFIFOHEAD(fd,packet_len(0x1a2));\n\tWFIFOW(fd,0)=0x1a2;\n\tsafestrncpy(WFIFOCP(fd,2),pet->name,NAME_LENGTH);\n\tWFIFOB(fd,26)=battle_config.pet_rename?0:pet->rename_flag;\n\tWFIFOW(fd,27)=pet->level;\n\tWFIFOW(fd,29)=pet->hungry;\n\tWFIFOW(fd,31)=pet->intimate;\n\tWFIFOW(fd,33)=pet->equip;\n#if PACKETVER >= 20081126\n\tWFIFOW(fd,35)=pet->class_;\n#endif\n\tWFIFOSET(fd,packet_len(0x1a2));\n}\n",
        "answer": "/** @brief Send pet status to the client.\n*\n*  This function sends the pet's base data (ZC_PROPERTY_PET) to the client.\n*\n* @param sd The map session data of the player.\n* @return void\n*/\nvoid clif_send_petstatus(struct map_session_data *sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_divorced(struct map_session_data* sd, const char* name)\n{\n\tint fd;\n\tnullpo_retv(sd);\n\n\tfd=sd->fd;\n\tWFIFOHEAD(fd,packet_len(0x205));\n\tWFIFOW(fd,0)=0x205;\n\tsafestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);\n\tWFIFOSET(fd, packet_len(0x205));\n}\n",
        "answer": "/** @brief Notify the client that a divorce has occurred.\n*\n*  This function is called when a divorce occurs in the game world, and it notifies the client of the event.\n*\n* @param sd The map session data for the player who is getting divorced.\n* @param name The name of the partner that the player is getting divorced from.\n*/\nvoid clif_divorced(struct map_session_data* sd, const char* name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_configuration( struct map_session_data* sd, enum e_config_type type, bool enabled ){\n\tint fd;\n\tnullpo_retv(sd);\n\tfd = sd->fd;\n\n\tWFIFOHEAD(fd, packet_len(0x2d9));\n\tWFIFOW(fd, 0) = 0x2d9;\n\tWFIFOL(fd, 2) = type;\n\tWFIFOL(fd, 6) = enabled;\n\tWFIFOSET(fd, packet_len(0x2d9));\n}\n",
        "answer": "/** @brief Send out reply to configuration change.\n*\n*  This function sends a reply to the client when the configuration changes.\n*\n* @param sd Pointer to map session data.\n* @param type Enumeration of configuration type.\n* @param enabled Boolean indicating whether the configuration is enabled or disabled.\n* @return void\n*/\nvoid clif_configuration(struct map_session_data* sd, enum e_config_type type, bool enabled) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_ChangeDir(int fd, struct map_session_data *sd)\n{\n\tunsigned char headdir, dir;\n\tstruct s_packet_db* info = &packet_db[RFIFOW(fd,0)];\n\n\theaddir = RFIFOB(fd,info->pos[0]);\n\tdir = RFIFOB(fd,info->pos[1]);\n\tpc_setdir(sd, dir, headdir);\n\n\tclif_changed_dir(&sd->bl, AREA_WOS);\n}\n",
        "answer": "/** @brief Request to change own body and head direction.\n*\n*  This function is called when the client requests to change its direction.\n*  It extracts the direction information from the packet and updates the player's direction accordingly.\n*\n* @param fd The file descriptor of the client connection.\n* @param sd Pointer to the session data for the client.\n* @return None\n*/\nvoid clif_parse_ChangeDir(int fd, struct map_session_data *sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_StatusUp(int fd,struct map_session_data *sd)\n{\n\tint increase_amount = RFIFOB(fd,packet_db[RFIFOW(fd,0)].pos[1]);\n\n\tif( increase_amount < 0 ) {\n\t\tShowDebug(\"clif_parse_StatusUp: Negative 'increase' value sent by client! (fd: %d, value: %d)\\n\",\n\t\t\tfd, increase_amount);\n\t}\n\tpc_statusup(sd,RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0]),increase_amount);\n}\n",
        "answer": "/** @brief Request to increase status (CZ_STATUS_CHANGE). 00bb <status id>=\"\">.W <amount>.B status id: SP_STR ~ SP_LUK amount: Old clients always send 1 for this, even when using /str+ and the like. Newer clients (2013-12-23 and newer) send the correct amount.\n*\n* @param fd The file descriptor of the client.\n* @param sd Pointer to the session data of the client.\n* @return void\n*/\nvoid clif_parse_StatusUp(int fd, struct map_session_data *sd) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_SolveCharName(int fd, struct map_session_data *sd)\n{\n\tint charid;\n\n\tcharid = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);\n\tmap_reqnickdb(sd, charid);\n}\n",
        "answer": "/** @brief Request character name by ID.\n*\n*  This function parses the packet for requesting a character's name by its ID.\n*  It extracts the character ID from the packet and passes it to map_reqnickdb()\n*  to retrieve the corresponding character name.\n*\n* @param fd The file descriptor of the client.\n* @param sd Pointer to the session data structure for the client.\n* @return void\n*/\nvoid clif_parse_SolveCharName(int fd, struct map_session_data *sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_MoveFromKafraToCart(int fd, struct map_session_data *sd){\n\tstruct s_packet_db* info = &packet_db[RFIFOW(fd,0)];\n\tint idx = RFIFOW(fd,info->pos[0]) - 1;\n\tint amount = RFIFOL(fd,info->pos[1]);\n\n\tif( sd->state.vending )\n\t\treturn;\n\tif (!pc_iscarton(sd))\n\t\treturn;\n\n\tif (sd->state.storage_flag == 1)\n\t\tstorage_storagegettocart(sd, &sd->storage, idx, amount);\n\telse\n\tif (sd->state.storage_flag == 2)\n\t\tstorage_guild_storagegettocart(sd, idx, amount);\n\telse if (sd->state.storage_flag == 3)\n\t\tstorage_storagegettocart(sd, &sd->premiumStorage, idx, amount);\n}\n",
        "answer": "/** @brief Request to move an item from storage to cart (CZ_MOVE_ITEM_FROM_STORE_TO_CART). 0128 <index>.W <amount>.L\n*\n* This function is used to move an item from the player's storage to their cart.\n* It checks if the player is in a state where they can move items, and then calls the appropriate storage function based on the player's storage flag.\n*\n* @param fd The file descriptor of the client connection.\n* @param sd The map session data for the player.\n*/\nvoid clif_parse_MoveFromKafraToCart(int fd, struct map_session_data *sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_GuildReplyInvite(int fd,struct map_session_data *sd){\n\tstruct s_packet_db* info = &packet_db[RFIFOW(fd,0)];\n\tguild_reply_invite(sd,RFIFOL(fd,info->pos[0]),\n\t    RFIFOL(fd,info->pos[1]));\n}\n",
        "answer": "/** @brief Handles the response to a guild invitation.\n*\n*  This function handles the response to a guild invitation, which can be either\n*  accept or refuse. The function takes two parameters, fd and sd, which are used\n*  to retrieve information about the client and the guild invitation.\n*\n* @param fd The file descriptor of the client.\n* @param sd The map session data of the client.\n*/\nvoid clif_parse_GuildReplyInvite(int fd, struct map_session_data *sd) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_GMRc(int fd, struct map_session_data* sd)\n{\n\tchar command[NAME_LENGTH+15];\n\tchar *name = RFIFOCP(fd,packet_db[RFIFOW(fd,0)].pos[0]);\n\n\tname[NAME_LENGTH-1] = '\\0';\n\tsafesnprintf(command,sizeof(command),\"%cmute %d %s\", atcommand_symbol, 60, name);\n\tis_atcommand(fd, sd, command, 1);\n}\n",
        "answer": "/** @brief Parses a GM request to give a player a manner adjustment.\n*\n*  This function parses a GM request to give a player a manner adjustment of -60. The request is in the form of a packet with the name of the player to be adjusted.\n*\n* @param fd The file descriptor of the client connection.\n* @param sd The map session data for the client.\n* @return void\n*/\nvoid clif_parse_GMRc(int fd, struct map_session_data* sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_Mail_send(struct map_session_data* sd, enum mail_send_result result){\n\tint fd = sd->fd;\n#if PACKETVER < 20150513\n\tWFIFOHEAD(fd,packet_len(0x249));\n\tWFIFOW(fd,0) = 0x249;\n\tWFIFOB(fd,2) = result != WRITE_MAIL_SUCCESS;\n\tWFIFOSET(fd,packet_len(0x249));\n#else\n\tWFIFOHEAD(fd, 3);\n\tWFIFOW(fd, 0) = 0x9ed;\n\tWFIFOB(fd, 2) = result;\n\tWFIFOSET(fd, 3);\n#endif\n}\n",
        "answer": "/** @brief Send mail notification to the client.\n*\n* This function sends a mail notification packet to the client with the specified result.\n* The result can be either WRITE_MAIL_SUCCESS or WRITE_MAIL_FAILURE.\n*\n* @param sd Pointer to the map session data for the client.\n* @param result The result of sending the mail, either WRITE_MAIL_SUCCESS or WRITE_MAIL_FAILURE.\n*/\nvoid clif_Mail_send(struct map_session_data* sd, enum mail_send_result result)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_cashshop_ack(struct map_session_data* sd, int error)\n{\n\tint fd, cost[2] = { 0, 0 };\n\tstruct npc_data *nd;\n\n\tnullpo_retv(sd);\n\n\tfd = sd->fd;\n\tnd = map_id2nd(sd->npc_shopid);\n\n\tnpc_shop_currency_type(sd, nd, cost, false);\n\n\tWFIFOHEAD(fd, packet_len(0x289));\n\tWFIFOW(fd,0) = 0x289;\n\tWFIFOL(fd,2) = cost[0];\n#if PACKETVER < 20070711\n\tWFIFOW(fd,6) = TOW(error);\n#else\n\tWFIFOL(fd,6) = cost[1];\n\tWFIFOW(fd,10) = TOW(error);\n#endif\n\tWFIFOSET(fd, packet_len(0x289));\n}\n",
        "answer": "/** @brief Cashshop Buy Ack (ZC_PC_CASH_POINT_UPDATE).\n*\n*  This function sends a packet to the client acknowledging the purchase of an item from the cash shop.\n*\n* @param sd The map session data for the player who made the purchase.\n* @param error The error code indicating whether the purchase was successful or not.\n*\n* @return void\n*/\nvoid clif_cashshop_ack(struct map_session_data* sd, int error)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_bg_xy(struct map_session_data *sd)\n{\n\tunsigned char buf[36];\n\tnullpo_retv(sd);\n\n\tWBUFW(buf,0)=0x2df;\n\tWBUFL(buf,2)=sd->status.account_id;\n\tsafestrncpy(WBUFCP(buf,6), sd->status.name, NAME_LENGTH);\n\tWBUFW(buf,30)=sd->status.class_;\n\tWBUFW(buf,32)=sd->bl.x;\n\tWBUFW(buf,34)=sd->bl.y;\n\n\tclif_send(buf, packet_len(0x2df), &sd->bl, BG_SAMEMAP_WOS);\n}\n",
        "answer": "/**\n* @brief Updates the position of a camp member on the minimap (ZC_BATTLEFIELD_NOTIFY_POSITION).\n*\n* @param sd The map session data for the player whose position is being updated.\n*/\nvoid clif_bg_xy(struct map_session_data *sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_instance_changestatus(unsigned int instance_id, int type, unsigned int limit)\n{\n#if PACKETVER >= 20071128\n\tstruct map_session_data *sd = NULL;\n\tenum send_target target = PARTY;\n\tunsigned char buf[10];\n\n\tinstance_getsd(instance_id, &sd, &target);\n\n\tif (!sd)\n\t\treturn;\n\n\tWBUFW(buf,0) = 0x2ce;\n\tWBUFL(buf,2) = type;\n\tWBUFL(buf,6) = limit;\n\tclif_send(buf,packet_len(0x2ce),&sd->bl,target);\n#endif\n\n\treturn;\n}\n",
        "answer": "/**\n* @brief Notify a status change to members S 0x2ce <Message id>=\"\">.L 0 = Notification (EnterLimitDate update?) 1 = The Memorial Dungeon expired; it has been destroyed 2 = The Memorial Dungeon's entry time limit expired; it has been destroyed 3 = The Memorial Dungeon has been removed. 4 = Create failure (removes the instance window)\n*\n* @param instance_id The ID of the instance that changed status\n* @param type The type of change (0-4)\n* @param limit The new limit for the instance, if applicable\n*/\nvoid clif_instance_changestatus(unsigned int instance_id, int type, unsigned int limit);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void clif_parse_SearchStoreInfoListItemClick(int fd, struct map_session_data* sd)\n{\n\tunsigned short nameid;\n\tuint32 account_id, store_id;\n\tstruct s_packet_db* info = &packet_db[RFIFOW(fd,0)];\n\n\taccount_id = RFIFOL(fd,info->pos[0]);\n\tstore_id   = RFIFOL(fd,info->pos[1]);\n\tnameid     = RFIFOW(fd,info->pos[2]);\n\n\tsearchstore_click(sd, account_id, store_id, nameid);\n}\n",
        "answer": "/** @brief Parses the Search Store Info List Item Click packet.\n*\n*  This function parses the Search Store Info List Item Click packet and invokes the catalog effect on a store from search results (CZ_SSILIST_ITEM_CLICK).\n*\n* @param fd The file descriptor of the client.\n* @param sd The map session data of the client.\n*/\nstatic void clif_parse_SearchStoreInfoListItemClick(int fd, struct map_session_data* sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_update_rankingpoint(struct map_session_data *sd, int rankingtype, int point) {\n\tint fd=sd->fd;\n#if PACKETVER < 20130710\n\tshort cmd;\n\tswitch(rankingtype){\n\t\tcase RANK_BLACKSMITH:\tcmd = 0x21b; break;\n\t\tcase RANK_ALCHEMIST:\tcmd = 0x21c; break;\n\t\tcase RANK_TAEKWON:\t\tcmd = 0x224; break;\n\t\tdefault:\n\t\t\tShowError( \"clif_update_rankingpoint: Unsupported ranking type '%d'. Please report this.\\n\", rankingtype );\n\t\t\treturn;\n\t}\n\n\tWFIFOHEAD(fd,packet_len(cmd));\n\tWFIFOW(fd,0) = cmd;\n\tWFIFOL(fd,2) = point;\n\tWFIFOL(fd,6) = sd->status.fame;\n\tWFIFOSET(fd, packet_len(cmd));\n#else\n\tWFIFOHEAD(fd,packet_len(0x97e));\n\tWFIFOW(fd,0) = 0x97e;\n\tWFIFOW(fd,2) = rankingtype;\n\tWFIFOL(fd,4) = point;\n\tWFIFOL(fd,8) = sd->status.fame;\n\tWFIFOSET(fd,packet_len(0x97e));\n#endif\n}\n",
        "answer": "/** @brief Updates the fame rank points for the given ranking.\n*\n*  This function updates the fame rank points for a given ranking type, using the provided point value.\n*\n* @param sd The map session data for the player whose fame rank points are being updated.\n* @param rankingtype The ranking type (e.g., RANK_BLACKSMITH, RANK_ALCHEMIST, etc.).\n* @param point The new point value to be assigned to the given ranking type.\n*\n* @return None\n*/\nvoid clif_update_rankingpoint(struct map_session_data *sd, int rankingtype, int point) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_sale_refresh( int fd, struct map_session_data* sd ){\n#if PACKETVER_SUPPORTS_SALES\n\tstruct sale_item_data* sale;\n\n\tif( RFIFOL(fd, 2) != sd->status.account_id ){\n\t\treturn;\n\t}\n\n\tsale = sale_find_item( RFIFOW(fd, 6), true );\n\n\tif( sale == NULL ){\n\t\treturn;\n\t}\n\n\tclif_sale_amount(sale, &sd->bl, SELF);\n#endif\n}\n",
        "answer": "/**\n* @brief Parses a sale refresh packet and updates the remaining count of the sale item.\n*\n* This function parses a sale refresh packet received from the client and updates the\n* remaining count of the sale item in the database. It also sends a response to the client\n* with the updated information.\n*\n* @param fd The file descriptor of the client connection.\n* @param sd Pointer to the session data for the client.\n*/\nvoid clif_parse_sale_refresh(int fd, struct map_session_data* sd) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clif_parse_AchievementCheckReward(int fd, struct map_session_data *sd)\n{\n\tnullpo_retv(sd);\n\n\tif( sd->achievement_data.save )\n\t\tintif_achievement_save(sd);\n\n\tachievement_check_reward(sd, RFIFOL(fd,2));\n}\n",
        "answer": "/** @brief Checks if an achievement reward can be rewarded (CZ_REQ_AG_REWARD). 0a25 <packetType>.W <achievementID>.L\n*\n* This function checks if an achievement reward can be rewarded. It first nullifies the pointer to the map session data, then it checks if the achievement data save is true. If it is, it saves the achievement data using intif_achievement_save(). Finally, it checks if the achievement reward can be given using achievement_check_reward() and passes the file descriptor and the achievement ID as arguments.\n* @param fd The file descriptor of the packet.\n* @param sd The map session data pointer.\n* @return void\n*/\nvoid clif_parse_AchievementCheckReward(int fd, struct map_session_data *sd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mapif_itembound_ack(int fd, int account_id, int guild_id)\n{\n\tWFIFOHEAD(fd,8);\n\tWFIFOW(fd,0) = 0x3856;\n\tWFIFOL(fd,2) = account_id;\n\tWFIFOW(fd,6) = guild_id;\n\tWFIFOSET(fd,8);\n\tchar_unset_session_flag(account_id, 1);\n}\n",
        "answer": "/** @brief Sends an acknowledgement to the map server that the item bound process is complete.\n*\n*  This function sends a packet to the map server indicating that the item bound process is complete, and unlocks the guild storage.\n*\n* @param fd The file descriptor of the client.\n* @param account_id The ID of the player's account.\n* @param guild_id The ID of the guild.\n*/\nvoid mapif_itembound_ack(int fd, int account_id, int guild_id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void do_shutdown(void)\n{\n\tif( runflag != MAPSERVER_ST_SHUTDOWN )\n\t{\n\t\trunflag = MAPSERVER_ST_SHUTDOWN;\n\t\tShowStatus(\"Shutting down...\\n\");\n\t\t{\n\t\t\tstruct map_session_data* sd;\n\t\t\tstruct s_mapiterator* iter = mapit_getallusers();\n\t\t\tfor( sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter) )\n\t\t\t\tclif_GM_kick(NULL, sd);\n\t\t\tmapit_free(iter);\n\t\t\tflush_fifos();\n\t\t}\n\t\tchrif_check_shutdown();\n\t}\n}\n",
        "answer": "/** @brief Shut down the server.\n*\n*  This function attempts to properly close the server when an interrupt signal is received.\n*  It catches SIGTERM and SIGINT signals.\n*\n* @return Should not return\n*/\nvoid do_shutdown(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int SqlStmt_PrepareV(SqlStmt* self, const char* query, va_list args)\n{\n\tif( self == NULL )\n\t\treturn SQL_ERROR;\n\n\tSqlStmt_FreeResult(self);\n\tStringBuf_Clear(&self->buf);\n\tStringBuf_Vprintf(&self->buf, query, args);\n\tif( mysql_stmt_prepare(self->stmt, StringBuf_Value(&self->buf), (unsigned long)StringBuf_Length(&self->buf)) )\n\t{\n\t\tShowSQL(\"DB error - %s\\n\", mysql_stmt_error(self->stmt));\n\t\tra_mysql_error_handler(mysql_stmt_errno(self->stmt));\n\t\treturn SQL_ERROR;\n\t}\n\tself->bind_params = false;\n\n\treturn SQL_SUCCESS;\n}\n",
        "answer": "/** @brief Prepare the statement.\n*\n*  This function prepares the statement by freeing any previous result and all parameter bindings, constructing the query using svprintf, and preparing the statement with MySQL.\n*\n* @param self The SqlStmt object.\n* @param query The SQL query to prepare.\n* @param args The arguments for the query.\n*\n* @return SQL_SUCCESS if successful, SQL_ERROR otherwise.\n*/\nint SqlStmt_PrepareV(SqlStmt* self, const char* query, va_list args)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void logTextMessage( const QString &message, enum QCA::Logger::Severity severity )\n    {\n        m_lastMessage = message;\n        m_messageSeverity = severity;\n    }\n",
        "answer": "/** @brief Logs a text message with the specified severity.\n*\n* This function logs a text message with the specified severity. The message is stored in the m_lastMessage member variable and the severity is stored in the m_messageSeverity member variable.\n*\n* @param message The message to log.\n* @param severity The severity of the message.\n*/\nvoid logTextMessage(const QString &message, enum QCA::Logger::Severity severity) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void init()\n\t{\n#ifndef FORWARD_ONLY\n\t\tsspi_set_logger(do_log);\n\t\thave_sspi = sspi_load();\n#endif\n\t}\n",
        "answer": "/** @brief Initialisation routine.\n*\n*  This routine will be called when your plugin is loaded, so this is a good place to do any one-off initialisation tasks. If you don't need any initialisation, just implement it as an empty routine.\n*\n* @return Should not return\n*/\nvoid init()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int qcaPatchVersion()\n{\n\treturn QCA_PATCH_VERSION;\n}\n",
        "answer": "/** @brief Returns the current version of QCA.\n*\n* This function returns the current version of QCA that is being used. It is equivalent to ::QCA_PATCH_VERSION, except it provides a runtime check of the version of QCA that is being used.\n*\n* @return The current version of QCA.\n*/\nint qcaPatchVersion()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool system_comms_poll(uint8 *buffer)\n{\n\tif (comms_poll_cb)\n\t\treturn comms_poll_cb(buffer);\n\telse\n\t\treturn false;\n}\n",
        "answer": "/** @brief Peeks at any data from the other system.\n*\n*  This function peeks at any data from the other system. If no data is available or no high-level communications have been established, then return FALSE. If buffer is NULL, then no data is read, only status is returned.\n*\n* @param[in] buffer A pointer to a buffer where the data will be stored.\n* @return TRUE if data was peeked successfully, FALSE otherwise.\n*/\nbool system_comms_poll(uint8 *buffer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool dynamic_link( const char*  library, const dynamic_link_descriptor descriptors[], size_t required, dynamic_link_handle*, int flags ) {\n        dynamic_link_handle tmp_handle = NULL;\n        TCHAR wlibrary[256];\n        if ( MultiByteToWideChar(CP_UTF8, 0, library, -1, wlibrary, 255) == 0 ) return false;\n        if ( flags & DYNAMIC_LINK_LOAD )\n            tmp_handle = LoadPackagedLibrary( wlibrary, 0 );\n        if (tmp_handle != NULL){\n            return resolve_symbols(tmp_handle, descriptors, required);\n        }else{\n            return false;\n        }\n    }\n",
        "answer": "/**\n* @brief Dynamically links a library and resolves symbols.\n*\n* This function dynamically links a library and resolves the specified symbols.\n* It takes in a library name, an array of symbol descriptors, and the number of required symbols as input.\n* If all the required symbols are found, it sets the corresponding handler pointers and returns true.\n* Otherwise, it leaves the original array of descriptors untouched and returns false.\n* The function also takes in a handle to the loaded library and a set of flags for dynamic linking.\n* Each of the DYNAMIC_LINK_* flags allows its corresponding linking stage.\n*\n* @param library The name of the requested library. It should not contain a full path since dynamic_link adds the full path (from which the runtime itself was loaded) to the library name.\n* @param descriptors An array of symbol descriptors, each containing information about a symbol to be resolved.\n* @param required The number of initial entries in the array descriptors[] that have to be found in order for the call to succeed.\n* @param handle A pointer to the handle of the loaded library if it is loaded. Otherwise, it is left untouched.\n* @param flags A set of DYNAMIC_LINK_* flags, each allowing its corresponding linking stage.\n* @return True if all required symbols are found and their corresponding handler pointers are set, false otherwise.\n*/\nbool dynamic_link(const char* library, const dynamic_link_descriptor descriptors[], size_t required, dynamic_link_handle* handle, int flags) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string FormatSubVersion(const std::string &name, int nClientVersion, const std::vector<std::string> &comments)\n{\n    std::ostringstream ss;\n    ss << \"/\";\n    ss << name << \":\" << FormatVersion(nClientVersion);\n    if (!comments.empty())\n    {\n        std::vector<std::string>::const_iterator it(comments.begin());\n        ss << \"(\" << *it;\n        for (++it; it != comments.end(); ++it)\n            ss << \"; \" << *it;\n        ss << \")\";\n    }\n    ss << \"/\";\n    return ss.str();\n}\n",
        "answer": "/** @brief Formats the subversion field according to BIP 14 spec.\n*\n*  This function formats the subversion field according to the BIP 14 specification, which is a standard for representing\n*  version information in a human-readable format. The function takes three parameters: the name of the software, the client\n*  version number, and a vector of comments. It returns a string containing the formatted subversion field.\n*\n* @param name The name of the software.\n* @param nClientVersion The client version number.\n* @param comments A vector of comments to include in the subversion field.\n* @return A string containing the formatted subversion field.\n*/\nstd::string FormatSubVersion(const std::string &name, int nClientVersion, const std::vector<std::string> &comments)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "UniValue ParseNonRFCJSONValue(const std::string &strVal)\n{\n    UniValue jVal;\n    if (!jVal.read(std::string(\"[\") + strVal + std::string(\"]\")) || !jVal.isArray() || jVal.size() != 1)\n        throw std::runtime_error(std::string(\"Error parsing JSON:\") + strVal);\n    return jVal[0];\n}\n",
        "answer": "/** @brief ParseNonRFCJSONValue\n*\n*  This function parses a non-RFC4627 JSON value.\n*\n* @param strVal The string to be parsed\n* @return A UniValue object representing the parsed value\n*/\nUniValue ParseNonRFCJSONValue(const std::string &strVal)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void on_init(){\n    console = AlgAudio::Console::Create();\n    console->on_close.SubscribeForever([&](){\n      AlgAudio::SDLMain::UnregisterWindow(console);\n    });\n    AlgAudio::SDLMain::RegisterWindow(console);\n  }\n",
        "answer": "/** @brief Module initialization.\n*\n* This function is called when the module is ready to work - the corresponding SC instance was created etc.\n* It is guaranteed to run before on_destroy.\n*\n* @return Should not return\n*/\nvoid on_init()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Communication_TransmitSX1278InitializedSuccess()\n{\n  Debugging_Utilities_DebugPrintLine(\"(T. SX1278 S.\");\n\tCommunication_SX1278Transmit(\"3\", \"\");\n}\n",
        "answer": "/** @brief Transmits the LoRa object initialization success message to the ground station.\n*\n*  This function indicates to the ground station that the satellite has successfully initialized the LoRa object.\n*\n* @return None\n*/\nvoid Communication_TransmitSX1278InitializedSuccess()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Communication_ReceivedDeploymentSuccess()\n{\n    Debugging_Utilities_DebugLog(\"(R) Arduino satellite's deployment sequence successfully completed.\");\n}\n",
        "answer": "/** @brief Indicates to the ground station that the deployment sequence was successful.\n*\n*  This function is called when the satellite's Setup() function is executed successfully. It notifies the ground station that the deployment sequence has completed successfully.\n*\n* @return void\n*/\nvoid Communication_ReceivedDeploymentSuccess()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid getDeviceProperties(executive::DeviceProperties &properties, int deviceIndex) {\n\t\tget()->getDeviceProperties(properties, deviceIndex);\n\t}\n",
        "answer": "/** @brief Gets the Ocelot device properties of either the current device (deviceIndex = -1) or the indexed device.\n*\n*  This function gets the Ocelot device properties of either the current device (deviceIndex = -1) or the indexed device.\n*\n* @param[in] properties The executive::DeviceProperties object to store the retrieved properties in.\n* @param[in] deviceIndex The index of the device to retrieve the properties for, or -1 for the current device.\n*\n* @return void\n*/\nvoid getDeviceProperties(executive::DeviceProperties &properties, int deviceIndex) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void qtg_refresh_unit_city_dialogs(struct unit *punit)\n{\n\n  struct city *pcity_sup, *pcity_pre;\n\n  pcity_sup = game_city_by_number(punit->homecity);\n  pcity_pre = tile_city(punit->tile);\n\n  qtg_real_city_dialog_refresh(pcity_sup);\n  qtg_real_city_dialog_refresh(pcity_pre);\n\n}\n",
        "answer": "/** @brief Update city dialogs when the given unit's status changes.\n*\n* This function updates both the unit's home city (if any) and the city in which it is present (if any).\n*\n* @param punit The unit whose status has changed.\n*/\nvoid qtg_refresh_unit_city_dialogs(struct unit *punit)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void races_toggles_set_sensitive(void)\n{\n  if (is_race_dialog_open) {\n    race_dialog->refresh();\n  }\n}\n",
        "answer": "/** @brief Sets the sensitivity of the races toggles.\n*\n*  This function sets the sensitivity of the races toggles in the nation selection dialog.\n*  It checks if the race dialog is open and refreshes it if necessary.\n*\n* @return None\n*/\nvoid races_toggles_set_sensitive(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int action_selection_target_city(void)\n{\n  choice_dialog *cd = gui()->get_diplo_dialog();\n\n  if (cd != NULL) {\n    return cd->target_id[ATK_CITY];\n  } else {\n    return IDENTITY_NUMBER_ZERO;\n  }\n}\n",
        "answer": "/** @brief Returns the id of the target city of the actions currently handled in action selection dialog when the action selection dialog is open and it has a city target.\n*\n* This function returns the identity number zero if no action selection dialog is open or no city target is present in the action selection dialog.\n*\n* @return The id of the target city of the actions currently handled in action selection dialog when the action selection dialog is open and it has a city target, or IDENTITY_NUMBER_ZERO if no action selection dialog is open or no city target is present in the action selection dialog.\n*/\nint action_selection_target_city(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void handle_diplomacy_accept_treaty(int counterpart, bool I_accepted,\n                                    bool other_accepted)\n{\n  int i;\n  diplo_dlg *dd;\n  diplo_wdg *dw;\n  QWidget *w;\n\n  if (!gui()->is_repo_dlg_open(\"DDI\")) {\n    return;\n  }\n  i = gui()->gimme_index_of(\"DDI\");\n  fc_assert(i != -1);\n  w = gui()->game_tab_widget->widget(i);\n  dd = qobject_cast<diplo_dlg *>(w);\n  dw = dd->find_widget(counterpart);\n  dw->treaty.accept0 = I_accepted;\n  dw->treaty.accept1 = other_accepted;\n  dw->update_wdg();\n\n}\n",
        "answer": "/**\n* @brief Updates a player's acceptance status of a treaty (traditionally shown with the thumbs-up/thumbs-down sprite).\n*\n* This function updates a player's acceptance status of a treaty, which is represented by a thumbs-up or thumbs-down sprite.\n* The function takes three parameters: `counterpart`, which is the index of the counterpart player; `I_accepted`, which is a boolean indicating whether the current player has accepted the treaty; and `other_accepted`, which is a boolean indicating whether the other player has accepted the treaty.\n* The function first checks if the diplomacy dialog is open, and if not, returns immediately. It then retrieves the index of the diplomacy dialog in the game tab widget, and uses this index to retrieve the corresponding `diplo_dlg` object. Finally, it updates the acceptance status of the treaty for both players using the `treaty.accept0` and `treaty.accept1` fields, and calls the `update_wdg()` function to update the widget.\n*\n* @param counterpart The index of the counterpart player.\n* @param I_accepted A boolean indicating whether the current player has accepted the treaty.\n* @param other_accepted A boolean indicating whether the other player has accepted the treaty.\n*/\nvoid handle_diplomacy_accept_treaty(int counterpart, bool I_accepted, bool other_accepted) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void qtg_set_unit_icons_more_arrow(bool onoff)\n{\n  /* PORTME */\n}\n",
        "answer": "/** @brief Set the unit icons more arrow.\n*\n* This function is used to activate or deactivate the arrow that indicates when the units below will not fit. It is disabled by default.\n*\n* @param onoff A boolean value indicating whether the arrow should be enabled (true) or disabled (false).\n*/\n/* PORTME */\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void update_info_label(void)\n{\n  gui()->update_info_label();\n}\n",
        "answer": "/** @brief Updates the info label for the player's civilization.\n*\n* This function is called when the label is changed, and it updates the information displayed in the label.\n*\n* @return void\n*/\nvoid update_info_label(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void gui_flush(void)\n{\n  gui()->mapview_wdg->update();\n}\n",
        "answer": "/** @brief GUI flush function.\n*\n* This function is used to make sure the hardware has caught up with the screen updates. It calls the update() method of the mapview widget, which ensures that the widget's contents are displayed on the screen.\n*\n* @return void\n*/\nvoid gui_flush(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tHWND get_main_window()\r\n\t{\r\n\t\tPFC_ASSERT( g_foobar2000_api != NULL );\r\n\t\treturn g_foobar2000_api->get_main_window();\r\n\t}\r\n",
        "answer": "/** @brief Retrieves main app window. WARNING: this is provided for parent of dialog windows and such only; using it for anything else (such as hooking windowproc to alter app behaviors) is absolutely illegal.\n*\n*  This function retrieves the main application window. It should not be used for any other purpose, including hooking the window procedure to alter app behavior.\n*\n* @return The main application window.\n*/\nHWND get_main_window()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\n#if defined(CRYPTOPP_DEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\nvoid ElGamal_TestInstantiations()\n{\n\tElGamalEncryptor test1(1, 1, 1);\n\tElGamalDecryptor test2(NullRNG(), 123);\n\tElGamalEncryptor test3(test2);\n}\n",
        "answer": "/** @brief ElGamal encryption and decryption.\n*\n* This function implements the ElGamal encryption and decryption algorithm.\n* It takes two parameters, `p` and `g`, which are the prime modulus and the generator of the underlying finite field, respectively.\n* The function also takes a message `m` to be encrypted and a random number `r` used in the encryption process.\n* The function returns the ciphertext `(c0, c1)`, where `c0 = g^m * h^r mod p` and `c1 = m * h^r mod p`.\n*\n* @param p The prime modulus of the underlying finite field.\n* @param g The generator of the underlying finite field.\n* @param m The message to be encrypted.\n* @param r A random number used in the encryption process.\n*\n* @return The ciphertext `(c0, c1)`.\n*/\nvoid ElGamal_Encrypt(const Integer &p, const Integer &g, const Integer &m, const Integer &r)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: lux-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH (const PAIRTYPE(string, string) & item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\"\n      << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/**\n* @brief Performs an HTTP POST request with a JSON message and custom headers.\n*\n* This function sends an HTTP POST request to the specified URL, with a JSON message as the request body\n* and custom headers. The response from the server is returned as a string.\n*\n* @param strMsg The JSON message to send in the request body.\n* @param mapRequestHeaders A map of custom headers to include in the request.\n*\n* @return The response from the server, or an empty string if there was an error.\n*/\nstring HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\n#if defined(CRYPTOPP_DEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\nvoid WAKE_TestInstantiations()\n{\n\tWAKE_OFB<>::Encryption x2;\n\tWAKE_OFB<>::Decryption x4;\n}\n",
        "answer": "/** @brief Test instantiations of the WAKE block cipher.\n*\n*  This function tests the instantiations of the WAKE block cipher with different key sizes and block sizes.\n*\n* @return None\n*/\nvoid WAKE_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void analyze(SILInstruction *I) {\n    assert(!LoopMode &&\n           \"This function can only be used in on cfg without loops\");\n    (void)LoopMode;\n\n    analyzeInstruction(I);\n  }\n",
        "answer": "/** @brief Analyzes a SIL instruction.\n*\n* This function analyzes a SIL instruction and returns false if the instruction may change the size of any array. All redundant safe array accesses seen up to the instruction can be removed.\n*\n* @param I The SIL instruction to analyze.\n* @return False if the instruction may change the size of any array, true otherwise.\n*/\nvoid analyze(SILInstruction *I) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool canApplyOfBuiltinUseNonTrivialValues(BuiltinInst *BInst) {\n  auto *F = BInst->getFunction();\n\n  auto &II = BInst->getIntrinsicInfo();\n  if (II.ID != llvm::Intrinsic::not_intrinsic) {\n    if (II.hasAttribute(llvm::Attribute::ReadNone)) {\n      for (auto &Op : BInst->getAllOperands()) {\n        if (!Op.get()->getType().isTrivial(*F)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  auto &BI = BInst->getBuiltinInfo();\n  if (BI.isReadNone()) {\n    for (auto &Op : BInst->getAllOperands()) {\n      if (!Op.get()->getType().isTrivial(*F)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n",
        "answer": "/** @brief Determines if a builtin apply can use reference counted values.\n*\n*  This function checks whether a builtin apply can use reference counted values or not. It does this by checking the intrinsic information and the builtin information of the given BuiltinInst. If the intrinsic information is not_intrinsic, it returns true. Otherwise, it checks if the intrinsic has the ReadNone attribute and if all operands have trivial types. If any operand has a non-trivial type, it returns false.\n*\n* @param BInst The BuiltinInst to check.\n* @return True if the builtin apply can use reference counted values, false otherwise.\n*/\nvoid canApplyOfBuiltinUseNonTrivialValues(BuiltinInst *BInst) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ClangNode getClangNodeForMacroDefinition(clang::MacroDefinition &M) {\n  if (!M.getModuleMacros().empty())\n    return ClangNode(M.getModuleMacros().back()->getMacroInfo());\n  if (auto *MD = M.getLocalDirective())\n    return ClangNode(MD->getMacroInfo());\n  return ClangNode();\n}\n",
        "answer": "/** @brief Translate a MacroDefinition to a ClangNode, either a ModuleMacro for a definition imported from a module or a MacroInfo for a macro defined locally.\n*\n* This function takes a clang::MacroDefinition object and returns a ClangNode object that represents the macro. If the macro is defined in a module, it returns a ModuleMacro object containing the macro info. Otherwise, it returns a MacroInfo object containing the macro info.\n*\n* @param M The MacroDefinition to translate.\n* @return A ClangNode representing the macro.\n*/\nClangNode getClangNodeForMacroDefinition(clang::MacroDefinition &M) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SILValue stripCopies(SILValue v) {\n  while (true) {\n    v = stripSinglePredecessorArgs(v);\n\n    if (auto *srcCopy = dyn_cast<CopyValueInst>(v)) {\n      v = srcCopy->getOperand();\n      continue;\n    }\n    return v;\n  }\n}\n",
        "answer": "/** @brief Strips copies from a SIL value.\n*\n* This function recursively strips copies from a SIL value until it reaches an opaque value or a non-copy definition.\n*\n* @param v The SIL value to strip copies from.\n* @return The stripped SIL value.\n*/\nstatic SILValue stripCopies(SILValue v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool CSEExistentialCalls(SILFunction *Func, DominanceInfo *DA) {\n  bool Changed = false;\n  for (auto *Arg : Func->getArgumentsWithoutIndirectResults()) {\n    if (Arg->getType().isExistentialType()) {\n      auto *FArg = cast<SILFunctionArgument>(Arg);\n      Changed |= CSExistentialInstructions(FArg, DA);\n    }\n  }\n\n  return Changed;\n}\n",
        "answer": "/** @brief Detects multiple calls to existential members and tries to CSE the instructions that perform the method lookup (the open_existential_addr and witness_method).\n*\n* This function detects multiple calls to existential members and tries to CSE the instructions that perform the method lookup (the open_existential_addr and witness_method).\n*\n* @param Func The SILFunction in which to search for existential calls.\n* @param DA The DominanceInfo of the function.\n*\n* @return true if any changes were made, false otherwise.\n*/\nbool CSEExistentialCalls(SILFunction *Func, DominanceInfo *DA) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isInPrivateOrLocalContext(const ValueDecl *D) {\n  const DeclContext *DC = D->getDeclContext();\n  if (!DC->isTypeContext()) {\n    assert((DC->isModuleScopeContext() || DC->isLocalContext()) &&\n           \"unexpected context kind\");\n    return DC->isLocalContext();\n  }\n\n  auto *nominal = DC->getSelfNominalTypeDecl();\n  if (nominal == nullptr)\n    return false;\n\n  if (hasPrivateOrFilePrivateFormalAccess(nominal))\n    return true;\n  return isInPrivateOrLocalContext(nominal);\n}\n",
        "answer": "/** @brief Checks if the given ValueDecl is in a private or local context.\n*\n* This function checks if one of the ancestor DeclContexts of the given ValueDecl is either marked private or fileprivate or is a local context.\n*\n* @param D The ValueDecl to check.\n* @return True if the ValueDecl is in a private or local context, false otherwise.\n*/\nstatic bool isInPrivateOrLocalContext(const ValueDecl *D) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SILValue scalarizeLoad(LoadInst *LI,\n                              SmallVectorImpl<SILValue> &ElementAddrs) {\n  SILBuilderWithScope B(LI);\n  SmallVector<SILValue, 4> ElementTmps;\n\n  for (unsigned i = 0, e = ElementAddrs.size(); i != e; ++i) {\n    auto *SubLI = B.createTrivialLoadOr(LI->getLoc(), ElementAddrs[i],\n                                        LI->getOwnershipQualifier());\n    ElementTmps.push_back(SubLI);\n  }\n\n  if (LI->getType().is<TupleType>())\n    return B.createTuple(LI->getLoc(), LI->getType(), ElementTmps);\n  return B.createStruct(LI->getLoc(), LI->getType(), ElementTmps);\n}\n",
        "answer": "/** @brief Scalarize a load down to its subelements. If NewLoads is specified, this can return the newly generated sub-element loads.\n*\n*  This function takes a LoadInst and a SmallVector of element addresses as input, and returns a new SILValue that represents the scalarized load. The function uses a SILBuilderWithScope to create new instructions, and it iterates over the elements in the SmallVector using a for loop. For each element, it creates a trivial load or a tuple/struct instruction depending on the type of the load.\n*\n* @param LI The LoadInst to be scalarized.\n* @param ElementAddrs A SmallVector of element addresses.\n* @return A new SILValue that represents the scalarized load.\n*/\nstatic SILValue scalarizeLoad(LoadInst *LI,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isPrintLikeMethod(DeclName name, const DeclContext *dc) {\n  if (!name || name.isSpecial() || name.isSimpleName())\n    return false;\n  if (name.getBaseIdentifier().str() != \"print\")\n    return false;\n  if (!dc->isTypeContext())\n    return false;\n  if (name.getArgumentNames().size() > 1)\n    return false;\n  return true;\n}\n",
        "answer": "/** @brief Checks whether a method name is similar to Swift.print.\n*\n*  This function checks if the given method name is similar to Swift.print, which means it has the same base name and only one argument.\n*\n* @param name The name of the method to check.\n* @param dc The declaration context of the method.\n* @return True if the method name is similar to Swift.print, false otherwise.\n*/\nstatic bool isPrintLikeMethod(DeclName name, const DeclContext *dc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool delimiterMatches(unsigned CustomDelimiterLen, const char *&BytesPtr,\n                             DiagnosticEngine *Diags, bool IsClosing = false) {\n  if (!CustomDelimiterLen)\n    return true;\n  const char *TmpPtr = BytesPtr;\n  while (diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags)) {}\n\n  if (TmpPtr - BytesPtr < CustomDelimiterLen)\n    return false;\n\n  BytesPtr += CustomDelimiterLen;\n\n  if (Diags && TmpPtr > BytesPtr) {\n    Diag<> message = IsClosing ? diag::lex_invalid_closing_delimiter\n                               : diag::lex_invalid_escape_delimiter;\n    Diags->diagnose(Lexer::getSourceLoc(BytesPtr), message)\n        .fixItRemoveChars(Lexer::getSourceLoc(BytesPtr),\n                          Lexer::getSourceLoc(TmpPtr));\n  }\n  return true;\n}\n",
        "answer": "/** @brief delimiterMatches - Does custom delimiter ('#' characters surrounding quotes) match the number of '#' characters after '\\' inside the string? This allows interpolation inside a \"raw\" string. Normal/cooked string processing is the degenerate case of there being no '#' characters surrounding the quotes. If delimiter matches, advances byte pointer passed in and returns true. Also used to detect the final delimiter of a string when IsClosing == true.\n*\n* @param CustomDelimiterLen The length of the custom delimiter.\n* @param BytesPtr A pointer to the bytes of the string.\n* @param Diags A pointer to the diagnostic engine.\n* @param IsClosing A boolean indicating whether this is the closing delimiter or not.\n* @return True if the delimiter matches, false otherwise.\n*/\nstatic bool delimiterMatches(unsigned CustomDelimiterLen, const char *&BytesPtr, DiagnosticEngine *Diags, bool IsClosing = false) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool extensionHasClangNode(ExtensionDecl *ext) {\n  return static_cast<bool>(swift::ide::extensionGetClangNode(ext));\n}\n",
        "answer": "/** @brief Determines whether a given extension has a Clang node that created it (vs. being a Swift extension).\n*\n*  This function checks if the given extension has a Clang node that created it, which indicates that it is not a Swift extension.\n*\n* @param ext The extension to check.\n* @return True if the extension has a Clang node, false otherwise.\n*/\nstatic bool extensionHasClangNode(ExtensionDecl *ext) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SILValue getAccessPathRoot(SILValue pointer) {\n  while (true) {\n    if (auto *TEAI = dyn_cast<TupleElementAddrInst>(pointer)) {\n      pointer = TEAI->getOperand();\n      continue;\n    }\n\n    if (auto *SEAI = dyn_cast<StructElementAddrInst>(pointer)) {\n      pointer = SEAI->getOperand();\n      continue;\n    }\n\n    if (auto *BAI = dyn_cast<BeginAccessInst>(pointer)) {\n      pointer = BAI->getSource();\n      continue;\n    }\n\n    return pointer;\n  }\n}\n",
        "answer": "/** @brief Given an address, dive through any tuple/struct element addresses to get the underlying value.\n*\n* This function takes a SILValue pointer as input and returns the root of the access path. It does this by iteratively diving into the tuple/struct elements until it reaches the underlying value.\n*\n* @param[in] pointer The address to dive into.\n* @return The root of the access path.\n*/\nstatic SILValue getAccessPathRoot(SILValue pointer) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uint8_t getRawStableRequirementKind(RequirementKind kind) {\n#define CASE(KIND)            \\\n  case RequirementKind::KIND: \\\n    return GenericRequirementKind::KIND;\n\n  switch (kind) {\n  CASE(Conformance)\n  CASE(Superclass)\n  CASE(SameType)\n  CASE(Layout)\n  }\n#undef CASE\n\n  llvm_unreachable(\"Unhandled RequirementKind in switch.\");\n}\n",
        "answer": "/**\n* @brief Translates a RequirementKind to its corresponding GenericRequirementKind.\n*\n* This function takes a RequirementKind as input and returns its corresponding\n* GenericRequirementKind value. The mapping is guaranteed to be stable, meaning that the same\n* RequirementKind will always map to the same GenericRequirementKind.\n*\n* @param kind The RequirementKind to translate.\n* @return The corresponding GenericRequirementKind value.\n*/\nstatic uint8_t getRawStableRequirementKind(RequirementKind kind) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uint8_t getRawStableSILCoroutineKind(\n                                    swift::SILCoroutineKind kind) {\n  switch (kind) {\n  SIMPLE_CASE(SILCoroutineKind, None)\n  SIMPLE_CASE(SILCoroutineKind, YieldOnce)\n  SIMPLE_CASE(SILCoroutineKind, YieldMany)\n  }\n  llvm_unreachable(\"bad kind\");\n}\n",
        "answer": "/** @brief Translate from the AST coroutine-kind enum to the Serialization enum values, which are guaranteed to be stable.\n*\n*  This function takes a swift::SILCoroutineKind enum value as input and returns the corresponding Serialization enum value.\n*\n* @param kind The swift::SILCoroutineKind enum value to translate.\n* @return The corresponding Serialization enum value.\n*/\nstatic uint8_t getRawStableSILCoroutineKind(swift::SILCoroutineKind kind) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static ManagedValue emitUnabstractedCast(SILGenFunction &SGF, SILLocation loc,\n                                         ManagedValue value,\n                                         CanType sourceFormalType,\n                                         CanType targetFormalType) {\n  if (value.getType() == SGF.getLoweredType(targetFormalType))\n    return value;\n\n  return SGF.emitTransformedValue(loc, value,\n                                  AbstractionPattern(sourceFormalType),\n                                  sourceFormalType,\n                                  AbstractionPattern(targetFormalType),\n                                  targetFormalType);\n}\n",
        "answer": "/** @brief Convert to the given formal type, assuming that the lowered type of the source type is the same as its formal type. This is a reasonable assumption for a wide variety of types.\n*\n*  @param SGF The SILGenFunction in which the cast is being emitted.\n*  @param loc The location of the cast instruction.\n*  @param value The ManagedValue representing the source value to be casted.\n*  @param sourceFormalType The formal type of the source value.\n*  @param targetFormalType The formal type of the target value.\n*\n*  @return A ManagedValue representing the result of the cast operation.\n*/\nstatic ManagedValue emitUnabstractedCast(SILGenFunction &SGF, SILLocation loc,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void emitForceInto(SILGenFunction &SGF, SILLocation loc,\n                          ManagedValue result, TemporaryInitialization &temp) {\n  if (result.isInContext()) return;\n  result.ensurePlusOne(SGF, loc).forwardInto(SGF, loc, temp.getAddress());\n  temp.finishInitialization(SGF);\n}\n",
        "answer": "/** @brief Force a ManagedValue to be stored into a temporary initialization if it wasn't emitted that way directly.\n*\n* This function is used to ensure that a ManagedValue is stored in a temporary initialization, even if it was not originally emitted that way.\n* It checks if the ManagedValue is already in context and, if not, forces it into the temporary initialization using the `ensurePlusOne` method.\n* Finally, it finishes the initialization of the temporary using the `finishInitialization` method.\n*\n* @param SGF The SILGenFunction object.\n* @param loc The location in the code where the ManagedValue is being emitted.\n* @param result The ManagedValue to be stored into a temporary initialization.\n* @param temp The TemporaryInitialization object where the ManagedValue will be stored.\n*/\nstatic void emitForceInto(SILGenFunction &SGF, SILLocation loc,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sourcekitd_shutdown(void) {\n  llvm::sys::ScopedLock L(GlobalInitMtx);\n  --gInitRefCount;\n  if (gInitRefCount > 0)\n    return;\n\n  LOG_INFO_FUNC(High, \"shutting down\");\n  sourcekitd::shutdown();\n}\n",
        "answer": "/** @brief Shuts down the SourceKit daemon.\n*\n* If there are response handlers still waiting for a response, they will receive a SOURCEKITD_ERROR_REQUEST_CANCELLED response.\n*\n* @return Should not return\n*/\nvoid sourcekitd_shutdown(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t fnd_get_demangled_name(const char *MangledName, char *OutputBuffer,\n                              size_t Length) {\n  return swift_demangle_getDemangledName(MangledName, OutputBuffer, Length);\n}\n",
        "answer": "/** @brief Get the demangled name of a Swift symbol.\n*\n* This function takes a mangled Swift symbol and returns its demangled name.\n* The demangled name is stored in the provided output buffer, which must be at least\n* as long as the length parameter. If the output buffer is not large enough to hold\n* the entire demangled name, it will be truncated.\n*\n* @param MangledName The mangled Swift symbol.\n* @param OutputBuffer The output buffer where the demangled name will be stored.\n* @param Length The length of the output buffer.\n* @return The length of the demangled name, or 0 if there was an error.\n*/\nsize_t fnd_get_demangled_name(const char *MangledName, char *OutputBuffer, size_t Length) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isInsideDeprecatedDeclaration(SourceRange ReferenceRange,\n                                          const DeclContext *ReferenceDC){\n  auto IsDeprecated = [](const Decl *D) {\n    return D->getAttrs().getDeprecated(D->getASTContext());\n  };\n\n  return someEnclosingDeclMatches(ReferenceRange, ReferenceDC, IsDeprecated);\n}\n",
        "answer": "/** @brief Check if the reference is lexically contained in a declaration that is deprecated on all deployment targets.\n*\n*  This function checks if the reference range is inside a declaration that is deprecated on all deployment targets.\n*\n* @param ReferenceRange The source range of the reference to check.\n* @param ReferenceDC The declaration context of the reference to check.\n* @return True if the reference is inside a deprecated declaration, false otherwise.\n*/\nstatic bool isInsideDeprecatedDeclaration(SourceRange ReferenceRange, const DeclContext *ReferenceDC) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static VALUE bf_init(VALUE self, VALUE size)\n{\n    Check_Type(size, T_FIXNUM);\n    BitField *ptr;\n    Data_Get_Struct(self, BitField, ptr);\n    ptr->data.resize(FIX2INT(size));\n    return self;\n}\n",
        "answer": "/**\n* @brief Initializes a new BitField object with the given size.\n*\n* This function initializes a new BitField object with the given size, and sets its data to an empty vector of the specified size.\n*\n* @param self The BitField object to initialize.\n* @param size The size of the BitField object.\n* @return The initialized BitField object.\n*/\nstatic VALUE bf_init(VALUE self, VALUE size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void draw_item_with_portrait_scale_height(\n    int image_id,\n    int color,\n    optional<int> chara_chip_id,\n    int x,\n    int y)\n{\n    optional_ref<Extent> rect;\n\n    if (chara_chip_id)\n    {\n        rect = prepare_item_image(image_id, color, *chara_chip_id);\n    }\n    else\n    {\n        rect = prepare_item_image(image_id, color);\n    }\n\n    gmode(2);\n\n    gcopy_c(\n        1,\n        0,\n        960,\n        rect->frame_width,\n        rect->height,\n        x,\n        y,\n        rect->frame_width * inf_tiles / rect->height,\n        inf_tiles);\n}\n",
        "answer": "/** @brief Draws an item sprite with a character sprite on top, for cards/figures. Fits the sprite to inf_tiles height if it is tall.\n*\n*  This function draws an item sprite with a character sprite on top, for cards/figures. It fits the sprite to inf_tiles height if it is tall.\n*\n* @param image_id The ID of the image to be drawn.\n* @param color The color of the image to be drawn.\n* @param chara_chip_id The ID of the character chip to be drawn on top of the item sprite. If not provided, no character chip will be drawn.\n* @param x The x coordinate of the upper-left corner of the drawing area.\n* @param y The y coordinate of the upper-left corner of the drawing area.\n*/\nvoid draw_item_with_portrait_scale_height(int image_id, int color, optional<int> chara_chip_id, int x, int y) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool to_b(const String& str)\n{\n if (str.length() != 4)\n  return false;\n \n if (!(str[0] == 'T' || str[0] == 't'))\n  return false;\n\n if (!(str[1] == 'R' || str[1] == 'r'))\n  return false;\n\n if (!(str[2] == 'U' || str[2] == 'u'))\n  return false;\n\n if (!(str[3] == 'E' || str[3] == 'e'))\n  return false;\n \n return true;\n}\n",
        "answer": "/** @brief Converts a string to a boolean value.\n*\n*  This function takes in a string and checks if it is equal to \"true\" (case-insensitive). If the string is not equal to \"true\", it returns false.\n*\n* @param str The input string.\n* @return True if the string is equal to \"true\" (case-insensitive), false otherwise.\n*/\nbool to_b(const String& str)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool split(const String& str, NxOgre::map<String, String>& value, char delimiter, bool lowerKey, bool trim)\n{\n size_t pos = str.find_first_of(delimiter);\n if (pos == String::npos)\n  return false;\n \n std::string k = str.substr(0,pos);\n std::string v = str.substr(pos+1);\n\n if (lowerKey)\n  lower(k);\n\n if (trim)\n {\n  Strings::trim(k);\n  Strings::trim(v);\n }\n \n value.insert(k, v);\n\n return true;\n}\n",
        "answer": "/**\n* @brief Splits a string into two parts and places them into a map.\n*\n* The first part is used as the key, and the second part is used as the value.\n*\n* @param str The input string to split.\n* @param value A reference to the map where the split values will be stored.\n* @param delimiter The character that separates the two parts of the string.\n* @param lowerKey Whether or not to convert the key to lowercase before inserting it into the map.\n* @param trim Whether or not to trim whitespace from the key and value before inserting them into the map.\n*\n* @return True if the split was successful, false otherwise.\n*/\nbool split(const String& str, NxOgre::map<String, String>& value, char delimiter, bool lowerKey, bool trim)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n                                    const unsigned char *txTo        , unsigned int txToLen,\n                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n{\n    CAmount am(0);\n    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, nIn, flags, err);\n}\n",
        "answer": "/** @brief Verifies a Bitcoin transaction input.\n*\n*  This function verifies a Bitcoin transaction input by checking if the input correctly spends the scriptPubKey under the additional constraints specified by flags. If not NULL, err will contain an error/success code for the operation.\n*\n* @param[in] scriptPubKey The scriptPubKey of the output being spent.\n* @param[in] scriptPubKeyLen The length of the scriptPubKey.\n* @param[in] txTo The transaction containing the input to be verified.\n* @param[in] txToLen The length of the transaction.\n* @param[in] nIn The index of the input in the transaction being verified.\n* @param[in] flags Additional constraints for the script verification.\n* @param[out] err An error/success code for the operation.\n* @return 1 if the input correctly spends the scriptPubKey, 0 otherwise.\n*/\nint bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int64_t GetTime()\n{\n    if (nMockTime) return nMockTime;\n\n    return time(NULL);\n}\n",
        "answer": "/** @brief Gets the system time in seconds.\n*\n*  This function returns the system time in seconds, but also supports mocktime, where the time can be specified by the user, eg for testing (eg with the setmocktime rpc, or -mocktime argument). TODO: Rework these functions to be type-safe (so that we don't inadvertently compare numbers with different units, or compare a mocktime to system time).\n*\n* @return The system time in seconds.\n*/\nint64_t GetTime()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double parameterOfPointOnLine(double x0, double y0, double dx, double dy, double x, double y, bool& ok)\n{\n\tconst double epsilon = 1e-5;\n\tok = true;\n\t\n\tif (qAbs(dx) > qAbs(dy))\n\t{\n\t\tdouble param = (x - x0) / dx;\n\t\tif (qAbs(y0 + param * dy - y) < epsilon)\n\t\t\treturn param;\n\t}\n\telse if (dy != 0)\n\t{\n\t\tdouble param = (y - y0) / dy;\n\t\tif (qAbs(x0 + param * dx - x) < epsilon)\n\t\t\treturn param;\n\t}\n\t\n\tok = false;\n\treturn -1;\n}\n",
        "answer": "/** @brief Calculates the line parameter for a point on a straight line.\n*\n*  This function calculates the line parameter for a point on a straight line. It sets ok to false in case of an error (if the line is actually a point, or if the test point is not on the line). x0, y0: line start dx, dy: vector from line start to line end x, y: suspected point on the line to calculate the parameter for so: x0 + parameter * dx = x (and the same for y).\n*\n* @param[in] x0 The x-coordinate of the line start.\n* @param[in] y0 The y-coordinate of the line start.\n* @param[in] dx The x-coordinate of the vector from the line start to the line end.\n* @param[in] dy The y-coordinate of the vector from the line start to the line end.\n* @param[in] x The x-coordinate of the suspected point on the line.\n* @param[in] y The y-coordinate of the suspected point on the line.\n* @param[out] ok A boolean value indicating whether the calculation was successful or not.\n* @return The line parameter for the point on the line, or -1 if there is an error.\n*/\ndouble parameterOfPointOnLine(double x0, double y0, double dx, double dy, double x, double y, bool& ok)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool copyAudioStreamInAudioBuffer (InputStream* stream)\r\n    {\r\n        AudioFormatManager manager;\r\n        manager.registerBasicFormats();\r\n\r\n        if (ScopedPointer<AudioFormatReader> formatReader = manager.createReaderFor (stream))\r\n        {\r\n            currentInfo.originalNumChannels = formatReader->numChannels > 1 ? 2 : 1;\r\n            currentInfo.originalSampleRate = formatReader->sampleRate;\r\n            currentInfo.originalSize = static_cast<int> (jmin (maximumTimeInSamples, formatReader->lengthInSamples));\r\n\r\n            impulseResponseOriginal.clear();\r\n            formatReader->read (&(impulseResponseOriginal), 0, (int) currentInfo.originalSize, 0, true, currentInfo.originalNumChannels > 1);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n",
        "answer": "/** @brief Copies the audio stream into an audio buffer of floats, and performs resampling if necessary.\n*\n*  This function takes an input stream and converts it to a stereo audio buffer of floats. If the input stream has more than two channels, it will be downmixed to stereo. If the input stream has a different sample rate than the target sample rate, it will be resampled to match.\n*\n* @param stream The input audio stream.\n* @return True if the conversion was successful, false otherwise.\n*/\nbool copyAudioStreamInAudioBuffer (InputStream* stream)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  bool checkReachability( const vectord &query )\n  { return true; }; \n",
        "answer": "/** @brief Checks the reachability of a query point in the vector space.\n*\n* This function checks if a given query point is reachable from the origin in the vector space.\n* The query point is represented as a vector in the same dimension as the vector space.\n*\n* @param[in] query The query point to be checked for reachability.\n*\n* @return True if the query point is reachable, false otherwise.\n*/\nbool checkReachability( const vectord &query )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  thread_t createThread(thread_func f, void* arg, size_t stack_size, ssize_t threadID)\n  {\n    HANDLE thread = CreateThread(nullptr, stack_size, (LPTHREAD_START_ROUTINE)threadStartup, new ThreadStartupData(f,arg), 0, nullptr);\n    if (thread == nullptr) throw std::runtime_error(\"ospcommon::CreateThread failed\");\n    if (threadID >= 0) setAffinity(thread, threadID);\n    return thread_t(thread);\n  }\n",
        "answer": "/** @brief Creates a hardware thread running on specific core.\n*\n* This function creates a hardware thread running on specific logical thread.\n* It takes in a thread function, argument for the thread function, stack size, and thread ID as input parameters.\n* The function returns a handle to the created thread. If the creation fails, it throws an error.\n*\n* @param f A pointer to the thread function.\n* @param arg An argument for the thread function.\n* @param stack_size The size of the stack for the new thread.\n* @param threadID The ID of the logical thread on which to create the hardware thread.\n* @return A handle to the created thread.\n*/\nthread_t createThread(thread_func f, void* arg, size_t stack_size, ssize_t threadID)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t meshopt_simplify(unsigned int* destination, const unsigned int* indices, size_t index_count, const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride, size_t target_index_count)\n{\n\tusing namespace meshopt;\n\n\tassert(index_count % 3 == 0);\n\tassert(vertex_positions_stride > 0 && vertex_positions_stride <= 256);\n\tassert(vertex_positions_stride % sizeof(float) == 0);\n\tassert(target_index_count <= index_count);\n\n\treturn simplifyEdgeCollapse(destination, indices, index_count, vertex_positions, vertex_positions_stride, vertex_count, target_index_count);\n}\n",
        "answer": "/** @brief Mesh simplifier.\n*\n*  This function reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible.\n*  Returns the number of indices after simplification, with destination containing new index data.\n*\n* @param[out] destination The buffer where the simplified mesh will be stored.\n* @param[in] indices The original mesh indices.\n* @param[in] index_count The number of indices in the original mesh.\n* @param[in] vertex_positions The positions of the vertices in the original mesh.\n* @param[in] vertex_count The number of vertices in the original mesh.\n* @param[in] vertex_positions_stride The stride of the vertex positions buffer.\n* @param[in] target_index_count The desired number of indices in the simplified mesh.\n* @return The number of indices after simplification, with destination containing new index data.\n*/\nsize_t meshopt_simplify(unsigned int* destination, const unsigned int* indices, size_t index_count, const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride, size_t target_index_count)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void findLength(ListNode* A, ListNode* B, int& lenA, int& lenB){\n    while((A != NULL) || (B != NULL)){\n        if(A != NULL){\n            lenA++;\n            A = A->next;\n        }\n        if(B != NULL){\n            lenB++;\n            B = B->next;\n        }\n    }\n} \n",
        "answer": "/** @brief Finds the length of two singly-linked lists.\n*\n* This function takes two pointers to the heads of two singly-linked lists, and returns the lengths of the lists by reference.\n* The function iterates through the lists until it reaches the end of both lists, and increments the corresponding length variables for each node it visits.\n*\n* @param A Pointer to the head of the first list.\n* @param B Pointer to the head of the second list.\n* @param lenA Reference to the length of the first list.\n* @param lenB Reference to the length of the second list.\n*/\nvoid findLength(ListNode* A, ListNode* B, int& lenA, int& lenB) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void putSum(TreeNode* root, vector<vector<int> >& sol, int sum, vector<int>& v){\n    if(sum == 0 && root->left == NULL && root->right == NULL){\n        sol.push_back(v);\n    }\n    \n    if(root->left != NULL){\n        v.push_back((root->left)->val);\n        putSum(root->left, sol, sum - (root->left)->val, v);\n        v.pop_back();\n    }\n    \n    if(root->right != NULL){\n        v.push_back((root->right)->val);\n        putSum(root->right, sol, sum - (root->right)->val, v);\n        v.pop_back();\n    }\n    \n}\n",
        "answer": "/** @brief Finds all paths in a binary tree that add up to a given sum.\n*\n*  This function takes a binary tree and a target sum as input, and returns a vector of vectors containing all the paths that add up to the target sum. Each path is represented by a vector of integers, where each integer is the value of a node in the tree. The function uses a recursive approach to traverse the tree and find all valid paths.\n*\n* @param root A pointer to the root node of the binary tree.\n* @param sol A reference to a vector of vectors that will hold the results.\n* @param sum The target sum that the paths must add up to.\n* @param v A reference to a vector that holds the current path being explored.\n*/\nvoid putSum(TreeNode* root, vector<vector<int> >& sol, int sum, vector<int>& v)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t wfLZ_MemCmp( const uint8_t* a, const uint8_t* b, const uint32_t maxLen )\n{\n\tuint32_t matched = 0;\n\twhile( *a++ == *b++ && matched < maxLen ) ++matched;\n\treturn matched;\n}\n",
        "answer": "/** @brief Compares two memory regions.\n*\n* This function compares the first \\p maxLen bytes of the memory regions pointed to by \\p a and \\p b.\n*\n* @param[in] a Pointer to the first memory region.\n* @param[in] b Pointer to the second memory region.\n* @param[in] maxLen Maximum number of bytes to compare.\n*\n* @return The number of bytes that match between the two memory regions.\n*/\nuint32_t wfLZ_MemCmp( const uint8_t* a, const uint8_t* b, const uint32_t maxLen )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void dpotrf_(\tconst char *uplo, const unsigned long *_n, double *a,\n\t\t\t\t\t\t\tconst unsigned long *_lda, long *info\n\t\t\t\t\t\t\t)\n{\n\tunsigned long n = *_n, lda = *_lda;\n\tdouble sum;\n\tunsigned long i, j;\n\tint k;\n\n\tfor( i=0; i<n; ++i )\n\t{\n\t\t/* j == i */\n\t\tsum = a[i + lda*i];\n\n\t\tfor( k=(i-1); k>=0; --k )\n\t\t\tsum -= a[k+lda*i] * a[k+lda*i];\n\n\t\tif ( sum > 0.0 )\n\t\t\ta[i+lda*i] = REFER_NAMESPACE_QPOASES getSqrt( sum );\n\t\telse\n\t\t{\n\t\t\ta[0] = sum; /* tunnel negative diagonal element to caller */\n\t\t\tif (info != 0)\n\t\t\t\t*info = i+1;\n\t\t\treturn;\n\t\t}\n\n\t\tfor( j=(i+1); j<n; ++j )\n\t\t{\n\t\t\tsum = a[j*lda + i];\n\n\t\t\tfor( k=(i-1); k>=0; --k )\n\t\t\t\tsum -= a[k+lda*i] * a[k+lda*j];\n\n\t\t\ta[i+lda*j] = sum / a[i+lda*i];\n\t\t}\n\t}\n\tif (info != 0)\n\t\t*info = 0;\n}\n",
        "answer": "/** @brief Calculates the Cholesky factorization of a real symmetric positive definite matrix in double precision.\n*\n* This function calculates the Cholesky factorization of a real symmetric positive definite matrix using the LAPACK dpotrf_ function. The Cholesky factorization is a lower triangular matrix L such that A = LL^T, where A is the original matrix and L^T is the transpose of L.\n*\n* @param uplo Specifies whether the upper or lower triangular part of the symmetric matrix A is stored in the array a. If uplo is 'U', the upper triangular part is stored; if uplo is 'L', the lower triangular part is stored.\n* @param n The number of columns and rows of the matrix A.\n* @param a An array of dimension (lda, n) containing the symmetric matrix A. If uplo is 'U', only the upper triangular part of A is used; if uplo is 'L', only the lower triangular part of A is used.\n* @param lda The leading dimension of the array a. This value must be at least max(1, n).\n* @param info An integer array of dimension (n) containing information about the Cholesky factorization. If info[i] = 0, the i-th diagonal element of A is positive and nonzero; if info[i] = j > 0, the j-th diagonal element of A is zero, and the Cholesky factorization could not be completed.\n*\n* @return void\n*/\nextern \"C\" void dpotrf_(\tconst char *uplo, const unsigned long *_n, double *a,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setMapMagicVersion(int iCoreNumber, char* magic)\n{\n    switch (iCoreNumber)\n    {\n    case CLIENT_CLASSIC:\n        std::strcpy(magic,\"z1.4\");\n        break;\n    case CLIENT_TBC:\n        std::strcpy(magic,\"s1.4\");\n        break;\n    case CLIENT_WOTLK:\n        std::strcpy(magic,\"v1.4\");\n        break;\n    case CLIENT_CATA:\n        std::strcpy(magic,\"c1.4\");\n        break;\n    case CLIENT_MOP:\n        std::strcpy(magic,\"p1.4\");\n        break;\n    case CLIENT_WOD:\n        std::strcpy(magic,\"w1.4\");\n        break;\n    case CLIENT_LEGION:\n        std::strcpy(magic,\"l1.4\");\n        break;\n    default:\n        std::strcpy(magic,\"UNKN\");\n        break;\n    }\n}\n",
        "answer": "/** @brief Sets the magic version for a map file based on the core number.\n*\n*  This function sets the 'magic' number for a map file based on the core number iCoreNumber is the Core Number\n*\n* @param[in] iCoreNumber The core number of the client.\n* @param[out] magic A pointer to the memory location where the magic version will be stored.\n* @return None\n*/\nvoid setMapMagicVersion(int iCoreNumber, char* magic)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SOUNDTOUCHDLL_API void __cdecl soundtouch_setRateChange(HANDLE h, float newRate)\n{\n    STHANDLE *sth = (STHANDLE*)h;\n    if (sth->dwMagic != STMAGIC) return;\n\n    sth->pst->setRateChange(newRate);\n}\n",
        "answer": "/**\n* @brief Sets new rate control value as a difference in percents compared to the original rate (-50 .. +100 %).\n*\n* This function sets the new rate control value as a difference in percents compared to the original rate. The range of values is from -50% to +100%.\n*\n* @param h A handle to the soundtouch object.\n* @param newRate The new rate control value, expressed as a percentage difference from the original rate.\n*/\nSOUNDTOUCHDLL_API void __cdecl soundtouch_setRateChange(HANDLE h, float newRate)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool ListMyBuckets(Aws::S3::S3Client s3_client) {\n  auto outcome = s3_client.ListBuckets();\n\n  if (outcome.IsSuccess()) {\n    std::cout << \"My buckets now are:\" << std::endl << std::endl;\n\n    Aws::Vector<Aws::S3::Model::Bucket> bucket_list =\n      outcome.GetResult().GetBuckets();\n\n    for (auto const &bucket: bucket_list) {\n      std::cout << bucket.GetName() << std::endl;\n    }\n\n    std::cout << std::endl;\n    return true;\n  } else {\n    std::cout << \"ListBuckets error: \"\n              << outcome.GetError().GetExceptionName() << std::endl\n              << outcome.GetError().GetMessage() << std::endl;\n\n    return false;\n  }\n}\n",
        "answer": "/** @brief Lists the buckets in an S3 client.\n*\n* This function lists all the buckets in an S3 client using the ListBuckets API.\n* It returns a boolean value indicating whether the operation was successful or not.\n* If the operation is successful, it prints the names of the buckets to the console.\n* Otherwise, it prints an error message to the console.\n*\n* @param s3_client The S3 client object used for listing buckets.\n* @return A boolean value indicating whether the operation was successful or not.\n*/\nbool ListMyBuckets(Aws::S3::S3Client s3_client) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static float max(float a, float b) {\n    return std::max(a,b);\n}\n",
        "answer": "/** @brief Encapsulates the std::max and std::min functions to provide parameter compatibility.\n*\n*  This function takes two float arguments, a and b, and returns the maximum of the two values using the std::max function.\n*\n* @param a The first value to compare.\n* @param b The second value to compare.\n* @return The maximum of the two input values.\n*/\nstatic float max(float a, float b) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void showSAS(std::string sas, bool verified) {\n            cout << \"SAS is: \" << sas << endl;\n\n        }\n",
        "answer": "/**\n* @brief Show the Short Authentication String (SAS) on user interface.\n*\n* ZRTP calls this method to display the SAS and inform about the SAS verification status. The user interface shall enable a SAS verification button (or similar UI element). The user shall click on this UI element after he/she confirmed the SAS code with the partner.\n*\n* @param sas The Short Authentication String to display.\n* @param verified Whether the SAS has been verified or not.\n*/\nvoid showSAS(std::string sas, bool verified) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool checkSASSignature(uint8_t* sasHash) {\n        cout << prefix << \"check signature\" << endl;\n        const uint8_t* sign = session->getSignatureData();\n        cout << prefix << \"signature: \" << sign << endl;\n        return true;\n    }\n",
        "answer": "/** @brief Checks the SAS signature.\n*\n*  This method is called by ZRTPQueue to request a SAS signature check. If the signature check fails, the client may return false to ZRTP, which will signal an error to the other peer and terminate the ZRTP handshake.\n*\n* @param sasHash The hash of the SAS signature.\n* @return True if the signature is valid, false otherwise.\n*/\nbool checkSASSignature(uint8_t* sasHash) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hmac_sha384( uint8_t* key, uint32_t keyLength,\n                  uint8_t* dataChunks[],\n                  uint32_t dataChunkLength[],\n                  uint8_t* mac, uint32_t* macLength )\n{\n    gcry_md_hd_t hd;\n    gcry_error_t err = 0;\n\n    err = gcry_md_open(&hd, GCRY_MD_SHA384, GCRY_MD_FLAG_HMAC);\n    gcry_md_setkey(hd, key, keyLength);\n\n    while (*dataChunks) {\n        gcry_md_write (hd, *dataChunks, (uint32_t)(*dataChunkLength));\n\tdataChunks++;\n\tdataChunkLength++;\n    }\n    uint8_t* p = gcry_md_read (hd, GCRY_MD_SHA384);\n    memcpy(mac, p, SHA384_DIGEST_LENGTH);\n    if (macLength != NULL) {\n        *macLength = SHA384_DIGEST_LENGTH;\n    }\n    gcry_md_close (hd);\n}\n",
        "answer": "/** @brief Compute SHA384 HMAC over several data chunks.\n*\n*  This function takes several data chunks and computes the SHA384 HAMAC. It uses the openSSL HAMAC SHA384 implementation.\n*\n* @param key The key to use for the HMAC computation.\n* @param keyLength The length of the key.\n* @param dataChunks An array of pointers to the data chunks to compute the HMAC over.\n* @param dataChunkLength An array of lengths of each data chunk.\n* @param mac A pointer to a buffer where the computed MAC will be stored.\n* @param macLength A pointer to a variable that will hold the length of the computed MAC.\n*/\n*macLength = SHA384_DIGEST_LENGTH;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sha384(unsigned char* dataChunks[],\n            unsigned int dataChunkLength[],\n            unsigned char* mac)\n{\n    gcry_md_hd_t hd;\n    gcry_error_t err = 0;\n\n    err = gcry_md_open(&hd, GCRY_MD_SHA384, 0);\n    while (*dataChunks) {\n        gcry_md_write (hd, *dataChunks, (uint32_t)(*dataChunkLength));\n        dataChunks++;\n        dataChunkLength++;\n    }\n    uint8_t* p = gcry_md_read (hd, GCRY_MD_SHA384);\n    memcpy(mac, p, SHA384_DIGEST_LENGTH);\n    gcry_md_close (hd);\n}\n",
        "answer": "/** @brief Compute SHA384 digest over several data chunks.\n*\n*  This function takes several data chunks and computes the SHA384 digest. It creates and deletes an own SHA384 context to perform the SHA384 operations.\n*\n* @param[in] dataChunks An array of pointers to the data chunks.\n* @param[in] dataChunkLength An array of unsigned integers representing the length of each data chunk.\n* @param[out] mac The computed SHA384 digest.\n*/\nvoid sha384(unsigned char* dataChunks[], unsigned int dataChunkLength[], unsigned char* mac) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hmacSha1Ctx(void* ctx, const uint8_t* data[], uint32_t dataLength[],\n                uint8_t* mac, int32_t* macLength )\n{\n    hmacSha1Context *pctx = (hmacSha1Context*)ctx;\n\n    hmacSha1Reset(pctx);\n    while (*data) {\n        hmacSha1Update(pctx, *data, *dataLength);\n        data++;\n        dataLength++;\n    }\n    hmacSha1Final(pctx, mac);\n    *macLength = SHA1_BLOCK_SIZE;\n}\n",
        "answer": "/**\n* @brief Compute SHA1 HMAC over several data chunks. This functions takes several data chunks and computes the SHA1 HAMAC. On return the SHA1 MAC context is ready to compute a HMAC for another data chunk.\n*\n* @param ctx The HMAC context to use.\n* @param data[] The data chunks to hash.\n* @param dataLength[] The length of each data chunk.\n* @param mac[] The output buffer for the computed MAC.\n* @param macLength[] The length of the output buffer.\n*/\n*macLength = SHA1_BLOCK_SIZE;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hmac_sha256(uint8_t* key, uint32_t key_length,\n                 uint8_t* data_chunks[],\n                 uint32_t data_chunck_length[],\n                 uint8_t* mac, uint32_t* mac_length )\n{\n    unsigned int tmp;\n    HMAC_CTX ctx;\n    HMAC_CTX_init( &ctx );\n    HMAC_Init_ex( &ctx, key, key_length, EVP_sha256(), NULL );\n    while( *data_chunks ){\n      HMAC_Update( &ctx, *data_chunks, *data_chunck_length );\n      data_chunks ++;\n      data_chunck_length ++;\n    }\n    HMAC_Final( &ctx, mac, &tmp);\n    *mac_length = tmp;\n    HMAC_CTX_cleanup( &ctx );\n}\n",
        "answer": "/**\n* @brief Compute SHA256 HMAC over several data chunks.\n*\n* This function takes several data chunks and computes the SHA256 HAMAC. It uses the OpenSSL HAMAC SHA256 implementation.\n*\n* @param key The key to use for the HMAC computation.\n* @param key_length The length of the key in bytes.\n* @param data_chunks An array of pointers to the data chunks to be hashed.\n* @param data_chunk_lengths An array of lengths of each data chunk, in bytes.\n* @param mac A pointer to a buffer where the computed HMAC will be stored.\n* @param mac_length The length of the computed HMAC, in bytes.\n*/\n*mac_length = tmp;\nHMAC_CTX_cleanup( &ctx );"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sha256(unsigned char * data_chunks[],\n\t    unsigned int data_chunck_length[],\n\t    unsigned char *digest)\n{\n\tSHA256_CTX ctx;\n\tSHA256_Init( &ctx);\n\twhile(*data_chunks) {\n\t\tSHA256_Update(&ctx, *data_chunks, *data_chunck_length);\n\t\tdata_chunks++;\n\t\tdata_chunck_length++;\n\t}\n\tSHA256_Final(digest, &ctx);\n}\n",
        "answer": "/** @brief Compute SHA256 digest over several data chunks.\n*\n*  This function takes several data chunks and computes the SHA256 digest. It creates and deletes an own SHA256 context to perform the SHA256 operations.\n*\n* @param[in] data_chunks An array of pointers to the data chunks.\n* @param[in] data_chunck_length An array of integers representing the length of each data chunk.\n* @param[out] digest A pointer to an unsigned char where the SHA256 digest will be stored.\n*/\nvoid sha256(unsigned char *data_chunks[], unsigned int data_chunk_length[], unsigned char *digest) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void closeSha256Context(void* ctx, unsigned char* digest)\n{\n    sha256_ctx* hd = reinterpret_cast<sha256_ctx*>(ctx);\n\n    if (digest != NULL && hd != NULL) {\n        sha256_end(digest, hd);\n    }\n    free(hd);\n}\n",
        "answer": "/** @brief Close the SHA256 digest and compute the final hash.\n*\n*  This function is used to close the SHA256 context and compute the final hash.\n*  It takes a pointer to the SHA256 context as its first argument, and a pointer\n*  to an unsigned char array as its second argument. The function will use the\n*  SHA256_end() function from the OpenSSL library to compute the final hash and\n*  store it in the provided buffer. If either of the pointers is NULL, the function\n*  will return without performing any action.\n*\n* @param ctx A pointer to the SHA256 context.\n* @param digest A pointer to an unsigned char array where the final hash will be stored.\n* @return void\n*/\nvoid closeSha256Context(void* ctx, unsigned char* digest)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sha384Ctx(void* ctx, unsigned char* dataChunks[],\n               unsigned int dataChunkLength[])\n{\n    SHA512_CTX* hd = (SHA512_CTX*)ctx;\n\n    while (*dataChunks) {\n        SHA384_Update (hd, *dataChunks, *dataChunkLength);\n        dataChunks++;\n        dataChunkLength++;\n    }\n}\n",
        "answer": "/**\n* @brief Update the SHA384 context with several data chunks. This functions updates the SHA384 context with some data. See also CloseSha384Context(...) how to get the digest.\n*\n* @param ctx The SHA384 context to update.\n* @param dataChunks An array of pointers to the data chunks to add to the context.\n* @param dataChunkLength An array of lengths for each data chunk in bytes.\n*/\nvoid sha384Ctx(void* ctx, unsigned char* dataChunks[], unsigned int dataChunkLength[]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void closeSkein256Context(void* ctx, unsigned char* digest)\n{\n    SkeinCtx_t* hd = reinterpret_cast<SkeinCtx_t*>(ctx);\n\n    if (digest != NULL) {\n        skeinFinal(hd, digest);\n    }\n    free(hd);\n}\n",
        "answer": "/** @brief Close the Skein256 context.\n*\n*  This function computes a digest and closes the Skein256 context.\n*  An application uses this function to compute the Skein256 digest and to close the Skein256 context.\n*\n* @param ctx The Skein256 context.\n* @param digest The computed digest.\n*\n* @return void\n*/\nvoid closeSkein256Context(void* ctx, unsigned char* digest)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void closeSkein384Context(void* ctx, unsigned char* digest)\n{\n    SkeinCtx_t* hd = reinterpret_cast<SkeinCtx_t*>(ctx);\n\n    if (digest != NULL && hd != NULL) {\n        skeinFinal(hd, digest);\n    }\n    free(hd);\n}\n",
        "answer": "/** @brief Close the Skein384 context and compute the digest.\n*\n*  This function computes the Skein384 digest and closes the Skein384 context.\n*  An application uses this function to compute the Skein384 digest and to close the Skein384 context.\n*\n* @param ctx The Skein384 context to be closed.\n* @param digest The computed Skein384 digest.\n*\n* @return None.\n*/\nvoid closeSkein384Context(void* ctx, unsigned char* digest)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void twoCfbEncrypt(uint8_t* key, int32_t keyLength, uint8_t* IV, uint8_t *data, int32_t dataLength)\n{\n    Twofish_key keyCtx;\n    int usedBytes = 0;\n\n    if (!initialized) {\n        Twofish_initialise();\n        initialized = 1;\n    }\n\n    memset(&keyCtx, 0, sizeof(Twofish_key));\n    Twofish_prepare_key(key, keyLength, &keyCtx);\n\n    Twofish_cfb128_encrypt(&keyCtx, (Twofish_Byte*)data, (Twofish_Byte*)data,\n\t\t\t   (size_t)dataLength, (Twofish_Byte*)IV, &usedBytes);\n}\n",
        "answer": "/**\n* @brief Encrypt data with Twofish CFB mode, full block feedback size.\n*\n* This functions takes one data chunk and encrypts it with Twofish CFB mode. The length of the data may be arbitrary and it is not needed to be a multiple of Twofish blocksize.\n*\n* @param key Pointer to the encryption key.\n* @param keyLength Length of the encryption key in bytes.\n* @param IV Initialization vector for the CFB mode.\n* @param data Pointer to the data to encrypt.\n* @param dataLength Length of the data to encrypt in bytes.\n*/\nvoid twoCfbEncrypt(uint8_t* key, int32_t keyLength, uint8_t* IV, uint8_t *data, int32_t dataLength)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void zrtp_setAuxSecret(ZrtpContext* zrtpContext, uint8_t* data, int32_t length) {\n    if (zrtpContext && zrtpContext->zrtpEngine)\n        zrtpContext->zrtpEngine->setAuxSecret(data, length);\n}\n",
        "answer": "/** @brief Set the auxilliary secret.\n*\n*  Use this method to set the auxilliary secret data. Refer to ZRTP specification, chapter 4.3 ff\n*\n* @param zrtpContext The ZRTP context.\n* @param data The auxilliary secret data.\n* @param length The length of the auxilliary secret data.\n*/\nvoid zrtp_setAuxSecret(ZrtpContext* zrtpContext, uint8_t* data, int32_t length) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void zrtp_setEnrollmentMode(ZrtpContext* zrtpContext, int32_t enrollmentMode) {\n    if (zrtpContext && zrtpContext->zrtpEngine)\n        return zrtpContext->zrtpEngine->setEnrollmentMode(enrollmentMode == 0 ? false : true);\n}\n",
        "answer": "/** @brief Sets the enrollment mode for ZRTP.\n*\n* This function sets the enrollment mode for ZRTP. If enrollment mode is set to true, then the confirm packets will have the enrollment flag (E) set and the enrollment actions will be performed. A MitM (PBX) enrollment service must set this mode to true. Can only be set to true if mitmMode is also true.\n*\n* @param zrtpContext The ZRTP context.\n* @param enrollmentMode The enrollment mode.\n*/\nvoid zrtp_setEnrollmentMode(ZrtpContext* zrtpContext, int32_t enrollmentMode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t zrtp_getPeerZid(ZrtpContext* zrtpContext, uint8_t* data) {\n    if (data == NULL)\n        return 0;\n\n    if (zrtpContext && zrtpContext->zrtpEngine)\n        return zrtpContext->zrtpEngine->getPeerZid(data);\n\n    return 0;\n}\n",
        "answer": "/** @brief Get other party's ZID (ZRTP Identifier) data.\n*\n* This function returns the other party's ZID that was received during ZRTP processing.\n*\n* @param zrtpContext The ZRTP context.\n* @param data A pointer to a buffer where the ZID will be stored.\n* @return The length of the ZID, or 0 if there is no ZID available.\n*/\nint32_t zrtp_getPeerZid(ZrtpContext* zrtpContext, uint8_t* data) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void death(const Event& event) {\n            mGui->widgetDied(event.getSource());\n        }\n",
        "answer": "/** @brief Called when a widget dies. It is used to be able to receive a notification when a death of a widget occurs.\n*\n*  This function is called whenever a widget dies, and it is used to notify the GUI that a widget has died.\n*\n* @param event The Event object containing information about the death of the widget.\n*/\nvoid death(const Event& event) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double GetFastMiningKHPS()\n{\n    double dFastKHPS = 0.0;\n\n    LOCK(cs_hashmeter);\n\n    if( nMinerThreadsRunning ) {\n        MeterMap mapMiner;\n        for( mruset<CHashMeter>::const_iterator it = mruFastReadings.begin(); it != mruFastReadings.end(); ++it )\n            UpdateMeterMap( (*it).GetMinerID(), (*it).GetFastKHPS(), mapMiner );\n        for( MeterMap::const_iterator it = mapMiner.begin(); it != mapMiner.end(); ++it )\n            dFastKHPS += (*it).second.second / (double)(*it).second.first;\n    }\n\n    return dFastKHPS;\n}\n",
        "answer": "/**\n* @brief Get the fast mining KH/s.\n*\n* This function averages the miner threads 10 second samples, as found from over the last 10 minutes. Once the totals from each thread have been created, it finds the average each of them are producing and sums each of those, into the total returned.\n*\n* @return The fast mining KH/s.\n*/\ndouble GetFastMiningKHPS()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string JSONRPCRequest(const string& strMethod, const Array& params, const Value& id)\n{\n    Object request;\n    request.push_back(Pair(\"method\", strMethod));\n    request.push_back(Pair(\"params\", params));\n    request.push_back(Pair(\"id\", id));\n    return write_string(Value(request), false) + \"\\n\";\n}\n",
        "answer": "/** @brief JSON-RPC Request function.\n*\n*  This function creates a JSON-RPC request object with the specified method, parameters, and id.\n*\n* @param strMethod The name of the method to call.\n* @param params An array of parameters to pass to the method.\n* @param id A unique identifier for the request.\n*\n* @return A JSON-RPC request object as a string.\n*/\nstring JSONRPCRequest(const string& strMethod, const Array& params, const Value& id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvoid initShapes() {\n\t\t\tCircle::init();\n\t\t\tCylinder::init();\n\t\t}\n",
        "answer": "/** @brief Initializes shapes.\n*\n*  This function initializes the shapes for the game.\n*  It calls the init() method of Circle and Cylinder classes.\n*\n* @return None\n*/\nvoid initShapes() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void print_usage(char **argv) {\n  std::cout << \"Usage: \" << std::endl;\n  std::cout << \"  \" << argv[0] << \" -h\" << std::endl;\n  std::cout << \"  \" << argv[0] << \" TARGET [TARGET...]\" << std::endl;\n}\n",
        "answer": "/**\n* @brief Prints usage information for the program.\n*\n* This function prints a brief message explaining how to use the program,\n* including the options and arguments that can be passed to it.\n*\n* @param argv The command line arguments passed to the program.\n*/\nstatic void print_usage(char **argv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool sortOnLength(const string* a, const string* b)\r\n{\r\n\treturn (*a).length() > (*b).length();\r\n}\r\n",
        "answer": "/** @brief Sort comparison function. Compares the length of the value of pointers in the vectors. The LONGEST strings will be first in the vector.\n*/\nbool sortOnLength(const string* a, const string* b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void RandomGauss_(double *r, int n, double mean, double sd, int rseed)\n{\n    int     k, i, j, nd;\n    double  sum, *rr;\n\n    k  = 6;\n    nd = n+k-1;\n\n    rr = (double*) malloc(sizeof(double)*nd);\n\n    RandomClose(rr, nd, rseed);\n\n    for(i=0; i<=nd-k; i++){\n        sum=0;\n        for(j=i; j<i+k; j++) sum += rr[j];\n        sum /= k;\n\n        rr[i] = (sum-0.5)/sqrt(1.0/(12.0*k))*sd + mean;\n    }\n\n    for(i=0; i<n; i++) r[i] = rr[i];\n\n    free(rr);\n}\n",
        "answer": "/** @brief Generate Gauss distributed random numbers.\n*\n*  This function generates Gaussian distributed random numbers using the Box-Muller transform.\n*\n* @param r [out] random number array\n* @param n [in] data number\n* @param mean [in] gauss mean\n* @param sd [in] gauss standard deviation\n* @param rseed [in] seed number, get rid of the first rseed random numbers\n*/\nvoid RandomGauss_(double *r, int n, double mean, double sd, int rseed)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string filenameBaseExt(const std::string& filename) {\n    int i = filename.rfind(\"/\");\n    int j = filename.rfind(\"\\\\\");\n\n    if ((j > i) && (j >= 0)) {\n        i = j;\n    }\n\n#   ifdef G3D_WIN32\n        j = filename.rfind(\":\");\n        if ((i == -1) && (j >= 0)) {\n            i = j;\n        }\n#   endif\n\n    if (i == -1) {\n        return filename;\n    } else {\n        return filename.substr(i + 1, filename.length() - i);\n    }\n}\n",
        "answer": "/**\n* @brief Returns the part of the filename that includes the base and ext from parseFilename (i.e. everything to the right of the path).\n*\n* This function returns the part of the filename that includes the base and extension, as determined by the `parseFilename` function. The returned string is everything to the right of the last path separator in the filename. If there are no path separators in the filename, the entire filename is returned.\n*\n* @param filename The input filename.\n* @return The part of the filename that includes the base and extension.\n*/\nstd::string filenameBaseExt(const std::string& filename) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void checkFontBitmapSize(const FT_Bitmap &bits)\n{\n\tif ((s32)bits.rows < 0 || (s32)bits.width < 0) {\n\t\tstd::cout << \"Insane font glyph size. File: \"\n\t\t          << __FILE__ << \" Line \" << __LINE__\n\t\t          << std::endl;\n\t\tabort();\n\t}\n}\n",
        "answer": "/** @brief Checks the size of a font bitmap.\n*\n*  This function checks that no dimension of the FT_BitMap object is negative. If either is negative, abort execution.\n*\n* @param bits The FT_Bitmap object to check.\n* @return void\n*/\nvoid checkFontBitmapSize(const FT_Bitmap &bits)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void vm_openlibs (lua_State *L) {\n\tstatic const luaL_Reg lualibs[] = {\n\t\t{ \"base\", \t\t\tluaopen_base \t},\n\t\t{ LUA_LOADLIBNAME, \tluaopen_package },\n\t\t{ LUA_TABLIBNAME, \tluaopen_table \t},\n\t\t{ LUA_MATHLIBNAME, \tluaopen_math \t},\n\t\t{ LUA_STRLIBNAME, \tluaopen_string\t},\n\t\t{ NULL, \t\t\tNULL \t\t\t}\n\t};\n\n\tconst luaL_Reg *lib;\n\tfor (lib = lualibs; lib->func; lib++) {\n\t\tluaL_requiref(L, lib->name, lib->func, 1);\n\t\tlua_pop(L, 1); /* remove lib */\n\t}\n}\n",
        "answer": "/** @brief Initialize the virtual machine with essential libraries.\n*\n* This function initializes the virtual machine by loading essential libraries such as base, package, table, math, and string.\n*\n* @param L The Lua state.\n*/\nvoid vm_openlibs (lua_State *L) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC int SDLCALL SDL_EnableUNICODE(int enable)\n{\n    return 0;\n}\n",
        "answer": "/** @brief Enable/Disable UNICODE translation of keyboard input.\n*\n* This function enables or disables the UNICODE translation of keyboard input. The translation has some overhead, so it defaults off.\n*\n* @param enable A boolean value indicating whether to enable (true) or disable (false) the UNICODE translation.\n*\n* @return 0 if successful, -1 on error.\n*/\nextern DECLSPEC int SDLCALL SDL_EnableUNICODE(int enable);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC int SDLCALL SDL_JoystickNumBalls(SDL_Joystick *joystick)\n{\n    return 0;\n}\n",
        "answer": "/** @brief Get the number of trackballs on a joystick.\n*\n* This function returns the number of trackballs on a joystick.\n* Trackballs have only relative motion events associated with them and their state cannot be polled.\n*\n* @param [in] joystick A pointer to the SDL_Joystick structure for the joystick to query.\n* @return The number of trackballs on the joystick, or 0 if there are no trackballs.\n*/\nextern DECLSPEC int SDLCALL SDL_JoystickNumBalls(SDL_Joystick *joystick)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC SDL_GrabMode SDLCALL SDL_WM_GrabInput(SDL_GrabMode mode)\n{\n    return SDL_GRAB_ON;\n}\n",
        "answer": "/** @brief Sets and queries the input grab state of the application.\n*\n*  This function allows you to set and query the input grab state of the application. It returns the new input grab state. Grabbing means that the mouse is confined to the application window, and nearly all keyboard input is passed directly to the application, and not interpreted by a window manager, if any.\n*\n* @param mode The new input grab mode.\n* @return The new input grab state.\n*/\nextern DECLSPEC SDL_GrabMode SDLCALL SDL_WM_GrabInput(SDL_GrabMode mode)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags)\n{\n    return 0;\n}\n",
        "answer": "/** @brief Loads the SDL dynamically linked library and initializes the subsystems specified by 'flags' (and those satisfying dependencies).\n*\n* Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup signal handlers for some commonly ignored fatal signals (like SIGSEGV)\n*\n* @param flags The bitwise OR of the subsystem initialization flags.\n* @return 0 on success or a negative error code on failure.\n*/\nextern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void gcode_M205() {\n  if (code_seen('S')) minimumfeedrate = code_value();\n  if (code_seen('T')) mintravelfeedrate = code_value();\n  if (code_seen('B')) minsegmenttime = code_value();\n  if (code_seen('X')) max_xy_jerk = code_value();\n  if (code_seen('Z')) max_z_jerk = code_value();\n  if (code_seen('E')) max_e_jerk = code_value();\n}\n",
        "answer": "/** @brief Set Advanced Settings.\n*\n*  This function sets the advanced settings for the machine.\n*\n* @param S Minimum feed rate (mm/s)\n* @param T Minimum travel feed rate (mm/s)\n* @param B Minimum segment time (s)\n* @param X Maximum XY jerk (mm/s/s)\n* @param Z Maximum Z jerk (mm/s/s)\n* @param E Maximum E jerk (mm/s/s)\n*/\ninline void gcode_M205() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool FileStream_SetCallback(TFileStream * pStream, SFILE_DOWNLOAD_CALLBACK pfnCallback, void * pvUserData)\n{\n    TBlockStream * pBlockStream = (TBlockStream *)pStream;\n\n    if(pStream->BlockRead == NULL)\n    {\n        SetLastError(ERROR_NOT_SUPPORTED);\n        return false;\n    }\n\n    pBlockStream->pfnCallback = pfnCallback;\n    pBlockStream->UserData = pvUserData;\n    return true;\n}\n",
        "answer": "/** @brief Sets a download callback for the file stream.\n*\n*  This function sets a download callback for the file stream. Whenever the stream needs to download one or more blocks from the server, the callback is called.\n*\n* @param pStream The file stream object.\n* @param pfnCallback The download callback function.\n* @param pvUserData User-defined data that will be passed to the callback function.\n*\n* @return true if the callback was set successfully, false otherwise.\n*/\nbool FileStream_SetCallback(TFileStream * pStream, SFILE_DOWNLOAD_CALLBACK pfnCallback, void * pvUserData)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SetGlobalFilter(const Filter& filter) {\n    Impl::Instance().SetGlobalFilter(filter);\n}\n",
        "answer": "/** @brief Sets the global filter for all backends.\n*\n*  This function sets the global filter for all backends, which will prevent any messages from being processed if they are filtered. Each backend can have its own filter, but if the level is lower than the global filter, the backend will never get the message.\n*\n* @param[in] filter The filter to be set as the global filter.\n*/\nvoid SetGlobalFilter(const Filter& filter) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void partition_info(const string &name,const string &value,const string &attribute)\n{\n\n    if(name.find(\" \")<0) err(1,\"partition_info(%s) has a space in it\",cstr(name));\n    if(a) a->add_comment(name + \": \" + value);\n    if(t && !opt_body_file) fputs(cstr(name + \": \" + value + \"\\n\"),t);\n    if(x) x->xmlout(name,value,attribute,true);\n}\n",
        "answer": "/**\n* @brief Output a name/format/value for the current partition.\n*\n* This information is simply printed as comments for ARFF files.\n*\n* @param[in] name The name of the partition.\n* @param[in] value The format of the partition.\n* @param[in] attribute The value of the partition.\n*/\nvoid partition_info(const string &name, const string &value, const string &attribute) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string imageType(const void *data, std::size_t size\n                      , const boost::filesystem::path &path)\n{\n    if (size < 1) {\n        LOGTHROW(err1, Error)\n            << \"Cannot determine type of image in file \" << path\n            << \": Too little data.\";\n    }\n    return imageType(*static_cast<const unsigned char*>(data), path);\n}\n",
        "answer": "/**\n* @brief Detects the type of image from a generic stream.\n*\n* This function detects the type of image from a generic stream by reading the first byte of data and\n* comparing it to the known file signatures for various image formats. If the format is not recognized,\n* an error is thrown.\n*\n* @param data A pointer to the start of the image data.\n* @param size The number of bytes in the image data.\n* @param path The path to the image file.\n*\n* @return The common file extension for the detected image type (e.g., \".jpg\", \".png\", etc.).\n*/\nstd::string imageType(const void *data, std::size_t size, const boost::filesystem::path &path) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void\t\tperf_end(perf_counter_t handle)\n{\n\n}\n",
        "answer": "/** @brief End a performance event.\n*\n*  This call applies to counters that operate over ranges of time; PC_ELAPSED etc. If a call is made without a corresponding perf_begin call, or if perf_cancel has been called subsequently, no change is made to the counter.\n*\n* @param handle The handle of the performance counter to end.\n* @return None.\n*/\nvoid perf_end(perf_counter_t handle)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int\torb_publish(const struct orb_metadata *meta, orb_advert_t handle, const void *data)\n{\n\treturn 0;\n}\n",
        "answer": "/** @brief Publish new data to a topic.\n*\n* This function publishes new data to a topic and notifies any waiting subscribers. Subscribers that are not waiting can check the topic for updates using orb_check and/or orb_stat.\n*\n* @param meta The metadata of the topic being published to.\n* @param handle The advertisement handle of the topic being published to.\n* @param data The new data to be published.\n*\n* @return 0 on success, -1 on failure.\n*/\nint\torb_publish(const struct orb_metadata *meta, orb_advert_t handle, const void *data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hal_aci_tl_debug_print(bool enable)\n{\n    aci_debug_print = enable;\n}\n",
        "answer": "/** @brief HAL ACI TL Debug Print.\n*\n*  This function enables or disables the debug printing on the Serial.\n*\n* @param[in] enable Boolean value to indicate whether to enable or disable the debug printing.\n*\n* @return None.\n*/\nvoid hal_aci_tl_debug_print(bool enable)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int parseInput(const string& s)\n{\n\tsize_t l = s.find('$');\n\tif (l == string::npos)\n\t\treturn -1;\n\tstring remainder = s.substr(l+1);\n\n\tint ret = -1;\n\tistringstream ss(remainder);\n\tss >> ret;\n\treturn ss ? ret : -1;\n}\n",
        "answer": "/** @brief Parses strings like \"$x\". It first throws away any characters before the $ sign. Then it attempts to read an int, and returns. On failure, -1 is returned.\n*\n*  This function parses strings like \"$x\". It first throws away any characters before the $ sign. Then it attempts to read an int, and returns. On failure, -1 is returned.\n*\n* @param s The string to parse.\n* @return The parsed integer or -1 on failure.\n*/\nint parseInput(const string& s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long MGL_EXPORT mgl_use_graph(HMGL gr, int inc)\r\n{\tif(!gr)\treturn 0;\tgr->InUse+=inc;\treturn gr->InUse;\t}\r\n",
        "answer": "/** @brief Increments the counter of HMGL uses (for advanced users only). Non-zero counter prevent automatic object removing.\n*\n*  This function increments the counter of HMGL uses, which is used to track the number of times an HMGL graph is being used. If the counter is non-zero, it means that the graph is in use and should not be automatically removed.\n*\n* @param gr The HMGL graph to increment the counter for.\n* @param inc The amount to increment the counter by.\n* @return The new value of the counter.\n*/\nlong MGL_EXPORT mgl_use_graph(HMGL gr, int inc)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_contf_xy(HMGL gr, HCDT x, HCDT y, HCDT z, const char *sch, const char *opt)\r\n{\r\n\tmreal r = gr->SaveState(opt);\r\n\tlong Num = mgl_isnan(r)?7:long(r+0.5);\r\n\tif(Num<1)\t{\tgr->SetWarn(mglWarnCnt,\"Cont\");\treturn;\t}\r\n\tmglDataV v(Num+2);\tv.Fill(gr->Min.c, gr->Max.c);\r\n\tmgl_contf_xy_val(gr,&v,x,y,z,sch,0);\r\n}\r\n",
        "answer": "/** @brief Draw contours at bottom of axis box.\n*\n*  This function draws contours at the bottom of the axis box.\n*  Option \"value\" sets the number of contour levels (default is 7).\n*\n* @param[in] gr: HMGL object.\n* @param[in] x: HCDT object containing X coordinates.\n* @param[in] y: HCDT object containing Y coordinates.\n* @param[in] z: HCDT object containing Z coordinates.\n* @param[in] sch: String containing the contour style.\n* @param[in] opt: String containing the option value.\n*\n* @return void\n*/\nvoid MGL_EXPORT mgl_contf_xy(HMGL gr, HCDT x, HCDT y, HCDT z, const char *sch, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_contv(HMGL gr, HCDT z, const char *sch, const char *opt)\r\n{\r\n\tmreal r = gr->SaveState(opt);\r\n\tlong Num = mgl_isnan(r)?7:long(r+0.5);\r\n\tif(Num<1)\t{\tgr->SetWarn(mglWarnCnt,\"Cont\");\treturn;\t}\r\n\tmglData v(Num);\r\n\tfor(long i=0;i<Num;i++)\tv.a[i] = gr->Min.c + (gr->Max.c-gr->Min.c)*mreal(i+1)/(Num+1);\r\n\tmgl_contv_val(gr,&v,z,sch,0);\r\n}\r\n",
        "answer": "/** @brief MGL_EXPORT mgl_contv.\n*\n*  This function creates a doxygen comment for the C++ function mgl_contv.\n*\n* @param gr The HMGL object.\n* @param z The HCDT object.\n* @param sch The contour scheme.\n* @param opt The options string.\n*\n* @return Should not return.\n*/\nvoid MGL_EXPORT mgl_contv(HMGL gr, HCDT z, const char *sch, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_dens3(HMGL gr, HCDT a, const char *sch, double sVal, const char *opt)\r\n{\r\n\tgr->SaveState(opt);\r\n\tmglDataV x(a->GetNx()), y(a->GetNy()),z(a->GetNz());\r\n\tx.Fill(gr->Min.x,gr->Max.x);\r\n\ty.Fill(gr->Min.y,gr->Max.y);\r\n\tz.Fill(gr->Min.z,gr->Max.z);\r\n\tmgl_dens3_xyz(gr,&x,&y,&z,a,sch,sVal,0);\r\n}\r\n",
        "answer": "/** @brief MGL_EXPORT mgl_dens3.\n*\n*  This function is used to create a density plot of a 3D data grid.\n*\n* @param gr The graph object.\n* @param a The data grid.\n* @param sch The style for the plot.\n* @param sVal The value of the parameter.\n* @param opt The options for the plot.\n*\n* @return void\n*/\nvoid MGL_EXPORT mgl_dens3(HMGL gr, HCDT a, const char *sch, double sVal, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_tricont_xyzcv(HMGL gr, HCDT v, HCDT nums, HCDT x, HCDT y, HCDT z, HCDT a, const char *sch, const char *opt)\r\n{\r\n\tmglDataV zz(x->GetNN());\r\n\tif(!z)\tz = &zz;\r\n\tif(mgl_check_trig(gr,nums,x,y,z,a,\"TriCont\"))\treturn;\r\n\r\n\tgr->SaveState(opt);\r\n\tstatic int cgid=1;\tgr->StartGroup(\"TriCont\",cgid++);\r\n\tint text=0;\r\n\tif(mglchr(sch,'t'))\ttext=1;\r\n\tif(mglchr(sch,'T'))\ttext=2;\r\n\tbool fixed=(mglchr(sch,'_')) || (gr->Min.z==gr->Max.z);\r\n\tlong s=gr->AddTexture(sch);\r\n\tgr->SetPenPal(sch);\r\n\r\n\tfor(long k=0;k<v->GetNx();k++)\r\n\t{\r\n\t\tmreal v0 = v->v(k);\t\tzz.Fill(fixed ? gr->Min.z : v0);\r\n\t\tmgl_draw_curvs(gr,v0,gr->GetC(s,v0),text,mgl_get_curvs(gr,mgl_tri_lines(v0,nums,a,x,y,fixed?&zz:z)));\r\n\t}\r\n}\r\n",
        "answer": "/** @brief Draw contours on triangular mesh.\n*\n* This function draws contours on a triangular mesh defined by the vertices in v, the triangle numbers in nums, and the x, y, and z coordinates of the vertices. The colors of the contours are determined by the values in a. The style of the contour labels is specified by sch, and the optional parameters are specified by opt.\n*\n* @param gr Handle to the MGL graph object.\n* @param v Handle to the data array containing the vertex coordinates.\n* @param nums Handle to the data array containing the triangle numbers.\n* @param x Handle to the data array containing the x coordinates of the vertices.\n* @param y Handle to the data array containing the y coordinates of the vertices.\n* @param z Handle to the data array containing the z coordinates of the vertices.\n* @param a Handle to the data array containing the values used to determine the colors of the contours.\n* @param sch String specifying the style of the contour labels.\n* @param opt String specifying the optional parameters.\n*\n* @return None.\n*/\nvoid MGL_EXPORT mgl_tricont_xyzcv(HMGL gr, HCDT v, HCDT nums, HCDT x, HCDT y, HCDT z, HCDT a, const char *sch, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_tricontv_xyc(HMGL gr, HCDT nums, HCDT x, HCDT y, HCDT z, const char *sch, const char *opt)\r\n{\tmgl_tricontv_xyzc(gr,nums,x,y,0,z,sch,opt);\t}\r\n",
        "answer": "/** @brief MGL_EXPORT mgl_tricontv_xyc.\n*\n*  This function is used to create a tricontour plot of the data in nums, x, y, and z with the given scheme and options.\n*  If id.ny=c.nx then c sets the quadrangle colors, else vertex colors. Option \"value\" set the number of contour levels (default is 7).\n*\n* @param gr The handle to the graph object.\n* @param nums The data to be plotted.\n* @param x The x-coordinates of the data points.\n* @param y The y-coordinates of the data points.\n* @param z The z-coordinates of the data points.\n* @param sch The scheme used for the contour plot.\n* @param opt The options used for the contour plot.\n* @return void\n*/\nvoid MGL_EXPORT mgl_tricontv_xyc(HMGL gr, HCDT nums, HCDT x, HCDT y, HCDT z, const char *sch, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void iupdrvFontGetCharSize(Ihandle* ih, int *charwidth, int *charheight)\n{\n  BFont* befont = beFontGet(ih);\n  if(!befont)\n  {\n    if (charwidth)  *charwidth = 0;\n    if (charheight) *charheight = 0;\n    return;\n  }\n\n  if (charheight) {\n    *charheight = beFontHeight(befont);\n  }\n\n  if (charwidth) {\n    *charwidth = (int)befont->StringWidth(\"M\");\n  }\n}\n",
        "answer": "/** @brief Retrieves the character size for the selected font. Should be used only to calculate the SIZE attribute.\n*\n* This function retrieves the character size for the selected font, which should be used only to calculate the SIZE attribute.\n*\n* @param ih The IUP handle of the element that is using the font.\n* @param charwidth A pointer to an integer that will receive the width of a character in pixels.\n* @param charheight A pointer to an integer that will receive the height of a character in pixels.\n*/\n*charheight = beFontHeight(befont);\n*charwidth = (int)befont->StringWidth(\"M\");\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int MGL_EXPORT mgl_parser_cmd_type(HMPR pr, const char *name)\n{\n\tconst mglCommand *cmd = pr->FindCommand(name);\n\treturn cmd ? cmd->type + 1 : 0;\n}\n",
        "answer": "/** @brief Determines the type of a command.\n*\n* This function takes a pointer to an MGL parser object and a string representing the name of a command, and returns an integer indicating the type of the command. If the command is not found, 0 is returned.\n*\n* @param pr A pointer to an MGL parser object.\n* @param name The name of the command.\n*\n* @return An integer representing the type of the command.\n*/\nint MGL_EXPORT mgl_parser_cmd_type(HMPR pr, const char *name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HADT MGL_EXPORT mgl_qo3d_solve_c(const char *ham, HCDT ini_re, HCDT ini_im, HCDT ray_dat, mreal r, mreal k0, HMDT xx, HMDT yy, HMDT zz)\r\n{\r\n\tmglFormula h(ham);\r\n\treturn mgl_qo3d_func_c(mgl_ham3d, &h, ini_re, ini_im, ray_dat, r, k0, xx, yy, zz);\r\n}\r\n",
        "answer": "/** @brief Solves the partial differential equation (PDE) for a given Hamiltonian with initial conditions along a curve.\n*\n*  This function saves the result of PDE solving for a given Hamiltonian \"ham\" with initial conditions \"ini_re\" and \"ini_im\" along a curve \"ray_dat\". The curve is defined by the points in \"xx\", \"yy\", and \"zz\", and the radius \"r\" and wave number \"k0\".\n*\n* @param ham The Hamiltonian for which to solve the PDE.\n* @param ini_re The real part of the initial conditions for the PDE.\n* @param ini_im The imaginary part of the initial conditions for the PDE.\n* @param ray_dat The curve along which to solve the PDE, defined by the points in \"xx\", \"yy\", and \"zz\".\n* @param r The radius of the curve.\n* @param k0 The wave number of the curve.\n* @param xx The x-coordinates of the points on the curve.\n* @param yy The y-coordinates of the points on the curve.\n* @param zz The z-coordinates of the points on the curve.\n* @return The solution to the PDE for the given Hamiltonian and initial conditions along the curve.\n*/\nHADT MGL_EXPORT mgl_qo3d_solve_c(const char *ham, HCDT ini_re, HCDT ini_im, HCDT ray_dat, mreal r, mreal k0, HMDT xx, HMDT yy, HMDT zz)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_ohlc(HMGL gr, HCDT open, HCDT high, HCDT low, HCDT close, const char *pen, const char *opt)\r\n{\r\n\tgr->SaveState(opt);\r\n\tmglDataV x(open->GetNx()+1);\tx.Fill(gr->Min.x,gr->Max.x);\r\n\tmgl_ohlc_x(gr,&x,open,high,low,close,pen,0);\r\n}\r\n",
        "answer": "/** @brief MGL_EXPORT mgl_ohlc.\n*\n*  This function is used to create an OHLC chart.\n*  It takes in HMGL gr, HCDT open, HCDT high, HCDT low, HCDT close, const char *pen, and const char *opt as parameters.\n*  The function creates an OHLC chart using the given data and options.\n*\n* @param[in] gr: HMGL gr is used to create the chart.\n* @param[in] open: HCDT open is used to get the open values for the chart.\n* @param[in] high: HCDT high is used to get the high values for the chart.\n* @param[in] low: HCDT low is used to get the low values for the chart.\n* @param[in] close: HCDT close is used to get the close values for the chart.\n* @param[in] pen: const char *pen is used to specify the color of the chart.\n* @param[in] opt: const char *opt is used to specify the options for the chart.\n* @return void\n*/\nvoid MGL_EXPORT mgl_ohlc(HMGL gr, HCDT open, HCDT high, HCDT low, HCDT close, const char *pen, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MGL_EXPORT mgl_surf3a(HMGL gr, HCDT a, HCDT b, const char *sch, const char *opt)\r\n{\r\n\tgr->SaveState(opt);\r\n\tmglDataV x(a->GetNx()), y(a->GetNy()),z(a->GetNz());\r\n\tx.Fill(gr->Min.x,gr->Max.x);\r\n\ty.Fill(gr->Min.y,gr->Max.y);\r\n\tz.Fill(gr->Min.z,gr->Max.z);\r\n\tmgl_surf3a_xyz(gr,&x,&y,&z,a,b,sch,0);\r\n}\r\n",
        "answer": "/** @brief MGL_EXPORT mgl_surf3a.\n*\n*  This function is used to create a wired plot of the surface defined by the arrays a and b.\n*  The style of the plot can be set using the \"sch\" parameter, which can take on the following values:\n*  - \"value\": Produce a plot by dots. Option \"value\" sets the number of isosurfaces (default is 3).\n*\n* @param gr HMGL object that represents the graphics state.\n* @param a HCDT array that contains the x-coordinates of the surface.\n* @param b HCDT array that contains the y-coordinates of the surface.\n* @param sch const char * that specifies the style of the plot.\n* @param opt const char * that specifies additional options for the plot.\n* @return void\n*/\nvoid MGL_EXPORT mgl_surf3a(HMGL gr, HCDT a, HCDT b, const char *sch, const char *opt)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int bitcoreconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n                                   const unsigned char *txTo        , unsigned int txToLen,\n                                   unsigned int nIn, unsigned int flags, bitcoreconsensus_error* err)\n{\n    if (flags & bitcoreconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n        return set_error(err, bitcoreconsensus_ERR_AMOUNT_REQUIRED);\n    }\n\n    CAmount am(0);\n    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, nIn, flags, err);\n}\n",
        "answer": "/** @brief Verifies a transaction input against a previous transaction output.\n*\n*  This function checks that the scriptPubKey of the previous transaction output is satisfied by the scriptSig of the current transaction input.\n*  It also validates that the transaction input satisfies any additional constraints specified by flags.\n*\n* @param[in] scriptPubKey The scriptPubKey of the previous transaction output.\n* @param[in] scriptPubKeyLen The length of the scriptPubKey in bytes.\n* @param[in] txTo The current transaction input.\n* @param[in] txToLen The length of the current transaction input in bytes.\n* @param[in] nIn The index of the current transaction input in the transaction.\n* @param[in] flags Additional constraints to verify, as specified by bitcoreconsensus_SCRIPT_FLAGS.\n* @param[out] err Error code if verification fails.\n* @return 1 if the input nIn of the serialized transaction pointed to by txTo correctly spends the scriptPubKey pointed to by scriptPubKey under the additional constraints specified by flags. If not nullptr, err will contain an error/success code for the operation.\n*/\nint bitcoreconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Run ( ThreadInfo& ) {\n        if ( UseAutoPartitioner() )\n            tbb::parallel_for( range_t(0, IterRange, IterGrain), Body(), my_autoPartitioner );\n        else\n            tbb::parallel_for( range_t(0, IterRange, IterGrain), Body(), my_simplePartitioner );\n    }\n",
        "answer": "/** @brief Runs the kernel with the specified thread information.\n*\n*  This function is called by the timing framework several times in a loop to achieve approximately RunDuration time, and this loop is timed NumRuns times to collect statistics. Argument ti specifies information about the master thread calling this method.\n*\n* @param [in] ti The thread information for the master thread calling this function.\n* @return void\n*/\nvoid Run ( ThreadInfo& ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void Run ( ThreadInfo& ) {\n        RunShallowTree<SimpleLeafTask>();\n    }\n",
        "answer": "/** @brief Runs the shallow tree with a simple leaf task.\n*\n*  This function runs the shallow tree with a simple leaf task. It is called by the timing framework several times in a loop to achieve approx. RunDuration time, and this loop is timed NumRuns times to collect statistics. Argument ti specifies information about the master thread calling this method.\n*\n* @param [in] ti Information about the master thread calling this method.\n* @return Should not return\n*/\nvoid Run ( ThreadInfo& ti ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "__TBB_PERF_API void WipeCaches () { NativeParallelFor( NumCpus, internal::WiperBody() ); }\n",
        "answer": "/** @brief Clean caches to obtain reproducible results when a test accesses significant ranges of memory.\n*\n* This function is used to clean the caches and ensure that the results are reproducible when a test accesses significant ranges of memory.\n* It uses the NativeParallelFor function to perform the cleaning in parallel across all CPUs.\n*\n* @param NumCpus The number of CPUs to use for the cleaning process.\n* @return Should not return\n*/\nvoid WipeCaches() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain () {\n    return Harness::Skipped;\n}\n",
        "answer": "/** @brief Create a doxygen comment for the following C++ Function.\n*\n* This is the description of the functionality of the function.\n* It MUST be defined by the test application. If min and max thread numbers specified on the command line are different, the test is run only for 2 sizes of the thread pool (MinThread and MaxThread) to be able to test the high and low contention modes while keeping the test reasonably fast\n*\n* @return Should not return\n*/\nvoid kernel_entrypoint() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain () {\n#ifdef _PGO_INSTRUMENT\n    REPORT(\"Known issue: test_malloc_atexit hangs if compiled with -prof-genx\\n\");\n    return Harness::Skipped;\n#elif __TBB_MIC_OFFLOAD\n    REPORT(\"Known issue: libmalloc_proxy.so is loaded too late in the offload mode on the target when linked via -lmalloc_proxy\\n\");\n    return Harness::Skipped;\n#else\n    ASSERT( dll_isMallocOverloaded(), \"malloc was not replaced\" );\n    ASSERT( exe_isMallocOverloaded(), \"malloc was not replaced\" );\n    return Harness::Done;\n#endif\n}\n",
        "answer": "/**\n* @brief The entry point for the test.\n*\n* This function is the entry point for the test. It checks if the malloc\n* has been overloaded and returns an appropriate value based on the result.\n*\n* @return Harness::Done if the malloc was overloaded, Harness::Skipped if not.\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    uniform_iterations_distribution::test<ParallelBody>();\n    return Harness::Done;\n}\n",
        "answer": "/** @brief Test entrypoint for the ParallelBody class.\n*\n*  This function is used to test and debug the ParallelBody class. It runs a series of tests using the uniform_iterations_distribution class, which is used to generate random inputs for the parallel body. If min and max thread numbers specified on the command line are different, the test is run only for 2 sizes of the thread pool (MinThread and MaxThread) to be able to test the high and low contention modes while keeping the test reasonably fast\n*\n* @return Harness::Done if the test completes successfully, otherwise an error code.\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() { \n    tbb::tick_count start = tbb::tick_count::now(), stop;\n    for (int p = 2; p <= 4; ++p) {\n        tbb::task_scheduler_init init(p);\n        test_serial<int>();\n        test_parallel<int>(p);\n    } \n#if TBB_PREVIEW_FLOW_GRAPH_FEATURES\n    test_buffer_extract<tbb::flow::sequencer_node<int> >().run_tests();\n#endif\n    stop = tbb::tick_count::now();\n    REMARK(\"Sequencer_Node Time=%6.6f\\n\", (stop-start).seconds());\n    return Harness::Done;\n}\n",
        "answer": "/** @brief Test entrypoint.\n*\n*  This is the entrypoint for your test application.\n*  It initializes the task scheduler with the specified number of threads, runs the tests for serial and parallel execution, and prints the time taken to execute the sequencer node tests.\n*\n* @param p The number of threads to use in the task scheduler.\n* @return Should not return.\n*/\nint TestMain(int p) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain () {\n    TestTaskAssertions();\n    return Harness::Done;\n}\n",
        "answer": "/** @brief TestMain entrypoint.\n*\n*  This is the entrypoint for your test application.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nint TestMain () "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain () {\n    CheckSignatures();\n    RunTests();\n    return Harness::Done;\n}\n",
        "answer": "/** @brief Test main function.\n*\n*  This is the entrypoint for your test application.\n*  It checks the signatures of the tests and runs them.\n*\n* @return Harness::Done if all tests pass, otherwise an error code\n*/\nint TestMain () "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid defineOptions(OptionSet& options)\n\t{\n\t\tApplication::defineOptions(options);\n\n\t\toptions.addOption(\n\t\t\tOption(\"help\", \"h\", \"Display help information on command line arguments.\")\n\t\t\t\t.required(false)\n\t\t\t\t.repeatable(false)\n\t\t\t\t.callback(OptionCallback<ProcessKillerApp>(this, &ProcessKillerApp::handleHelp)));\n\n\t\toptions.addOption(\n\t\t\tOption(\"friendly\", \"f\", \"Kindly ask application to shut down.\")\n\t\t\t\t.required(false)\n\t\t\t\t.repeatable(false)\n\t\t\t\t.callback(OptionCallback<ProcessKillerApp>(this, &ProcessKillerApp::handleFriendly)));\n\t}\n",
        "answer": "/** @brief Define options for the application.\n*\n*  This function defines the command line options that are available for the application.\n*  It adds two options: \"help\" and \"friendly\". The \"help\" option displays help information on command line arguments, while the \"friendly\" option kindly asks an application to shut down.\n*\n* @param[in] options The OptionSet object that will be used to define the options for the application.\n*/\nvoid defineOptions(OptionSet& options)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void register_segfault_tracer(std::nothrow_t)\n    {\n        OldHandler = signal(SIGSEGV, [](int sig)\n        {\n            if (OldHandler) OldHandler(sig);\n            print_trace();\n        });\n    }\n",
        "answer": "/** @brief Registers a default handler for SIGSEGV that prints stack trace to stderr and then calls std::terminate.\n*\n*  This function installs a default handler for SIGSEGV which will print the stack trace to stderr and then call std::terminate.\n*\n* @param[in] nothrow_t A tag type indicating that the function should not throw any exceptions.\n*/\nvoid register_segfault_tracer(std::nothrow_t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool stripPrefix(StringSlice prefix, StringSlice& from) {\n  if (!from.startsWith(prefix)) return false;\n  from = pop_front(from, prefix.size());\n  return true;\n}\n",
        "answer": "/** @brief Strip the given prefix from a string slice.\n*\n* This function takes a string slice and removes the specified prefix if it exists. If the prefix is not found, the original string slice is left untouched.\n*\n* @param prefix The prefix to be removed.\n* @param from The string slice from which the prefix should be removed.\n* @return True if the prefix was successfully stripped, false otherwise.\n*/\nbool stripPrefix(StringSlice prefix, StringSlice& from) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Lav_PUBLIC_FUNCTION LavError Lav_createBuffer(LavHandle simulationHandle, LavHandle* destination) {\n\tPUB_BEGIN\n\tauto simulation = incomingObject<Simulation>(simulationHandle);\n\tLOCK(*simulation);\n\t*destination = outgoingObject(createBuffer(simulation));\n\tPUB_END\n}\n",
        "answer": "/** @brief Creates a buffer for audio data.\n*\n*  This function creates a buffer for audio data and returns it as an outgoing object.\n*\n* @param[in] simulationHandle Handle to the simulation that will use the buffer.\n* @param[out] destination Pointer to a handle where the created buffer will be stored.\n*\n* @return Should not return\n*/\n*destination = outgoingObject(createBuffer(simulation));\nPUB_END"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Lav_PUBLIC_FUNCTION LavError Lav_nodeGetIntPropertyRange(LavHandle nodeHandle, int slot, int* destination_lower, int* destination_upper) {\n\tPUB_BEGIN\n\tPROP_PREAMBLE(nodeHandle, slot, Lav_PROPERTYTYPE_INT);\n\t*destination_lower = prop.getIntMin();\n\t*destination_upper = prop.getIntMax();\n\tPUB_END\n}\n",
        "answer": "/** @brief Query property ranges. These are set only by internal code. Float3 and Float6 are effectively rangeless: specifically what a range is for those is very undefined and specific to the node in question.\n*\n*  This function retrieves the minimum and maximum values of an integer property on a Lav node.\n*\n* @param[in] nodeHandle Handle to the Lav node.\n* @param[in] slot The slot number of the property.\n* @param[out] destination_lower Pointer to an integer that will be set to the minimum value of the property.\n* @param[out] destination_upper Pointer to an integer that will be set to the maximum value of the property.\n* @return LavError code indicating success or failure.\n*/\n*destination_lower = prop.getIntMin();\n*destination_upper = prop.getIntMax();\nPUB_END"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double trigamma(double x)\r\n{\r\n    double p;\r\n    int i;\r\n\r\n    x = x+6;\r\n    p = 1/(x*x);\r\n    p = (((((0.075757575757576*p-0.033333333333333)*p+0.0238095238095238)*p-0.033333333333333)*p+0.166666666666667)*p+1)/x+0.5*p;\r\n    for (i=0; i<6 ;i++)\r\n    {\r\n        x = x-1;\r\n        p = 1/(x*x)+p;\r\n    }\r\n    return p;\r\n}\r\n",
        "answer": "/** @brief Calculate the value of the trigamma, the second derivative of the loggamma function. Accepts positive matrices. From Abromowitz and Stegun. Uses formulas 6.4.11 and 6.4.12 with recurrence formula 6.4.6. Each requires workspace at least 5 times the size of X.\n*\n* @param x The positive matrix to calculate the trigamma for.\n* @return The value of the trigamma function for the given matrix.\n*/\ndouble trigamma(double x)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int GetCpuThreadPoolCapacity() { return arrow::GetCpuThreadPoolCapacity(); }\n",
        "answer": "/** @brief Returns the number of worker threads in the thread pool to which Arrow dispatches various CPU-bound tasks.\n*\n* This is an ideal number, not necessarily the exact number of threads at a given point in time. You can change this number using SetCpuThreadPoolCapacity().\n*\n* @return The number of worker threads in the thread pool.\n*/\nint GetCpuThreadPoolCapacity() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned int getBookmarkAddress(unsigned int index)\r\n{\r\n\tif (index < bookmarks_addr.size())\r\n\t\treturn bookmarks_addr[index];\r\n\telse\r\n\t\treturn 0;\r\n}\r\n",
        "answer": "/** @brief Returns the bookmark address of a CPU bookmark identified by its index.\n*\n* This function returns the bookmark address of a CPU bookmark identified by its index. The caller must make sure that the index is valid.\n*\n* @param index The index of the bookmark to retrieve.\n* @return The bookmark address if the index is valid, 0 otherwise.\n*/\nunsigned int getBookmarkAddress(unsigned int index)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "u8 RecipEstimate(u64 a) {\n    using LUT = std::array<u8, 256>;\n    static constexpr u64 lut_offset = 256;\n\n    static const LUT lut = [] {\n        LUT result{};\n        for (u64 i = 0; i < result.size(); i++) {\n            u64 a = i + lut_offset;\n\n            a = a * 2 + 1;\n            u64 b = (1u << 19) / a;\n            result[i] = static_cast<u8>((b + 1) / 2);\n        }\n        return result;\n    }();\n\n    return lut[a - lut_offset];\n}\n",
        "answer": "/**\n* @brief Reciprocal estimate of a u64 number.\n*\n* This function estimates the reciprocal of a u64 number using a lookup table and\n* a simple formula. The input value must be in the range [0.5, 1.0), and the output\n* value is a u8 fixed point number with an implied 1 prefixed, i.e., it represents\n* a value in the range [1.0, 2.0).\n*\n* @param a The input value to estimate the reciprocal of.\n* @return The estimated reciprocal of the input value.\n*/\nu8 RecipEstimate(u64 a) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    string serialize(TreeNode *root) {\n        string ans = \"\";\n        if(!root) return ans;\n        queue<TreeNode*> que;\n        que.push(root);\n        while(!que.empty()) {\n            int len = que.size();\n            for(int i=0; i<len; i++) {\n                TreeNode* tmp = que.front();\n                que.pop();\n                if(!tmp) {\n                    ans+=ans.empty()?\"#\":\",#\";\n                } else {\n                    ans+=ans.empty()?to_string(tmp->val):(','+to_string(tmp->val));\n                    que.push(tmp->left);\n                    que.push(tmp->right);\n                }\n            }\n        }\n        return ans;\n    }\n",
        "answer": "/**\n* @brief Serialize a binary tree to a string.\n*\n* This method will be invoked first, you should design your own algorithm to serialize a binary tree which denote by a root node to a string which can be easily deserialized by your own \"deserialize\" method later.\n*\n* @param root The root node of the binary tree.\n* @return A string representing the serialized binary tree.\n*/\nstring serialize(TreeNode *root) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void EVENT_USB_Device_Connect(void)\n{\n\t/* Indicate USB enumerating */\n\tusb_int_state = USB_ENUM;\n\n\t/* Reset the MSReset flag upon connection */\n\tIsMassStoreReset = false;\n}\n",
        "answer": "/** @brief Event handler for the USB_Connect event.\n*\n*  This function is called when the device is enumerating via the status LEDs.\n*\n* @return Should not return\n*/\n/* Indicate USB enumerating */\n/* Reset the MSReset flag upon connection */\nIsMassStoreReset = false;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void widget_value_int(char * value, uint8_t x, uint8_t y, uint8_t w, uint8_t h)\n{\n\tdisp.LoadFont(F_VALUES_XL);\n\tuint8_t text_w = disp.GetTextWidth(value);\n\tuint8_t text_h = disp.GetTextHeight();\n\n\tif (w < text_w || h < text_h)\n\t{\n\t\tdisp.LoadFont(F_VALUES_L);\n\t\ttext_w = disp.GetTextWidth(value);\n\t\ttext_h = disp.GetTextHeight();\n\t\tif (w < text_w || h < text_h)\n\t\t{\n\t\t\tdisp.LoadFont(F_VALUES_M);\n\t\t\ttext_w = disp.GetTextWidth(value);\n\t\t\ttext_h = disp.GetTextHeight();\n\t\t\tif (w < text_w || h < text_h)\n\t\t\t{\n\t\t\t\tdisp.LoadFont(F_VALUES_S);\n\t\t\t\ttext_w = disp.GetTextWidth(value);\n\t\t\t\ttext_h = disp.GetTextHeight();\n\t\t\t\tif (w < text_w || h < text_h)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tdisp.GotoXY(x + w / 2 - text_w / 2, y + h / 2 - text_h / 2);\n\tfprintf_P(lcd_out, PSTR(\"%s\"), value);\n}\n",
        "answer": "/** @brief Prints the text (containing digits) into the given box. Values are printed in a bigger font and with a limited character set: Available characters: 042 2A = * 043 2B = + 044 2C = , 045 2D = - 046 2E = . 047 2F = / 048 30 = 0 049 31 = 1 050 32 = 2 051 33 = 3 052 34 = 4 053 35 = 5 054 36 = 6 055 37 = 7 056 38 = 8 057 39 = 9\n* @param value The text to be printed.\n* @param x The x coordinate of the top-left corner of the box.\n* @param y The y coordinate of the top-left corner of the box.\n* @param w The width of the box.\n* @param h The height of the box.\n*/\nvoid widget_value_int(char * value, uint8_t x, uint8_t y, uint8_t w, uint8_t h)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SimTK::Vector calcCentralDifference(const SimTK::Vector& x, \n        const SimTK::Vector& y,                                          \n        bool extrap_endpoints){\n\n\n    SimTK::Vector dy(x.size());\n    double dx1,dx2;\n    double dy1,dy2;\n    int size = x.size();\n    for(int i=1; i<x.size()-1; i++){\n        dx1 = x(i)-x(i-1);\n        dx2 = x(i+1)-x(i);\n        dy1 = y(i)-y(i-1);\n        dy2 = y(i+1)-y(i);\n        dy(i)= 0.5*dy1/dx1 + 0.5*dy2/dx2;\n    }\n\n    if(extrap_endpoints == true){\n        dy1 = dy(2)-dy(1);\n        dx1 = x(2)-x(1);\n        dy(0) = dy(1) + (dy1/dx1)*(x(0)-x(1));\n\n        dy2 = dy(size-2)-dy(size-3);\n        dx2 = x(size-2)-x(size-3);\n        dy(size-1) = dy(size-2) + (dy2/dx2)*(x(size-1)-x(size-2));\n    }\n    return dy;\n}\n",
        "answer": "/**\n* @brief Calculates the central difference of two vectors using SimTK::Vector.\n*\n* This function computes a standard central difference dy/dx. If extrap_endpoints is set to 1, then the derivative at the end points is estimated by linearly extrapolating the dy/dx values beside the end points.\n*\n* @param x The vector of independent variables.\n* @param y The vector of dependent variables.\n* @param extrap_endpoints A boolean indicating whether to extrapolate the derivative at the end points.\n* @return The central difference vector dy/dx.\n*/\nSimTK::Vector calcCentralDifference(const SimTK::Vector& x, const SimTK::Vector& y, bool extrap_endpoints);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void printMatrixToFile( const SimTK::Matrix& data, string filename)\n{\n    ofstream datafile;\n    datafile.open(filename.c_str());\n\n    for(int i = 0; i < data.nrow(); i++){\n        for(int j = 0; j < data.ncol(); j++){\n            if(j<data.ncol()-1)\n                datafile << data(i,j) << \",\";\n            else\n                datafile << data(i,j) << \"\\n\";\n        }   \n    }\n    datafile.close();\n}\n",
        "answer": "/** @brief Print a matrix to a file in CSV format.\n*\n*  This function takes a SimTK::Matrix and a filename as input, and prints the matrix to a file in CSV (Comma Separated Values) format. The resulting file will have each element of the matrix separated by commas, with each row on a new line.\n*\n* @param[in] data The SimTK::Matrix to be printed.\n* @param[in] filename The name of the file to print to.\n*/\nvoid printMatrixToFile(const SimTK::Matrix& data, string filename) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void nanos6_memory_allocation_interception_init(\n\tnanos6_memory_allocation_functions_t const *nextMemoryFunctions, \n\tnanos6_memory_allocation_functions_t *nanos6MemoryFunctions\n) {\n\t_pageSize = sysconf(_SC_PAGE_SIZE);\n\t\n\t_nextMemoryFunctions = *nextMemoryFunctions;\n\t*nanos6MemoryFunctions = _nanos6MemoryFunctions;\n}\n",
        "answer": "/** @brief Initializes the memory allocation interception.\n*\n*  This function initializes the memory allocation interception by filling out the replacements for the original memory allocation functions in the second table, which will be enabled after this call. The first parameter contains the original memory allocation functions and can be used for chain-calling.\n*\n* @param[in] nextMemoryFunctions  A pointer to the original memory allocation functions.\n* @param[out] nanos6MemoryFunctions  A pointer to the replacements for the original memory allocation functions.\n*/\n*nanos6MemoryFunctions = _nanos6MemoryFunctions;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void nanos6_register_taskloop_bounds(\n\tvoid *taskHandle,\n\tsize_t lower_bound,\n\tsize_t upper_bound,\n\tsize_t step,\n\tsize_t chunksize\n) {\n\tTask *task = (Task *) taskHandle;\n\tassert(task != nullptr);\n\tassert(task->isTaskloop());\n\t\n\tTaskloop *taskloop = (Taskloop *) task;\n\ttaskloop->getTaskloopInfo().initialize(lower_bound, upper_bound, step, chunksize);\n}\n",
        "answer": "/** @brief Registers and initializes the loop bounds of a taskloop.\n*\n*  This function registers and initializes the loop bounds of a taskloop. It should be called after the creation of the task (see nanos6_create_task) and before the submission of the task (see nanos6_submit_task).\n*\n* @param [in] taskHandle A handle to the task that will execute the taskloop.\n* @param [in] lower_bound The lower bound of the loop.\n* @param [in] upper_bound The upper bound of the loop.\n* @param [in] step The step size of the loop.\n* @param [in] chunksize The chunk size of the loop.\n*/\nvoid nanos6_register_taskloop_bounds("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void print(std::ostream& out, MetricList& stats, const std::string& legacy_stats) {\n      std::ostringstream o;\n      o << \"STATS{\\n\";\n\n      impl::stat_list_json(o, stats);\n      o << \",\\n\";\n\n      o << legacy_stats;\n\n      o << \"\\n}STATS\";\n      out << o.str() << std::endl;\n    }\n",
        "answer": "/**\n* @brief Print all registered stats in JSON format.\n*\n* This function takes another argument for including legacy stats in output (inside \"STATS{  }STATS\" bookends).\n* It prints all registered stats in JSON format, using the impl::stat_list_json() function to generate the JSON string.\n* The legacy stats are included in the output if the legacy_stats argument is non-empty.\n*\n* @param out The output stream to print to.\n* @param stats The list of registered stats.\n* @param legacy_stats The legacy stats to include in the output, or an empty string if none.\n*/\nvoid print(std::ostream& out, MetricList& stats, const std::string& legacy_stats) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void reportOutput (const String& message, const int appendMode)\r\n    {\r\n        printf(\"%s\", (const char*)message.toUTF8());\r\n    }\r\n",
        "answer": "/**\n* @brief Report output from plugins in a IDE output section.\n*\n* This function is used to output lines from plugins in a IDE output section. It is useful when you want the user-defined plugins to be able to interact with the IDE directly, outputting strings in the text editor debugger.\n*\n* @param message The message to output.\n* @param appendMode The mode for appending the message.\n*/\nvoid reportOutput(const String& message, const int appendMode);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void draw_string(int x, int y, const char *s)\n{\n    short i;\n\n    if (x != 0 && y != 0) {\n        grMoveTo(x, y);\n    }\n\n    if (strlen(s) > 100) {\n        return;\n    }\n\n    for (i = 0; i < (int)strlen(s); i++) {\n        draw_character(s[i]);\n    }\n}\n",
        "answer": "/** @brief Draw a string at a specific position.\n*\n* This function will print a string at a certain position. If both the x and y coordinate are zero (0) the position is \"current position\". The area will be marked as \"needs update\" to the graphics handler.\n*\n* @param x The x coordinate of the position where the string should be drawn.\n* @param y The y coordinate of the position where the string should be drawn.\n* @param s The string that should be drawn.\n*/\nvoid draw_string(int x, int y, const char *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void closeTransport() {\n    transportClosed = true;\n  }\n",
        "answer": "/** @brief Closes the transport and cleans up any state.\n*\n*  This function is invoked on the sub-class when the transport is closed. The sub-class may clean up any state during this call. The transport may still be draining after this call.\n*\n* @return Should not return\n*/\nvoid closeTransport() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HeaderForm getHeaderForm(uint8_t headerValue) {\n  if (headerValue & kHeaderFormMask) {\n    return HeaderForm::Long;\n  }\n  return HeaderForm::Short;\n}\n",
        "answer": "/** @brief Returns the form of the header from the initial byte of a QUIC packet.\n*\n* This function returns whether the header is long or short based on the value of the first byte of the QUIC packet. It does not depend on the version of the protocol.\n*\n* @param headerValue The value of the first byte of the QUIC packet.\n*\n* @return HeaderForm::Long if the header is long, or HeaderForm::Short if the header is short.\n*/\nHeaderForm getHeaderForm(uint8_t headerValue) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void updateFlowControlList(QuicStreamState& stream) {\n  stream.conn.streamManager->queueFlowControlUpdated(stream.id);\n}\n",
        "answer": "/** @brief Updates the flow control list with the stream.\n*\n* This function updates the flow control list with the given stream. Callers should ensure that this is only invoked when the flow control changes.\n*\n* @param[in] stream The QuicStreamState object representing the stream to be updated.\n*\n* @return None.\n*/\nvoid updateFlowControlList(QuicStreamState& stream) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void appendPendingStreamReset(\n    QuicConnectionStateBase& conn,\n    const QuicStreamState& stream,\n    ApplicationErrorCode errorCode) {\n  conn.pendingEvents.resets.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(stream.id),\n      std::forward_as_tuple(\n          stream.id,\n          errorCode,\n          std::min(\n              stream.currentWriteOffset,\n              stream.finalWriteOffset.value_or(\n                  std::numeric_limits<uint64_t>::max()))));\n}\n",
        "answer": "/** @brief Add a pending reset for the given stream to the connection's pending events if the stream is not in WaitingForRstAck or Closed state already.\n*\n*  This function checks the current state of the stream and adds a pending reset event to the connection's pendingEvents list if the stream is not in WaitingForRstAck or Closed state already. The reset event includes the stream ID, error code, and minimum of the current write offset and final write offset (if available).\n*\n* @param conn The QuicConnectionStateBase object representing the connection to which the stream belongs.\n* @param stream The QuicStreamState object representing the stream for which the reset is being added.\n* @param errorCode The application error code associated with the reset.\n*\n* @return void\n*/\nvoid appendPendingStreamReset("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Line get_line(const Point& p1, const Point& p2)\n{\n    /**\n        This function returns the equation of the line.\n        Each line can be represented as\n        y = mx+c\n        So for a given line, this function will return the value of\n        m and c as a pair.\n\n        @param p1 First point of the two points for which the equation\n                  of the line has to be calculated\n        @param p1 Second point of the two points for which the equation\n                  of the line has to be calculated\n        @return m and c as `std::pair`\n     */\n\n    double slope = cal_slope(p1, p2);\n    return std::make_pair(slope, p1.second - p1.first * slope);\n}\n",
        "answer": "/**\n* @brief Returns the equation of a line given two points on the line.\n*\n* The equation of a line can be represented as y = mx + c, where m is the slope\n* and c is the y-intercept. This function returns the values of m and c for a\n* given line.\n*\n* @param p1 First point on the line.\n* @param p2 Second point on the line.\n* @return A pair containing the slope (m) and y-intercept (c) of the line.\n*/\nLine get_line(const Point& p1, const Point& p2);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    size_t encodeHuff (const THuffx H, uint symb, uint *stream, size_t ptr) {\n        size_t pos;\n        size_t code;\n        size_t d;\n        pos = H.spos[symb];\n        code = 0;\n        d = H.depth;\n        while (pos >= H.num_enc[d]) {\n            code = (code + H.num_enc[d]) >> 1;\n            pos -= H.num_enc[d--];\n        }\n        code += pos;\n        if (d > W) { bitzero(stream,ptr,d-W); ptr += d-W; d = W; }\n        while (d--) {\n            if ((code >> d) & 1) bitset(stream,ptr);\n            else bitclean(stream,ptr);\n            ptr++;\n        }\n        return ptr;\n    }\n",
        "answer": "/** @brief Encodes a symbol using Huffman coding.\n*\n*  This function encodes a symbol using Huffman coding, over the stream[ptr...lim] (ptr and lim are bit positions of stream). It returns the new ptr.\n*\n* @param H The Huffman code to use for encoding.\n* @param symb The symbol to encode.\n* @param stream The stream to encode over.\n* @param ptr The current position in the stream.\n* @return The new position in the stream after encoding.\n*/\nsize_t encodeHuff(const THuffx H, uint symb, uint *stream, size_t ptr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static Expr allEqualTo(const std::vector<Iterator>& iterators, Expr idx) {\n  if (iterators.empty()) {\n    return true;\n  }\n\n  std::vector<Expr> iterIdxEqualToIdx;\n  for (const auto& iter : iterators) {\n    iterIdxEqualToIdx.push_back(Eq::make(iter.getCoordVar(), idx));\n  }\n  return conjunction(iterIdxEqualToIdx);\n}\n",
        "answer": "/** @brief Checks if all iterator index variables are equal to a given expression.\n*\n* This function takes in a vector of iterators and an expression, and returns true iff all the iterator index variables are equal to the given expression or if there are no iterators.\n*\n* @param[in] iterators A vector of iterators.\n* @param[in] idx An expression.\n* @return True if all iterator index variables are equal to the given expression, or false otherwise.\n*/\nstatic Expr allEqualTo(const std::vector<Iterator>& iterators, Expr idx) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void plusAssign(double* V, int len, double v) {\n\tfor (int i = 0; i < len; i++)\n\t\tV[i] += v;\n}\n",
        "answer": "/** @brief Element-wise addition and assignment operation. It adds the first argument by the second argument and assign the result to the first argument, i.e., V = V + v.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param V The first argument.\n* @param len The length of the array.\n* @param v The second argument.\n* @return Should not return\n*/\nvoid plusAssign(double* V, int len, double v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void timesAssign(double* V1, double* V2, int len) {\n\tfor (int i = 0; i < len; i++)\n\t\tV1[i] = V1[i] * V2[i];\n}\n",
        "answer": "/** @brief Element-wise multiplication and assignment operation.\n*\n*  This function multiplies the first argument with the second argument and assigns the result to the first argument, i.e., V1 = V1 .* V2.\n*\n* @param[in] V1 The first vector of length len.\n* @param[in] V2 The second vector of length len.\n* @param[in] len The length of the vectors V1 and V2.\n*\n* @return None\n*/\nvoid timesAssign(double* V1, double* V2, int len) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setSubMatrix(Matrix& A, int* selectedRows, int numSelRows,\n\t\tint* selectedColumns, int numSelColumns, Matrix& B) {\n\tint r, c;\n\tfor (int i = 0; i < numSelRows; i++) {\n\t\tfor (int j = 0; j < numSelColumns; j++) {\n\t\t\tr = selectedRows[i];\n\t\t\tc = selectedColumns[j];\n\t\t\tA.setEntry(r, c, B.getEntry(i, j));\n\t\t}\n\t}\n}\n",
        "answer": "/** @brief Set submatrix of A with selected rows and selected columns by elements of B.\n*\n*  This function sets the submatrix of A with selected rows and selected columns by elements of B. B should have the same shape to the submatrix of A to be set. It is equivalent to the syntax A(selectedRows, selectedColumns) = B.\n*\n* @param[in] A The matrix to be modified.\n* @param[in] selectedRows An array of integers containing the indices of the rows to be modified.\n* @param[in] numSelRows The number of selected rows.\n* @param[in] selectedColumns An array of integers containing the indices of the columns to be modified.\n* @param[in] numSelColumns The number of selected columns.\n* @param[in] B The matrix containing the new values for the submatrix of A.\n*/\nvoid setSubMatrix(Matrix& A, int* selectedRows, int numSelRows,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid action(const gcn::ActionEvent& actionEvent) override\n\t{\n\t\tchar foldername[MAX_DPATH] = \"\";\n\n\t\tconst auto selected_item = lstFiles->getSelected();\n\t\tstrncpy(foldername, workingDir, MAX_DPATH);\n\t\tstrncat(foldername, \"/\", MAX_DPATH - 1);\n\t\tstrncat(foldername, fileList->getElementAt(selected_item).c_str(), MAX_DPATH - 2);\n\t\tif (fileList->isDir(selected_item))\n\t\t\tcheckfoldername(foldername);\n\t\telse if (!createNew)\n\t\t{\n\t\t\tstrncpy(workingDir, foldername, sizeof workingDir);\n\t\t\tdialogResult = true;\n\t\t\tdialogFinished = true;\n\t\t}\n\t}\n",
        "answer": "/** @brief Called when an action is received from a Widget. It is used to be able to receive a notification that an action has occurred.\n*\n*  This function is called when the user selects an item in the file list and presses the \"OK\" button. It checks if the selected item is a directory, and if so, it calls the checkfoldername() function to validate its name. If the selected item is not a directory, it copies its name to the workingDir variable and sets the dialogResult and dialogFinished variables to true.\n*\n* @param actionEvent The ActionEvent object that contains information about the action that was received.\n*/\nvoid action(const gcn::ActionEvent& actionEvent) override"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "createPadding(const openssl::RSAPaddingMode &mode,\n                                        const openssl::DigestTypes &hashing,\n                                        const openssl::DigestTypes &masking,\n                                        const std::vector<uint8_t> &label)\n{\n    std::unique_ptr<RSAPadding> padding;\n\n    if (mode == openssl::RSAPaddingMode::OAEP) {\n        padding = std::make_unique<OAEPPadding>(hashing, masking, label);\n    } else if (mode == openssl::RSAPaddingMode::PKCS1) {\n        padding = std::make_unique<PKCSPadding>();\n    } else if (mode == openssl::RSAPaddingMode::NONE) {\n        padding = std::make_unique<NoPadding>();\n    }\n\n    return padding;\n}\n",
        "answer": "/** @brief Creates a shared pointer for an RSA padding based on the given inputs. Simplifies the tests by taking advantage of polymorphism.\n*\n*  This function creates a shared pointer for an RSA padding based on the given inputs. It simplifies the tests by taking advantage of polymorphism, allowing for easier testing and debugging.\n*\n* @param mode The RSAPaddingMode to use.\n* @param hashing The DigestTypes to use for hashing.\n* @param masking The DigestTypes to use for masking.\n* @param label The label to use for the padding.\n* @return A shared pointer for an RSA padding based on the given inputs.\n*/\nstd::shared_ptr<RSAPadding> createPadding(const openssl::RSAPaddingMode &mode,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    QString errorString() { return \"\"; }\n",
        "answer": "/** @brief Returns an error string if any of the handler functions returns FALSE to the reader.\n*\n*  This function is called by the reader to get an error string if any of the handler functions\n*  returns FALSE.\n*\n* @return An empty string if no errors occurred, or a string describing the error otherwise.\n*/\nQString errorString() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QCString generateMarker(int id)\n{\n  QCString result;\n  result.sprintf(\"@%d\",id);\n  return result;\n}\n",
        "answer": "/** @brief Generate a place holder for a position in a list. Used for translators to be able to specify different elements orders depending on whether text flows from left to right or visa versa.\n*\n*  This function generates a place holder for a position in a list, which can be used by translators to specify different element orders depending on the direction of the text flow.\n*\n* @param id The ID of the marker to generate.\n* @return A string representing the marker.\n*/\nQCString generateMarker(int id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void playlist_added(sp_playlistcontainer *playlists,\n                               sp_playlist *addedPlaylist,\n                               int position,\n                               void * /*userdata*/)\n{\n    DEBUG printf(\"SpotWorker: playlist_added: (position: %d, name:%s)\\n\",\n                 position,\n                 sp_playlist_name(addedPlaylist));\n    sp_playlist_add_callbacks(addedPlaylist, &pl_callbacks, NULL);\n    SpotWorker *sw = SpotWorker::getInstance();\n    sw->emitPlaylistAdded(playlists);\n}\n",
        "answer": "/** @brief Callback from libspotify when a playlist is added to the playlist container.\n*\n*  This function is called by libspotify when a new playlist is added to the playlist container.\n*  It adds callbacks to the newly added playlist and emits a signal to notify the application of the addition.\n*\n* @param[in] playlists The playlist container that the playlist was added to.\n* @param[in] addedPlaylist The playlist that was added.\n* @param[in] position The position of the newly added playlist in the playlist container.\n* @param[in] userdata A pointer to user data, which is not used in this function.\n*/\nextern \"C\" void playlist_added(sp_playlistcontainer *playlists,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    jstring localName() {\n        return internString(mEnv, mParsingContext, mLocalName);\n    }\n",
        "answer": "/**\n* @brief Returns the element or attribute local name.\n*\n* This function returns the local name of an element or attribute, which is the part of the name that comes after the namespace prefix (if any). The local name is never empty and may contain a prefix if namespace processing is disabled, in which case the qName will always be empty.\n*\n* @return A string containing the local name.\n*/\njstring localName() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void testWriteMultithread() {\n            DataFileWriteFromThreadsRunner runner(10, 1000000);\n            runner.start();\n            runner.join();\n\n            CPPUNIT_ASSERT(runner.m_dataFileSink->m_bytesWritten == 10 * 1000000);\n        }\n",
        "answer": "/** @brief Tests writing to a data file from multiple threads.\n*\n*  This test creates 10 threads and has each thread write 1,000,000 bytes to a data file. The test then verifies that the total number of bytes written is equal to 10,000,000.\n*\n* @return Should not return\n*/\nvoid testWriteMultithread() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CExternalAlgorithmDataPtr CExternalAlgorithmData_newAlgorithmData() {\n\tMR4C::ExternalAlgorithmData* algoData = new MR4C::ExternalAlgorithmData();\n\treturn wrapExternalAlgorithmData(algoData);\n}\n",
        "answer": "/** @brief Creates a new instance of the CExternalAlgorithmData class.\n*\n*  This function creates a new instance of the CExternalAlgorithmData class, which is used to store data for an external algorithm.\n*\n* @return A pointer to the newly created CExternalAlgorithmData object.\n*/\nCExternalAlgorithmDataPtr CExternalAlgorithmData_newAlgorithmData() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CExternalDatasetPtr CExternalDataset_newDataset(\n\tconst char* name,\n\tconst CExternalDatasetCallbacks& callbacks\n) {\n\tMR4C::ExternalDataset* dataset = new MR4C::ExternalDataset();\n\tdataset->init(name, callbacks);\n\treturn wrapExternalDataset(dataset);\n}\n",
        "answer": "/** @brief Creates a new external dataset.\n*\n*  This function creates a new external dataset with the given name and callbacks.\n*\n* @param[in] name The name of the dataset.\n* @param[in] callbacks The callback functions for the dataset.\n* @return A pointer to the newly created dataset.\n*/\nCExternalDatasetPtr CExternalDataset_newDataset("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "      bool signed_by( const public_key_type& k )\n      {\n         auto itr = provided_signatures.find(k);\n         if( itr == provided_signatures.end() )\n         {\n            auto pk = available_keys.find(k);\n            if( pk  != available_keys.end() )\n               return provided_signatures[k] = true;\n            return false;\n         }\n         return itr->second = true;\n      }\n",
        "answer": "/** @brief Checks if a public key is signed by the available keys.\n*\n*  This function checks if a public key is signed by the available keys. It returns true if we have a signature for this key or can produce a signature for this key, else returns false.\n*\n* @param k The public key to check.\n* @return True if the public key is signed by the available keys, false otherwise.\n*/\nbool signed_by( const public_key_type& k )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "TCOD_event_t TCOD_sys_process_key_event(\n    const union SDL_Event* in, TCOD_key_t* out)\n{\n  if (!in || !out) { return TCOD_EVENT_NONE; }\n  return tcod::sdl2::process_event(*in, *out);\n}\n",
        "answer": "/** @brief Processes a key event from an SDL_Event and returns the relevant TCOD_event_t.\n*\n*  This function takes an SDL_Event as input and returns the corresponding TCOD_event_t if the event was keyboard related.\n*  If the event is not keyboard related, it returns TCOD_EVENT_NONE.\n*\n* @param in The SDL_Event to be processed.\n* @param out The TCOD_key_t that will hold the relevant information about the key event.\n* @return The TCOD_event_t corresponding to the keyboard event, or TCOD_EVENT_NONE if the event was not keyboard related.\n*/\nTCOD_event_t TCOD_sys_process_key_event(const union SDL_Event* in, TCOD_key_t* out)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int64_t timestamp_to_microseconds(char const * data_pointer)\n{\n    auto & sql_ts = *reinterpret_cast<SQL_TIMESTAMP_STRUCT const *>(data_pointer);\n    intptr_t const microseconds = sql_ts.fraction / 1000;\n    boost::posix_time::ptime const ts({static_cast<unsigned short>(sql_ts.year), sql_ts.month, sql_ts.day},\n            {sql_ts.hour, sql_ts.minute, sql_ts.second, microseconds});\n    return (ts - timestamp_epoch).total_microseconds();\n}\n",
        "answer": "/**\n* @brief Convert an SQL_TIMESTAMP_STRUCT stored at data_pointer to an integer describing the elapsed microseconds since the POSIX epoch.\n*\n* This function takes a pointer to an SQL_TIMESTAMP_STRUCT and converts it to an integer representing the number of microseconds that have passed since the POSIX epoch (January 1, 1970, 00:00:00 UTC).\n*\n* @param data_pointer A pointer to an SQL_TIMESTAMP_STRUCT.\n* @return An integer representing the number of microseconds since the POSIX epoch.\n*/\nint64_t timestamp_to_microseconds(char const * data_pointer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void set_status_message(int color, const std::string &msg, unsigned int timeout_sec)\n{\n    bool old_message_has_timed_out = status_message_timeout <=\n        g_1s_timer_ticks - status_message_timestamp;\n\n    if (msg != status_message_text || old_message_has_timed_out) {\n        static SAMPLE *sound_sample;\n        if (!sound_sample)\n            sound_sample = wav_sample(\"$(ufo2000)/sfx/freesound.org/135125__ecfike__computer-error.wav\");\n        ASSERT(sound_sample);\n        play_sample(sound_sample, 255, 127, 1000, 0);\n    }\n    status_message_text = msg;\n    status_message_timestamp = g_1s_timer_ticks;\n    status_message_timeout = timeout_sec;\n    status_message_color = color;\n}\n",
        "answer": "/**\n* @brief Set status message text, which will automatically disappear approximately after 'timeout_sec' seconds (precision is very rough).\n*\n* This function sets the status message text and color, and also starts a timer to automatically clear the message after the specified timeout.\n* If the message has not timed out yet, it will be replaced with the new message.\n*\n* @param color The color of the status message text.\n* @param msg The status message text.\n* @param timeout_sec The number of seconds to wait before automatically clearing the message.\n*/\nvoid set_status_message(int color, const std::string &msg, unsigned int timeout_sec)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class Flat : public AbstractLeakContainer {\n\n  public:\n    Flat() {\n      currentContext = new Context();\n    }\n    \n    virtual void call_create(uint64_t caller, uint64_t callee) {\n    }\n    \n    virtual void ret_create(uint64_t ip) {\n    }\n    \n    virtual void call_consume(uint64_t caller, uint64_t callee) {\n    }\n    \n    virtual void ret_consume(uint64_t ip) {\n    }\n    \n    virtual void print_all() {\n      currentContext->print();\n    }\n};\n",
        "answer": "/** @brief Flat class.\n*\n*  This is the Flat class, which inherits from AbstractLeakContainer. It is used to report leaks and does not keep track of the actual calling context. It is used to trace leaking instructions at any calling context.\n*\n* @return Should not return\n*/\nclass Flat : public AbstractLeakContainer "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "API VsmStatus vsm_declare_link(VsmClient client,\n                               const char* source,\n                               const char* zone,\n                               const char* target)\n{\n    return getClient(client).vsm_declare_link(source, zone, target, NULL);\n}\n",
        "answer": "/** @brief Declares a link in the specified zone.\n*\n*  This function declares a link between two entities in the specified zone.\n*\n* @param client The VsmClient object representing the client connection.\n* @param source The name of the source entity.\n* @param zone The name of the zone where the link will be declared.\n* @param target The name of the target entity.\n* @return A VsmStatus object indicating the result of the operation.\n*/\nVsmStatus vsm_declare_link(VsmClient client, const char* source, const char* zone, const char* target) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isImplicitCastCandidate(const CastExpr *Cast) {\n  return Cast->getCastKind() == CK_UserDefinedConversion ||\n         Cast->getCastKind() == CK_FloatingToBoolean ||\n         Cast->getCastKind() == CK_FloatingToIntegral ||\n         Cast->getCastKind() == CK_IntegralToBoolean ||\n         Cast->getCastKind() == CK_IntegralToFloating ||\n         Cast->getCastKind() == CK_MemberPointerToBoolean ||\n         Cast->getCastKind() == CK_PointerToBoolean;\n}\n",
        "answer": "/** @brief Checks if a cast expression is an implicit cast candidate.\n*\n*  This function checks if a given cast expression is an implicit cast candidate, which means that it is most likely accidental. User defined or integral conversions fit in this category, lvalue to rvalue or derived to base does not.\n*\n* @param Cast The cast expression to check.\n* @return True if the cast expression is an implicit cast candidate, false otherwise.\n*/\nstatic bool isImplicitCastCandidate(const CastExpr *Cast) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void binary_write (T x, ostream& stream) {\n        stream.write (reinterpret_cast<char*>(&x), sizeof(x));\n    }\n",
        "answer": "/** @brief Writes value in direct binary (not suitable for pointers). Currently machine dependent (don't transfer a checkpoint to another machine).\n*\n* This function writes the value of type T in direct binary form to an output stream. The function is not suitable for pointers and is currently machine-dependent, meaning it should not be used to transfer a checkpoint to another machine.\n*\n* @param x The value to write to the output stream.\n* @param stream The output stream to which the value will be written.\n*/\nvoid binary_write (T x, ostream& stream) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isNetCDFfile(const string &filename) \n{\n    size_t extIndex = filename.find_last_of(\".\");\n    if (extIndex == string::npos) {\n        return false;\n    }\n\n    string ext = filename.substr(extIndex);\n    return (ext.compare(NETCDF_FILE_EXTENTION) == 0);\n}\n",
        "answer": "/** @brief Checks if a file is a NetCDF file based on its extension.\n*\n*  This function checks if the given filename has the extension \".nc\" or \".cdf\", which are the standard extensions for NetCDF files.\n*\n* @param[in] filename The name of the file to check.\n* @return True if the file is a NetCDF file, false otherwise.\n*/\nbool isNetCDFfile(const string &filename)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HRESULT M2GetLastError()\n{\n    return __HRESULT_FROM_WIN32(GetLastError());\n}\n",
        "answer": "/** @brief Retrieves the calling thread's last-error code value.\n*\n*  The last-error code is maintained on a per-thread basis. Multiple threads do not overwrite each other's last-error code.\n*\n* @return HRESULT The last-error code for the calling thread.\n*/\nHRESULT M2GetLastError()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int test_RendezvousRotator(int threadCount)\n    {\n        ACE_UNUSED_ARG(threadCount);\n        int result = 0;\n        int expected = 10;\n        const int rotateValue = 20;\n        int value = 0;\n        DAF::RendezvousRotator<int> rotator;\n\n        DAF::Rendezvous<int> rend(2,rotator);\n\n        TestRotator *test1 = new TestRotator(rend,expected);\n\n        DAF::Runnable_ref runner1(test1);\n\n        {\n            DAF::TaskExecutor executor;\n\n            executor.execute(runner1);\n\n            value = rend.rendezvous(rotateValue);\n        }\n\n        result = (test1->result == rotateValue) && (value  == expected);\n\n        std::cout << __FUNCTION__ <<  \" Expected \" << expected << \" result \" << value << \" \" << (result ? \"OK\" : \"FAILED\" ) << std::endl;\n\n        return result;\n    }\n",
        "answer": "/**\n* @brief Tests the RendezvousRotator class.\n*\n* This function tests the functionality of the RendezvousRotator class by creating a rendezvous between two threads and rotating the value passed through the rendezvous. The test checks that the expected value is received by both threads after rotation.\n*\n* @param threadCount The number of threads to use in the test.\n*\n* @return True if the test passes, false otherwise.\n*/\nint test_RendezvousRotator(int threadCount) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int qfsqldbfs_fsync(const char *path, int isdatasync, struct fuse_file_info *fi)\n{\n\tqfLogFuncFrame() << path << \"file handle:\" << fi->fh;\n\tQ_UNUSED(isdatasync);\n\tMUTEX_LOCKER;\n\tint ret = qfsqldbfs_flush(path, fi);\n\tqfDebug() << \"\\t ret:\" << ret;\n\treturn ret;\n}\n",
        "answer": "/** @brief Synchronize file contents.\n*\n*  This function synchronizes the file contents if the datasync parameter is non-zero, otherwise it only flushes the user data and not the meta data. Changed in version 2.2\n*\n* @param path The path to the file to be flushed.\n* @param isdatasync A flag indicating whether to flush only the user data or both the user data and meta data.\n* @param fi The file handle for the file to be flushed.\n* @return Should not return\n*/\nint qfsqldbfs_fsync(const char *path, int isdatasync, struct fuse_file_info *fi)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool checkTerrainHeight(float x, float y, int height)\n\t{\n\t\tfloat realHeight = 0;\n\t\tgetHeight(TerrainPosition(x,y), realHeight);\n\t\treturn (int)(realHeight) == height;\n\t}\n",
        "answer": "/** @brief Checks the terrain height.\n*\n*  This function checks the height of the terrain at a given position using an integer.\n*  It is important to note that the height is checked using an integer because of the floats being used, we can't be 100% certain that a piece of terrain should be exactly the specified height.\n*\n* @param x The x coordinate of the position to check.\n* @param y The y coordinate of the position to check.\n* @param height The expected height at the given position.\n* @return True if the terrain height matches the expected height, false otherwise.\n*/\nbool checkTerrainHeight(float x, float y, int height)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void useTrainingSampleChecker(TrainingSampleChecker checker) {\n    ((ofApp *) ofGetAppPtr())->useTrainingSampleChecker(checker);\n}\n",
        "answer": "/** @brief Registers a TrainingSampleChecker to be used for training sample validation.\n*\n*  This function registers a TrainingSampleChecker to be used for training sample validation. Only one TrainingSampleChecker can be active at any time. Subsequent calls to this function will replace the previously-registered checker.\n*\n* @param checker The TrainingSampleChecker to use for training sample validation.\n*/\nvoid useTrainingSampleChecker(TrainingSampleChecker checker) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" __declspec(dllexport) void __stdcall CheckLibraryHasLoaded()\n{\n\treturn;\n}\n",
        "answer": "/** @brief MarkerDetector_DetectMarkers\n*\n*  This function detects markers in an image.\n*\n* @param _imageWidth : width of the image data\n* @param _imageHeight: height of the image data\n* @param _imageData : input image data\n* @param _markerSize : The physical size of the target marker in meters\n*\n* @return _numMarkersDetected : the number of markers detected\n*\n* @details This function looks for markers in an image and returns the number of markers detected. It also gets an array of detected marker ids after MarkerDetector_DetectMarkers has been called. Additionally, it gets the marker position and rotation in camera space for a given marker.\n*/\nextern \"C\" __declspec(dllexport) void __stdcall CheckLibraryHasLoaded()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void CD3_PUBLIC registerSimulations(SimulationRegistry *registry) {\n    }\n",
        "answer": "/** @brief Register simulations with the simulation registry.\n*\n*  This function registers all available simulations with the simulation registry.\n*\n* @param[in] registry The simulation registry to register with.\n*/\nvoid CD3_PUBLIC registerSimulations(SimulationRegistry *registry) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool onInit() {\n        test = Surface::load(\"/home/agladd/alpha-test.png\");\n\n        if(test == NULL) return false;\n        else return true;\n    }\n",
        "answer": "/** @brief Perform user initialization. Called after SDL has been initialized and the video mode has been set. If you want to use OpenGL, this is where you'd want to initialize it. Subclasses must implement!\n*\n* This function loads a surface from the specified file path and checks if it is NULL or not. If it is NULL, the function returns false, otherwise it returns true.\n*\n* @param filePath The file path of the surface to load.\n* @return True if the surface was loaded successfully, false otherwise.\n*/\nbool onInit(const char* filePath) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void MarkupContextLoadString(benchmark::State& state) {\n    std::ifstream t(OKUI_BENCHMARK_RESOURCES_PATH \"/markup.xml\");\n    std::string markup((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());\n    while (state.KeepRunning()) {\n        okui::ml::Environment environment;\n        okui::ml::Context context{&environment};\n        context.define(\"state\", \"standby\");\n        benchmark::DoNotOptimize(context.load(markup));\n    }\n}\n",
        "answer": "/**\n* @brief Loads a markup string into an okui::ml::Context.\n*\n* This function loads a markup string into an okui::ml::Context, which can be used to render the markup.\n*\n* @param state The benchmark state.\n*/\nstatic void MarkupContextLoadString(benchmark::State& state) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int chromaprint_decode_fingerprint(void *encoded_fp, int encoded_size, void **fp, int *size, int *algorithm, int base64)\n{\n\tstring encoded = string((char *)encoded_fp, encoded_size);\n\tstring compressed = base64 ? Chromaprint::Base64Decode(encoded) : encoded;\n\tvector<int32_t> uncompressed = Chromaprint::DecompressFingerprint(compressed, algorithm);\n\t*fp = malloc(sizeof(int32_t) * uncompressed.size());\n\t*size = uncompressed.size();\t\n\tcopy(uncompressed.begin(), uncompressed.end(), (int32_t *)*fp);\n\treturn 1;\n}\n",
        "answer": "/** @brief Decode and decompress an encoded fingerprint.\n*\n* This function takes a pointer to an encoded fingerprint, its size, and options for base64-decoding and algorithm. It returns a pointer to the decoded and decompressed fingerprint, its size, and the algorithm used. The caller is responsible for freeing the returned pointer using chromaprint_dealloc().\n*\n* @param encoded_fp A pointer to the encoded fingerprint.\n* @param encoded_size The size of the encoded fingerprint.\n* @param fp A pointer to the decoded and decompressed fingerprint.\n* @param size The size of the decoded and decompressed fingerprint.\n* @param algorithm The algorithm used for decompression.\n* @param base64 Whether or not to base64-decode the encoded fingerprint before decompressing it.\n* @return 1 if successful, 0 otherwise.\n*/\nint chromaprint_decode_fingerprint(void *encoded_fp, int encoded_size, void **fp, int *size, int *algorithm, int base64)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void destroy_image(astc_codec_image * img)\n{\n\tif (img == NULL)\n\t\treturn;\n\n\tif (img->imagedata8)\n\t{\n\t\tdelete[]img->imagedata8[0][0];\n\t\tdelete[]img->imagedata8[0];\n\t\tdelete[]img->imagedata8;\n\t}\n\tif (img->imagedata16)\n\t{\n\t\tdelete[]img->imagedata16[0][0];\n\t\tdelete[]img->imagedata16[0];\n\t\tdelete[]img->imagedata16;\n\t}\n\tdelete img;\n}\n",
        "answer": "/** @brief Destroys an image.\n*\n*  This function destroys an image by deleting the data and the image itself.\n*\n* @param[in,out] img The image to destroy.\n*/\nvoid destroy_image(astc_codec_image *img) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void handleReadyState(CivetServer *server,\n\t                              struct mg_connection *conn) {\n\t\tprintf(\"WS ready\\n\");\n\n\t\tconst char *text = \"Hello from the websocket ready handler\";\n\t\tmg_websocket_write(conn, WEBSOCKET_OPCODE_TEXT, text, strlen(text));\n\t}\n",
        "answer": "/** @brief Callback method for when websocket handshake is successfully completed, and connection is ready for data exchange.\n*\n* This function is called by the CivetServer when a websocket handshake is successfully completed, and the connection is ready for data exchange.\n* It will print a message to the console indicating that the websocket is ready, and then send a text message over the websocket connection.\n*\n* @param server The CivetServer instance that called this function.\n* @param conn The mg_connection struct representing the websocket connection.\n*/\nvirtual void handleReadyState(CivetServer *server,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "jstring Java_org_apache_nifi_processor_JniInitializationContext_getIdentifier(JNIEnv *env, jobject obj) {\n  minifi::jni::JniInitializationContext *ptr = minifi::jni::JVMLoader::getInstance()->getReference<minifi::jni::JniInitializationContext>(env, obj);\n  return env->NewStringUTF(ptr->identifier_.c_str());\n}\n",
        "answer": "/** @brief Get the identifier for a JNI initialization context.\n*\n* This function returns the identifier for a JNI initialization context.\n* The identifier is used to identify the context and can be used in\n* logging or debugging messages.\n*\n* @param env The JNI environment.\n* @param obj The Java object representing the JNI initialization context.\n* @return A string containing the identifier for the JNI initialization context.\n*/\njstring Java_org_apache_nifi_processor_JniInitializationContext_getIdentifier(JNIEnv *env, jobject obj) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned int ess_recv(int socket, void* buf, unsigned int len, int flags) {\n  memset(buf,0,len);\n  return recv(socket,buf,len,flags);\n}\n",
        "answer": "/** @brief Receives data sent from the host connected to a datagram socket.\n*\n* If a datagram socket is connected, this function may be called to receive data sent from the host connected to.\n*\n* @param[in] socket The file descriptor of the datagram socket.\n* @param[out] buf The buffer where the received data will be stored.\n* @param[in] len The length of the buffer.\n* @param[in] flags The flags used to control the behavior of the function.\n*\n* @return The number of bytes received, or -1 if an error occurred.\n*/\nunsigned int ess_recv(int socket, void* buf, unsigned int len, int flags) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "JNIEXPORT jint JNICALL scsynth_android_genaudio ( JNIEnv* env, jobject obj, jshortArray arr )\n{\n\tenv->GetShortArrayRegion(arr, 0, bufflen, buff);\n\n\t((SC_AndroidJNIAudioDriver*)AudioDriver(world))->genaudio(buff, bufflen);\n\n\tenv->SetShortArrayRegion(arr, 0, bufflen, buff);\n\treturn 0;\n}\n",
        "answer": "/** @brief JNI function for generating audio on Android.\n*\n* This function is called by the Java code to generate audio on Android. It uses the JNI (Java Native Interface) to interact with the native code and generate audio samples.\n*\n* @param env The JNI environment.\n* @param obj The object that is calling this function.\n* @param arr The short array containing the audio data.\n*\n* @return 0 if successful, non-zero otherwise.\n*/\nJNIEXPORT jint JNICALL scsynth_android_genaudio ( JNIEnv* env, jobject obj, jshortArray arr )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int get_next_point(bresenham_param_t *params)\r\n{\r\n  if (params->XIndex == params->X2)\r\n    {\r\n      return 0;\r\n    }\r\n  params->XIndex += params->Increment;\r\n  if (params->DTerm < 0 || (params->Increment < 0 && params->DTerm <= 0))\r\n    params->DTerm += params->IncrE;\r\n  else\r\n    {\r\n      params->DTerm += params->IncrNE;\r\n      params->YIndex += params->Increment;\r\n    }\r\n  return 1;\r\n}\r\n",
        "answer": "/** @brief Get the next point in a bresenham path.\n*\n* This function is one of the three functions that correspond to the bresenham algorithm of path following moves to the next point.\n* It takes a pointer to a bresenham_param_t structure as an argument and returns 1 if it successfully finds the next point, or 0 if it reaches the end of the line.\n* The function checks if the current X index is equal to the target X2 coordinate, and if so, it returns 0. Otherwise, it increments the X index by the increment value and updates the DTerm value accordingly. If the DTerm value is less than or equal to zero, it adds IncrE to DTerm. Otherwise, it adds IncrNE to DTerm and increments the Y index by the increment value. Finally, it returns 1 to indicate that a new point has been found.\n*\n* @param params A pointer to a bresenham_param_t structure containing the parameters for the bresenham algorithm.\n* @return 1 if a new point is found, or 0 if the end of the line is reached.\n*/\nint get_next_point(bresenham_param_t *params)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void discover_descriptors(const DiscoveredCharacteristic &characteristic)\n    {\n        printf(\"Initiating descriptor discovery of %u.\\r\\n\", characteristic.getValueHandle());\n\n        _descriptor_handle = 0;\n        ble_error_t error = characteristic.discoverDescriptors(\n            as_cb(&Self::when_descriptor_discovered),\n            as_cb(&Self::when_descriptor_discovery_ends)\n        );\n\n        if (error) {\n            printf(\n                \"Error: cannot initiate discovery of %04X due to %u.\\r\\n\",\n                characteristic.getValueHandle(), error\n            );\n            stop();\n        }\n    }\n",
        "answer": "/** @brief Initiates the discovery of descriptors for a given characteristic.\n*\n*  This function initiates the discovery of descriptors for a given characteristic. When a descriptor is discovered, the function when_descriptor_discovered is invoked.\n*\n*  @param[in] characteristic The characteristic to discover descriptors for.\n*\n*  @return void\n*/\nvoid discover_descriptors(const DiscoveredCharacteristic &characteristic)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void linkEncryptionResult(\n        ble::connection_handle_t connectionHandle,\n        ble::link_encryption_t result\n    ) {\n        if (result == ble::link_encryption_t::ENCRYPTED) {\n            printf(\"Link ENCRYPTED\\r\\n\");\n        } else if (result == ble::link_encryption_t::ENCRYPTED_WITH_MITM) {\n            printf(\"Link ENCRYPTED_WITH_MITM\\r\\n\");\n        } else if (result == ble::link_encryption_t::NOT_ENCRYPTED) {\n            printf(\"Link NOT_ENCRYPTED\\r\\n\");\n        }\n\n        /* disconnect in 2 s */\n        _event_queue.call_in(\n            2000,\n            &_ble.gap(),\n            disconnect_call,\n            _handle,\n            ble::local_disconnection_reason_t(ble::local_disconnection_reason_t::USER_TERMINATION)\n        );\n    }\n",
        "answer": "/**\n* @brief Inform the application of change in encryption status. This will be communicated through the serial port.\n*\n* @param connectionHandle The handle of the connection that has changed its encryption status.\n* @param result The new encryption status of the connection.\n*/\n/* disconnect in 2 s */\n_event_queue.call_in("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void _EEPROM_writeData(int &pos, uint8_t* value, uint8_t size) {\n  uint8_t c;\n  while(size--) {\n    eeprom_write_byte((unsigned char*)pos, *value);\n    c = eeprom_read_byte((unsigned char*)pos);\n    if (c != *value) {\n      SERIAL_ECHO_START;\n      SERIAL_ECHOLNPGM(MSG_ERR_EEPROM_WRITE);\n    }\n    pos++;\n    value++;\n  };\n}\n",
        "answer": "/** @brief EEPROM data writer.\n*\n* This function writes data to the EEPROM.\n* It takes an integer position, a pointer to an array of bytes, and the size of the array as input.\n* It then loops through each byte in the array and writes it to the EEPROM at the specified position.\n* After writing each byte, it reads back the value from the EEPROM and compares it to the original value.\n* If they are not equal, an error message is printed to the serial console.\n* The function then increments the position and moves on to the next byte in the array.\n*\n* @param pos The position in the EEPROM where the data should be written.\n* @param value A pointer to an array of bytes that contains the data to be written.\n* @param size The size of the array.\n* @return void\n*/\nvoid _EEPROM_writeData(int &pos, uint8_t* value, uint8_t size) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void board_init()\n{\n    gpio_init_generated();\n}\n",
        "answer": "/** @brief Board initialization routine.\n*\n*  This is the first user-defined function that will be called after reset. No static or global object is constructed at this particular moment. Usually, this routine should perform basic GPIO initialization.\n*\n* @return None\n*/\nvoid board_init()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    unsigned int Input(void* data, size_t maxlen)\n    {\n        unsigned int rb = m_chain.Input(data, maxlen);\n        m_hash.update((Botan::byte*)data, rb);\n        return rb;\n    }\n",
        "answer": "/** @brief Requests data block-wise.\n*\n*  This function requests data block-wise and returns maxlen byte at once if they are available. Must return the number of bytes retrieved.\n*\n* @param[in] data Pointer to a buffer where the requested data will be stored.\n* @param[in] maxlen Maximum length in bytes that can be stored in the buffer.\n* @return The number of bytes retrieved.\n*/\nunsigned int Input(void* data, size_t maxlen)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setGroupingInUtc ( bool b_GroupingInUtc )\n{\n\tbGroupingInUtc = b_GroupingInUtc;\n}\n",
        "answer": "/** @brief Set global behavior of grouping by day/week/month/year functions.\n*\n*  If invoked true, params treated as UTC timestamps, and as local timestamps otherwise (default).\n*\n* @param b_GroupingInUtc Boolean value indicating whether to group in UTC or not.\n*/\nvoid setGroupingInUtc(bool b_GroupingInUtc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline bool IsDebuggerPresent()\n{\n#ifdef NDEBUG\n    return false;\n#else\n\treturn true;\n#endif\n}\n",
        "answer": "/** @brief Check if the program was compiled with NDEBUG flag.\n*\n*  This function returns true if the program was compiled with NDEBUG flag and false otherwise.\n*\n* @return bool: True if the program was compiled with NDEBUG flag, False otherwise.\n*/\ninline bool IsDebuggerPresent()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    QString getRepositoryVersion()\n    {\n        return QString(SIRE_REPOSITORY_VERSION);\n    }\n",
        "answer": "/**\n* @brief Returns the version number of this copy of the corelib from the online source repository.\n*\n* This function returns a QString object containing the version number of this copy of the corelib, as retrieved from the online source repository.\n*\n* @return A QString object containing the version number of this copy of the corelib.\n*/\nQString getRepositoryVersion()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Complex pow(const Complex &z, const Complex &a)\n    {\n        return gsl_complex_pow(z,a);\n    }\n",
        "answer": "/** @brief Computes the complex power of a complex number.\n*\n*  This function computes the complex power of a complex number z raised to a complex power a, z^a.\n*  The computation is performed using complex logarithms and complex exponentials.\n*\n* @param[in] z The base complex number.\n* @param[in] a The exponent complex number.\n* @return The result of the complex power operation.\n*/\nComplex pow(const Complex &z, const Complex &a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Complex arccos(const Complex &z)\n    {\n        return gsl_complex_arccos(z);\n    }\n",
        "answer": "/** @brief Calculates the complex arccosine of a given complex number.\n*\n*  This function returns the complex arccosine of the complex number z, (z). The branch cuts are on the real axis, less than -1 and greater than 1.\n*\n* @param[in] z A reference to the complex number for which the arccosine is calculated.\n* @return The complex arccosine of z.\n*/\nComplex arccos(const Complex &z)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Complex arctanh(const Complex &z)\n    {\n        return gsl_complex_arctanh(z);\n    }\n",
        "answer": "/** @brief Calculates the complex hyperbolic arctangent of a given complex number.\n*\n*  This function returns the complex hyperbolic arctangent of the complex number z, (z). The branch cuts are on the real axis, less than -1 and greater than 1.\n*\n* @param[in] z The complex number to calculate the arctanh for.\n* @return The complex hyperbolic arctangent of z.\n*/\nComplex arctanh(const Complex &z)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "T getProperty(const PropertyName &prop, const MoleculeData &moldata, bool *found)\n{\n    if (moldata.hasProperty(prop))\n    {\n        const Property &p = moldata.property(prop);\n\n        if (p.isA<T>())\n        {\n            *found = true;\n            return p.asA<T>();\n        }\n    }\n\n    *found = false;\n    return T();\n}\n",
        "answer": "/** @brief Get property from molecule data.\n*\n*  This function is used to grab the property from a molecule data, catching errors and signalling if the correct property has been found.\n*\n* @param prop The name of the property to retrieve.\n* @param moldata The molecule data object containing the property.\n* @param found A pointer to a boolean value that will be set to true if the property is found, or false otherwise.\n* @return The value of the property if it is found, or an empty T() if it is not found.\n*/\nT getProperty(const PropertyName &prop, const MoleculeData &moldata, bool *found)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int gridIndexToArrayIndex(int ix, int iy, int iz, int dimx, int dimy, int dimz)\n{\n    return ix*(dimy*dimz) + iy*dimz + iz;\n}\n",
        "answer": "/** @brief Convert the indicies ix, iy, iz for the 3-dimensional array of dimension dimx, dimy, dimz into the returned index into the corresponding 1-dimensional array.\n*\n* This function takes in six parameters: ix, iy, iz, dimx, dimy, and dimz. It returns a single integer value that represents the index of the element in a one-dimensional array that corresponds to the provided three-dimensional indices and dimensions.\n*\n* @param ix The x-index of the element in the 3D array.\n* @param iy The y-index of the element in the 3D array.\n* @param iz The z-index of the element in the 3D array.\n* @param dimx The dimension of the 3D array in the x-direction.\n* @param dimy The dimension of the 3D array in the y-direction.\n* @param dimz The dimension of the 3D array in the z-direction.\n* @return The index of the element in the corresponding 1D array.\n*/\nstatic int gridIndexToArrayIndex(int ix, int iy, int iz, int dimx, int dimy, int dimz)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, const char **argv)\n{\n    QHash<Foo::Bar, Foo::Bar> foo_hash;\n\n    foo_hash.insert( Foo::Bar(), Foo::Bar() );\n\n    return 0;\n}\n",
        "answer": "/** @brief Main function.\n*\n* This is the main entrypoint for your program.\n* It initializes the QHash and inserts a pair of Foo::Bar objects into it.\n*\n* @param argc The number of command-line arguments.\n* @param argv An array of command-line argument strings.\n* @return 0 on success, non-zero on failure.\n*/\nint main(int argc, const char **argv)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void SetMainLoop(GMainLoop *ml)\n    {\n        if (be_obj)\n        {\n            be_obj->SetMainLoop(ml);\n        }\n    }\n",
        "answer": "/** @brief Sets the main loop for the session manager.\n*\n*  This function provides a reference to the Glib2 main loop object, which is used to cleanly shutdown this process when the session manager wants to shutdown this process via D-Bus.\n*\n* @param ml A pointer to the GMainLoop object.\n*/\nvoid SetMainLoop(GMainLoop *ml)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void SetMainLoop(GMainLoop *ml)\n    {\n        mainloop = ml;\n    }\n",
        "answer": "/** @brief Sets the Glib2 main loop object.\n*\n*  This function provides a reference to the Glib2 main loop object, which is used to cleanly shutdown this process when the session manager wants to shutdown this process via D-Bus.\n*\n* @param ml A pointer to the GMainLoop object.\n*/\nvoid SetMainLoop(GMainLoop *ml)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int stop_handler(void *loop)\n{\n#ifdef SHUTDOWN_NOTIF_PROCESS_NAME\n    std::cout << \"** Shutting down \";\n    std::cout << SHUTDOWN_NOTIF_PROCESS_NAME << \" \";\n    std::cout << \"(pid: \" << std::to_string(getpid()) << \")\" << std::endl;\n#endif\n    g_main_loop_quit((GMainLoop *)loop);\n    return G_SOURCE_CONTINUE;\n}\n",
        "answer": "/** @brief GLib2 interrupt/signal handler.\n*\n*  This is used to gracefully shutdown the GLib main loop. This is called via the g_unix_signal_add() or similar interfaces which has access to the GMainLoop object.\n*\n* @param[in] void *loop The GMainLoop object to quit.\n* @return Should not return\n*/\nint stop_handler(void *loop)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int queryCursor(int fd, int* cols)\n{\n  /* control sequence - report cursor location */\n  fd_printf(fd, \"\\x1b[6n\");\n\n  /* Parse the response: ESC [ rows ; cols R */\n  if (fd_read_char(fd, 100) == 0x1b &&\n    fd_read_char(fd, 100) == '[') {\n\n    int n = 0;\n    while (1) {\n      int ch = fd_read_char(fd, 100);\n      if (ch == ';') {\n        /* Ignore rows */\n        n = 0;\n      }\n      else if (ch == 'R') {\n        /* Got cols */\n        if (n != 0 && n < 1000) {\n          *cols = n;\n        }\n        break;\n      }\n      else if (ch >= 0 && ch <= '9') {\n        n = n * 10 + ch - '0';\n      }\n      else {\n        break;\n      }\n    }\n    return 1;\n  }\n\n  return 0;\n}\n",
        "answer": "/**\n* @brief Query the cursor position.\n*\n* This function queries the current cursor position and stores it in the 'cols' parameter.\n* It returns 1 if successful, or 0 if failed to determine the cursor position.\n*\n* @param fd The file descriptor for the terminal device.\n* @param cols A pointer to an integer where the cursor column will be stored.\n*\n* @return 1 if successful, 0 otherwise.\n*/\n/* control sequence - report cursor location */\n/* Parse the response: ESC [ rows ; cols R */\n/* Ignore rows */\n/* Got cols */\n*cols = n;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int utf8_charlen(int c)\n{\n  if ((c & 0x80) == 0) {\n    return 1;\n  }\n  if ((c & 0xe0) == 0xc0) {\n    return 2;\n  }\n  if ((c & 0xf0) == 0xe0) {\n    return 3;\n  }\n  if ((c & 0xf8) == 0xf0) {\n    return 4;\n  }\n  /* Invalid sequence */\n  return -1;\n}\n",
        "answer": "/** @brief Returns the length of a UTF-8 character sequence.\n*\n* This function takes an integer representing the first byte of a UTF-8 character sequence and returns its length in bytes.\n* The function checks if the input is a valid start byte by checking if it has the most significant bit set to 1, and then proceeds to check if the remaining bits are set correctly according to the UTF-8 encoding rules.\n* If the input is not a valid start byte or the sequence length is greater than 4, the function returns -1.\n* Note that charlen=4 is not supported by the rest of the API.\n*\n* @param c The first byte of the UTF-8 character sequence.\n* @return The length of the character sequence in bytes, or -1 if it is not a valid start byte or the sequence length is greater than 4.\n*/\n/* Invalid sequence */\nreturn -1;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void handle(Event* event) {\n            throw DefaultFlag();\n        }\n",
        "answer": "/** @brief Generic event handler for all events types.\n*\n*  The default implementation does nothing. Implement in subclasses to handle incoming events.\n*\n* @param[in] event A pointer to an Event object.\n* @return Should not return.\n*/\nvirtual void handle(Event* event) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void handle(GameDataEvent* event) {\n            throw GameDataFlag();\n        }\n",
        "answer": "/**\n* @brief Specialized event handler for input events.\n*\n* This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This can be implemented to handle input events only. The default implementation forwards the events to the generic event handler.\n*\n* @param event A pointer to a GameDataEvent object that contains information about the input event.\n*/\nvirtual void handle(GameDataEvent* event) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void checkNoCycleInFollowonChain(const Registry &registry,\n                                        AtomToAtomT &followOnNexts,\n                                        const DefinedAtom *root) {\n  const DefinedAtom *tortoise = root;\n  const DefinedAtom *hare = followOnNexts[root];\n  while (true) {\n    if (!tortoise || !hare)\n      return;\n    if (tortoise == hare)\n      showCycleDetectedError(registry, followOnNexts, tortoise);\n    tortoise = followOnNexts[tortoise];\n    hare = followOnNexts[followOnNexts[hare]];\n  }\n}\n",
        "answer": "/**\n* @brief Check if there's a cycle in a followon chain reachable from the given root atom.\n*\n* Uses the tortoise and hare algorithm to detect a cycle. If a cycle is detected, it will be reported using showCycleDetectedError().\n*\n* @param registry The registry of atoms.\n* @param followOnNexts A map from each atom to its followon chain.\n* @param root The root atom to start the search from.\n*/\nstatic void checkNoCycleInFollowonChain(const Registry &registry, AtomToAtomT &followOnNexts, const DefinedAtom *root) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid prepare() {\n\t\tregister_datastructure_usage(\"datastructure1\", settings.frac1);\n\t\tregister_datastructure_usage(\"datastructure2\", settings.frac2);\n\t}\n",
        "answer": "/** @brief Prepares the kernel for execution.\n*\n*  This method is called before memory assignment but after depending phases have executed and ended. The implementer may use fetch and forward in this phase. The implementer does not have to call the super prepare-method; its default implementation is empty.\n*\n* @param settings The kernel settings.\n*/\nvoid prepare(const KernelSettings& settings) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void memset_pattern4(void *b, const void *pattern, const size_t len)\n{\n    uint32_t *intb = (uint32_t *) b;\n    uint32_t patternValue = *((uint32_t *) pattern);\n    for (size_t i = 0; i < len/4; i++)\n        intb[i] = patternValue;\n}\n",
        "answer": "/** @brief Fills an area of memory with a four-byte pattern pointed to. This is a standard library function on Mac OS X, but sadly not anywhere else, so I'm redefining it here. Because I know where it will be called, I can add additional requirements: len must be a multiple of four, and pattern and b both must be four-byte aligned.\n* @param[in] b The memory area to fill with the pattern.\n* @param[in] pattern The pattern to use for filling the memory area.\n* @param[in] len The length of the memory area to fill.\n*/\nstatic void memset_pattern4(void *b, const void *pattern, const size_t len)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CAResult_t CAIPStartListenServer()\n{\n    OIC_LOG(DEBUG, TAG, \"IN\");\n    CAResult_t ret = CAIPStartMulticastServer(\"0.0.0.0\", IPv4_MULTICAST, IPv4_MULTICAST_PORT);\n    if (CA_STATUS_OK != ret)\n    {\n        OIC_LOG_V(ERROR, TAG, \"Start multicast failed[%d]\", ret);\n    }\n    OIC_LOG(DEBUG, TAG, \"OUT\");\n    return CA_STATUS_OK;\n}\n",
        "answer": "/** @brief Starts receiving multicast traffic.\n*\n*  This function is used to start receiving the multicast traffic in case a sleepy device wants to start back receiving the multicast traffic.\n*\n* @return CA_STATUS_OK if successful, otherwise an appropriate CAResult_t error code\n*/\nCAResult_t CAIPStartListenServer()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "esp_err_t wl_write(wl_handle_t handle, size_t dest_addr, const void *src, size_t size)\r\n{\r\n    esp_err_t result = check_handle(handle, __func__);\r\n    if (result != ESP_OK) {\r\n        return result;\r\n    }\r\n    _lock_acquire(&s_instances[handle].lock);\r\n    result = s_instances[handle].instance->write(dest_addr, src, size);\r\n    _lock_release(&s_instances[handle].lock);\r\n    return result;\r\n}\r\n",
        "answer": "/**\n* @brief Write data to flash.\n*\n* Before writing data to flash, corresponding region of flash needs to be erased. This can be done using wl_erase_range function.\n*\n* @param handle Handle to the flash device.\n* @param dest_addr Destination address in flash where data will be written.\n* @param src Pointer to the source buffer containing data to be written.\n* @param size Size of the data to be written, in bytes.\n* @return ESP_OK on success; otherwise an error code.\n*/\nesp_err_t wl_write(wl_handle_t handle, size_t dest_addr, const void *src, size_t size);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    AccessibleContext getActiveDescendent (const long vmID, const AccessibleContext accessibleContext) {\n\n        if (theWindowsAccessBridge != 0) {\n            return theWindowsAccessBridge->getActiveDescendent(vmID, accessibleContext);\n        }\n        return (AccessibleContext)0;\n    }\n",
        "answer": "/** @brief Returns the Accessible Context of the currently ActiveDescendent of an object.\n*\n*  This function returns the Accessible Context of the currently ActiveDescendent of an object. It takes two parameters, vmID and accessibleContext, which are used to identify the object. If the WindowsAccessBridge is not null, it will call the getActiveDescendent method on the WindowsAccessBridge instance with the given parameters and return the result. Otherwise, it will return (AccessibleContext)0 on error.\n*\n* @param vmID The ID of the virtual machine.\n* @param accessibleContext The Accessible Context of the object.\n* @return The Accessible Context of the currently ActiveDescendent of an object, or (AccessibleContext)0 on error.\n*/\nAccessibleContext getActiveDescendent(const long vmID, const AccessibleContext accessibleContext);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    BOOL getTextAttributesInRange(long vmID, AccessibleContext accessibleContext, int startIndex, int endIndex,\n                                  AccessibleTextAttributesInfo *attributes, short *len) {\n        if (theWindowsAccessBridge != 0) {\n            return theWindowsAccessBridge->getTextAttributesInRange(vmID, accessibleContext,\n                                                                    startIndex, endIndex, attributes, len);\n        }\n        return FALSE;\n    }\n",
        "answer": "/** @brief Get text attributes between two indices. The attribute list includes the text at the start index and the text at the end index. Returns whether successful; Bug ID 4944761 - getTextAttributes between two indices method needed\n*\n* @param vmID The virtual machine identifier.\n* @param accessibleContext The accessible context of the component.\n* @param startIndex The starting index of the range.\n* @param endIndex The ending index of the range.\n* @param attributes The text attributes in the specified range.\n* @param len The length of the attribute list.\n* @return Whether successful or not.\n*/\nBOOL getTextAttributesInRange(long vmID, AccessibleContext accessibleContext, int startIndex, int endIndex,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" esp_err_t nvs_flash_secure_init(nvs_sec_cfg_t* cfg)\n{\n    return nvs_flash_secure_init_partition(NVS_DEFAULT_PART_NAME, cfg);\n}\n",
        "answer": "/** @brief Initializes the default NVS partition.\n*\n*  This API initialises the default NVS partition. The default NVS partition is the one that is labeled \"nvs\" in the partition table.\n*\n* @param cfg A pointer to an nvs_sec_cfg_t structure that contains the security configuration for the NVS partition.\n* @return ESP_OK if successful, or an error code if not.\n*/\nextern \"C\" esp_err_t nvs_flash_secure_init(nvs_sec_cfg_t* cfg)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void audioDeviceAboutToStart(AudioIODevice* device)\r\n  {\r\n    const auto availableBufferSizes = device->getAvailableBufferSizes();\r\n    _numberBuffers = static_cast<size_t>(availableBufferSizes.size());\r\n    _buffers = new float*[_numberBuffers];\r\n    for (const auto bufferSize : availableBufferSizes)\r\n    {\r\n      _bufferSize = std::max(_bufferSize, static_cast<size_t>(bufferSize));\r\n    }\r\n    for (size_t i=0; i<_numberBuffers; ++i)\r\n    {\r\n      _buffers[i] = new float[_bufferSize];\r\n    }\r\n\r\n    _audioSourcePlayer.audioDeviceAboutToStart(device);\r\n    _audioProcessorPlayer.audioDeviceAboutToStart(device);\r\n  }\r\n",
        "answer": "/** @brief Called to indicate that the device is about to start calling back. This will be called just before the audio callbacks begin, either when this callback has just been added to an audio device, or after the device has been restarted because of a sample-rate or block-size change.\n*  @param[in] device The AudioIODevice that is about to start calling back.\n*/\nvirtual void audioDeviceAboutToStart(AudioIODevice* device)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AudioProcessor* JUCE_CALLTYPE createPluginFilter()\r\n{\r\n  return new Processor();\r\n}\r\n",
        "answer": "/** @brief Creates a new instance of the filter subclass.\n*\n* This function is used to test and debug the drivers and will eventually hold the code for the game. Right now, it is a tight while loop.\n*\n* @return A new instance of the Processor class.\n*/\nAudioProcessor* JUCE_CALLTYPE createPluginFilter()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void ecasound_signal_unblock(void)\n{\n#ifdef SIGNALS_CAN_BE_BLOCKED\n  sigset_t sigs;\n  sigemptyset(&sigs);\n  sigaddset(&sigs, SIGTERM);\n  sigaddset(&sigs, SIGINT);\n  sigaddset(&sigs, SIGPIPE);\n  sigaddset(&sigs, SIGQUIT);\n  sigprocmask(SIG_UNBLOCK, &sigs, NULL);\n#endif\n}\n",
        "answer": "/** @brief Unblocks SIGTERM, SIGINT, SIGPIPE and SIGQUIT signals for the calling thread or in case pthread_sigmask() is not supported, for the whole process.\n*\n* @return Should not return\n*/\nstatic void ecasound_signal_unblock(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int kvu_pthread_timed_wait(pthread_mutex_t* mutex, pthread_cond_t* cond, long int seconds)\n{\n   struct timeval now;\n   gettimeofday(&now, 0);\n   struct timespec sleepcount;\n   sleepcount.tv_sec = now.tv_sec + seconds;\n   sleepcount.tv_nsec = now.tv_usec * 1000;\n   int ret = 0;\n\n   /* note: timing race possible here, if condition has already been\n    *       signaled at this point, thus the sleepcount is mandatory */\n    \n   pthread_mutex_lock(mutex);\n   ret = pthread_cond_timedwait(cond, \n\t\t\t\tmutex,\n\t\t\t\t&sleepcount);\n   pthread_mutex_unlock(mutex);\n\n   return(ret);\n}\n",
        "answer": "/**\n* @brief Waits for condition to occur. Note: this model of condition waiting is inherently racy and must be only used in specific cases (not a general solution). The main problem is that the condition is not checked with mutex held before going into pthread_cond_timedwait(), so a condition change may be missed.\n* @param mutex A pointer to a pthread_mutex_t object that will be used to lock the mutex.\n* @param cond A pointer to a pthread_cond_t object that will be used to wait for the condition.\n* @param seconds The number of seconds to wait before timing out.\n* @return 0 if the condition was signaled, ETIMEDOUT if the timeout expired, or an error code if there was an error.\n*/\n/* note: timing race possible here, if condition has already been\n*       signaled at this point, thus the sleepcount is mandatory */\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void cmd(void){\n\tvolatile uint8_t ser = SerialRecv();\n    if(ser != 0){\n        CmdHandler();\n    }\n}\n",
        "answer": "/** @brief Command line console functionality over the primary UART port.\n*\n* This function enables command line console functionality over the primary UART port.\n* It receives data from the serial port and passes it to the CmdHandler() function for processing.\n*\n* @param ser The received data from the serial port.\n* @return None\n*/\nvoid cmd(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VDStringW VDFileResolvePath(const wchar_t *basePath, const wchar_t *pathToResolve) {\r\n\tif (VDFileIsRelativePath(pathToResolve))\r\n\t\treturn VDFileGetCanonicalPath(VDMakePath(basePath, pathToResolve).c_str());\r\n\r\n\treturn VDStringW(pathToResolve);\r\n}\r\n",
        "answer": "/** @brief Resolves a possibly relative path with a given base path. If the path is absolute, the base path is ignored.\n*\n*  This function takes in two string parameters, basePath and pathToResolve, and returns a VDStringW object that represents the resolved path. If the pathToResolve is a relative path, it is appended to the basePath using the VDMakePath() function, and then the resulting path is made canonical using the VDFileGetCanonicalPath() function. If the pathToResolve is an absolute path, the basePath is ignored and the pathToResolve is returned as is.\n*\n* @param[in] basePath The base path to use for resolving the relative path.\n* @param[in] pathToResolve The possibly relative path to resolve.\n* @return A VDStringW object that represents the resolved path.\n*/\nVDStringW VDFileResolvePath(const wchar_t *basePath, const wchar_t *pathToResolve) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int calibrate(int bus)\n{\n\tint ret;\n\tconst char *path = (bus==PX4_I2C_BUS_ONBOARD?HMC5883L_DEVICE_PATH_INT:HMC5883L_DEVICE_PATH_EXT);\n\n\tint fd = open(path, O_RDONLY);\n\n\tif (fd < 0)\n\t\terr(1, \"%s open failed (try 'hmc5883 start' if the driver is not running\", path);\n\n\tif (OK != (ret = ioctl(fd, MAGIOCCALIBRATE, fd))) {\n\t\twarnx(\"failed to enable sensor calibration mode\");\n\t}\n\n\tclose(fd);\n\n\tif (ret == OK) {\n\t\terrx(0, \"PASS\");\n\n\t} else {\n\t\terrx(1, \"FAIL\");\n\t}\n}\n",
        "answer": "/** @brief Automatic scale calibration. Basic idea: output = (ext field +- 1.1 Ga self-test) * scale factor and consequently: 1.1 Ga = (excited - normal) * scale factor scale factor = (excited - normal) / 1.1 Ga sxy = (excited - normal) / 766 | for conf reg. B set to 0x60 / Gain = 3 sz = (excited - normal) / 713 | for conf reg. B set to 0x60 / Gain = 3 By subtracting the non-excited measurement the pure 1.1 Ga reading can be extracted and the sensitivity of all axes can be matched. SELF TEST OPERATION To check the HMC5883L for proper operation, a self test feature in incorporated in which the sensor offset straps are excited to create a nominal field strength (bias field) to be measured. To implement self test, the least significant bits (MS1 and MS0) of configuration register A are changed from 00 to 01 (positive bias) or 10 (negetive bias), e.g. 0x11 or 0x12. Then, by placing the mode register into single-measurement mode (0x01), two data acquisition cycles will be made on each magnetic vector. The first acquisition will be a set pulse followed shortly by measurement data of the external field. The second acquisition will have the offset strap excited (about 10 mA) in the positive bias mode for X, Y, and Z axes to create about a 1.1 gauss self test field plus the external field. The first acquisition values will be subtracted from the second acquisition, and the net measurement will be placed into the data output registers. Since self test adds ~1.1 Gauss additional field to the existing field strength, using a reduced gain setting prevents sensor from being saturated and data registers overflowed. For example, if the configuration register B is set to 0x60 (Gain=3), values around +766 LSB (1.16 Ga * 660 LSB/Ga) will be placed in the X and Y data output registers and around +713 (1.08 Ga * 660 LSB/Ga) will be placed in Z data output register. To leave the self test mode, change MS1 and MS0 bit of the configuration register A back to 00 (Normal Measurement Mode), e.g. 0x10. Using the self test method described above, the user can scale sensor\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int srt_epoll_wait(\n\t\tint eid,\n\t\tSRTSOCKET* readfds, int* rnum, SRTSOCKET* writefds, int* wnum,\n\t\tint64_t msTimeOut,\n        SYSSOCKET* lrfds, int* lrnum, SYSSOCKET* lwfds, int* lwnum)\n{\n    return UDT::epoll_wait2(\n    \t\teid,\n    \t\treadfds, rnum, writefds, wnum,\n    \t\tmsTimeOut,\n    \t\tlrfds, lrnum, lwfds, lwnum);\n}\n",
        "answer": "/** @brief Wait for events on a set of sockets.\n*\n*  This function waits for events on a set of sockets and returns the ones that are ready.\n*  It can be used to wait for read, write, or both types of events.\n*\n* @param eid The epoll instance ID.\n* @param readfds A pointer to a set of SRTSOCKETs to check for read events.\n* @param rnum A pointer to an integer that will be filled with the number of sockets ready for reading.\n* @param writefds A pointer to a set of SRTSOCKETs to check for write events.\n* @param wnum A pointer to an integer that will be filled with the number of sockets ready for writing.\n* @param msTimeOut The maximum time to wait for events, in milliseconds.\n* @param lrfds A pointer to a set of SYSSOCKETs to check for read events.\n* @param lrnum A pointer to an integer that will be filled with the number of sockets ready for reading.\n* @param lwfds A pointer to a set of SYSSOCKETs to check for write events.\n* @param lwnum A pointer to an integer that will be filled with the number of sockets ready for writing.\n* @return The number of sockets that are ready, or -1 if there was an error.\n*/\nint srt_epoll_wait("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Boolean_t ArrayListIsValid(ArrayList_pa ArrayList)\n{\n    Boolean_t IsValid;\n\n    /* this just makes sure that the NULL item global was initialized */\n    INVARIANT(ArrayListNullItem.Double == 0.0);\n\n    IsValid = (VALID_REF(ArrayList) &&\n               VALID_ENUM(ArrayList->Type, ArrayListType_e) &&\n               (1 <= ArrayList->ItemSize &&\n                ArrayList->ItemSize <= (SmInteger_t)sizeof(ArrayListItem_u)) &&\n               (0 <= ArrayList->Count &&\n                ArrayList->Count <= ArrayList->Capacity));\n\n    ENSURE(VALID_BOOLEAN(IsValid));\n    return IsValid;\n}\n",
        "answer": "/** @brief Determine if the list handle is sane.\n*\n*  This function determines if the array list is valid or not.\n*\n* @param ArrayList Array list in question.\n* @return TRUE if the array list is valid, otherwise FALSE.\n*/\n/* this just makes sure that the NULL item global was initialized */\nINVARIANT(ArrayListNullItem.Double == 0.0);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ArrayListItem_u ArrayListRemoveItem(ArrayList_pa ArrayList,\n                                    LgIndex_t    ItemOffset)\n{\n    ArrayListItem_u Result;\n\n    REQUIRE(ArrayListIsValid(ArrayList));\n    REQUIRE(0 <= ItemOffset && ItemOffset <= ArrayList->Count - 1);\n    REQUIRE(!ArrayList->IsVisitingItems);\n\n    /* record the original item */\n    CopyArrayItems((char *)&Result, 0,\n                   ArrayList->Array, ItemOffset,\n                   1, ArrayList->ItemSize);\n\n    /* delete the item from the array */\n    ArrayListDeleteItems(ArrayList, ItemOffset, 1, NULL, 0);\n\n    ENSURE(ArrayListIsValid(ArrayList));\n    return Result;\n}\n",
        "answer": "/** @brief Removes an item from the array list.\n*\n* This function removes an item from the array list at a given offset. The members following the item removed are shifted down accordingly to fill the vacated space.\n*\n* @param ArrayList Array list containing the item to remove.\n* @param ItemOffset Offset to the item in the list.\n* @return Item removed from the array list.\n*/\n/* record the original item */\n/* delete the item from the array */\nArrayListDeleteItems(ArrayList, ItemOffset, 1, NULL, 0);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Boolean_t AuxDataIsValidNameChar(char      Char,\n                                 Boolean_t IsLeadChar)\n{\n    Boolean_t IsValidNameChar;\n\n    REQUIRE(\"Char can be any value\");\n    REQUIRE(VALID_BOOLEAN(IsLeadChar));\n\n    IsValidNameChar = (Char == '_' ||\n                       isalpha(Char));\n    if (!IsLeadChar)\n        IsValidNameChar = (IsValidNameChar ||\n                           Char == '.'     ||\n                           isdigit(Char));\n\n    ENSURE(VALID_BOOLEAN(IsValidNameChar));\n    return IsValidNameChar;\n}\n",
        "answer": "/**\n* @brief Checks if a character is valid as an auxiliary data name character.\n*\n* A valid auxiliary data name character must begin with a '_' or alpha character and may be followed by one or more '_', '.', alpha or digit characters.\n*\n* @param Char The character to check.\n* @param IsLeadChar Whether the character is the first character of the name.\n* @return True if the character is valid, false otherwise.\n*/\nBoolean_t AuxDataIsValidNameChar(char Char, Boolean_t IsLeadChar) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AuxData_pa AuxDataAlloc(void)\n{\n    AuxData_pa Result = ALLOC_ITEM(AuxData_s, \"auxiliary data container\");\n    if (Result != NULL)\n    {\n        Result->ItemList = ArrayListAlloc(0, ArrayListType_VoidPtr, NULL, 0);\n        if (Result->ItemList == NULL)\n            AuxDataDealloc(&Result);\n    }\n\n    ENSURE(VALID_REF(Result) || Result == NULL);\n    return Result;\n}\n",
        "answer": "/**\n* @brief Allocates an auxiliary data handle.\n*\n* This function allocates a new auxiliary data handle and initializes it with default values.\n*\n* @return Auxiliary data handle or NULL if sufficient memory was not available.\n*/\nAuxData_pa AuxDataAlloc(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void FieldDataDeallocData(FieldData_pa FieldData)\n{\n    REQUIRE(VALID_REF(FieldData));\n\n#if defined TECPLOTKERNEL\n/* CORE SOURCE CODE REMOVED */\n#endif\n        if (FieldData->Data != NULL)\n        {\n            /* Hack to remove 'deleting void* is undefined' warning... */\n            char *Tmp = (char *)FieldData->Data;\n            FREE_ARRAY(Tmp, \"FieldData _Data\");\n            FieldData->Data = NULL;\n        }\n\n#if defined TECPLOTKERNEL\n/* CORE SOURCE CODE REMOVED */\n#endif\n\n    ENSURE(FieldData->Data == NULL);\n}\n",
        "answer": "/** @brief Deallocates the data stored in a FieldData object.\n*\n*  This function deallocates the memory used to store the data in a FieldData object. It is intended for internal use by Tecplot and should not be called directly by most clients. An exception to this would be Tecplot's own storable load-on-demand functions.\n*\n*  @param[in] FieldData A pointer to the FieldData object whose data will be deallocated.\n*\n*  @return None.\n*/\n/* CORE SOURCE CODE REMOVED */\n/* Hack to remove 'deleting void* is undefined' warning... */\n/* CORE SOURCE CODE REMOVED */\n#endif"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static Boolean_t AuxDataIsValidNameChar(char      Char,\n                                        Boolean_t IsLeadChar)\n{\n    Boolean_t IsValidNameChar;\n\n    REQUIRE(0 <= Char && \"Char <= 127\");\n    REQUIRE(VALID_BOOLEAN(IsLeadChar));\n\n    IsValidNameChar = (Char == '_' ||\n                       isalpha(Char));\n    if (!IsLeadChar)\n        IsValidNameChar = (IsValidNameChar ||\n                           Char == '.'     ||\n                           isdigit(Char));\n\n    ENSURE(VALID_BOOLEAN(IsValidNameChar));\n    return IsValidNameChar;\n}\n",
        "answer": "/**\n* @brief Checks if a character is valid for an auxiliary data name.\n*\n* A valid auxiliary data name character must begin with a '_' or alpha character and may be followed by one or more '_', '.', alpha or digit characters.\n*\n* @param Char The character to check.\n* @param IsLeadChar Whether the character is the first character of the name.\n* @return True if the character is valid, false otherwise.\n*/\nstatic Boolean_t AuxDataIsValidNameChar(char Char, Boolean_t IsLeadChar)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int PipeAndFork ( bool, bool )\t{ return -1; }\n",
        "answer": "/** @brief Create a new worker child and perform post-fork work in the child.\n*\n*  This function creates a pipe to the child process, forks, and performs some post-fork work in the child. It returns the write-end pipe file descriptor (which may be -1!) and sets g_bHeadDaemon to false in the parent. In the child, it returns -1 and leaves g_bHeadDaemon unaffected.\n*\n* @param bool A boolean value indicating whether or not to perform post-fork work in the child.\n* @param bool A boolean value indicating whether or not to set g_bHeadDaemon to false in the parent.\n* @return The write-end pipe file descriptor (which may be -1!) if successful, otherwise -1.\n*/\nint PipeAndFork(bool postForkWork, bool setGHeadDaemon) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void dumpModelTree( const QAbstractItemModel * model,\n\t\t\tconst QModelIndex\t & index,\n\t\t\tconst QString\t\t & indent )\n    {\n\tint rowCount = model->rowCount( index );\n\tQVariant data = model->data( index, Qt::DisplayRole );\n\n\tif ( data.isValid() )\n\t{\n\t    if ( rowCount > 0 )\n\t\tlogDebug() << indent << data.toString() << \": \" << rowCount << \" rows\" << endl;\n\t    else\n\t\tlogDebug() << indent << data.toString() << endl;\n\t}\n\telse\n\t{\n\t    logDebug() << \"<No data> \" << rowCount << \" rows\" << endl;\n\t}\n\n\tfor ( int row=0; row < rowCount; row++ )\n\t{\n\t    QModelIndex childIndex = model->index( row, 0, index );\n\t    Debug::dumpModelTree( model, childIndex, indent + QString( 4, ' ' ) );\n\t}\n    }\n",
        "answer": "/** @brief Recursively dump the model tree from 'index' on to the log. Indent each line with 'indent' (typically a string consisting of blanks).\n*\n*  This function recursively dumps the model tree starting at the given index, indenting each line with the specified indent string. It is used for debugging purposes.\n*\n* @param model The QAbstractItemModel to dump.\n* @param index The root index of the subtree to dump.\n* @param indent The string to use for indentation.\n*/\nvoid dumpModelTree( const QAbstractItemModel * model,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int EASTLTest_CheckMemory_Imp(const char* pFile, int nLine)\n{\n\tint  nErrorCount(0);\n\tbool bMemoryOK(true);\n\n\t#if defined(_DEBUG) && (defined(EA_COMPILER_MSVC) && defined(EA_PLATFORM_MICROSOFT))\n\t\tif(!_CrtCheckMemory())\n\t\t\tbMemoryOK = false;\n\t#endif\n\n\t#ifdef EA_DEBUG\n\t\tif(!EASTLTest_ValidateHeap())\n\t\t\tbMemoryOK = false;\n\t#endif\n\n\tif(!bMemoryOK)\n\t{\n\t\tnErrorCount++;\n\t\tEASTLTest_Printf(\"Memory check failure:\\n%s: line %d\\n\\n\", pFile, nLine);\n\t}\n\n\treturn nErrorCount;\n}\n",
        "answer": "/** @brief EASTLTest_CheckMemory Does a global memory heap validation check. Returns 0 if OK and an error count if there is a problem. Example usage: EASTLTest_CheckMemory();\n*/\nint EASTLTest_CheckMemory(const char* pFile, int nLine)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void add_gtfs_comment(GtfsData& gtfs_data, Data& data, const T& obj, const std::string& comment) {\n    std::string& comment_id = gtfs_data.comments_id_map[comment];\n    if (comment_id.empty()) {\n        comment_id = \"comment__\" + boost::lexical_cast<std::string>(gtfs_data.comments_id_map.size());\n    }\n    data.add_pt_object_comment(obj, comment_id);\n\n    data.comment_by_id[comment_id] = comment;\n}\n",
        "answer": "/** @brief Adds a GTFS comment to the given object.\n*\n*  This function adds a comment to the given object in the GTFS data, using the provided comment string.\n*  If the comment is not already present in the comments ID map, it will be added with a new ID generated using the size of the map.\n*  The function also updates the comment by ID map with the new comment.\n*\n* @param gtfs_data The GTFS data object to which the comment should be added.\n* @param data The data object to which the comment should be added.\n* @param obj The object to which the comment should be added.\n* @param comment The comment string to add.\n*/\nvoid add_gtfs_comment(GtfsData& gtfs_data, Data& data, const T& obj, const std::string& comment) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ga_conf_reset() {\n\tga_vmi = ga_vars.begin();\n}\n",
        "answer": "/** @brief Reset the global runtime configuration iteration pointer.\n*\n*  This function is used to enumerate all runtime configurations.\n*\n* @return Should not return\n*/\nvoid ga_conf_reset() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id)\n{\n    UniValue request(UniValue::VOBJ);\n    request.pushKV(\"method\", strMethod);\n    request.pushKV(\"params\", params);\n    request.pushKV(\"id\", id);\n    return request;\n}\n",
        "answer": "/** @brief Creates a JSON-RPC request object.\n*\n*  This function creates a JSON-RPC request object with the specified method, parameters, and ID.\n*\n* @param strMethod The name of the RPC method to call.\n* @param params The parameters for the RPC method.\n* @param id The ID of the RPC request.\n* @return A JSON-RPC request object with the specified method, parameters, and ID.\n*/\nUniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool Validate(const std::string& sim_filename,\n              const std::string& ref_filename,\n              ChNormType         norm_type,\n              double             tolerance,\n              DataVector&        norms\n              )\n{\n  ChValidation validator;\n\n  if (!validator.Process(sim_filename, ref_filename))\n    return false;\n\n  size_t num_cols = validator.GetNumColumns() - 1;\n  norms.resize(num_cols);\n\n  switch (norm_type) {\n  case L2_NORM:  norms = validator.GetL2norms(); break;\n  case RMS_NORM: norms = validator.GetRMSnorms(); break;\n  case INF_NORM: norms = validator.GetINFnorms(); break;\n  }\n\n  for (size_t col = 0; col < num_cols; col++) {\n    if (norms[col] > tolerance)\n      return false;\n  }\n\n  return true;\n}\n",
        "answer": "/** @brief Validate the data in two specified files.\n*\n* This function compares the data in the two specified files and returns true if the norms of all column differences are below the given tolerance. It is assumed that the input files are TAB-delimited.\n*\n* @param sim_filename The name of the file containing the simulation data.\n* @param ref_filename The name of the file containing the reference data.\n* @param norm_type The type of norm to use for the comparison (L2, RMS, or INF).\n* @param tolerance The maximum allowed value for the norms.\n* @param norms A vector containing the calculated norms for each column.\n* @return True if all norms are below the given tolerance, false otherwise.\n*/\nbool Validate(const std::string& sim_filename,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int bson_copy( bson *out, const bson *in ) {\n\tif ( !out ) return BSON_ERROR;\n\tif ( !in->finished ) return BSON_ERROR;\n\tbson_init_size( out, bson_size( in ) );\n\tmemcpy( out->data, in->data, bson_size( in ) );\n\tout->finished = 1;\n\n\treturn BSON_OK;\n}\n",
        "answer": "/** @brief Copies a BSON object.\n*\n*  This function makes a complete copy of the source bson object. The source bson object must be in a finished state; otherwise, the copy will fail.\n*\n* @param out The destination bson object.\n* @param in The source bson object.\n* @return BSON_OK if successful, BSON_ERROR if not.\n*/\nint bson_copy( bson *out, const bson *in ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bson_bool_t bson_iterator_bool_raw( const bson_iterator *i ) {\n\treturn bson_iterator_value( i )[0];\n}\n",
        "answer": "/** @brief Get the bson_bool_t value of the BSON object currently pointed to by the iterator. Assumes the correct type is used.\n*\n*  This function returns the bson_bool_t value of the BSON object currently pointed to by the iterator. It assumes that the correct type is being used and does not perform any validation checks.\n*\n* @param i A pointer to a bson_iterator structure representing the current position in the BSON object.\n*\n* @return The bson_bool_t value of the BSON object currently pointed to by the iterator.\n*/\nbson_bool_t bson_iterator_bool_raw( const bson_iterator *i ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t countTrianglesInFrustum(Node * root, const Geometry::Frustum & frustum) {\n\tconst auto geoNodes = collectNodesInFrustum<GeometryNode>(root, frustum);\n\tuint32_t triangleCount = 0;\n\tfor(const auto & geoNode : geoNodes) {\n\t\ttriangleCount += geoNode->getTriangleCount();\n\t}\n\treturn triangleCount;\n}\n",
        "answer": "/** @brief Count the number of triangles in a geometry node subtree that intersect with a given frustum.\n*\n*  This function starts at the root node and traverses down the tree, collecting all geometry nodes that are within the bounding box of the frustum. It then iterates over these nodes and sums up their triangle counts to return the total number of triangles in the subtree that intersect with the frustum.\n*\n* @param root The root node of the geometry node subtree to count triangles in.\n* @param frustum The frustum to test for intersection with the geometry nodes.\n* @return The total number of triangles in the subtree that intersect with the given frustum.\n*/\nuint32_t countTrianglesInFrustum(Node * root, const Geometry::Frustum & frustum) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void configParserError(void)\n{\n    CSFLogError( logTag, \"In configParserError\");\n}\n",
        "answer": "/** @brief Config parser error.\n*\n*  This function notifies the config manager that the config file has an error and a new config file needs to be downloaded. The error could be XML format error or minimum config not being present in the config file. It is expected that this will result in processing of the config file after the config managers response is received.\n*\n* @return Should not return\n*/\nvoid configParserError(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "plat_soc_connect_status_e platSecSockIsConnected (cpr_socket_t sock) {\n    return PLAT_SOCK_CONN_OK;\n}\n",
        "answer": "/** @brief Determine the status of a secure connection that was initiated in non-blocking mode.\n*\n* This function determines the status of a secure connection that was initiated in non-blocking mode.\n* It returns an enum value indicating the current status of the connection.\n*\n* @param sock The socket for which to check the connection status.\n*\n* @return PLAT_SOCK_CONN_OK if the connection is established, PLAT_SOCK_CONN_INPROGRESS if the connection is still in progress, or an error code otherwise.\n*/\nplatSecSockIsConnected(cpr_socket_t sock) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool fatalError( const QXmlParseException &exception )\n    {\n      err(\"fatal: at line %d column %d of %s: %s\\n\",\n          exception.lineNumber(),exception.columnNumber(),fileName.data(),\n          exception.message().data());\n      return FALSE;\n    }\n",
        "answer": "/** @brief fatalError() function.\n*\n*  This function is used to handle fatal errors that occur during parsing.\n*  It prints an error message to the console and returns FALSE, indicating\n*  that the parser should not continue.\n*\n* @param exception The QXmlParseException object containing information about the error.\n* @return FALSE, indicating that the parser should not continue.\n*/\nbool fatalError(const QXmlParseException &exception)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QCString generateMarker(int id)\n{\n  const int maxMarkerStrLen = 20;\n  char result[maxMarkerStrLen];\n  qsnprintf(result,maxMarkerStrLen,\"@%d\",id);\n  return result;\n}\n",
        "answer": "/** @brief Generate a place holder for a position in a list. Used for translators to be able to specify different elements orders depending on whether text flows from left to right or visa versa.\n*\n* @param id The ID of the marker to generate.\n* @return A string representing the marker with the given ID.\n*/\nQCString generateMarker(int id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC int\tSDLCALL SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained){\r\n\t*obtained = *desired;\r\n\tmixerCallBack = desired->callback;\r\n\tint bufSize = Android_OpenAudio(desired->freq, desired->channels, 1, desired->samples << 2);\r\n\r\n\tif (bufSize == 0)\r\n\t\treturn -1;\r\n\r\n\tobtained->samples = bufSize >> 2;\r\n\tAndroid_AudioGetBuffer();\r\n\r\n\treturn 0;\r\n}\r\n",
        "answer": "/** @brief Opens the audio device with desired parameters and returns 0 if successful.\n*\n* This function opens the audio device with the desired parameters, and returns 0 if successful, placing the actual hardware parameters in the structure pointed to by 'obtained'. If 'obtained' is NULL, the audio data passed to the callback function will be guaranteed to be in the requested format, and will be automatically converted to the hardware audio format if necessary. This function returns -1 if it failed to open the audio device, or couldn't set up the audio thread. The audio device starts out playing silence when it's opened, and should be enabled for playing by calling SDL_PauseAudio(0) when you are ready for your audio callback function to be called. Since the audio driver may modify the requested size of the audio buffer, you should allocate any local mixing buffers after you open the audio device.\n* @param desired The desired audio specification.\n* @param obtained The obtained audio specification.\n* @return 0 if successful, -1 if failed to open the audio device or couldn't set up the audio thread.\n*/\n*obtained = *desired;\nmixerCallBack = desired->callback;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC int SDLCALL SDL_ShowCursor(int toggle){return SDL_ENABLE;}\r\n",
        "answer": "/** @brief Toggle whether or not the cursor is shown on the screen.\n*\n*  The cursor start off displayed, but can be turned off. SDL_ShowCursor() returns 1 if the cursor was being displayed before the call, or 0 if it was not. You can query the current state by passing a 'toggle' value of -1.\n*\n* @param toggle An integer indicating whether to show (1) or hide (0) the cursor. A value of -1 will return the current state without changing it.\n* @return 1 if the cursor was being displayed before the call, or 0 if it was not.\n*/\nextern DECLSPEC int SDLCALL SDL_ShowCursor(int toggle)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern DECLSPEC void SDLCALL SDL_Quit (void){}\r\n",
        "answer": "/** @brief Cleans up all initialized subsystems and unloads the dynamically linked library.\n*\n*  This function cleans up all initialized subsystems and unloads the dynamically linked library. You should call it upon all exit conditions.\n*\n* @return Should not return\n*/\nvoid SDL_Quit(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_dirble_play_category (tiz_dirble_t *ap_dirble,\n                                         const char *ap_category)\n{\n  assert (ap_dirble);\n  assert (ap_dirble->p_proxy_);\n  return ap_dirble->p_proxy_->play_category (ap_category);\n}\n",
        "answer": "/** @brief Search Dirble for a category and add matching stations to the playback queue.\n*\n* This method searches Dirble for a given category and adds all matching stations to the playback queue.\n* After calling this method, the various tiz_dirble_get* methods can be used to interact with the playback queue.\n*\n* @param ap_dirble A pointer to the tiz_dirble_t structure representing the Dirble instance.\n* @param ap_category The category to search for.\n*\n* @return 0 on success, -1 on failure.\n*/\nextern \"C\" int tiz_dirble_play_category (tiz_dirble_t *ap_dirble, const char *ap_category)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_gmusic_play_artist (tiz_gmusic_t *ap_gmusic,\n                                       const char *ap_artist,\n                                       const bool a_unlimited_search)\n{\n  assert (ap_gmusic);\n  assert (ap_gmusic->p_proxy_);\n  return ap_gmusic->p_proxy_->play_artist (ap_artist, a_unlimited_search);\n}\n",
        "answer": "/** @brief Add the tracks of the specified artist to the playback queue.\n*\n*  This function adds the tracks of the specified artist to the playback queue. After calling this method, the various tiz_gmusic_get* methods can be used to interact with the playback queue.\n*\n* @param ap_gmusic A pointer to a tiz_gmusic_t object that represents the Google Music player.\n* @param ap_artist The name of the artist whose tracks should be added to the playback queue.\n* @param a_unlimited_search If true, search for the artist's tracks without any limits.\n*\n* @return 0 on success, -1 on failure.\n*/\nextern \"C\" int tiz_gmusic_play_artist (tiz_gmusic_t *ap_gmusic, const char *ap_artist, const bool a_unlimited_search)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_gmusic_play_podcast (tiz_gmusic_t *ap_gmusic,\n                                      const char *ap_podcast)\n{\n  assert (ap_gmusic);\n  assert (ap_gmusic->p_proxy_);\n  return ap_gmusic->p_proxy_->play_podcast (ap_podcast);\n}\n",
        "answer": "/** @brief Adds the tracks of a specified podcast to the playback queue.\n*\n* This function adds the tracks of a specified podcast to the playback queue, allowing the user to interact with them using various tiz_gmusic_get* methods.\n*\n* @param ap_gmusic A pointer to a tiz_gmusic_t object that represents the Google Music player.\n* @param ap_podcast The name of the podcast to be played.\n*\n* @return An integer representing the result of the operation. 0 indicates success, while any other value indicates failure.\n*/\nextern \"C\" int tiz_gmusic_play_podcast (tiz_gmusic_t *ap_gmusic, const char *ap_podcast)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_scloud_play_user_stream (tiz_scloud_t *ap_scloud)\n{\n  assert (ap_scloud);\n  assert (ap_scloud->p_proxy_);\n  return ap_scloud->p_proxy_->play_user_stream ();\n}\n",
        "answer": "/** @brief Add the tracks in the user's stream to the playback queue.\n*\n* This function adds the tracks in the user's stream to the playback queue. After calling this method, the various tiz_scloud_get* methods can be used to interact with the playback queue.\n*\n* @param ap_scloud The scloud object.\n* @return Should not return.\n*/\nextern \"C\" int tiz_scloud_play_user_stream (tiz_scloud_t *ap_scloud)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_scloud_play_playlists (tiz_scloud_t *ap_scloud,\n                                          const char *ap_playlists)\n{\n  assert (ap_scloud);\n  assert (ap_scloud->p_proxy_);\n  return ap_scloud->p_proxy_->play_playlists (ap_playlists);\n}\n",
        "answer": "/** @brief Search SoundCloud for playlists and add them to the playback queue.\n*\n*  This function searches SoundCloud for playlists based on a given query string,\n*  and adds them to the playback queue. After calling this method, the various\n*  tiz_scloud_get* methods can be used to interact with the playback queue.\n*\n* @param ap_scloud A pointer to a tiz_scloud_t object that represents the SoundCloud\n*                  client.\n* @param ap_playlists The query string to search for playlists on SoundCloud.\n*\n* @return An integer representing the result of the operation. A value of 0 indicates\n*         success, while a non-zero value indicates failure.\n*/\nextern \"C\" int tiz_scloud_play_playlists (tiz_scloud_t *ap_scloud, const char *ap_playlists)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_spotify_play_album (tiz_spotify_t *ap_spotify,\n                                       const char *ap_album)\n{\n  assert (ap_spotify);\n  assert (ap_spotify->p_proxy_);\n  return ap_spotify->p_proxy_->play_album (ap_album);\n}\n",
        "answer": "/** @brief Search Spotify for an album and add all its tracks to the playback queue.\n*\n*  This function searches Spotify for an album and adds all its tracks to the playlist queue.\n*  After calling this method, the various tiz_spotify_get* methods can be used to interact with the playback queue.\n*\n* @param ap_spotify A pointer to a tiz_spotify_t object that represents the Spotify client.\n* @param ap_album The name of the album to search for.\n*\n* @return 0 if successful, -1 otherwise.\n*/\nextern \"C\" int tiz_spotify_play_album (tiz_spotify_t *ap_spotify, const char *ap_album)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_spotify_play_playlist_by_id (tiz_spotify_t *ap_spotify,\n                                                const char *ap_playlist_id,\n                                                const char *ap_owner)\n{\n  assert (ap_spotify);\n  assert (ap_spotify->p_proxy_);\n  return ap_spotify->p_proxy_->play_playlist_id (ap_playlist_id, ap_owner);\n}\n",
        "answer": "/** @brief Add a playlist tracks to the playback queue using a Spotify playlist ID, URI, or URL.\n*\n*  This function adds a playlist tracks to the playback queue using a Spotify playlist ID, URI, or URL. After calling this method, the various tiz_spotify_get* methods can be used to interact with the playback queue.\n*\n* @param ap_spotify The Spotify object.\n* @param ap_playlist_id The Spotify playlist ID.\n* @param ap_owner The owner of the playlist.\n* @return Should not return\n*/\nextern \"C\" int tiz_spotify_play_playlist_by_id (tiz_spotify_t *ap_spotify, const char *ap_playlist_id, const char *ap_owner)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_spotify_play_recommendations_by_artist_id (\n    tiz_spotify_t *ap_spotify, const char *ap_artist_id)\n{\n  assert (ap_spotify);\n  assert (ap_spotify->p_proxy_);\n  return ap_spotify->p_proxy_->play_recommendations_by_artist_id (ap_artist_id);\n}\n",
        "answer": "/** @brief Play Spotify recommendations by artist ID, URI, or URL and add artists to the playback queue.\n*\n*  This function plays Spotify recommendations by artist ID, URI, or URL and adds artists to the playback queue. After calling this method, the various tiz_spotify_get* methods can be used to interact with the playback queue.\n*\n* @param ap_spotify The Spotify context.\n* @param ap_artist_id The artist ID to play recommendations for.\n*\n* @return 0 on success, non-zero error code on failure.\n*/\nextern \"C\" int tiz_spotify_play_recommendations_by_artist_id (tiz_spotify_t *ap_spotify, const char *ap_artist_id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" int tiz_youtube_play_audio_search (tiz_youtube_t *ap_youtube,\n                                              const char *ap_search)\n{\n  assert (ap_youtube);\n  assert (ap_youtube->p_proxy_);\n  return ap_youtube->p_proxy_->play_audio_search (ap_search);\n}\n",
        "answer": "/** @brief Add all the audio streams of a YouTube search to the playback queue.\n*\n* This function adds all the audio streams of a YouTube search to the playlist queue.\n* After calling this method, the various tiz_youtube_get* methods can be used to interact with the playback queue.\n*\n* @param ap_youtube The YouTube object.\n* @param ap_search The search string.\n*\n* @return 0 on success, -1 on failure.\n*/\nextern \"C\" int tiz_youtube_play_audio_search (tiz_youtube_t *ap_youtube, const char *ap_search)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void buffer_line_to_current_position() {\n  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);\n}\n",
        "answer": "/** @brief Move the planner to the current position from wherever it last moved (or from wherever it has been told it is located).\n*\n*  This function moves the planner to the current position from wherever it last moved (or from wherever it has been told it is located).\n*\n* @param current_position The current position of the planner.\n* @param feedrate_mm_s The feedrate of the planner in mm/s.\n* @param active_extruder The active extruder for the planner.\n* @return void\n*/\nvoid buffer_line_to_current_position(float current_position[XYZE], float feedrate_mm_s, uint8_t active_extruder) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static float _baseline(YGNodeRef node, const float width, const float height) {\n  float* baseline = (float*)node->getContext();\n  return *baseline;\n}\n",
        "answer": "/** @brief Baseline function for Yoga nodes.\n*\n* This function is used to retrieve the baseline value for a given Yoga node.\n* The baseline value is stored in the context of the node and is retrieved using the getContext() method.\n*\n* @param[in] node The Yoga node for which the baseline should be retrieved.\n* @param[in] width The width of the node.\n* @param[in] height The height of the node.\n*\n* @return The baseline value for the given node.\n*/\nstatic float _baseline(YGNodeRef node, const float width, const float height) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool transitionIsCut(obs_source_t* transition) {\n\tif (!transition)\n\t\treturn false;\n\n\tif (obs_source_get_type(transition) == OBS_SOURCE_TYPE_TRANSITION\n\t\t&& QString(obs_source_get_id(transition)) == \"cut_transition\") {\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "answer": "/** @brief Determines if a transition is a cut.\n*\n* This function checks the type of the transition and its ID to determine if it is a cut transition.\n* If the transition is not valid or its type is not OBS_SOURCE_TYPE_TRANSITION, false will be returned.\n* Otherwise, true will be returned if the transition's ID matches \"cut_transition\".\n*\n* @param transition The transition to check.\n* @return True if the transition is a cut, false otherwise.\n*/\nbool transitionIsCut(obs_source_t* transition) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void _condor_file_table_init()\n{\n\tif(!FileTab) {\n\t\tFileTab = new CondorFileTable();\n\t\tFileTab->init();\n\t}\n}\n",
        "answer": "/** @brief Set up the file table if necessary.\n*\n*  Calling this function multiple times is harmless. All system calls that access FileTab should call this function first.\n*\n* @return Should not return\n*/\nvoid _condor_file_table_init()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void setUp()\n        {\n            _loop.setIdleTimeout(2000);\n            connect(_loop.timeout, *this, &BinRpcTest::failTest);\n            connect(_loop.timeout, _loop, &cxxtools::EventLoop::exit);\n\n            _server = new cxxtools::bin::RpcServer(_loop, _port);\n            _server->minThreads(1);\n        }\n",
        "answer": "/** @brief Initializes required resources before each tester function is invoked.\n*\n*  This function is called before each registered tester function is invoked. It is meant to initialize any required resources.\n*\n* @return Should not return\n*/\nvoid setUp()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void setUp()\n        {\n            _server = new cxxtools::http::Server(_loop, _port);\n            _server->minThreads(1);\n        }\n",
        "answer": "/** @brief Set up the server.\n*\n*  This function is called before each registered tester function is invoked. It is meant to initialize any required resources.\n*\n* @param[in] _loop The event loop.\n* @param[in] _port The port number.\n* @return Should not return\n*/\nvoid setUp(cxxtools::EventLoop *_loop, int _port)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static dynamic shuffleMacro(Context&& ctx) {\n    auto array = ctx.expandRawArg(\"dictionary\");\n    checkLogic(array.isArray(), \"Shuffle: argument must be an array\");\n\n    static thread_local std::minstd_rand defaultEngine(\n        folly::randomNumberSeed());\n\n    if (auto seedArg = ctx.tryExpandRawArg(\"seed\")) {\n      checkLogic(\n          seedArg->isInt() && seedArg->getInt() >= 0,\n          \"Shuffle: seed must be a non-negative integer\");\n      auto seed = static_cast<uint32_t>(seedArg->getInt());\n      std::minstd_rand seededEngine(seed);\n      std::shuffle(array.begin(), array.end(), seededEngine);\n      return array;\n    }\n\n    std::shuffle(array.begin(), array.end(), defaultEngine);\n    return array;\n  }\n",
        "answer": "/** @brief Shuffles a list randomly.\n*\n* This function takes in a list and optionally a seed, and returns the shuffled list.\n* The shuffle is done using the std::shuffle algorithm from the C++ standard library.\n* If no seed is provided, a default engine with a random seed is used.\n*\n* @param ctx The context in which the function is called.\n* @return The shuffled list.\n*/\nstatic dynamic shuffleMacro(Context&& ctx) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool determineIfSampleKeyForViolet(\n    uint32_t routingKeyHash,\n    uint32_t sample_period) {\n  assert(sample_period > 0);\n  const uint32_t m = std::numeric_limits<uint32_t>::max();\n  uint32_t keyHashMax = m / sample_period;\n\n  return routingKeyHash <= keyHashMax;\n}\n",
        "answer": "/** @brief Determines if a given hash is within a range for violet.\n*\n* This function checks if the given hash is within a range, which is used for probabilistic decisions, like stats sampling. The range is from 0 to (MAX(uint32_t)/sample_rate) Used for probabilistic decisions, like stats sampling.\n* @param routingKeyHash The hash to be checked.\n* @param sample_period The sample period used to determine the range.\n* @return True if the hash is within the range, false otherwise.\n*/\nbool determineIfSampleKeyForViolet(uint32_t routingKeyHash, uint32_t sample_period) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void log(\n    folly::StringPiece file,\n    int line,\n    folly::StringPiece service,\n    folly::StringPiece category,\n    folly::StringPiece msg) {\n  std::map<std::string, std::string> contexts;\n  std::vector<std::pair<std::string, HandlerFunc>> handlers;\n  if (auto container = containerSingleton.try_get()) {\n    std::lock_guard<std::mutex> lock(container->lock);\n    contexts = container->contexts;\n    handlers = container->handlers;\n  }\n  for (auto& handler : handlers) {\n    handler.second(file, line, service, category, msg, contexts);\n  }\n}\n",
        "answer": "/** @brief Log failure according to action for given category.\n*\n* This function logs a failure message according to the specified action and category. If no special action is provided, the default constructed one will be used.\n*\n* @param file The name of the source code file where the log message originated.\n* @param line The line number in the source code file where the log message originated.\n* @param service The name of the service that generated the log message.\n* @param category The category of the log message (e.g., \"error\", \"warning\", etc.).\n* @param msg The log message to be logged.\n* @param contexts A map of additional context information to include in the log message.\n* @param handlers A vector of pairs of strings and handler functions, where each pair represents a category and its corresponding handler function.\n*/\nvoid log(folly::StringPiece file, int line, folly::StringPiece service, folly::StringPiece category, folly::StringPiece msg, std::map<std::string, std::string> contexts, std::vector<std::pair<std::string, HandlerFunc>> handlers) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void runStandaloneMcrouter(\n    const CmdLineOptions& cmdLineOpts,\n    const McrouterOptions& libmcrouterOptions,\n    const McrouterStandaloneOptions& standaloneOptions,\n    StandalonePreRunCb preRunCb) {\n  try {\n    if (cmdLineOpts.validateConfigMode == ValidateConfigMode::Exit) {\n      CALL_BY_ROUTER_NAME(\n          standaloneOptions.carbon_router_name,\n          validateConfigAndExit,\n          libmcrouterOptions);\n    }\n\n    CALL_BY_ROUTER_NAME(\n        standaloneOptions.carbon_router_name,\n        run,\n        libmcrouterOptions,\n        standaloneOptions,\n        std::move(preRunCb));\n  } catch (const std::invalid_argument& ia) {\n    LOG(ERROR) << \"Error starting mcrouter: \" << ia.what();\n    exit(EXIT_FAILURE);\n  }\n}\n",
        "answer": "/** @brief Starts standalone mcrouter. Note: this function will just return when standalone mcrouter is shutdown.\n*\n* This is the entrypoint for your kernel. You will use this to test and debug your drivers and it will eventually hold the code for your game. Right now, it is A tight while loop.\n* @param cmdLineOpts The command line options for the mcrouter.\n* @param libmcrouterOptions The libmcrouter options for the mcrouter.\n* @param standaloneOptions The standalone mcrouter options for the mcrouter.\n* @param preRunCb A callback function to be called before running the mcrouter.\n* @return Should not return\n*/\nvoid runStandaloneMcrouter(const CmdLineOptions& cmdLineOpts, const McrouterOptions& libmcrouterOptions, const McrouterStandaloneOptions& standaloneOptions, StandalonePreRunCb preRunCb) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool luaval_to_uint32(lua_State* L, int lo, unsigned int* outValue, const char* funcName)\n{\n    if (NULL == L || NULL == outValue)\n        return false;\n    \n    bool ok = true;\n\n    tolua_Error tolua_err;\n    if (!tolua_isnumber(L,lo,0,&tolua_err))\n    {\n#if COCOS2D_DEBUG >=1\n        luaval_to_native_err(L,\"#ferror:\",&tolua_err,funcName);\n#endif\n        ok = false;\n    }\n    \n    if (ok)\n    {\n        *outValue = (unsigned int)tolua_tonumber(L, lo, 0);\n    }\n    \n    return ok;\n}\n",
        "answer": "/**\n* @brief luaval_to_uint32\n*\n* This function gets a unsigned int value from the given acceptable index of stack. If the value at the given acceptable index of stack is a number or a string convertible to a number, it returns true, otherwise returns false.\n*\n* @param L The Lua state.\n* @param lo The index of the value on the stack.\n* @param outValue A pointer to an unsigned int where the result will be stored.\n* @param funcName The name of the function that called this function (for error reporting).\n*\n* @return True if the value at the given acceptable index of stack is a number or a string convertible to a number, false otherwise.\n*/\nbool luaval_to_uint32(lua_State* L, int lo, unsigned int* outValue, const char* funcName);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool luaval_to_std_string(lua_State* L, int lo, std::string* outValue, const char* funcName)\n{\n    if (NULL == L || NULL == outValue)\n        return false;\n    \n    bool ok = true;\n\n    tolua_Error tolua_err;\n    if (!tolua_iscppstring(L,lo,0,&tolua_err))\n    {\n#if COCOS2D_DEBUG >=1\n        luaval_to_native_err(L,\"#ferror:\",&tolua_err,funcName);\n#endif\n        ok = false;\n    }\n    \n    if (ok)\n    {\n        *outValue = tolua_tocppstring(L,lo,NULL);\n    }\n    \n    return ok;\n}\n",
        "answer": "/** @brief luaval_to_std_string.\n*\n*  This function gets a std::string value from the given acceptable index of stack. If the value at the given acceptable index of stack is a string or a number convertible to a string it returns true, otherwise returns false.\n*\n* @param L The lua state.\n* @param lo The acceptable index of stack.\n* @param outValue The output std::string value.\n* @param funcName The name of the function.\n* @return True if the value at the given acceptable index of stack is a string or a number convertible to a string, false otherwise.\n*/\n*outValue = tolua_tocppstring(L,lo,NULL);\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void vec2_to_luaval(lua_State* L,const cocos2d::Vec2& vec2)\n{\n    if (NULL  == L)\n        return;\n    lua_newtable(L);                                    /* L: table */\n    lua_pushstring(L, \"x\");                             /* L: table key */\n    lua_pushnumber(L, (lua_Number) vec2.x);               /* L: table key value*/\n    lua_rawset(L, -3);                                  /* table[key] = value, L: table */\n    lua_pushstring(L, \"y\");                             /* L: table key */\n    lua_pushnumber(L, (lua_Number) vec2.y);               /* L: table key value*/\n    lua_rawset(L, -3);\n    \n}\n",
        "answer": "/** @brief Push a table converted from a cocos2d::Vec2 object into the Lua stack. The format of table as follows: {x=numberValue1, y=numberValue2}.\n*\n*  This function pushes a table containing the x and y values of a cocos2d::Vec2 object onto the Lua stack.\n*\n* @param L The Lua state.\n* @param vec2 The cocos2d::Vec2 object to be converted into a table.\n* @return Should not return.\n*/\nvoid vec2_to_luaval(lua_State* L, const cocos2d::Vec2& vec2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void blendfunc_to_luaval(lua_State* L, const cocos2d::BlendFunc& func)\n{\n    if (nullptr == L)\n        return;\n    \n    lua_newtable(L);                                    /* L: table */\n    \n    lua_pushstring(L, \"src\");                           /* L: table key */\n    lua_pushnumber(L, (lua_Number) func.src);           /* L: table key value*/\n    lua_rawset(L, -3);                                  /* table[key] = value, L: table */\n    lua_pushstring(L, \"dst\");                           /* L: table key */\n    lua_pushnumber(L, (lua_Number) func.dst);           /* L: table key value*/\n    lua_rawset(L, -3);\n}\n",
        "answer": "/** @brief Push a table converted from a cocos2d::BlendFunc object into the Lua stack. The format of table as follows: {src=numberValue1, dst=numberValue2}\n*\n*  This function pushes a table onto the Lua stack that represents a cocos2d::BlendFunc object. The table has two fields, \"src\" and \"dst\", which correspond to the source and destination blending factors of the BlendFunc object.\n*\n* @param L The Lua state.\n* @param func The cocos2d::BlendFunc object to convert to a Lua table.\n*/\nvoid blendfunc_to_luaval(lua_State* L, const cocos2d::BlendFunc& func)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ccvector_int_to_luaval(lua_State* L, const std::vector<int>& inValue)\n{\n    if (nullptr == L)\n        return;\n    \n    lua_newtable(L);\n    \n    int index = 1;\n    for (const int value : inValue)\n    {\n        lua_pushnumber(L, (lua_Number)index);\n        lua_pushnumber(L, (lua_Number)value);\n        lua_rawset(L, -3);\n        ++index;\n    }\n}\n",
        "answer": "/** @brief Push a Lua array table converted from a std::vector<int> into the Lua stack.\n*\n*  This function pushes a Lua array table converted from a std::vector<int> into the Lua stack. The format of the table is as follows: {numberValue1, numberValue2, ..., numberVectorSize}.\n*\n* @param L A pointer to the lua_State structure for the Lua interpreter.\n* @param inValue A reference to a constant std::vector<int> object containing the values to be pushed into the Lua stack.\n*/\nvoid ccvector_int_to_luaval(lua_State* L, const std::vector<int>& inValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int size_from_channelarray(struct iio_channel_info *channels, int num_channels)\n{\n\tint bytes = 0, i;\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tif (channels[i].bytes == 0)\n\t\t\tcontinue;\n\n\t\tif (bytes % channels[i].bytes == 0)\n\t\t\tchannels[i].location = bytes;\n\t\telse\n\t\t\tchannels[i].location = bytes - (bytes % channels[i].bytes) + channels[i].bytes;\n\n\t\tbytes = channels[i].location + channels[i].bytes;\n\t}\n\n\treturn bytes;\n}\n",
        "answer": "/** @brief Calculates the storage size of a scan's channel info array.\n*\n*  This function calculates the total number of bytes required to store the channel information for a given scan, based on the number of channels and their respective byte sizes.\n*\n* @param[in] channels The channel info array for the scan.\n* @param[in] num_channels The number of channels in the scan.\n* @return The total number of bytes required to store the channel information.\n*/\nstatic int size_from_channelarray(struct iio_channel_info *channels, int num_channels)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int st_hal_dev_batch(struct sensors_poll_device_1 *dev, int handle,\n\t\t\t\tint flags, int64_t period_ns, int64_t timeout)\n{\n\tSTSensorHAL_data *hal_data = (STSensorHAL_data *)dev;\n\tunsigned int index = st_hal_get_handle(hal_data, handle);\n\n#if (CONFIG_ST_HAL_ANDROID_VERSION == ST_HAL_KITKAT_VERSION)\n\tif (((flags & SENSORS_BATCH_DRY_RUN) || (flags & SENSORS_BATCH_WAKE_UPON_FIFO_FULL)) && (timeout > 0)) {\n\t\tif (hal_data->sensor_classes[index]->GetMaxFifoLenght() > 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n#else /* CONFIG_ST_HAL_ANDROID_VERSION */\n\t(void)flags;\n#endif /* CONFIG_ST_HAL_ANDROID_VERSION */\n\n\treturn hal_data->sensor_classes[index]->SetDelay(handle, period_ns, timeout, true);\n}\n",
        "answer": "/**\n* @brief Set sensor batch mode.\n*\n* This function sets the sensor batch mode for a specific sensor device.\n*\n* @param dev The sensors poll device structure.\n* @param handle The Android sensor handle.\n* @param flags Used to indicate whether to test the availability of batch mode or not.\n* @param period_ns The time to batch in nanoseconds.\n* @param timeout The timeout for the batch operation in nanoseconds.\n* @return 0 on success, negative number on fail.\n*/\nstatic int st_hal_dev_batch(struct sensors_poll_device_1 *dev, int handle,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int st_hal_dev_register_direct_channel(struct sensors_poll_device_1 *dev,\n\t\t\t\t\t      const struct sensors_direct_mem_t* mem,\n\t\t\t\t\t      int channel_handle)\n{\n\tif (mem)\n\t\treturn st_hal_add_direct_channel(dev, mem);\n\n\treturn st_hal_dev_remove_direct_channel(dev, channel_handle);\n}\n",
        "answer": "/** @brief Registers a direct report channel with the device.\n*\n*  This function is called by Android to allocate a new Direct Report Channel structure.\n*\n* @param dev The poll device pointer.\n* @param mem The shared memory information pointer for a direct channel.\n* @param channel_handle The handle from st_hal_add_direct_channel().\n*\n* @return Returns 0 on success, negative error code otherwise.\n*/\nstatic int st_hal_dev_register_direct_channel(struct sensors_poll_device_1 *dev,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static std::string GetSwiftFriendlyTriple(const std::string &triple) {\n  static std::string s_x86_64h(\"x86_64h\");\n  static std::string::size_type s_x86_64h_size = s_x86_64h.size();\n\n  if (0 == triple.compare(0, s_x86_64h_size, s_x86_64h)) {\n    std::string fixed_triple(\"x86_64\");\n    fixed_triple.append(\n        triple.substr(s_x86_64h_size, triple.size() - s_x86_64h_size));\n    return fixed_triple;\n  }\n  return triple;\n}\n",
        "answer": "/** @brief Strips the Haswell marker off the CPU name.\n*\n*  This function removes the \"Haswell\" marker from the CPU name, if present.\n*  It is used to make the Swift more robust.\n*\n* @param triple The original CPU name string.\n* @return A new string with the Haswell marker removed, if present.\n*/\nstatic std::string GetSwiftFriendlyTriple(const std::string &triple) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void logger(QtMsgType type, const QMessageLogContext& ctx, const QString& msg)\n{\n\tQFile logFile(qgetenv(\"NVIM_QT_LOG\"));\n\tif (logFile.open(QIODevice::Append | QIODevice::Text)) {\n\t\tQTextStream stream(&logFile);\n\t\tstream << msg << \"\\n\";\n\t}\n}\n",
        "answer": "/** @brief A log handler for Qt messages.\n*\n* This function is used to dump all messages into the file passed via the NVIM_QT_LOG variable. Some information is only available in debug builds (e.g. qDebug is only called in debug builds). In UNIX, Qt prints messages to the console output, but in Windows, this is the only way to get Qt's debug/warning messages.\n*\n* @param type The message type.\n* @param ctx The message context.\n* @param msg The message string.\n*\n* @return void\n*/\nvoid logger(QtMsgType type, const QMessageLogContext& ctx, const QString& msg)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "connector_ptr create_tcp_ssl_local_client(const std::string& file, const ssl_config& config)\n{\n#ifdef ASIO_HAS_LOCAL_SOCKETS\n\tusing type = net::tcp::basic_ssl_client<asio::local::stream_protocol>;\n\tauto& net_context = get_io_context();\n\ttype::protocol_endpoint endpoint(file);\n\ttry\n\t{\n\t\treturn std::make_shared<type>(net_context, endpoint, config);\n\t}\n\tcatch(const std::exception& e)\n\t{\n\t\tlog() << this_func << \" Failed for endpoint - \" << endpoint << \" : \" << e.what();\n\t}\n#else\n\t(void)file;\n\t(void)config;\n\tlog() << this_func << \" Local(domain) sockets are not supported.\";\n#endif\n\treturn nullptr;\n}\n",
        "answer": "/** @brief Creates a secure tcp local(domain socket) client. Only available on platforms that support unix domain sockets.\n*\n*  This function creates a secure tcp local(domain socket) client using the ASIO library. It is only available on platforms that support unix domain sockets. The function takes two parameters, a file path and an ssl_config object, which are used to configure the client. If the platform does not support unix domain sockets, the function will log an error message and return nullptr.\n*\n* @param[in] file A string containing the file path for the local(domain) socket.\n* @param[in] config An ssl_config object containing the configuration for the client.\n* @return A shared pointer to a net::tcp::basic_ssl_client<asio::local::stream_protocol> object, or nullptr if the platform does not support unix domain sockets.\n*/\nconnector_ptr create_tcp_ssl_local_client(const std::string& file, const ssl_config& config)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double test_as_array(BaseArrayDouble &a) {\n  ArrayDouble array = a.as_array();\n  double sum = array.sum();\n  array.init_to_zero();\n  return sum;\n}\n",
        "answer": "/** @brief Tests if as_array works. It should return the sum of the original array and set its data to 0 if and only if the original array was dense.\n*\n* @param a The BaseArrayDouble object to test.\n* @return The sum of the original array, or -1 if the original array was not dense.\n*/\ndouble test_as_array(BaseArrayDouble &a) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n{\n    ScriptError error;\n    CTransaction inputi(input);\n    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, &inputi.wit.vtxinwit[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue), &error);\n    BOOST_CHECK(ret == (error == SCRIPT_ERR_OK));\n\n    return error;\n}\n",
        "answer": "/** @brief VerifyWithFlag entrypoint.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param output The CTransaction object representing the output of a transaction.\n* @param input The CMutableTransaction object representing the input of a transaction.\n* @param flags The integer value representing the flag to be used for verification.\n*\n* @return Should not return\n*/\nvoid kernel_entrypoint()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "jobject WebPImage_nativeCreateFromNativeMemory(\n    JNIEnv* pEnv,\n    jclass clazz,\n    jlong nativePtr,\n    jint sizeInBytes) {\n\n  jbyte* const pointer = (jbyte*) nativePtr;\n  std::vector<uint8_t> vBuffer(pointer, pointer + sizeInBytes);\n  return WebPImage_nativeCreateFromByteVector(pEnv, vBuffer);\n}\n",
        "answer": "/** @brief Creates a new WebPImage from the specified native pointer.\n*\n* This function creates a new WebPImage object from the specified native pointer. The data is copied into memory managed by WebPImage.\n*\n* @param pEnv JNI environment.\n* @param clazz Java class reference.\n* @param nativePtr Native pointer to the image data.\n* @param sizeInBytes Size of the image data in bytes.\n* @return A new WebPImage object created from the specified native pointer.\n*/\njobject WebPImage_nativeCreateFromNativeMemory("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "wxArrayString cbReadBatchBuildPlugins()\n{\n    ConfigManager *bbcfg = Manager::Get()->GetConfigManager(_T(\"plugins\"));\n    wxArrayString bbplugins = bbcfg->ReadArrayString(_T(\"/batch_build_plugins\"));\n\n    if (!bbplugins.GetCount())\n        bbplugins.Add(getCompilerPluginFilename());\n\n    return bbplugins;\n}\n",
        "answer": "/** @brief Reads the list of batch build plugins and returns them.\n*\n*  This function reads the list of batch build plugins from the configuration file and returns them in an array. If the list is empty, it adds the compiler plugin to the list before returning it. The list contains the library names of the plugins and differs on every OS.\n*\n* @return An array of strings containing the library names of the batch build plugins.\n*/\nwxArrayString cbReadBatchBuildPlugins()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void changeButtonLabel(wxButton &button, const wxString &text)\n{\n    if (text != button.GetLabel())\n        button.SetLabel(text);\n}\n",
        "answer": "/** @brief Change the label of a button only if it has really changed.\n*\n* This function is used to avoid flickering while scrolling in the editor, by only changing the label of a button if it has actually changed. It is used for status bar buttons.\n*\n* @param button The button whose label should be changed.\n* @param text The new label for the button.\n*/\nvoid changeButtonLabel(wxButton &button, const wxString &text)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void l3gd20h_getRawAngularRates(int16_t *pX, int16_t *pY, int16_t *pZ)\n{\n  if((NULL != pX) && (NULL != pY) && (NULL != pZ))\n  {\n    _2bit_xyz_read(L3GD20_ADDRESS, L3GD20_GYRO_REGISTER_OUT_X_L | 0x80,\n                     pX, pY, pZ, false);\n  }\n}\n",
        "answer": "/** @brief Get raw 16 bit readings from l3gd20h gyroscope. These raw values can then be converted into engineering values.\n*\n* This function retrieves the raw angular rates of the l3gd20h gyroscope, which are represented as 16-bit integers. The raw values can be converted into engineering units using the appropriate conversion factors.\n*\n* @param pX A pointer to an integer where the X-axis raw value will be stored.\n* @param pY A pointer to an integer where the Y-axis raw value will be stored.\n* @param pZ A pointer to an integer where the Z-axis raw value will be stored.\n*/\nvoid l3gd20h_getRawAngularRates(int16_t *pX, int16_t *pY, int16_t *pZ)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void serializerToBase64Stream(DataSerializer const* serializer, std::ostream* ostr, bool enforceUint, bool mainProcOnly)\n{\n    serializerToSink (\n            serializer,\n            new Base64Writer(ostr, enforceUint,\n                                global::IOpolicy().getEndianSwitchOnBase64out()),\n            mainProcOnly );\n}\n",
        "answer": "/** @brief Serializes data to a base64 stream.\n*\n*  This function serializes the data from a DataSerializer object and writes it to an output stream in base64 format. The enforceUint parameter determines whether the type of the variable that stores the size of the serialized data should be converted to \"unsigned int\" for compatibility with the VTK file format. The mainProcOnly parameter determines whether only the main process should perform the serialization.\n*\n* @param[in] serializer A pointer to a DataSerializer object containing the data to be serialized.\n* @param[out] ostr An output stream where the base64-encoded data will be written.\n* @param[in] enforceUint If true, the type of the variable that stores the size of the serialized data will be converted to \"unsigned int\".\n* @param[in] mainProcOnly If true, only the main process will perform the serialization.\n*/\nvoid serializerToBase64Stream(DataSerializer const* serializer, std::ostream* ostr, bool enforceUint, bool mainProcOnly)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void integrateProcessingFunctional(BoxProcessingFunctional3D* functional,\n                                   Box3D domain,\n                                   std::vector<MultiGrid3D*> multiBlocks,\n                                   plint referenceLevel, plint level)\n{\n    addInternalProcessor( BoxProcessorGenerator3D(functional, domain),\n                          multiBlocks, referenceLevel, level);\n}\n",
        "answer": "/** @brief Integrates a 3D boxed data functional.\n*\n* This function integrates a 3D boxed data functional by adding an internal processor to the specified multi-blocks at the given reference level and level.\n*\n* @param[in] functional The box processing functional to be integrated.\n* @param[in] domain The 3D box domain of the functional.\n* @param[in,out] multiBlocks The vector of multi-blocks to which the internal processor will be added.\n* @param[in] referenceLevel The reference level of the multi-blocks.\n* @param[in] level The level of the multi-blocks.\n*/\nvoid integrateProcessingFunctional(BoxProcessingFunctional3D* functional,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool merge(DirectedEdge& e1, DirectedEdge const& e2) {\n    if ((e1.planeDir == e2.planeDir) && (e1.dir1 == e2.dir1) && (e1.dir2 == e2.dir2)) {\n        return merge(e1.bb,e2.bb);\n    }\n    return false;\n}\n",
        "answer": "/** @brief Merge two directed edges into one if possible.\n*\n*  This function takes two directed edges as input and checks if they can be merged into one. If the two directed edges can be merged, it will write the result into the first directed edge and return true. Otherwise, it will return false.\n*\n* @param e1 The first directed edge to merge.\n* @param e2 The second directed edge to merge.\n* @return True if merging was successful, false otherwise.\n*/\nbool merge(DirectedEdge& e1, DirectedEdge const& e2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\n#if defined(CRYPTOPP_DEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\nvoid TestInstantiations_gfpcrypt()\n{\n\tGDSA<SHA1>::Signer test;\n\tGDSA<SHA1>::Verifier test1;\n\tDSA::Signer test5(NullRNG(), 100);\n\tDSA::Signer test2(test5);\n\tNR<SHA1>::Signer test3;\n\tNR<SHA1>::Verifier test4;\n\tDLIES<>::Encryptor test6;\n\tDLIES<>::Decryptor test7;\n}\n",
        "answer": "/** @brief Test instantiations for the gfpcrypt library.\n*\n*  This function tests the instantiations of the gfpcrypt library. It creates instances of the GDSA, DSA, NR, and DLIES classes with various parameters and checks that they are working correctly.\n*\n* @param[in] test A GDSA signer object using SHA1 as the hash function.\n* @param[in] test1 A GDSA verifier object using SHA1 as the hash function.\n* @param[in] test5 A DSA signer object with a 100-bit key.\n* @param[in] test2 A DSA signer object copied from test5.\n* @param[in] test3 An NR signer object using SHA1 as the hash function.\n* @param[in] test4 An NR verifier object using SHA1 as the hash function.\n* @param[in] test6 A DLIES encryptor object.\n* @param[in] test7 A DLIES decryptor object.\n*/\nvoid TestInstantiations_gfpcrypt()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool __cdecl LoadLibraryList(void **proc, const char *dll, HMODULE module)\n{\n\tbool retVal = true;\n\tHMODULE lib = module;\n\tvoid *p;\n\n\tif (lib) goto load_procs;\n\n\twhile (*dll) {\n\t\tlib = LoadLibraryA(dll);\n\t\tif (lib == NULL) {\n\t\t\tDWORD err = GetLastError();\n\t\t\tretVal = false;\n\t\t\tbreak;\n\t\t}\n\t\twhile (true) {\n\t\t\twhile(*dll++);\nload_procs:\n\t\t\tif (!*dll)\n\t\t\t\tbreak;\n\t\t\tp = (void *) GetProcAddress(lib, dll);\n\t\t\tif (p == NULL)\n\t\t\t\tretVal = false;\n\t\t\t*proc++ = p;\n\t\t}\n\t\tdll++;\n\t}\n\treturn retVal;\n}\n",
        "answer": "/** @brief Loads a list of functions from a specific DLL into a struct with function pointers.\n*\n*  This function loads a list of functions from a specific DLL into a struct with function pointers. The substrings are nul-separated and the whole thing is terminated by an additional nul character. The first substring is the name of the DLL to load.\n*\n* @param proc A pointer to a struct containing function pointers.\n* @param dll A string containing the names of the functions to load, separated by nul characters.\n* @param module A handle to the DLL from which the functions should be loaded.\n*\n* @return true if all functions were successfully loaded, false otherwise.\n*/\nbool __cdecl LoadLibraryList(void **proc, const char *dll, HMODULE module)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void retrieve(const ComfortQuery& query, ComfortAnswer& answer)\n\t{\n\t\tif( query.interpretation.size() <= 1 )\n\t\t{\n      ComfortTuple tu;\n      tu.push_back(ComfortTerm::createConstant(\"bar\"));\n      answer.insert(tu);\n\t\t}\n    else if( query.interpretation.size() > 1 )\n\t\t{\n      ComfortTuple tu;\n      tu.push_back(ComfortTerm::createConstant(\"foo\"));\n      answer.insert(tu);\n\t\t}\n\t}\n",
        "answer": "/** @brief Retrieve the external atoms for a given query and answer.\n*\n*  This function implements the external atom computation. See also documentation of Query and Answer classes.\n*\n* @param[in] query The ComfortQuery object containing the query information.\n* @param[out] answer The ComfortAnswer object where the external atoms will be stored.\n*/\nvoid retrieve(const ComfortQuery& query, ComfortAnswer& answer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void retrieve(const Query& query, Answer& answer)\n  {\n    std::stringstream ss;\n\n    BOOST_FOREACH(ID tid, query.input)\n    {\n\t\t\tassert(tid.isTerm());\n      if( tid.isIntegerTerm() )\n        ss << tid.address;\n      else if( tid.isConstantTerm() )\n\t\t\t{\n\t\t\t\tconst std::string& str = registry->terms.getByID(tid).getUnquotedString();\n\t\t\t\tif (ss.str().length() > 0) ss << \";\";\n\t\t\t\tss << str;\n\t\t\t}\n      else\n        throw PluginError(\"encountered unknown term type!\");\n    }\n    \n\t\tTerm resultterm(ID::MAINKIND_TERM | ID::SUBKIND_TERM_CONSTANT, \"\\\"\" + ss.str() + \"\\\"\");\n    Tuple tu;\n    tu.push_back(registry->storeTerm(resultterm));\n\n    answer.get().push_back(tu);\n  }\n",
        "answer": "/** @brief Retrieves the external atoms for a given query.\n*\n* This function implements the external atom computation without customized learning functions. See also documentation of Query and Answer classes.\n*\n* @param[in] query The query to retrieve the external atoms for.\n* @param[out] answer The answer containing the external atoms.\n*/\nvoid retrieve(const Query& query, Answer& answer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void retrieve(const Query& query, Answer& answer)\n  {\n    Tuple tu;\n    tu.push_back(ID::termFromInteger(registry->terms.getByID(query.input[0]).getUnquotedString().length()));\n    answer.get().push_back(tu);\n  }\n",
        "answer": "/** @brief Retrieves the external atom computation without customized learning functions. See also documentation of Query and Answer classes.\n*\n* This function implements the external atom computation without customized learning functions. See also documentation of Query and Answer classes.\n*\n* @param query The input query for which the answer is to be computed.\n* @param answer The output answer that is to be returned.\n*/\nvoid retrieve(const Query& query, Answer& answer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void init(icontext_type& context, const vertex_type& vertex,\n                    const message_type& msg) {\n    ASSERT_EQ(msg, 100);\n  }\n",
        "answer": "/** @brief Initializes the vertex program.\n*\n* This function initializes the vertex program with a context, a vertex, and a message.\n* It asserts that the message is equal to 100.\n*\n* @param[in] context The context of the vertex program.\n* @param[in] vertex The vertex being initialized.\n* @param[in] msg The message received by the vertex.\n*/\nvoid init(icontext_type& context, const vertex_type& vertex,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void apply(icontext_type& context, vertex_type& vertex,\n             const gather_type& total) {\n    ASSERT_EQ( total, int(vertex.num_out_edges()) );\n  }\n",
        "answer": "/** @brief Apply function for the vertex program.\n*\n*  This is the apply function for the vertex program. It modifies the vertex data and can modify the state of the vertex program. If a vertex has no neighbors than the apply function is called passing the default value for the gather_type.\n*\n* @param context The context object that contains information about the current execution.\n* @param vertex The vertex object that represents the current vertex being processed.\n* @param total The total number of outgoing edges for the vertex, or the default value if there are no neighbors.\n* @return void\n*/\nvoid apply(icontext_type& context, vertex_type& vertex, const gather_type& total) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void load_version(iarchive& iarc, size_t version) {}\n",
        "answer": "/** @brief Loads a toolkit class previously saved at a particular version number. Should raise an exception on failure.\n*\n*  This function loads a toolkit class that was previously saved at a specific version number. If the loading fails, it should raise an exception.\n*\n* @param iarc The input archive to load from.\n* @param version The version number of the toolkit class to be loaded.\n* @return Should not return on success, raises an exception on failure.\n*/\nvoid load_version(iarchive& iarc, size_t version) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "image_type read_image(const std::string& url, const std::string& format_hint) {\n  image_type img;\n  char* data;\n  read_raw_image(url, &data, img.m_image_data_size,\n      img.m_width, img.m_height, img.m_channels,\n      img.m_format, format_hint);\n  img.m_image_data.reset(data);\n  return img;\n}\n",
        "answer": "/** @brief Reads an image from a URL and returns it as an image type object.\n*\n* This function reads the content of the specified URL and decodes it into an image type object. If the image cannot be decoded using the provided format hint, an exception is thrown.\n*\n* @param url The URL of the image to read.\n* @param format_hint A string indicating the expected format of the image data (e.g., \"PNG\", \"JPEG\").\n* @return An image type object containing the decoded image data.\n*/\nimage_type read_image(const std::string& url, const std::string& format_hint) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::shared_ptr<unity_sframe_base> binary_sframe_append(\n  const std::vector<std::shared_ptr<unity_sframe_base>>& lazy_sframes,\n  size_t begin_index, size_t end_index) {\n\n  std::shared_ptr<unity_sframe_base> ret;\n  if (begin_index + 1 == end_index)\n    ret = lazy_sframes[begin_index];\n  else if (begin_index < end_index) {\n    size_t middle = begin_index + (end_index - begin_index)/ 2;\n    auto left = binary_sframe_append(lazy_sframes, begin_index, middle);\n    auto right = binary_sframe_append(lazy_sframes, middle, end_index);\n    if (left && right) {\n      ret = left->append(right);\n    } else if (left) {\n      ret= left;\n    } else {\n      ret = right;\n    }\n  }\n  return ret;\n}\n",
        "answer": "/** @brief Helper function for binary_sframe_append.\n*\n* This function recursively appends a vector of lazy objects and returns the result of append in the range(begin, end).\n*\n* @param[in] lazy_sframes A vector of shared pointers to unity_sframe_base objects.\n* @param[in] begin_index The starting index of the range to be appended.\n* @param[in] end_index The ending index of the range to be appended.\n* @return A shared pointer to a unity_sframe_base object containing the result of the append operation.\n*/\nstd::shared_ptr<unity_sframe_base> binary_sframe_append("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_writable_protocol(std::string protocol) {\n  return protocol == \"hdfs\" || protocol == \"s3\" ||\n      protocol == \"\" || protocol == \"file\" || protocol == \"cache\";\n}\n",
        "answer": "/** @brief Check if the protocol is writable.\n*\n*  This function checks if the given protocol is writable or not.\n*  It returns true if the protocol is writeable S3, HDFS, cache and local filesystem; returns false otherwise.\n*\n* @param[in] protocol The protocol to check for writability.\n* @return True if the protocol is writable, False otherwise.\n*/\nbool is_writable_protocol(std::string protocol) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t make_lambda(const std::string& pylambda_str) {\n  DASSERT_TRUE(evaluation_functions.init_lambda != NULL);\n  \n  size_t lambda_id = evaluation_functions.init_lambda(pylambda_str);\n  python::check_for_python_exception();\n  \n  logstream(LOG_DEBUG) << \"Created lambda id=\" << lambda_id << std::endl;  \n\n  return lambda_id;\n}\n",
        "answer": "/** @brief Creates the current lambda interface.\n*\n* This function creates a lambda from a pickled lambda string. It throws an exception if the construction failed.\n*\n* @param pylambda_str The pickled lambda string to create the lambda from.\n* @return The id of the created lambda.\n*/\nsize_t make_lambda(const std::string& pylambda_str) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void write_msg(const std::string & buffer) {\n  write_msg(&buffer[0], buffer.size());\n}\n",
        "answer": "/** @brief Write a message to standard out in binary format encoded in the format: message length (4 bytes) followed by bytes\n*\n* This is the description of the functionality of the function.\n*\n* @param buffer The buffer containing the message to be written\n* @return Should not return\n*/\nvoid write_msg(const std::string & buffer) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    float randFloat()\n    {\n        uint32_t randBits = randInt32();\n        randBits = (randBits & 0x007fffff) | 0x3f800000;\n        return *reinterpret_cast<float*>(&randBits) - 1.0f;\n    }\n",
        "answer": "/** @brief Generates a random floating point value in [ 0, 1 ).\n*\n* This function directly manipulates the bits of a floating point number, and will not work properly on a system that doesn't use IEEE754 floats.\n*\n* @return A random floating point value in [ 0, 1 )\n*/\nfloat randFloat()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void errorMessagePrelude(const Tokenizer& tok)\n{\n    fmt::fprintf(cerr,_(\"Error in .ssc file (line %d): \"), tok.getLineNumber());\n}\n",
        "answer": "/** @brief Prints an error message prelude for an .ssc file.\n*\n*  This function prints a prelude for an error message in an .ssc file, including the line number where the error occurred.\n*\n* @param tok The Tokenizer object containing the .ssc file data.\n*/\nstatic void errorMessagePrelude(const Tokenizer& tok)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned int checkAndReturnIndex(const std::string &shapeName)\n{\n  unsigned int pos=0;\n\n  while ((pos < shapes2D.size()) && (shapes2D[pos] != shapeName))\n    pos++;\n\n  if (pos == shapes2D.size())\n  {\n    trace.error() << \"The specified shape has not found.\";\n    trace.info() << std::endl;\n    exit(1);\n  }\n\n  return pos;\n}\n",
        "answer": "/** @brief Check if a given shape is available and return its corresponding index in the global vectors.\n*\n* This function checks if a given shape is available in the global vectors, and returns its corresponding index if it exists. If the shape does not exist, an error message is printed to the console and the program exits with a non-zero status code.\n*\n* @param[in] shapeName The name of the shape to check for availability.\n* @return The index of the shape in the global vectors if it exists, or -1 if it does not exist.\n*/\nunsigned int checkAndReturnIndex(const std::string &shapeName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned int Log2ceil(uint64_t i) {\n    int retval = i ? 1 : 0 ;\n    while (i >>= 1) {++retval;}\n    return retval;\n}\n",
        "answer": "/** @brief Returns an upper bound on log2(i). Namely, returns the number of binary digits needed to store the value 'i'. When i == 0 returns 0.\n*\n* @param i The input value.\n* @return The upper bound on log2(i).\n*/\nunsigned int Log2ceil(uint64_t i) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "UINT16 addINT32ToBuffer(UINT8* buffer, INT32 value)\n{\n\tUINT32 uValue = (UINT32)value;\n\n\tUINT16 pos = addUINT32ToBuffer(buffer, uValue);\n\n\treturn pos;\n}\n",
        "answer": "/** @brief Adds an INT32 value to a buffer as text.\n*\n*  The function first converts the INT32 value to a UINT32 value and then calls addUINT32ToBuffer() to write the value to the buffer.\n*\n* @param [in] buffer A pointer to the buffer where the value should be written.\n* @param [in] value The INT32 value to be written.\n* @return The length of the string that was added to the buffer.\n*/\nUINT16 addINT32ToBuffer(UINT8* buffer, INT32 value)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "mat p_ikjl(const vec &a) {\n\n\tmat A = (a)*trans(a);\n\tmat F = zeros(6,6);\n\n\tint ij=0;\n\tint kl=0;\n\tint ik=0;\n\tint jl=0;\n\tint il=0;\n\tint jk=0;\n    \n    mat Id = zeros(3,3);\n    Id(0,0) = 0;\n    Id(0,1) = 3;\n    Id(0,2) = 4;\n    Id(1,0) = 3;\n    Id(1,1) = 1;\n    Id(1,2) = 5;\n    Id(2,0) = 4;\n    Id(2,1) = 5;\n    Id(2,2) = 2;\n\t\n\tfor (int i=0; i<3; i++) {\n\t\tfor (int j=i; j<3; j++) {\n\t\t\tij = Id(i,j);\n\t\t\tfor (int k=0; k<3; k++) {\n\t\t\t\tfor (int l=k; l<3; l++) {\n\t\t\t\t\tkl = Id(k,l);\n\t\t\t\t\tik = Id(i,k);\n\t\t\t\t\tjl = Id(j,l);\n\t\t\t\t\til = Id(i,l);\n\t\t\t\t\tjk = Id(j,k);\n\t\t\t\t\t\n\t\t\t\t\tF(ij,kl) += 0.5*(A(ik,jl)+A(jk,il));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn F;\n}\n",
        "answer": "/** @brief Computes the Hill interfacial operator according to a normal a (see papers of Siredey and Entemeyer phD dissertation)\n*  This function computes the Hill interfacial operator for a given vector a. The operator is defined as:\n*  F(ij,kl) = 0.5*(A(ik,jl)+A(jk,il))\n*  where A is a matrix constructed from the input vector a and Id is an identity matrix.\n*\n* @param[in] a The input vector used to construct the Hill interfacial operator.\n* @return The Hill interfacial operator for the given input vector.\n*/\nmat p_ikjl(const vec &a) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void guac_common_clipboard_append(guac_common_clipboard* clipboard, const char* data, int length) {\n\n    /* Truncate data to available length */\n    int remaining = clipboard->available - clipboard->length;\n    if (remaining < length)\n        length = remaining;\n\n    /* Append to buffer */\n    memcpy(clipboard->buffer + clipboard->length, data, length);\n\n    /* Update length */\n    clipboard->length += length;\n\n}\n",
        "answer": "/** @brief Appends the given data to the current clipboard contents.\n*\n* This function appends the given data to the current clipboard contents,\n* matching the mimetype chosen for the clipboard data by guac_common_clipboard_reset().\n*\n* @param[in] clipboard The clipboard to append the data to.\n* @param[in] data The data to be appended to the clipboard.\n* @param[in] length The length of the data to be appended.\n*/\n/* Truncate data to available length */\n/* Append to buffer */\n/* Update length */\nclipboard->length += length;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void guac_common_display_free_buffer(guac_common_display* display,\n        guac_common_display_layer* buffer) {\n\n    /* Free associated layer and surface */\n    display->client.FreeBuffer(buffer->layer);\n    guac_common_surface_free(buffer->surface);\n\n    buffer->layer = NULL;\n    buffer->surface = NULL;\n\n}\n",
        "answer": "/** @brief Frees the given surface and associated buffer, returning the buffer to the given display for future use.\n*\n*  This function frees the given surface and associated buffer, returning the buffer to the given display for future use.\n*\n* @param[in] display The display to which the buffer should be returned.\n* @param[in] buffer The buffer to free.\n*/\n/* Free associated layer and surface */\ndisplay->client.FreeBuffer(buffer->layer);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_parser_expect(guac_parser* parser, guac_socket* socket, int usec_timeout, const char* opcode) {\n\n    /* Read next instruction */\n    if (guac_parser_read(parser, socket, usec_timeout) != 0)\n        return -1;\n\n    /* Validate instruction */\n    if (strcmp(parser->opcode, opcode) != 0) {\n        guac_error = GUAC_STATUS_PROTOCOL_ERROR;\n        guac_error_message = \"Instruction read did not have expected opcode\";\n        guac_parser_free(parser);\n        return -1;\n    }\n\n    /* Return non-zero only if valid instruction read */\n    return parser->state != GUAC_PARSE_COMPLETE;\n\n}\n",
        "answer": "/** @brief Expect a specific instruction from the Guacamole protocol.\n*\n*  This function reads the next instruction from the given socket using the provided parser, and validates that it has the expected opcode. If an error occurs while reading the instruction, NULL is returned, and guac_error is set appropriately. If the instruction read does not have the expected opcode, NULL is returned, and guac_error is set to GUAC_STATUS_BAD_STATE.\n*\n*  @param parser The Guacamole protocol parser to use for reading instructions.\n*  @param socket The socket to read instructions from.\n*  @param usec_timeout The maximum amount of time to wait for an instruction, in microseconds. A value of -1 indicates that the function should block indefinitely until an instruction is received.\n*  @param opcode The expected opcode of the instruction.\n*  @return Non-zero if a valid instruction with the expected opcode was read, or zero otherwise.\n*/\n/* Read next instruction */\n/* Validate instruction */\n/* Return non-zero only if valid instruction read */\nreturn parser->state != GUAC_PARSE_COMPLETE;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_protocol_send_close(GuacSocket& socket, const guac_layer* layer)\n{\n    int ret_val;\n\n    socket.InstructionBegin();\n    ret_val =\n           socket.WriteString(\"5.close,\")\n        || __guac_socket_write_length_int(socket, layer->index)\n        || socket.WriteString(\";\");\n\n    socket.InstructionEnd();\n    return ret_val;\n}\n",
        "answer": "/** @brief Sends a close instruction to the Guacamole client.\n*\n*  This function sends a \"close\" instruction to the Guacamole client,\n*  which will cause the client to close the specified layer.\n*\n* @param socket The GuacSocket object to send the instruction on.\n* @param layer The guac_layer object representing the layer to be closed.\n*\n* @return Zero if the instruction was sent successfully, non-zero otherwise.\n*/\nint guac_protocol_send_close(GuacSocket& socket, const guac_layer* layer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_protocol_send_dispose(GuacSocket& socket, const guac_layer* layer)\n{\n    int ret_val;\n\n    socket.InstructionBegin();\n    ret_val =\n           socket.WriteString(\"7.dispose,\")\n        || __guac_socket_write_length_int(socket, layer->index)\n        || socket.WriteString(\";\");\n\n    socket.InstructionEnd();\n    return ret_val;\n}\n",
        "answer": "/** @brief Sends a dispose instruction to the Guacamole client.\n*\n*  This function sends a dispose instruction to the Guacamole client, which\n*  instructs it to release any resources associated with the given layer. If an\n*  error occurs sending the instruction, a non-zero value is returned and\n*  guac_error is set appropriately.\n*\n* @param socket The GuacSocket object to send the instruction on.\n* @param layer The layer to dispose of.\n* @return Zero on success, non-zero if an error occurs sending the instruction.\n*/\nint guac_protocol_send_dispose(GuacSocket& socket, const guac_layer* layer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_protocol_send_file(GuacSocket& socket, const guac_stream* stream,\n        const char* mimetype, const char* name)\n{\n    int ret_val;\n\n    socket.InstructionBegin();\n    ret_val =\n           socket.WriteString(\"4.file,\")\n        || __guac_socket_write_length_int(socket, stream->index)\n        || socket.WriteString(\",\")\n        || __guac_socket_write_length_string(socket, mimetype)\n        || socket.WriteString(\",\")\n        || __guac_socket_write_length_string(socket, name)\n        || socket.WriteString(\";\");\n\n    socket.InstructionEnd();\n    return ret_val;\n}\n",
        "answer": "/** @brief Sends a file on the given stream with the specified mimetype and name.\n*\n*  This function sends a file on the given stream with the specified mimetype and name.\n*  If an error occurs sending the instruction, a non-zero value is returned, and guac_error is set appropriately.\n*\n* @param socket The GuacSocket to send the file on.\n* @param stream The guac_stream to associate with the file.\n* @param mimetype The mimetype of the file.\n* @param name The name of the file.\n* @return Zero on success, non-zero if an error occurs sending the instruction.\n*/\nint guac_protocol_send_file(GuacSocket& socket, const guac_stream* stream,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_protocol_send_nop(GuacSocket& socket)\n{\n    int ret_val;\n\n    socket.InstructionBegin();\n    ret_val = socket.WriteString(\"3.nop;\");\n    socket.InstructionEnd();\n\n    return ret_val;\n}\n",
        "answer": "/** @brief Send a NOP instruction to the Guacamole client.\n*\n*  This function sends a NOP (no-operation) instruction to the Guacamole client, which is used to keep the connection alive and measure latency.\n*\n* @param socket The GuacSocket object representing the connection to the Guacamole client.\n* @return Zero on success, non-zero if an error occurs sending the instruction or if the connection is closed.\n*/\nint guac_protocol_send_nop(GuacSocket& socket)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_protocol_send_ready(GuacSocket& socket, const char* id)\n{\n    int ret_val;\n\n    socket.InstructionBegin();\n    ret_val =\n           socket.WriteString(\"5.ready,\")\n        || __guac_socket_write_length_string(socket, id)\n        || socket.WriteString(\";\");\n\n    socket.InstructionEnd();\n    return ret_val;\n}\n",
        "answer": "/**\n* @brief Sends a \"ready\" instruction to the Guacamole socket.\n*\n* This function sends a \"ready\" instruction to the Guacamole socket, indicating that the client is ready to receive instructions.\n* If an error occurs sending the instruction, a non-zero value is returned and guac_error is set appropriately.\n*\n* @param socket The GuacSocket to send the instruction on.\n* @param id The ID of the client.\n* @return Zero on success, non-zero if an error occurs sending the instruction.\n*/\nint guac_protocol_send_ready(GuacSocket& socket, const char* id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int guac_protocol_send_shade(GuacSocket& socket, const guac_layer* layer,\n        int a)\n{\n    int ret_val;\n\n    socket.InstructionBegin();\n    ret_val =\n           socket.WriteString(\"5.shade,\")\n        || __guac_socket_write_length_int(socket, layer->index)\n        || socket.WriteString(\",\")\n        || __guac_socket_write_length_int(socket, a)\n        || socket.WriteString(\";\");\n\n    socket.InstructionEnd();\n    return ret_val;\n}\n",
        "answer": "/** @brief Sends a shade instruction to the Guacamole protocol.\n*\n*  This function sends a shade instruction to the Guacamole protocol, which\n*  will apply a shading effect to the specified layer. The shading effect is\n*  determined by the value of the \"a\" parameter.\n*\n* @param socket The GuacSocket object to send the instruction on.\n* @param layer The layer to apply the shade effect to.\n* @param a The value of the shade effect.\n*\n* @return Zero if the instruction was sent successfully, or non-zero if an error\n*         occurred sending the instruction.\n*/\nint guac_protocol_send_shade(GuacSocket& socket, const guac_layer* layer, int a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ssize_t guac_socket_write(guac_socket* socket,\n        const void* buf, size_t count) {\n\n    const char* buffer = (const char*)buf;\n\n    /* Write until completely written */\n    while (count > 0) {\n\n        /* Attempt to write, return on error */\n        int written = __guac_socket_write(socket, buffer, count);\n        if (written == -1)\n            return 1;\n\n        /* Advance buffer as data written */\n        buffer += written;\n        count  -= written;\n\n    }\n\n    return 0;\n\n}\n",
        "answer": "/** @brief Writes the given data to the specified socket.\n*\n*  This function writes the given data to the specified socket. The data written is not buffered, and will be sent immediately. If an error occurs while writing, a non-zero value is returned, and guac_error is set appropriately.\n*\n* @param[in] socket The socket to write to.\n* @param[in] buf The buffer containing the data to write.\n* @param[in] count The number of bytes to write from the buffer.\n* @return Zero on success, non-zero on error.\n*/\nssize_t guac_socket_write(guac_socket* socket, const void* buf, size_t count) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "guac_timestamp guac_timestamp_current() {\n\n#ifdef HAVE_CLOCK_GETTIME\n\n    struct timespec current;\n\n    /* Get current time */\n    clock_gettime(CLOCK_REALTIME, &current);\n    \n    /* Calculate milliseconds */\n    return (guac_timestamp) current.tv_sec * 1000 + current.tv_nsec / 1000000;\n\n#else\n\n    struct timeval current;\n\n    /* Get current time */\n    gettimeofday(&current, (timezone*)0);\n    \n    /* Calculate milliseconds */\n    return (guac_timestamp) current.tv_sec * 1000 + current.tv_usec / 1000;\n\n#endif\n\n}\n",
        "answer": "/**\n* @brief Returns an arbitrary timestamp. The difference between return values of any two calls is equal to the amount of time in milliseconds between those calls. The return value from a single call will not have any useful (or defined) meaning.\n*\n* @return An arbitrary timestamp, measured in milliseconds since some unspecified starting point.\n*/\nguac_timestamp guac_timestamp_current();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int __guac_handle_file(GuacUser* user, int argc, char** argv) {\n\n    /* Pull corresponding stream */\n    int stream_index = atoi(argv[0]);\n    guac_stream* stream = __init_input_stream(user, stream_index);\n    if (stream == NULL)\n        return 0;\n\n    /* If supported, call handler */\n    if (user->file_handler)\n        return user->file_handler(\n            user,\n            stream,\n            argv[1], /* mimetype */\n            argv[2]  /* filename */\n        );\n\n    /* Otherwise, abort */\n    guac_protocol_send_ack(user->socket_, stream,\n            \"File transfer unsupported\", GUAC_PROTOCOL_STATUS_UNSUPPORTED);\n    return 0;\n}\n",
        "answer": "/** @brief Internal initial handler for the file instruction.\n*\n*  When a file instruction is received, this handler will be called. The client's file handler will be invoked if defined.\n*\n* @param user The GuacUser associated with the file instruction.\n* @param argc The number of arguments in the file instruction.\n* @param argv An array of strings containing the arguments of the file instruction.\n*\n* @return 0 if the file instruction is handled successfully, or non-zero if an error occurs.\n*/\n/* Pull corresponding stream */\n/* If supported, call handler */\n/* Otherwise, abort */\nguac_protocol_send_ack(user->socket_, stream,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void initializeIO() {\r\n  lcdInit(uart1);\r\n}\r\n",
        "answer": "/** @brief Runs pre-initialization code.\n*\n* This function will be started in kernel mode one time while the VEX Cortex is starting up. As the scheduler is still paused, most API functions will fail. The purpose of this function is solely to set the default pin modes (pinMode()) and port states (digitalWrite()) of limit switches, push buttons, and solenoids. It can also safely configure a UART port (usartOpen()) but cannot set up an LCD (lcdInit()).\n*\n* @return Should not return\n*/\nvoid initializeIO() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void addStringToBuffer(UINT8* buffer, UINT16& pos, const std::string& stringValue)\n{\n\tUINT16 length = stringValue.length();\n\tstrcpy((char*) &buffer[pos], stringValue.c_str());\n\tpos += length;\n}\n",
        "answer": "/** @brief Adds a string to a buffer at a specified position.\n*\n*  This function adds a string to a buffer at a specified position, and updates the position accordingly. If the length of the string is longer than the remaining space in the buffer, then filling stops at the end of the buffer.\n*\n* @param[in] buffer The buffer to add the string to.\n* @param[in,out] pos The position in the buffer where the string should be added. This will be updated to point to the next available byte after the string has been added.\n* @param[in] stringValue The string to add to the buffer.\n*/\nvoid addStringToBuffer(UINT8* buffer, UINT16& pos, const std::string& stringValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int is_acceptance_dfa_state (int state_id\n                    , std::vector<acceptance_state> &acceptance_states_info) {\n    for (int i = 0 ; i < acceptance_states_info.size () ; i++) {\n        if (acceptance_states_info[i].state_id == state_id)\n            return i;\n    }\n    return -1;\n}\n",
        "answer": "/**\n* @brief Checks whether the DFA state represented by the given ID is an acceptance state or not.\n*\n* If yes, it returns the index of this acceptance state info in the acceptance states info vector.\n* Otherwise, it returns -1.\n*\n* @param state_id The ID of the DFA state to check.\n* @param acceptance_states_info A vector containing information about the acceptance states.\n* @return The index of the acceptance state info in the acceptance states info vector if the given state is an acceptance state, -1 otherwise.\n*/\nint is_acceptance_dfa_state(int state_id, std::vector<acceptance_state> &acceptance_states_info) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "jmethodID getStaticMethodIdOrThrow(\n        JNIEnv* pEnv,\n        jclass clazz,\n        const char* szMethodName,\n        const char* szSig) {\n    return pEnv->GetStaticMethodID(clazz, szMethodName, szSig);\n}\n",
        "answer": "/** @brief Finds the specified method of the specified class. If it's not found, instructs the JNI environment to throw an exception.\n*\n*  This function is used to find a specific method in a Java class. If the method is not found, it will instruct the JNI environment to throw an exception.\n*\n* @param pEnv The JNI environment.\n* @param clazz The Java class containing the method.\n* @param szMethodName The name of the method to find.\n* @param szSig The signature of the method to find.\n* @return The ID of the found method, or NULL if not found.\n*/\njmethodID getStaticMethodIdOrThrow("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  typename std::enable_if<!B, size_t>::type push_front() {\n    return detail::StackP4_16<Header>::push_front();\n  }\n",
        "answer": "/** @brief Pushes an element to the front of the stack. If the stack is already full, the last element of the stack will be discarded. This function returns the number of elements pushed, which is guaranteed to be always 1. The first element of the stack is marked valid (note that it was already valid if the stack was not empty).\n*\n* @tparam B A boolean value indicating whether the stack is full or not.\n* @return size_t The number of elements pushed, which is guaranteed to be always 1.\n*/\ntypename std::enable_if<!B, size_t>::type push_front() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    uint32_t tile_element_height(int16_t x, int16_t y)\n    {\n        registers regs;\n        regs.ax = x;\n        regs.cx = y;\n        call(0x00467297, regs);\n\n        return regs.edx;\n    }\n",
        "answer": "/** @brief Calculates the absolute height of an element given its (x, y) coordinates.\n*\n*  This function returns the absolute height of an element, given its (x, y) coordinates. The height is calculated by calling a kernel function at address 0x00467297 with the x and y coordinates as parameters. The result is stored in the edx register and returned as the function's output.\n*\n* @param[in] x The x coordinate of the element.\n* @param[in] y The y coordinate of the element.\n* @return The absolute height of the element.\n*/\nuint32_t tile_element_height(int16_t x, int16_t y)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool MDAL_DR_meshLoadCapability( DriverH driver )\n{\n  if ( !driver )\n  {\n    sLastStatus = MDAL_Status::Err_MissingDriver;\n    return false;\n  }\n\n  MDAL::Driver *d = static_cast< MDAL::Driver * >( driver );\n  return d->hasCapability( MDAL::Capability::ReadMesh );\n}\n",
        "answer": "/** @brief Checks if the driver can be used to mesh.\n*\n*  This function returns whether the driver can be used to mesh or not. If false, the driver can only be used to load datasets to existing mesh.\n*\n* @param[in] driver The driver handle.\n* @return Whether the driver can be used to mesh.\n*/\nbool MDAL_DR_meshLoadCapability( DriverH driver )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int MDAL_FI_next( MeshFaceIteratorH iterator,\n                  int faceOffsetsBufferLen,\n                  int *faceOffsetsBuffer,\n                  int vertexIndicesBufferLen,\n                  int *vertexIndicesBuffer )\n{\n  if ( !iterator )\n  {\n    sLastStatus = MDAL_Status::Err_IncompatibleMesh;\n    return 0;\n  }\n  MDAL::MeshFaceIterator *it = static_cast< MDAL::MeshFaceIterator * >( iterator );\n  size_t ret = it->next( static_cast<size_t>( faceOffsetsBufferLen ),\n                         faceOffsetsBuffer,\n                         static_cast<size_t>( vertexIndicesBufferLen ),\n                         vertexIndicesBuffer );\n  return static_cast<int>( ret );\n}\n",
        "answer": "/** @brief Returns the next faces from the iterator for the mesh. Reading stops when the vertex indices buffer capacity is full, the face offsets buffer capacity is full, or the end of the faces is reached, whichever comes first.\n*\n* @param[in] iterator The mesh face iterator.\n* @param[in] faceOffsetsBufferLen The length of the face offsets buffer.\n* @param[out] faceOffsetsBuffer The face offsets buffer.\n* @param[in] vertexIndicesBufferLen The length of the vertex indices buffer.\n* @param[out] vertexIndicesBuffer The vertex indices buffer.\n* @return The number of faces read.\n*/\nint MDAL_FI_next( MeshFaceIteratorH iterator, int faceOffsetsBufferLen, int *faceOffsetsBuffer, int vertexIndicesBufferLen, int *vertexIndicesBuffer )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool convert(ZZ_mat<ZTto> &Ato, const ZZ_mat<ZTfrom> &Afrom, int buffer)\n{\n  Ato.clear();\n  int r = Afrom.get_rows();\n  int c = Afrom.get_cols();\n  Ato.resize(r, c);\n  long threshold = (1L << (numeric_limits<long>::digits - buffer - 1));\n  Z_NR<ZTfrom> ztmp;\n  for (int i = 0; i < r; ++i)\n  {\n    for (int j = 0; j < c; ++j)\n    {\n      ztmp.abs(Afrom[i][j]);\n      if (ztmp > threshold)\n      {\n        return false;\n      }\n      Ato[i][j] = Afrom[i][j].get_si();\n    }\n  }\n\n  return true;\n}\n",
        "answer": "/** @brief Converts integer matrices.\n*\n* This function converts an integer matrix from one type to another, while ensuring that the values in the resulting matrix fit within the bounds of a long integer.\n*\n* @param Ato The resulting matrix after conversion.\n* @param Afrom The original matrix to be converted.\n* @param buffer The number of bits to use as a buffer when checking if the values in the original matrix can be safely converted to long integers.\n*\n* @return True if all values in the original matrix fit within the bounds of a long integer, false otherwise.\n*/\nbool convert(ZZ_mat<ZTto> &Ato, const ZZ_mat<ZTfrom> &Afrom, int buffer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  double get_monotonic_time()\n  {\n    return seconds{ std::chrono::steady_clock::now().time_since_epoch() }.count();\n  }\n",
        "answer": "/** @brief Get monotonic time.\n*\n* This function returns a monotonically increasing time which does not need to have a reference point. It is used for measuring the execution time of code fragments.\n*\n* @return A double representing the monotonic time in seconds.\n*/\ndouble get_monotonic_time()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ssize_t readFull(int fd, void* buf, size_t count) {\n  return wrapFull(read, fd, buf, count);\n}\n",
        "answer": "/** @brief Wrapper around read() (and pread()) that, in addition to retrying on EINTR, will loop until all data is read. This wrapper is only useful for blocking file descriptors (for non-blocking file descriptors, you have to be prepared to deal with incomplete reads anyway), and only exists because POSIX allows read() to return an incomplete read if interrupted by a signal (instead of returning -1 and setting errno to EINTR). Note that readvFull and preadvFull require iov to be non-const, unlike readv and preadv. The contents of iov after these functions return is unspecified.\n*  @param fd The file descriptor to read from.\n*  @param buf A pointer to a buffer where the read data will be stored.\n*  @param count The number of bytes to read.\n*  @return The number of bytes read, or -1 on error.\n*/\nssize_t readFull(int fd, void* buf, size_t count) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LogConfig parseLogConfigJson(StringPiece value) {\n  json::serialization_opts opts;\n  opts.allow_trailing_comma = true;\n  auto jsonData = folly::parseJson(json::stripComments(value), opts);\n  return parseLogConfigDynamic(jsonData);\n}\n",
        "answer": "/** @brief Parse a JSON configuration string.\n*\n* This function parses a JSON configuration string, allowing C and C++ style comments, as well as trailing commas.\n* The parsed JSON data is then used to create a LogConfig object, which is returned by the function.\n*\n* @param value A StringPiece containing the JSON configuration string to be parsed.\n* @return A LogConfig object representing the parsed JSON data.\n*/\nLogConfig parseLogConfigJson(StringPiece value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool compareJsonWithTolerance(\n    StringPiece json1,\n    StringPiece json2,\n    double tolerance) {\n  auto obj1 = parseJson(json1);\n  auto obj2 = parseJson(json2);\n  return compareDynamicWithTolerance(obj1, obj2, tolerance);\n}\n",
        "answer": "/** @brief Compare two JSON strings with a given tolerance.\n*\n* This function compares two JSON strings and returns true if they are equal, taking into account the given tolerance when comparing numbers. Note that in the dynamic flavor of JSON 64-bit integers are a supported type. If the values to be compared are both integers, tolerance is not applied (it may not be possible to represent them as double without loss of precision). When comparing objects exact key match is required, including if keys are doubles (again a dynamic extension).\n*\n* @param json1 The first JSON string.\n* @param json2 The second JSON string.\n* @param tolerance The tolerance to use when comparing numbers.\n* @return True if the two JSON strings are equal, taking into account the given tolerance.\n*/\nbool compareJsonWithTolerance(StringPiece json1, StringPiece json2, double tolerance) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void init() {\n  std::lock_guard<std::mutex> g(initMutex());\n  initializeOpenSSLLocked();\n}\n",
        "answer": "/** @brief Initializes openssl. This should be invoked once, during the start of an application. Subsequent calls to this function are no-ops.\n*\n*  @return Should not return\n*/\nvoid init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int futexWakeImpl(const detail::Futex<ManualAtomic>*, int, uint32_t) {\n  ManualSchedule::beforeSharedAccess();\n  return 1;\n}\n",
        "answer": "/** @brief Futex extensions for ManualAtomic.\n*\n* This function implements the futex wake functionality for a manual atomic.\n* It is used to wake up threads that are waiting on a futex.\n*\n* @param futex The futex to wake up.\n* @param count The number of threads to wake up.\n* @param wake_mask The mask of threads to wake up.\n* @return The number of threads that were woken up.\n*/\nint futexWakeImpl(const detail::Futex<ManualAtomic>* futex, int count, uint32_t wake_mask) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int GetAircraftHoldMaxAltitude(const Aircraft *v)\n{\n\tint tile_height = GetTileHeightBelowAircraft(v);\n\n\treturn tile_height + ((v->subtype == AIR_HELICOPTER) ? HELICOPTER_HOLD_MAX_FLYING_ALTITUDE : PLANE_HOLD_MAX_FLYING_ALTITUDE);\n}\n",
        "answer": "/** @brief Gets the maximum 'flight level' for the holding pattern of the aircraft, in pixels 'z_pos' 0, depending on terrain below.\n*\n* This function returns the maximum flight level for the holding pattern of an aircraft, taking into account the terrain below.\n* The maximum flight level is determined by the height of the tile below the aircraft, and is adjusted based on the type of aircraft.\n* For helicopters, the maximum flight level is higher than for planes.\n*\n* @param v A pointer to an Aircraft object representing the aircraft in question.\n* @return The maximum flight level for the holding pattern of the aircraft, in pixels 'z_pos' 0.\n*/\nint GetAircraftHoldMaxAltitude(const Aircraft *v)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void DoAutosave()\n{\n\tchar buf[MAX_PATH];\n\n#if defined(PSP)\n\t/* Autosaving in networking is too time expensive for the PSP */\n\tif (_networking) return;\n#endif /* PSP */\n\n\tif (_settings_client.gui.keep_all_autosave) {\n\t\tGenerateDefaultSaveName(buf, lastof(buf));\n\t\tstrecat(buf, \".sav\", lastof(buf));\n\t} else {\n\t\tstatic int _autosave_ctr = 0;\n\n\t\t/* generate a savegame name and number according to _settings_client.gui.max_num_autosaves */\n\t\tseprintf(buf, lastof(buf), \"autosave%d.sav\", _autosave_ctr);\n\n\t\tif (++_autosave_ctr >= _settings_client.gui.max_num_autosaves) _autosave_ctr = 0;\n\t}\n\n\tDEBUG(sl, 2, \"Autosaving to '%s'\", buf);\n\tif (SaveOrLoad(buf, SLO_SAVE, DFT_GAME_FILE, AUTOSAVE_DIR) != SL_OK) {\n\t\tShowErrorMessage(STR_ERROR_AUTOSAVE_FAILED, INVALID_STRING_ID, WL_ERROR);\n\t}\n}\n",
        "answer": "/** @brief Create an autosave. The default name is \"autosave#.sav\". However with the setting 'keep_all_autosave' the name defaults to company-name + date\n*\n*  This function creates an autosave with a default name of \"autosave#.sav\" or with the setting 'keep_all_autosave' the name defaults to company-name + date.\n*\n* @param buf A character buffer to store the savegame name and number according to _settings_client.gui.max_num_autosaves\n* @return Should not return\n*/\n/* Autosaving in networking is too time expensive for the PSP */\n/* generate a savegame name and number according to _settings_client.gui.max_num_autosaves */\nseprintf(buf, lastof(buf), \"autosave%d.sav\", _autosave_ctr);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline bool ContinueUpperMapEdgeSearch(int iter, int iter_limit, int sy, int sy_limit) { return iter < iter_limit && sy < sy_limit; }\n",
        "answer": "/** @brief Checks if the upper map edge search should continue in a positive direction.\n*\n*  This function checks if the upper map edge search should continue in a positive direction, starting at some tile.\n*\n* @param iter The current iteration number.\n* @param iter_limit The maximum number of iterations allowed.\n* @param sy The current y-coordinate of the tile being searched.\n* @param sy_limit The maximum y-coordinate of the map edge.\n* @return True if the search should continue, false otherwise.\n*/\nstatic inline bool ContinueUpperMapEdgeSearch(int iter, int iter_limit, int sy, int sy_limit) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string amino_acid_name( char code )\n{\n    auto ucode = toupper(code);\n    if( amino_acid_code_to_name.count( ucode ) == 0 ) {\n        throw std::out_of_range( \"Invalid amino acid code '\" + std::string( 1, code ) + \"'.\" );\n    }\n    return amino_acid_code_to_name.at( ucode );\n}\n",
        "answer": "/** @brief Returns the name of an amino acid given its one-letter code.\n*\n*  This function takes a character representing the one-letter code of an amino acid and returns its corresponding name.\n*  The valid codes are A, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, Y, Z, X, *, and -.\n*  If an invalid code is passed as input, the function throws a std::out_of_range exception.\n*\n* @param code The one-letter code of the amino acid.\n* @return The name of the amino acid corresponding to the given code.\n*/\nstd::string amino_acid_name( char code )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_valid_label( std::string const& label )\n{\n    std::string invalid_chars = \":,();[]'\";\n    for( auto c : label ) {\n        if( ! isgraph(c) || invalid_chars.find( c ) != std::string::npos ) {\n            return false;\n        }\n    }\n    return true;\n}\n",
        "answer": "/** @brief Checks if a given label is valid according to the most common interpretation of valid labels.\n*\n*  This function checks if a string is a valid label by checking if it contains any invalid characters.\n*  The invalid characters are defined as \":,();[]'\".\n*\n* @param label The label to be checked.\n* @return True if the label is valid, false otherwise.\n*/\nbool is_valid_label(std::string const& label) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::vector<double> signature_jensen_shannon(\n    Sequence const& sequence,\n    SignatureSpecifications const& settings\n) {\n    return signature_complementarity_frequencies_helper(\n        sequence,\n        settings,\n        []( double ff, double fc ){\n            assert( ff >= 0.0 && fc >= 0.0 );\n            auto const s1 = ff * log( ( 2 * ff ) / ( ff + fc ) );\n            auto const s2 = fc * log( ( 2 * fc ) / ( ff + fc ) );\n            return s1 + s2;\n        }\n    );\n}\n",
        "answer": "/**\n* @brief Calculates the Jensen-Shannon signature of a sequence.\n*\n* This function calculates the Jensen-Shannon signature of a sequence, which is a measure of the similarity between the\n* frequency of each nucleotide in the sequence and its complement. The signature is calculated using the formula:\n*\n* \\f[\n*   JS(x) = \\frac{1}{2} \\left( x \\log\\left(\\frac{2x}{x+y}\\right) + y \\log\\left(\\frac{2y}{x+y}\\right) \\right)\n* \\f]\n*\n* where \\f$x\\f$ and \\f$y\\f$ are the frequencies of the nucleotides in the sequence. The signature is a value between 0 and 1,\n* with higher values indicating greater similarity between the frequency of the nucleotides and their complements.\n*\n* @param sequence The input sequence to calculate the Jensen-Shannon signature for.\n* @param settings The signature specifications to use when calculating the signature.\n*\n* @return A vector containing the Jensen-Shannon signature for each k-mer in the sequence.\n*/\nstd::vector<double> signature_jensen_shannon(Sequence const& sequence, SignatureSpecifications const& settings);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string file_path( std::string const& filename )\n{\n    auto result = filename;\n    const size_t idx = result.find_last_of(\"\\\\/\");\n    if( idx == std::string::npos ) {\n        return \"\";\n    }\n\n    result.erase(idx);\n    return result;\n}\n",
        "answer": "/** @brief Extracts the directory path from a file name.\n*\n*  This function extracts the directory path from a file name by splitting at the last directory separator. If there is no directory separator, it returns an empty string.\n*\n* @param filename The file name to extract the directory path from.\n* @return The directory path.\n*/\nstd::string file_path( std::string const& filename )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dJointGetBallAnchor( dJointID j, dVector3 result )\n{\n    dxJointBall* joint = ( dxJointBall* )j;\n    dUASSERT( joint, \"bad joint argument\" );\n    dUASSERT( result, \"bad result argument\" );\n    checktype( joint, Ball );\n    if ( joint->flags & dJOINT_REVERSE )\n        getAnchor2( joint, result, joint->anchor2 );\n    else\n        getAnchor( joint, result, joint->anchor1 );\n}\n",
        "answer": "/** @brief Get the ball anchor point.\n*\n* This function returns the point on body 1 where the ball is attached. If the joint is perfectly satisfied, this will be the same as the point on body 2.\n*\n* @param j The ID of the ball joint.\n* @param result A vector to store the anchor point in.\n*/\nvoid dJointGetBallAnchor( dJointID j, dVector3 result )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "dHeightfieldDataID dGeomHeightfieldDataCreate()\n{\n    return new dxHeightfieldData();\n}\n",
        "answer": "/** @brief Allocates a new dHeightfieldDataID and returns it.\n*\n* This function allocates a new dHeightfieldDataID and returns it. You must call dGeomHeightfieldDataDestroy to destroy it after the geom has been removed. The dHeightfieldDataID value is used when specifying a data format type.\n*\n* @return A newly allocated dHeightfieldDataID.\n*/\ndHeightfieldDataID dGeomHeightfieldDataCreate()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dJointGetHinge2Anchor2( dJointID j, dVector3 result )\n{\n    dxJointHinge2* joint = ( dxJointHinge2* )j;\n    dUASSERT( joint, \"bad joint argument\" );\n    dUASSERT( result, \"bad result argument\" );\n    checktype( joint, Hinge2 );\n    if ( joint->flags & dJOINT_REVERSE )\n        getAnchor( joint, result, joint->anchor1 );\n    else\n        getAnchor2( joint, result, joint->anchor2 );\n}\n",
        "answer": "/**\n* @brief Get the joint anchor point in world coordinates.\n*\n* This returns the point on body 2. If the joint is perfectly satisfied, this will return the same value as dJointGetHinge2Anchor. If not, this value will be slightly different. This can be used, for example, to see how far the joint has come apart.\n*\n* @param j The joint ID.\n* @param result A pointer to a dVector3 that will hold the anchor point in world coordinates.\n*/\nvoid dJointGetHinge2Anchor2(dJointID j, dVector3 result) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int dWorldSetStepMemoryManager(dWorldID w, const dWorldStepMemoryFunctionsInfo *memfuncs)\n{\n    dUASSERT (w,\"bad world argument\");\n    dUASSERT (!memfuncs || memfuncs->struct_size >= sizeof(*memfuncs), \"Bad memory functions info\");\n\n    bool result = false;\n\n    dxStepWorkingMemory *wmem = memfuncs ? AllocateOnDemand(w->wmem) : w->wmem;\n\n    if (wmem)\n    {\n        if (memfuncs)\n        {\n            wmem->SetMemoryManager(memfuncs->alloc_block, memfuncs->shrink_block, memfuncs->free_block);\n            result = wmem->GetMemoryManager() != NULL;\n        }\n        else\n        {\n            wmem->ResetMemoryManagerToDefault();\n            result = true;\n        }\n    }\n    else if (!memfuncs)\n    {\n        result = true;\n    }\n\n    return result;\n}\n",
        "answer": "/** @brief Set the step memory manager for a world.\n*\n*  This function sets the memory manager for a world's step memory. If the world uses working memory sharing, changing the memory manager affects all the worlds linked together. Failure result status means a memory allocation failure.\n*\n* @param w The world to set the memory manager for.\n* @param memfuncs The memory functions info struct containing the memory manager functions.\n* @return True if the memory manager was successfully set, false otherwise.\n*/\nint dWorldSetStepMemoryManager(dWorldID w, const dWorldStepMemoryFunctionsInfo *memfuncs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dCleanupODEAllDataForThread()\n{\n    dUASSERT(g_uiODEInitCounter != 0, \"Call dInitODE2 first or delay dCloseODE until all threads exit\");\n\n    InternalCleanupODEAllDataForThread();\n}\n",
        "answer": "/** @brief Cleans up ODE data for a thread.\n*\n*  This function cleans up the ODE data for a thread. It is called by dCloseODE and should not be called directly.\n*\n* @return None\n*/\nvoid dCleanupODEAllDataForThread()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid print_gc_error_info(const char *func_name, int func_return) {\n\t\tGC_INFO gc_error_info;\n\t\tif (GC_ERROR == func_return) {\n\t\t\tgc_ErrorInfo(&gc_error_info);\n\t\t\tprint(\"%s return %d, GC ErrorValue:0x%hx-%s,\\n  CCLibID:%i-%s, CC ErrorValue:0x%lx-%s,\\n  Additional Info:%s\",\n\t\t\t\tfunc_name, func_return, gc_error_info.gcValue, gc_error_info.gcMsg,\n\t\t\t\tgc_error_info.ccLibId, gc_error_info.ccLibName,\n\t\t\t\tgc_error_info.ccValue, gc_error_info.ccMsg,\n\t\t\t\tgc_error_info.additionalInfo);\n\t\t}\n\t}\n",
        "answer": "/** @brief Print GC error information.\n*\n*  This function prints the error information returned by a GC API function.\n*\n* @param func_name The name of the function that returned an error.\n* @param func_return The return value of the function that returned an error.\n*/\nvoid print_gc_error_info(const char *func_name, int func_return) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool loopAgain(int event_thrown, int wait_for_event, int count, int wait_time){\n\n\tbool has_event_thrown = false;\n\tbool has_expired = false;\n\n\tif (event_thrown == wait_for_event){\n\t\thas_event_thrown = true;\n\t}\n\n\tif (hasExpired(count, wait_time)){\n\t\thas_expired = true;\n\t}\n\n\tif (has_event_thrown || has_expired){\n\t\treturn false;\n\t}\n\treturn true;\n}\n",
        "answer": "/** @brief Determines if the synchronous wrapper should loop again.\n*\n*  This function checks if the synchronous wrapper should continue to loop based on whether an event has been thrown and if the wait time has expired.\n*\n* @param event_thrown The event that was thrown.\n* @param wait_for_event The event that the wrapper is waiting for.\n* @param count The number of times the wrapper has looped.\n* @param wait_time The maximum amount of time the wrapper should wait before expiring.\n*\n* @return True if the synchronous wrapper should continue to loop, false otherwise.\n*/\nbool loopAgain(int event_thrown, int wait_for_event, int count, int wait_time)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double getXMLNum(CPLXMLNode *node, const char *pszPath, double def) \n{\n    const char *textval=CPLGetXMLValue(node,pszPath,0);\n    if (textval) return atof(textval);\n    return def;\n}\n",
        "answer": "/** @brief Extracts a numerical value from a XML node.\n*\n*  This function works like CPLGetXMLValue except for the default value being a number instead of a string.\n*\n* @param[in] node The XML node to extract the value from.\n* @param[in] pszPath The path to the value in the XML node.\n* @param[in] def The default value to return if the value is not found.\n*\n* @return The extracted numerical value or the default value if it was not found.\n*/\ndouble getXMLNum(CPLXMLNode *node, const char *pszPath, double def)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t getPrevWordBreakForCache(const uint16_t* chars,\n                                size_t offset,\n                                size_t len) {\n  if (offset == 0)\n    return 0;\n  if (offset > len)\n    offset = len;\n  if (isWordBreakBefore(chars[offset - 1])) {\n    return offset - 1;\n  }\n  for (size_t i = offset - 1; i > 0; i--) {\n    if (isWordBreakBefore(chars[i]) || isWordBreakAfter(chars[i - 1])) {\n      return i;\n    }\n  }\n  return 0;\n}\n",
        "answer": "/** @brief Get the offset of the previous word break for a given cache.\n*\n* This function returns the offset of the previous word break before the given offset in a string. It is either < offset or == 0. For the purpose of layout, a word break is a boundary with no kerning or complex script processing. This is necessarily a heuristic, but should be accurate most of the time.\n*\n* @param chars The string to search for the previous word break in.\n* @param offset The offset to start searching from.\n* @param len The length of the string.\n* @return The offset of the previous word break. It is either < offset or == 0.\n*/\nsize_t getPrevWordBreakForCache(const uint16_t* chars, size_t offset, size_t len) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main() {\n    app_setup_and_loop();\n    return 0;\n}\n",
        "answer": "/** @brief The entry point for the application.\n*\n* This is the entrypoint for your application.\n* You will use this to test and debug your\n* drivers and it will eventually hold the\n* code for your game.  Right now, it is\n* A tight while loop.\n*\n* @return Should not return\n*/\nvoid main() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void HAL_Delay_Milliseconds(uint32_t millis)\n{\n#if 1\n    os_delay(millis);\n#else\n    system_tick_t start_millis = HAL_Tick_Get_Milli_Seconds();\n\n    while (1)\n    {\n        HAL_IWDG_Feed();\n\n        system_tick_t elapsed_millis = HAL_Tick_Get_Milli_Seconds() - start_millis;\n\n        if (elapsed_millis > millis)\n        {\n            break;\n        }\n    }\n#endif\n}\n",
        "answer": "/**\n* @brief Delays the program execution for a specified number of milliseconds.\n*\n* This function delays the program execution for a specified number of milliseconds using the IWDG (Independent Watchdog) peripheral.\n* The IWDG is used to generate a system tick that is used to measure the elapsed time.\n*\n* @param millis The number of milliseconds to delay the program execution.\n*/\nvoid HAL_Delay_Milliseconds(uint32_t millis)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "log_output_fn_t molmc_log_set_output(log_output_fn_t func)\n{\n    init_debug_mutex();\n    LOCK();\n\n    log_output_fn_t orig_func = s_log_print_func;\n    s_log_print_func = func;\n\n    UNLOCK();\n    return orig_func;\n}\n",
        "answer": "/** @brief Set the log output function.\n*\n*  This function sets the log output function to a new function, which can be used to redirect log output to some other destination, such as file or network. Returns the original log handler, which may be necessary to return output to the previous destination.\n*\n* @param func The new log output function.\n* @return The original log output function.\n*/\nlog_output_fn_t molmc_log_set_output(log_output_fn_t func)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool system_rgb_off(void)\n{\n    if(!RGB.controlled()) {\n        HAL_UI_RGB_Color(RGB_COLOR_BLACK);\n        return true;\n    }\n    return false;\n}\n",
        "answer": "/** @brief Turns off the system RGB light.\n*\n*  This function turns off the system RGB light by setting its color to black.\n*\n* @return True if the RGB light was successfully turned off, false otherwise.\n*/\nbool system_rgb_off(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void tone(uint8_t pin, uint32_t frequency, uint32_t duration)\n{\n    if (pinAvailable(pin) && HAL_Validate_Pin_Function(pin, PF_TIMER)==PF_TIMER) {\n        HAL_Tone_Start(pin, frequency, duration);\n    }\n}\n",
        "answer": "/**\n* @brief Generates a tone on a pin.\n*\n* This function generates a tone of the specified frequency and duration on the specified pin.\n* The tone is generated using a timer peripheral, so it can be used to play music or other tones.\n*\n* @param[in] pin The pin number where the tone will be generated.\n* @param[in] frequency The frequency of the tone in Hz.\n* @param[in] duration The duration of the tone in milliseconds.\n*/\nvoid tone(uint8_t pin, uint32_t frequency, uint32_t duration)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void ble_evt_dispatch(ble_evt_t const * p_ble_evt, void *p_context)\n{\n    uint16_t role = ble_conn_state_role(p_ble_evt->evt.gap_evt.conn_handle);\n\n    if ((role == BLE_GAP_ROLE_CENTRAL) || /*(p_ble_evt->header.evt_id == BLE_GAP_EVT_ADV_REPORT) ||*/ g_BleAppData.AppRole & BLEAPP_ROLE_CENTRAL)\n    {\n        BleCentralEvtUserHandler((ble_evt_t *)p_ble_evt);\n    }\n    if (g_BleAppData.AppRole & BLEAPP_ROLE_PERIPHERAL)\n    {\n        BlePeriphEvtUserHandler((ble_evt_t *)p_ble_evt);\n    }\n    on_ble_evt(p_ble_evt);\n}\n",
        "answer": "/**\n* @brief BLE event dispatcher.\n*\n* This function is called from the SoftDevice event interrupt handler after a SoftDevice event has been received. It dispatches the event to the appropriate user handler based on the role of the connection.\n*\n* @param p_ble_evt The BLE event.\n* @param p_context The context pointer passed to the event interrupt handler.\n*/\nstatic void ble_evt_dispatch(ble_evt_t const * p_ble_evt, void *p_context)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int AiGetUnitTypeRequestedCount(const PlayerAi &pai, const CUnitType *type, const int landmass, const CSite *settlement)\n{\n\tint count = 0;\n\t\n\tfor (size_t i = 0; i < pai.UnitTypeBuilt.size(); ++i) {\n\t\tconst AiBuildQueue &queue = pai.UnitTypeBuilt[i];\n\t\tif (\n\t\t\tqueue.Type == type\n\t\t\t&& (!landmass || queue.Landmass == landmass)\n\t\t\t&& (!settlement || queue.Settlement == settlement)\n\t\t) {\n\t\t\tcount += queue.Want;\n\t\t}\n\t}\n\t\t\n\treturn count;\n}\n",
        "answer": "/** @brief Get whether the AI has a particular upgrade, possibly including requests and currently under research upgrades.\n*\n*  This function checks if the AI has a particular upgrade, taking into account both completed and in-progress upgrades.\n*\n* @param pai The PlayerAi object representing the AI player.\n* @param type The CUnitType object representing the unit type to check for.\n* @param landmass An optional parameter specifying the landmass on which the upgrade should be located.\n* @param settlement An optional parameter specifying the settlement where the upgrade should be located.\n* @return The number of units of the specified type that are currently requested or under research by the AI player.\n*/\nint AiGetUnitTypeRequestedCount(const PlayerAi &pai, const CUnitType *type, const int landmass, const CSite *settlement)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int CclUnitVar(lua_State *l)\n{\n\tif (lua_gettop(l) == 0 || lua_gettop(l) > 3) {\n\t\tLuaError(l, \"Bad number of arg for ActiveUnitVar()\\n\");\n\t}\n\treturn AliasUnitVar(l, \"Unit\");\n}\n",
        "answer": "/** @brief CclUnitVar function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param lua_State *l The Lua state.\n* @return Should not return\n*/\nstatic int CclUnitVar(lua_State *l)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void get_cartesian_from_steppers() {\n  #if ENABLED(DELTA)\n    forward_kinematics_DELTA(\n      stepper.get_axis_position_mm(A_AXIS),\n      stepper.get_axis_position_mm(B_AXIS),\n      stepper.get_axis_position_mm(C_AXIS)\n    );\n  #else\n    #if IS_SCARA\n      forward_kinematics_SCARA(\n        stepper.get_axis_position_degrees(A_AXIS),\n        stepper.get_axis_position_degrees(B_AXIS)\n      );\n    #else\n      cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);\n      cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);\n    #endif\n    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);\n  #endif\n}\n",
        "answer": "/** @brief Get the Cartesian positions from the steppers.\n*\n* This function applies forward kinematics for DELTA and SCARA printers, and returns the resulting Cartesian coordinates in the current coordinate space with leveling applied. The coordinates need to be run through unapply_leveling() to obtain machine coordinates suitable for current_position, etc.\n*\n* @param stepper The stepper motor positions.\n* @return The Cartesian coordinates in the current coordinate space with leveling applied.\n*/\nvoid get_cartesian_from_steppers(const float stepper[XYZ]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid startDocument()\n\t{\n\t\twhere(\"startDocument\");\n\t}\n",
        "answer": "/** @brief Receive an object for locating the origin of SAX document events.\n*\n*  This is the description of the functionality of the function.\n*\n*  SAX parsers are strongly encouraged (though not absolutely required) to supply a locator: if it does so, it must supply the locator to the application by invoking this method before invoking any of the other methods in the ContentHandler interface. The locator allows the application to determine the end position of any document-related event, even if the parser is not reporting an error. Typically, the application will use this information for reporting its own errors (such as character content that does not match an application's business rules). The information returned by the locator is probably not sufficient for use with a search engine. Note that the locator will return correct information only during the invocation SAX event callbacks after startDocument returns and before endDocument is called. The application should not attempt to use it at any other time.\n*\n* @return Should not return\n*/\nvoid startDocument()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool assert_main_thread()\r\n\t{\r\n\t\treturn (g_services_available && g_api) ? g_api->assert_main_thread() : true;\r\n\t}\r\n",
        "answer": "/** @brief Tests whether calling thread is main app thread, and shows diagnostic message in debugger output if it's not.\n*\n*  This function tests whether the calling thread is the main application thread, and displays a diagnostic message in the debugger output if it is not.\n*\n* @return true if the calling thread is the main app thread, false otherwise.\n*/\nbool assert_main_thread()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual bool handleEvent(unsigned long delay, unsigned int trackIndex,\n\t\t\tunsigned int patternIndex, const gm::NoteOnEvent *ev) { return true; };\n",
        "answer": "/** @brief Handles an event.\n*\n*  This function handles an event for a specific track and pattern.\n*  It returns true if the event was handled successfully, false otherwise.\n*\n* @param delay The delay in milliseconds before the event is triggered.\n* @param trackIndex The index of the track that the event belongs to.\n* @param patternIndex The index of the pattern that the event belongs to.\n* @param ev A pointer to the NoteOnEvent object that represents the event.\n* @return True if the event was handled successfully, false otherwise.\n*/\nvirtual bool handleEvent(unsigned long delay, unsigned int trackIndex,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  AtomicGroup averageStructure(const AtomicGroup& g, const std::vector<XForm>& xforms, pTraj& traj) {\n    uint nx = xforms.size();\n    uint nt = traj->nframes();\n    \n    if (nt != nx)\n      throw(std::runtime_error(\"Mismatch in number of frames in the trajectory and passed transforms\"));\n    std::vector<uint> frame_indices;\n    for (uint i=0; i<nt; ++i)\n      frame_indices.push_back(i);\n\n    return(averageStructure(g, xforms, traj, frame_indices));\n  }\n",
        "answer": "/** @brief Average structure of an atomic group from a trajectory.\n*\n* This function takes an AtomicGroup and a Trajectory as input, and returns the average structure of the group over all frames in the trajectory. The function also takes a vector of XForms and a pTraj object as input, which are used to transform the atomic positions in each frame before averaging.\n*\n* @param g The AtomicGroup to be averaged.\n* @param xforms A vector of XForms that will be applied to the atomic positions in each frame before averaging.\n* @param traj The Trajectory object containing the frames to be averaged.\n* @return The average structure of the AtomicGroup over all frames in the trajectory.\n*/\nAtomicGroup averageStructure(const AtomicGroup& g, const std::vector<XForm>& xforms, pTraj& traj) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "lepcc_status lepcc_encodeIntensity(lepcc_ContextHdl _ctx, unsigned char** ppByteOut, int bufferSizeOut,  const unsigned short* intensities, unsigned int nElem)\n{\n  CtxImpl* ctx = reinterpret_cast<CtxImpl*>(_ctx);\n  if (!ctx || !ctx->inty || !intensities)\n    return (lepcc_status)ErrCode::WrongParam;\n\n  auto hr = ctx->inty->Encode(ppByteOut, int64(bufferSizeOut), nElem, intensities);\n  return (lepcc_status)hr;\n}\n",
        "answer": "/** @brief Encodes intensity following a call to lepcc_computeCompressedSizeIntensity(). Output buffers must have been sized accordingly.\n*\n*  This function encodes the intensity values passed in the \"intensities\" parameter, using the context and output buffer provided. The function returns a status code indicating whether the encoding was successful or not.\n*\n* @param _ctx A handle to the LEPCC context.\n* @param ppByteOut A pointer to the output buffer where the encoded data will be written.\n* @param bufferSizeOut The size of the output buffer in bytes.\n* @param intensities A pointer to an array of unsigned short values representing the intensity values to be encoded.\n* @param nElem The number of elements in the \"intensities\" array.\n* @return lepcc_status::Ok if the encoding was successful, or a status code indicating the error that occurred.\n*/\nlepcc_status lepcc_encodeIntensity(lepcc_ContextHdl _ctx, unsigned char** ppByteOut, int bufferSizeOut,  const unsigned short* intensities, unsigned int nElem)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void myOnOffWrite(struct wiringPiNodeStruct *node, int pin, int value)\n{\n\tint fd = node->fd;\n\tint ipin = pin - node->pinBase;\n\n\tif (value)\n\t\tPCA9685FullOn(fd, ipin, 1);\n\telse\n\t\tPCA9685FullOff(fd, ipin, 1);\n}\n",
        "answer": "/** @brief myOnOffWrite function.\n*\n* This function is used to enable or disable the full-on and full-off control of a pin.\n* If value is 0, full-off will be enabled.\n* If value is not 0, full-on will be enabled.\n*\n* @param node A pointer to a wiringPiNodeStruct structure that contains information about the pin.\n* @param pin The pin number for which the full-on and full-off control needs to be enabled or disabled.\n* @param value The value that determines whether full-on or full-off should be enabled. If 0, full-off will be enabled. If not 0, full-on will be enabled.\n* @return None.\n*/\nstatic void myOnOffWrite(struct wiringPiNodeStruct *node, int pin, int value)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void gfxSemSignal(gfxSem *psem)\n{\n    static_cast<QSemaphore*>(*psem)->release(1);\n}\n",
        "answer": "/** @brief Increases the semaphore counter and queues a waiting thread for execution if the result is non-positive.\n*\n*  If the semaphore counter reaches \"limit\", further signals are ignored.\n*\n* @param psem The semaphore to signal.\n*/\nvoid gfxSemSignal(gfxSem *psem)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void pushScreenCoordinateMatrix() {\n\tglPushAttrib(GL_TRANSFORM_BIT);\n\tGLint\tviewport[4];\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\tglMatrixMode(GL_PROJECTION);\n\tglPushMatrix();\n\tglLoadIdentity();\n\tgluOrtho2D(viewport[0],viewport[2],viewport[1],viewport[3]);\n\tglPopAttrib();\n}\n",
        "answer": "/** @brief Pushes a projection matrix that will make object world coordinates identical to window coordinates.\n*\n*  This function pushes a projection matrix onto the OpenGL matrix stack that will make object world coordinates identical to window coordinates. It does this by first pushing the current transform attributes, then getting and storing the current viewport dimensions, switching to the projection matrix mode, pushing a new matrix onto the stack, loading an identity matrix, and finally setting up an orthographic projection using the stored viewport dimensions.\n*\n* @return void\n*/\ninline void pushScreenCoordinateMatrix() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int azs_rename(const char *src, const char *dst)\n{\n    AZS_DEBUGLOGV(\"azs_rename called with src = %s, dst = %s.\\n\", src, dst);\n\n    struct stat statbuf;\n    errno = 0;\n    int getattrret = azs_getattr(src, &statbuf);\n    if (getattrret != 0)\n    {\n        return getattrret;\n    }\n    if ((statbuf.st_mode & S_IFDIR) == S_IFDIR)\n    {\n        azs_rename_directory(src, dst);\n    }\n    else\n    {\n        azs_rename_single_file(src, dst);\n    }\n\n    return 0;\n}\n",
        "answer": "/** @brief Renames a file or directory.\n*\n* This method renames a file or directory in the Azure Blob Storage account. It is implemented using server-side blob copy, followed by deletion of the source. This method is not atomic.\n*\n* @param src The current name of the file or directory to be renamed.\n* @param dst The new name for the file or directory.\n*\n* @return 0 if successful, otherwise returns an error code.\n*/\nint azs_rename(const char *src, const char *dst)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    static bool HasANSIColourSupport()\n    {\n        return IsOSVersionAtLeast(10, 0, 10586);\n    }\n",
        "answer": "/** @brief Checks if the current version of Windows supports ANSI colour codes.\n*\n*  From Windows 10, build 10586 ANSI escape colour codes can be used on stdout.\n*\n* @return true if the current version of Windows supports ANSI colour codes, false otherwise.\n*/\nstatic bool HasANSIColourSupport()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int32_t get_object_from_object_selection(uint8_t object_type, int32_t y)\n{\n    int32_t listItemIndex = y / 12;\n    if (listItemIndex < 0 || (size_t)listItemIndex >= _listItems.size())\n        return -1;\n\n    return listItemIndex;\n}\n",
        "answer": "/** @brief Get the object from an object selection based on its y coordinate.\n*\n*  This function takes the y coordinate of a clicked scroll list item and converts it into an object selection. It returns the position in the list. The object_selection_flags and installed_entry are also populated.\n*\n* @param[in] object_type The type of object to retrieve.\n* @param[in] y The y coordinate of the clicked scroll list item.\n* @return The position in the list, or -1 if the index is out of range.\n*/\nstatic int32_t get_object_from_object_selection(uint8_t object_type, int32_t y)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void format_string_to_upper(utf8* dest, size_t size, rct_string_id format, const void* args)\n{\n#ifdef DEBUG\n    if (gDebugStringFormatting)\n    {\n        printf(\"format_string_to_upper(%hu)\\n\", format);\n    }\n#endif\n\n    if (size == 0)\n    {\n        return;\n    }\n\n    format_string(dest, size, format, args);\n\n    std::string upperString = String::ToUpper(dest);\n\n    if (upperString.size() + 1 >= size)\n    {\n        upperString.resize(size - 1);\n        dest[size - 1] = '\\0';\n        log_warning(\"Truncating formatted string \\\"%s\\\" to %d bytes.\", dest, size);\n    }\n\n    upperString.copy(dest, upperString.size());\n    dest[upperString.size()] = '\\0';\n}\n",
        "answer": "/**\n* @brief Formats a string and converts it to upper case.\n*\n* This function formats a string using the specified format string and arguments,\n* and then converts the resulting string to upper case.\n*\n* @param dest The destination buffer for the formatted string.\n* @param size The size of the destination buffer.\n* @param format The format string used to format the output string.\n* @param args The arguments to be passed to the format string.\n*/\nvoid format_string_to_upper(utf8* dest, size_t size, rct_string_id format, const void* args)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void TitleSequenceCloseParkHandle(TitleSequenceParkHandle* handle)\n{\n    if (handle != nullptr)\n    {\n        Memory::Free(handle->HintPath);\n        delete ((IStream*)handle->Stream);\n        Memory::Free(handle);\n    }\n}\n",
        "answer": "/** @brief Closes a title sequence park handle.\n*\n*  This function closes the given title sequence park handle and frees any associated memory.\n*  The pointer to the handle is invalid after calling this function.\n*\n* @param[in,out] handle A pointer to the title sequence park handle to be closed.\n*/\nvoid TitleSequenceCloseParkHandle(TitleSequenceParkHandle* handle)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void widget_invalidate_by_number(rct_windowclass cls, rct_windownumber number, rct_widgetindex widgetIndex)\n{\n    for (auto& w : g_window_list)\n    {\n        if (w->classification == cls && w->number == number)\n        {\n            widget_invalidate(w.get(), widgetIndex);\n        }\n    }\n}\n",
        "answer": "/** @brief Invalidates the specified widget of all windows that match the specified window class and number.\n*\n*  This function iterates through a list of windows, checking each one to see if it matches the specified window class and number. If a match is found, the specified widget is invalidated using the widget_invalidate() function.\n*\n* @param cls The window class to search for.\n* @param number The window number to search for.\n* @param widgetIndex The index of the widget to invalidate.\n*/\nvoid widget_invalidate_by_number(rct_windowclass cls, rct_windownumber number, rct_widgetindex widgetIndex)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool gfx_d3d9 (void)\n{\n    return d3d9;\n}\n",
        "answer": "/** @brief Checks if we are in Direct3D 9.\n*\n*  This function checks if the environment variable for Direct3D 9 is set.\n*  It can be used to initialize globals before main().\n*\n* @return True if we are in Direct3D 9, false otherwise.\n*/\nbool gfx_d3d9 (void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void input_filter_set_cursor_hidden (bool v)\n{\n    cursor_hidden = v;\n    update_grabbed();\n}\n",
        "answer": "/** @brief Suppress system mouse cursor.\n*\n*  This function is used to hide the system mouse cursor and draw your own instead.\n*\n* @param v A boolean value indicating whether the cursor should be hidden or not.\n*/\nvoid input_filter_set_cursor_hidden(bool v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual ssize_t GetMessageLength(const flinter::EasyContext &context,\n                                     const void *buffer,\n                                     size_t length)\n    {\n        LOG(INFO) << \"Handler: \" << _id << \" GetMessageLength(\" << context.channel() << \")\";\n        return length;\n    }\n",
        "answer": "/** @brief Gets the message length from a buffer.\n*\n*  This function is called within I/O threads to get the message length from a buffer. It returns the packet size even if it's incomplete as long as you can tell, which is very handy when you write the message length in the header.\n*\n* @param context The easy context of the channel.\n* @param buffer The buffer containing the message.\n* @param length The length of the buffer.\n* @return The message length.\n*/\nvirtual ssize_t GetMessageLength(const flinter::EasyContext &context, const void *buffer, size_t length) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void world2machine_reset()\n{\n    const float vx[] = { 1.f, 0.f };\n    const float vy[] = { 0.f, 1.f };\n    const float cntr[] = { 0.f, 0.f };\n    world2machine_update(vx, vy, cntr);\n}\n",
        "answer": "/** @brief Resets the world-to-machine transformation.\n*\n*  This function resets the world-to-machine transformation by setting the\n*  translation and rotation vectors to their default values. It does not wait\n*  for finishing moves nor updates the current position with the absolute values.\n*\n* @return None\n*/\nvoid world2machine_reset()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual uint32_t getFlags()\n    {\n        uint32_t flags = this->INHERITED::getFlags();\n        \n        switch (this->getSrcBitmap().getConfig()) {\n        case SkBitmap::kRGB_565_Config:\n            flags |= kHasSpan16_Flag;\n            break;\n        case SkBitmap::kIndex8_Config:\n        case SkBitmap::kARGB_8888_Config:\n            if (this->getSrcBitmap().isOpaque())\n                flags |= kHasSpan16_Flag;\n            break;\n        default:\n            break;\n        }\n        return flags;\n    }\n",
        "answer": "/**\n* @brief Gets the flags for the shader.\n*\n* This method is called sometimes before drawing with this shader. It returns the type of alpha that the shader will return. The default implementation returns 0. Your subclass should override if it can (even sometimes) report a non-zero value, since that will enable various blitters to perform faster.\n*\n* @return The flags for the shader.\n*/\nvirtual uint32_t getFlags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double MercatorLatToY(double lat) {\n  if (lat >= MAX_MERCATOR_LATITUDE) {\n    return PI;\n  } else if (lat <= -MAX_MERCATOR_LATITUDE) {\n    return -PI;\n  }\n\n  return log(tan(PI / 4.0 + lat / 360.0 * PI));\n}\n",
        "answer": "/** @brief Converts Mercator latitude to y coordinate.\n*\n*  This function takes a Mercator latitude as input and returns the corresponding y coordinate. The y coordinate is in the range of (-pi, pi).\n*\n* @param lat The Mercator latitude.\n* @return The y coordinate associated with the given latitude.\n*/\ndouble MercatorLatToY(double lat) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void HandleIntegerSModifier(unsigned ValNo,\n                                   SmallVectorImpl<char> &OutStr) {\n  if (ValNo != 1)\n    OutStr.push_back('s');\n}\n",
        "answer": "/** @brief Handle the integer 's' modifier.\n*\n* This function adds the letter 's' to the string if the value is not 1. It is used in cases like this: \"you idiot, you have %4 parameter%s4!\".\n*\n* @param ValNo The value number.\n* @param OutStr The output string.\n*/\nstatic void HandleIntegerSModifier(unsigned ValNo, SmallVectorImpl<char> &OutStr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool checkMSVCHeaderSearch(DiagnosticsEngine &Diags,\n                                  const FileEntry *MSFE, const FileEntry *FE,\n                                  SourceLocation IncludeLoc) {\n    if (MSFE && FE != MSFE) {\n        Diags.Report(IncludeLoc, diag::ext_pp_include_search_ms) << MSFE->getName();\n        return true;\n    }\n    return false;\n}\n",
        "answer": "/** @brief Checks if MSVC header search is enabled.\n*\n*  This function checks if MSVC header search is enabled and reports a diagnostic if it fails to match the one that Clang would have found with MSVC header search disabled.\n*\n* @param Diags The diagnostics engine.\n* @param MSFE The file entry for the MSVC header search.\n* @param FE The file entry for the Clang header search.\n* @param IncludeLoc The source location of the include directive.\n* @return True if MSVC header search is enabled and a diagnostic is reported, false otherwise.\n*/\nstatic bool checkMSVCHeaderSearch(DiagnosticsEngine &Diags,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline char findMatchingPunctuation(char c) {\n  switch (c) {\n  case '\\'': return '\\'';\n  case '`': return '\\'';\n  case '\"':  return '\"';\n  case '(':  return ')';\n  case '[': return ']';\n  case '{': return '}';\n  default: break;\n  }\n\n  return 0;\n}\n",
        "answer": "/** @brief Finds the matching punctuation for a given character.\n*\n* This function takes in a character and returns the matching punctuation for it, if it exists.\n* If the given character is not the start of some kind of balanced punctuation (e.g., quotes or parentheses),\n* the function will return 0.\n*\n* @param c The character to find the matching punctuation for.\n* @return The matching punctuation character, or 0 if none exists.\n*/\nstatic inline char findMatchingPunctuation(char c) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int chromaprint_get_fingerprint(ChromaprintContext *c, char **data)\n{\n\tChromaprintContextPrivate *ctx = (ChromaprintContextPrivate *)c;\n\tif (!ctx->finished) {\n\t\treturn 0;\n\t}\n\tstring fp = Chromaprint::Base64Encode(Chromaprint::CompressFingerprint(ctx->fingerprint, ctx->algorithm));\n\t*data = (char *)malloc(fp.size() + 1);\n\tif (!*data) {\n\t\treturn 0;\n\t}\n\tcopy(fp.begin(), fp.end(), *data);\n\t(*data)[fp.size()] = 0;\n\treturn 1;\n}\n",
        "answer": "/** @brief Calculates the fingerprint of an audio file and returns it as a compressed string.\n*\n*  This function takes a ChromaprintContext object and a pointer to a char array as input, and returns the calculated fingerprint as a compressed string. The caller is responsible for freeing the returned pointer using chromaprint_dealloc().\n*\n* @param c A ChromaprintContext object representing the audio file to be processed.\n* @param data A pointer to a char array where the calculated fingerprint will be stored.\n* @return 1 if the calculation was successful, 0 otherwise.\n*/\n*data = (char *)malloc(fp.size() + 1);\nif (!*data) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int chromaprint_hash_fingerprint(const void *fp, int size, void *hash)\n{\n\tif (fp == NULL || size < 0 || hash == NULL) {\n\t\treturn 0;\n\t}\n\t*((int32_t *)hash) = SimHash((const int32_t *)fp, size);\n\treturn 1;\n}\n",
        "answer": "/** @brief Generate a single 32-bit hash for a raw fingerprint.\n*\n* This function generates a single 32-bit hash for a raw fingerprint. If two fingerprints are similar, their hashes generated by this function will also be similar. If they are significantly different, their hashes will most likely be significantly different as well, but you can't rely on that. You compare two hashes by counting the bits in which they differ. Normally that would be something like POPCNT(hash1 XOR hash2), which returns a number between 0 and 32. Anything above 15 means the hashes are completely different.\n*\n* @param fp The raw fingerprint data to generate the hash for.\n* @param size The size of the raw fingerprint data in bytes.\n* @param hash A pointer to a 32-bit integer where the generated hash will be stored.\n* @return 1 if the hash was generated successfully, 0 otherwise.\n*/\n*((int32_t *)hash) = SimHash((const int32_t *)fp, size);\nreturn 1;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_bailie_psw_probable_prime(const BigInt& n)\n   {\n   Modular_Reducer mod_n(n);\n   return is_bailie_psw_probable_prime(n, mod_n);\n   }\n",
        "answer": "/** @brief Perform Bailie-PSW primality test.\n*\n*  This function performs the Bailie-PSW primality test on a given number. The test is a combination of Miller-Rabin with base 2 and a Lucas test. No known composite integer passes both tests, though it is conjectured that infinitely many composite counterexamples exist.\n*\n* @param n The number to be tested for primality.\n* @param mod_n A ModularReducer object for the given number.\n* @return True if the number is probably prime, false otherwise.\n*/\nbool is_bailie_psw_probable_prime(const BigInt& n, const ModularReducer& mod_n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NJXLInsRef NJX_eqi(NJXFunctionBuilderRef fn, NJXLInsRef lhs, NJXLInsRef rhs) {\n  return wrap_ins(\n      unwrap_function_builder(fn)->eqi(unwrap_ins(lhs), unwrap_ins((rhs))));\n}\n",
        "answer": "/** @brief Compares two integers for equality.\n*\n*  This function compares two integers for equality. It takes two arguments, lhs and rhs, which are the left-hand side and right-hand side of the comparison, respectively. The function returns a boolean value indicating whether the two values are equal or not.\n*\n* @param fn A reference to the NJXFunctionBuilder object.\n* @param lhs The left-hand side argument of the comparison.\n* @param rhs The right-hand side argument of the comparison.\n* @return A boolean value indicating whether the two values are equal or not.\n*/\nNJXLInsRef NJX_eqi(NJXFunctionBuilderRef fn, NJXLInsRef lhs, NJXLInsRef rhs) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string contentsString(boost::filesystem::path const& _file)\n{\n\treturn contentsGeneric<string>(_file);\n}\n",
        "answer": "/** @brief Retrieves and returns the contents of a file as a std::string.\n*\n*  This function retrieves and returns the contents of a given file as a std::string. If the file doesn't exist or isn't readable, it returns an empty container / bytes.\n*\n* @param _file The path to the file to be read.\n* @return A std::string containing the contents of the file, or an empty string if the file couldn't be read.\n*/\nstring contentsString(boost::filesystem::path const& _file)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool definedInCaller(const SetVector<BasicBlock *> &Blocks, Value *V) {\n    if (isa<Argument>(V)) return true;\n    if (Instruction *I = dyn_cast<Instruction>(V))\n        if (!Blocks.count(I->getParent())) return true;\n    return false;\n}\n",
        "answer": "/** @brief Determines whether a value is defined in the caller function but not in the extracted region.\n*\n*  This function checks if the specified value is an argument or an instruction that belongs to a basic block that is not part of the extracted region. If it is, then the value is considered to be defined in the caller function but not in the extracted region.\n*\n* @param Blocks The set of basic blocks that make up the extracted region.\n* @param V The value to check.\n* @return True if the value is defined in the caller function but not in the extracted region, false otherwise.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "EVENT_TYPE confirm_license(char * product,\n\t\tLicenseLocation licenseLocation) {\n\treturn LICENSE_OK;\n}\n",
        "answer": "/** @brief Confirms the license for a given product and location.\n*\n* This function is used to confirm that a license is valid for a given product and location. It should be called periodically to ensure that the license is still valid.\n*\n* @param product The name of the product for which the license is being confirmed.\n* @param licenseLocation The location where the license was obtained (either from a file or from a network).\n*\n* @return LICENSE_OK if the license is valid, or an error code otherwise.\n*/\nEVENT_TYPE confirm_license(char * product, LicenseLocation licenseLocation) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcInit(const char* cfg) \n  {\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcInit);\n    Lock<MutexSys> lock(g_mutex);\n    if (g_device) throw_RTCError(RTC_INVALID_OPERATION,\"already initialized\");\n    g_device = new Device(cfg,true);\n    RTCORE_CATCH_END(g_device);\n  }\n",
        "answer": "/**\n* @brief Initializes the ray tracing core and passes some configuration string.\n*\n* The configuration string allows to configure implementation specific parameters. If this string is NULL, a default configuration is used.\n*\n* @param cfg A pointer to a null-terminated string containing the configuration options.\n*\n* @return Should not return.\n*/\nRTCORE_API void rtcInit(const char* cfg);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcDeviceSetMemoryMonitorFunction(RTCDevice hdevice, RTCMemoryMonitorFunc func) \n  {\n    Device* device = (Device*) hdevice;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcDeviceSetMemoryMonitorFunction);\n    device->memory_monitor_function = func;\n    RTCORE_CATCH_END(device);\n  }\n",
        "answer": "/**\n* @brief Sets the memory consumption callback function which is called before or after the library allocates or frees memory.\n*\n* This function sets a callback function that will be called by the library whenever it needs to allocate or free memory. The callback function should return the amount of memory that was allocated or freed, and can optionally provide additional information about the allocation or deallocation event.\n*\n* @param hdevice A handle to the device for which the memory monitor function is being set.\n* @param func The memory monitor function to be called by the library. This function should have a signature of void(size_t bytes, bool post) where bytes is the number of bytes allocated or freed and post is true if the callback is being made after the allocation or deallocation event, and false otherwise.\n* @return None.\n*/\nRTCORE_API void rtcDeviceSetMemoryMonitorFunction(RTCDevice hdevice, RTCMemoryMonitorFunc func);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API unsigned rtcNewQuadMesh (RTCScene hscene, RTCGeometryFlags flags, size_t numQuads, size_t numVertices, size_t numTimeSteps) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcNewQuadMesh);\n    RTCORE_VERIFY_HANDLE(hscene);\n    return scene->newQuadMesh(flags,numQuads,numVertices,numTimeSteps);\n    RTCORE_CATCH_END(scene->device);\n    return -1;\n  }\n",
        "answer": "/** @brief Creates a new quad mesh.\n*\n* This function creates a new quad mesh with the specified number of quads, vertices, and time steps. The quad indices can be set by mapping and writing to the index buffer (RTC_INDEX_BUFFER) and the quad vertices can be set by mapping and writing into the vertex buffer (RTC_VERTEX_BUFFER). In case of linear motion blur, two vertex buffers have to get filled (RTC_VERTEX_BUFFER0, RTC_VERTEX_BUFFER1), one for each time step. The index buffer has the default layout of three 32 bit integer indices for each quad. An index points to the ith vertex. The vertex buffer stores single precision x,y,z floating point coordinates aligned to 16 bytes. The value of the 4th float used for alignment can be arbitrary.\n*\n* @param hscene A handle to the scene that will contain the new quad mesh.\n* @param flags Flags specifying properties of the quad mesh, such as RTC_GEOMETRY_STATIC or RTC_GEOMETRY_DYNAMIC.\n* @param numQuads The number of quads in the mesh.\n* @param numVertices The number of vertices in the mesh.\n* @param numTimeSteps The number of time steps in the mesh, which should be 1 for normal meshes and 2 for linear motion blur.\n* @return A handle to the new quad mesh, or -1 if an error occurred.\n*/\nRTCORE_API unsigned rtcNewQuadMesh (RTCScene hscene, RTCGeometryFlags flags, size_t numQuads, size_t numVertices, size_t numTimeSteps)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcUpdate (RTCScene hscene, unsigned geomID) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcUpdate);\n    RTCORE_VERIFY_HANDLE(hscene);\n    RTCORE_VERIFY_GEOMID(geomID);\n    scene->get_locked(geomID)->update();\n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/** @brief Updates the geometry buffers of a specified geometry in the scene.\n*\n* Each time geometry buffers got modified, the user has to call some update function to tell the ray tracing engine which buffers got modified. The rtcUpdate function tags each geometry buffer of the specified geometry as modified.\n*\n* @param hscene A handle to the scene containing the geometry to be updated.\n* @param geomID The ID of the geometry to be updated.\n*\n* @return void\n*/\nRTCORE_API void rtcUpdate (RTCScene hscene, unsigned geomID)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcSetBoundsFunction2 (RTCScene hscene, unsigned geomID, RTCBoundsFunc2 bounds, void* userPtr)\n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcSetBoundsFunction2);\n    RTCORE_VERIFY_HANDLE(hscene);\n    RTCORE_VERIFY_GEOMID(geomID);\n    scene->get_locked(geomID)->setBoundsFunction2(bounds,userPtr);\n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/** @brief Sets the bounding function to calculate bounding boxes of the user geometry items when building spatial index structures. The calculated bounding box have to be conservative and should be tight.\n*\n* @param hscene Handle to the scene.\n* @param geomID ID of the geometry item.\n* @param bounds Pointer to the function that calculates the bounding boxes.\n* @param userPtr Pointer to the user data.\n*/\nRTCORE_API void rtcSetBoundsFunction2 (RTCScene hscene, unsigned geomID, RTCBoundsFunc2 bounds, void* userPtr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcSetOccludedFunction (RTCScene hscene, unsigned geomID, RTCOccludedFunc occluded) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcSetOccludedFunction);\n    RTCORE_VERIFY_HANDLE(hscene);\n    RTCORE_VERIFY_GEOMID(geomID);\n    scene->get_locked(geomID)->setOccludedFunction(occluded);\n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/**\n* @brief Set occlusion function for single rays.\n*\n* The rtcOccluded function will call the passed function for intersecting the user geometry.\n*\n* @param hscene Handle to the scene.\n* @param geomID ID of the geometry.\n* @param occluded Pointer to the occlusion function.\n*/\nRTCORE_API void rtcSetOccludedFunction (RTCScene hscene, unsigned geomID, RTCOccludedFunc occluded);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t vu_max(int32_t a, int32_t b)\n{\n    if (a < 0 && b < 0)\n        return std::min(a, b);\n    return std::max(a, b);\n}\n",
        "answer": "/** @brief Calculates the maximum of two integers.\n*\n*  This function calculates the maximum of two integers using the std::max and std::min functions.\n*  It is used to support denormals in the VU max and min instructions.\n*\n* @param a The first integer to compare.\n* @param b The second integer to compare.\n* @return The maximum of the two integers.\n*/\nint32_t vu_max(int32_t a, int32_t b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "menoh_error_code menoh_variable_profile_table_get_dims_at(\n  const menoh_variable_profile_table_handle variable_profile_table,\n  const char* name, int32_t index, int32_t* dst_size) {\n    return impl::menoh_variable_profile_table_get_variable_attribute(\n      variable_profile_table, name,\n      [&](auto const& profile) { *dst_size = profile.dims().at(index); });\n}\n",
        "answer": "/** @brief Get the dimensions of a variable at a specific index in the variable profile table.\n*\n*  This function selects a variable by name and index, then gets its dimensions using the `dims.at(index)` method.\n*\n* @param[in] variable_profile_table The handle to the variable profile table.\n* @param[in] name The name of the variable to select.\n* @param[in] index The index of the dimension to get.\n* @param[out] dst_size A pointer to an integer that will hold the size of the dimension at the specified index.\n*\n* @return A menoh error code indicating success or failure.\n*/\nvoid menoh_variable_profile_table_get_dims_at("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid threadMain() {\n\t\tTRACE_POINT();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tUPDATE_TRACE_POINT();\n\t\t\t\tinactivityTimer.start();\n\t\t\t\tFileDescriptor fd(acceptConnection());\n\t\t\t\tinactivityTimer.stop();\n\t\t\t\thandleRequest(fd);\n\t\t\t}\n\t\t} catch (const boost::thread_interrupted &) {\n\t\t\tP_TRACE(2, \"Client thread \" << this << \" interrupted.\");\n\t\t} catch (const tracable_exception &e) {\n\t\t\tP_ERROR(\"Uncaught exception in PassengerServer client thread:\\n\"\n\t\t\t\t<< \"   exception: \" << e.what() << \"\\n\"\n\t\t\t\t<< \"   backtrace:\\n\" << e.backtrace());\n\t\t\tabort();\n\t\t}\n\t}\n",
        "answer": "/** @brief Client thread main function.\n*\n*  This is the main function for the client's main thread, responsible for accepting connections made by a client to the server and handling its request.\n*\n* @return Should not return\n*/\nvoid threadMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tint saveStateBeforeRewriteRules(request_rec *r) {\n\t\tRequestNote *note = getRequestNote(r);\n\t\tif (note != 0 && hasModRewrite()) {\n\t\t\tnote->handlerBeforeModRewrite = r->handler;\n\t\t\tnote->filenameBeforeModRewrite = r->filename;\n\t\t}\n\t\treturn DECLINED;\n\t}\n",
        "answer": "/** @brief Save the state before mod_rewrite rules are applied.\n*\n*  This function saves the current request handler and filename\n*  before any mod_rewrite rules are applied. It is used to restore\n*  the original request handler and filename after the rewrite rules\n*  have been processed.\n*\n* @param r The request record for the current request.\n* @return DECLINED if the function succeeds, or an error code if it fails.\n*/\nint saveStateBeforeRewriteRules(request_rec *r) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void sendStartupInfo(int fd) {\n\t\twriteArrayMessage(fd,\n\t\t\t\"LoggingServer info\",\n\t\t\tloggingAgentAddress.c_str(),\n\t\t\tloggingAgentPassword.c_str(),\n\t\t\tNULL);\n\t}\n",
        "answer": "/** @brief Send started agent process's startup information over the given file descriptor to the starter process. May throw arbitrary exceptions.\n*\n* This function sends the startup information of a started agent process over a given file descriptor to the starter process. The startup information includes the logging server address and password.\n*\n* @param fd The file descriptor to send the startup information over.\n*/\nvirtual void sendStartupInfo(int fd) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class EnvironmentBlock {\npublic:\n    EnvironmentBlock(HANDLE hToken) : m_pv(NULL)\n    {\n        ::CreateEnvironmentBlock(&m_pv, hToken, FALSE);\n    }\n    ~EnvironmentBlock()\n    {\n        if (m_pv) ::DestroyEnvironmentBlock(m_pv);\n    }\n    operator PVOID()\n    { return m_pv; }\nprivate:\n    PVOID m_pv;\n};\n",
        "answer": "/**\n* @brief RAII class to create/destroy an environment block for a specific user. The user is identified by the supplied token handle.\n*\n* This class creates and manages an environment block for a specific user, using the provided token handle to identify the user.\n* The environment block is created when the class is constructed, and it is destroyed when the class is destructed.\n*\n* @param hToken A handle to the token that identifies the user for which the environment block should be created.\n*/\nclass EnvironmentBlock "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool printInstance(const Graph &graph, const EdgeArray<T> caps, const node s, const node t, const EdgeArray<T> &flows)\n{\n\tif(!printedFailedInstance) {\n\t\tprintedFailedInstance = true;\n\n\t\tstd::cout << std::endl << \"Graph consists of \" << graph.numberOfNodes() << \" nodes:\" << std::endl;\n\t\tfor(node v : graph.nodes) {\n\t\t\tstd::cout << \"  \" << v;\n\t\t\tif(v == s) { std::cout << \" [source]\"; }\n\t\t\tif(v == t) { std::cout << \" [sink]\"; }\n\t\t\tstd::cout << std::endl;\n\t\t}\n\t\tstd::cout << \"Graph has \" << graph.numberOfEdges() << \" edges:\" << std::endl;\n\t\tfor(edge e : graph.edges) {\n\t\t\tstd::cout << \"  \" << e << \" \" << flows[e] << \" / \" << caps[e] << std::endl;\n\t\t}\n\t}\n\treturn false;\n}\n",
        "answer": "/** @brief Prints the first encountered failed instance.\n*\n*  This function is used to print the first encountered failed instance of a graph. It takes in a graph, edge capacities, source and sink nodes, and flow values as input. If it has not already printed a failed instance, it will print out the number of nodes and edges in the graph, as well as the capacities and flow values for each edge. It always returns false and can thus be used in an assertion.\n*\n* @param graph The graph to be tested.\n* @param caps Edge capacities.\n* @param s Source node.\n* @param t Sink node.\n* @param flows Flow values.\n* @return False.\n*/\nbool printInstance(const Graph &graph, const EdgeArray<T> caps, const node s, const node t, const EdgeArray<T> &flows)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BOOL InitC2(\r\n\tPDISC* pDisc\r\n) {\r\n\tsize_t dwAllocSize = (size_t)((*pDisc)->SCSI.nAllLength + FIRST_TRACK_PREGAP_SIZE + LAST_TRACK_LEADOUT_SIZE);\r\n\tif (NULL == ((*pDisc)->MAIN.lpAllSectorCrc32 = (LPDWORD)calloc(dwAllocSize, sizeof(DWORD)))) {\r\n\t\tOutputLastErrorNumAndString(_T(__FUNCTION__), __LINE__);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (NULL == ((*pDisc)->MAIN.lpAllLBAOfC2Error = (LPINT)calloc(dwAllocSize, sizeof(INT)))) {\r\n\t\tOutputLastErrorNumAndString(_T(__FUNCTION__), __LINE__);\r\n\t\treturn FALSE;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n",
        "answer": "/** @brief Initializes the C2 error correction data.\n*\n*  This function initializes the C2 error correction data for a disc. It allocates memory for the CRC32 checksums and LBA of C2 errors, and returns TRUE if successful or FALSE if an error occurs.\n*\n* @param pDisc A pointer to a PDISC structure that contains information about the disc.\n*\n* @return TRUE if successful, FALSE if an error occurs.\n*/\nBOOL InitC2(PDISC* pDisc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void glfmMain(GLFMDisplay *display) {\n    gDisplay = display;\n\n    glfmSetDisplayConfig(gDisplay,\n                         GLFMRenderingAPIOpenGLES3,\n                         GLFMColorFormatRGBA8888,\n                         GLFMDepthFormat16,\n                         GLFMStencilFormatNone,\n                         GLFMMultisampleNone);\n\n    glfmSetMainLoopFunc(gDisplay, onFrame);\n    glfmSetSurfaceCreatedFunc(gDisplay, onCreate);\n    glfmSetSurfaceResizedFunc(gDisplay, onResize);\n\n    glfmSetTouchFunc(gDisplay, onTouch);\n}\n",
        "answer": "/**\n* @brief Main entry point for the app, where the display can be initialized and the GLFMMainLoopFunc can be set.\n*\n* This function sets up the display and initializes the main loop for the application. It is called when the application starts and should not return until the application exits.\n*\n* @param display The display to use for rendering.\n*/\nvoid glfmMain(GLFMDisplay *display) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool InitSanityCheck(void)\n{\n    if (!ECC_InitSanityCheck()) {\n        InitError(\"Elliptic curve cryptography sanity check failure. Aborting.\");\n        return false;\n    }\n    if (!glibc_sanity_test() || !glibcxx_sanity_test())\n        return false;\n\n    return true;\n}\n",
        "answer": "/** @brief Initializes the sanity checks for SwiftCash.\n*\n*  This function ensures that SwiftCash is running in a usable environment with all necessary library support.\n*  It performs sanity checks on the Elliptic Curve Cryptography (ECC) and the GNU C Library (glibc).\n*\n* @return true if the sanity checks pass, false otherwise.\n*/\nbool InitSanityCheck(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void zg_context_delete(ZGContext *context) {\n  delete context;\n}\n",
        "answer": "/** @brief Deletes the given ZGContext.\n*\n* This function deletes the given ZGContext and all attached graphs. Unattached graphs are not automatically deleted, but should be by the user. They are thereafter useless.\n*\n* @param context The ZGContext to delete.\n*/\nvoid zg_context_delete(ZGContext *context) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "struct RecepteurSUpdater : public t_baseEvtCatcher\n{\n\tRecepteurSUpdater(Element* _rsPrefItem,RecepteursSControler* _recepteurSctrl)\n\t\t: rsPrefItem(_rsPrefItem),recepteurSctrl(_recepteurSctrl)\n\t{\n\n\t}\n\tvirtual void OnModified(const int& elid)\n\t{\n\t\trecepteurSctrl->Refresh(rsPrefItem);\n\t}\n\tElement* rsPrefItem;\n\tRecepteursSControler* recepteurSctrl;\n};\n",
        "answer": "/** @brief Updates the RecepteursSControler when the Element is modified.\n*\n*  This class is used to update the RecepteursSControler when the Element is modified. It is attached to the Element and listens for modifications. When a modification occurs, it calls the Refresh() method on the RecepteursSControler with the updated Element.\n*\n* @param _rsPrefItem The Element that was modified.\n* @param _recepteurSctrl The RecepteursSControler to update.\n*/\nstruct RecepteurSUpdater : public t_baseEvtCatcher"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isShortAvailable(const DeclAttribute *DA) {\n  auto *AvailAttr = dyn_cast<AvailableAttr>(DA);\n  if (!AvailAttr)\n    return false;\n\n  if (!AvailAttr->Introduced.hasValue())\n    return false;\n\n  if (AvailAttr->Deprecated.hasValue())\n    return false;\n\n  if (AvailAttr->Obsoleted.hasValue())\n    return false;\n\n  if (!AvailAttr->Message.empty())\n    return false;\n\n  if (!AvailAttr->Rename.empty())\n    return false;\n\n  if (AvailAttr->PlatformAgnostic != PlatformAgnosticAvailabilityKind::None &&\n      !AvailAttr->isLanguageVersionSpecific())\n    return false;\n\n  return true;\n}\n",
        "answer": "/**\n* @brief Checks if an attribute can be presented as a short form available attribute.\n*\n* This function checks if the given DeclAttribute can be presented as a short form available attribute, which means that it has an introduction version but no deprecation, obsoletion, or messages.\n*\n* @param DA The DeclAttribute to check.\n* @return True if the attribute can be presented as a short form available attribute, false otherwise.\n*/\nstatic bool isShortAvailable(const DeclAttribute *DA) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isPotentiallyMoreOptionalThan(Type objType1,\n                                          unsigned numOptionals1,\n                                          Type objType2,\n                                          unsigned numOptionals2) {\n  if (numOptionals1 <= numOptionals2 && !objType1->isTypeVariableOrMember())\n    return false;\n\n  return true;\n}\n",
        "answer": "/** @brief Determine whether the first type with the given number of optionals is potentially more optional than the second type with its number of optionals.\n*\n* This function determines if the first type with a given number of optionals is potentially more optional than the second type with its own number of optionals.\n*\n* @param objType1 The first type to compare.\n* @param numOptionals1 The number of optionals for the first type.\n* @param objType2 The second type to compare.\n* @param numOptionals2 The number of optionals for the second type.\n* @return True if the first type is potentially more optional than the second type, false otherwise.\n*/\nstatic bool isPotentiallyMoreOptionalThan(Type objType1, unsigned numOptionals1, Type objType2, unsigned numOptionals2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void getScalarizedElements(SILValue V,\n                                  SmallVectorImpl<SILValue> &ElementVals,\n                                  SILLocation Loc, SILBuilder &B) {\n  TupleType *TT = V->getType().castTo<TupleType>();\n  for (auto Index : indices(TT->getElements())) {\n    ElementVals.push_back(B.emitTupleExtract(Loc, V, Index));\n  }\n}\n",
        "answer": "/**\n* @brief Get scalarized elements from a tuple value.\n*\n* Given an RValue of aggregate type, compute the values of the elements by emitting a series of tuple_element instructions.\n*\n* @param V The input tuple value.\n* @param ElementVals A vector to store the extracted element values.\n* @param Loc The location for the tuple extract instruction.\n* @param B The SIL builder used to emit instructions.\n*/\nstatic void getScalarizedElements(SILValue V, SmallVectorImpl<SILValue> &ElementVals, SILLocation Loc, SILBuilder &B) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool canBridgeTypes(ImportTypeKind importKind) {\n  switch (importKind) {\n  case ImportTypeKind::Abstract:\n  case ImportTypeKind::Typedef:\n  case ImportTypeKind::Value:\n  case ImportTypeKind::Variable:\n  case ImportTypeKind::AuditedVariable:\n  case ImportTypeKind::Pointee:\n  case ImportTypeKind::Enum:\n  case ImportTypeKind::RecordField:\n    return false;\n  case ImportTypeKind::Result:\n  case ImportTypeKind::AuditedResult:\n  case ImportTypeKind::Parameter:\n  case ImportTypeKind::CFRetainedOutParameter:\n  case ImportTypeKind::CFUnretainedOutParameter:\n  case ImportTypeKind::Property:\n  case ImportTypeKind::PropertyWithReferenceSemantics:\n  case ImportTypeKind::BridgedValue:\n    return true;\n  }\n\n  llvm_unreachable(\"Invalid ImportTypeKind.\");\n}\n",
        "answer": "/**\n* @brief Determines if we can bridge types.\n*\n* This function checks if we are converting a function parameter, property type, or function result type, and can thus safely apply representation conversions for bridged types.\n*\n* @param importKind The kind of import to check.\n* @return True if we can bridge types, false otherwise.\n*/\nstatic bool canBridgeTypes(ImportTypeKind importKind) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SILValue getAccessPathRoot(SILValue Pointer) {\n  while (1) {\n    if (auto *TEAI = dyn_cast<TupleElementAddrInst>(Pointer))\n      Pointer = TEAI->getOperand();\n    else if (auto SEAI = dyn_cast<StructElementAddrInst>(Pointer))\n      Pointer = SEAI->getOperand();\n    else if (auto BAI = dyn_cast<BeginAccessInst>(Pointer))\n      Pointer = BAI->getSource();\n    else\n      return Pointer;\n  }\n}\n",
        "answer": "/** @brief Given an address, dive through any tuple/struct element addresses to get the underlying value.\n*\n* This function takes a SILValue as input and returns the root value of the access path. It does this by iteratively diving into the operands of TupleElementAddrInst, StructElementAddrInst, and BeginAccessInst instructions until it reaches the root value. If the input is not an address, the function simply returns the input.\n*\n* @param Pointer The SILValue to be processed.\n* @return The root value of the access path.\n*/\nstatic SILValue getAccessPathRoot(SILValue Pointer) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isMatchedAnyToAnyObjectConversion(CanType from, CanType to) {\n  while (auto fromObject = from.getAnyOptionalObjectType()) {\n    auto toObject = to.getAnyOptionalObjectType();\n    if (!toObject) return false;\n    from = fromObject;\n    to = toObject;\n  }\n\n  if (from->isAny()) {\n    assert(to->lookThroughAllAnyOptionalTypes()->isAnyObject());\n    return true;\n  }\n  return false;\n}\n",
        "answer": "/** @brief Check whether this conversion is Any to AnyObject.\n*\n*  This function checks if the given types are Any and AnyObject, respectively. If the result type is less optional, it doesn't count.\n*\n* @param from The source type.\n* @param to The destination type.\n* @return True if the conversion is Any to AnyObject, false otherwise.\n*/\nstatic bool isMatchedAnyToAnyObjectConversion(CanType from, CanType to) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static Type rebuildSelfTypeWithObjectType(Type selfTy, Type objectTy) {\n  auto existingObjectTy = selfTy->getRValueInstanceType();\n  return selfTy.transform([=](Type type) -> Type {\n    if (type->isEqual(existingObjectTy))\n      return objectTy;\n    return type;\n  });\n}\n",
        "answer": "/** @brief Rebuilds the given 'self' type using the given object type as the replacement for the object type of self.\n*\n* This function takes two types, `selfTy` and `objectTy`, and returns a new type that is similar to `selfTy`, but with the object type of `selfTy` replaced by `objectTy`.\n*\n* @param selfTy The original 'self' type.\n* @param objectTy The replacement object type.\n* @return A new type that is similar to `selfTy`, but with the object type of `selfTy` replaced by `objectTy`.\n*/\nstatic Type rebuildSelfTypeWithObjectType(Type selfTy, Type objectTy) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "wxString CoordinateToString( int aValue, bool aConvertToMils )\n{\n    return LengthDoubleToString( (double) aValue, aConvertToMils );\n}\n",
        "answer": "/** @brief Converts a coordinate value to a string.\n*\n*  This function converts a coordinate value to a string, taking into account the number of digits required for readability.\n*  If the parameter aConvertToMils is set to true, the value will be converted from microns to mils before being displayed.\n*\n* @param aValue The coordinate value to convert.\n* @param aConvertToMils A boolean indicating whether the value should be converted from microns to mils.\n* @return The string representation of the coordinate value.\n*/\nwxString CoordinateToString( int aValue, bool aConvertToMils )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool ReplaceIllegalFileNameChars( std::string* aName, int aReplaceChar )\n{\n    bool              changed = false;\n    std::string       result;\n\n    for( std::string::iterator it = aName->begin();  it != aName->end();  ++it )\n    {\n        if( strchr( illegalFileNameChars, *it ) )\n        {\n            if( aReplaceChar )\n                StrPrintf( &result, \"%c\", aReplaceChar );\n            else\n                StrPrintf( &result, \"%%%02x\", *it );\n\n            changed = true;\n        }\n        else\n        {\n            result += *it;\n        }\n    }\n\n    if( changed )\n        *aName =  result;\n\n    return changed;\n}\n",
        "answer": "/** @brief Replaces illegal file name characters in a string.\n*\n* This function replaces illegal file name characters in a given string with the specified replacement character or its hexadecimal equivalent.\n* The function returns true if any changes were made to the original string, and false otherwise.\n*\n* @param[in,out] aName A pointer to the string that needs to be checked for illegal file name characters.\n* @param[in] aReplaceChar The replacement character or its hexadecimal equivalent that will be used to replace any illegal file name characters found in the input string. If this parameter is not provided, the function will use 'xx' as the default replacement character.\n*\n* @return True if any changes were made to the original string, and false otherwise.\n*/\n*aName =  result;\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int clampJitter(int rawError){\n\n\tint zeroError = rawError;\n\n\tif (rawError > g.hardLimit){\n\t\tzeroError = g.hardLimit;\n\t}\n\telse if (rawError < -g.hardLimit){\n\t\tzeroError = -g.hardLimit;\n\t}\n\n\treturn zeroError;\n}\n",
        "answer": "/** @brief Clamp jitter in raw error values to +/- 1 microsecond and settle control loop.\n*\n* This function clamps the raw error values to +/- 1 microsecond and settles the control loop by making the average number of positive and negative rawError values equal. It also removes the bias introduced by the random rawError values, which would otherwise introduce a constantly changing random offset. The result is to move the average PPS interrupt delay to its median value.\n*\n* @param rawError Raw error value from the control loop.\n* @return Clamped and settled raw error value.\n*/\nint clampJitter(int rawError) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int getFractionalSeconds(timeval pps_t){\n\tint interruptTime = pps_t.tv_usec;\n\n\tif (interruptTime > 500000){\n\t\tinterruptTime -= USECS_PER_SEC;\n\t}\n\treturn interruptTime;\n}\n",
        "answer": "/** @brief Gets the fractional seconds part of interrupt time and if the value should be interpreted as negative then translates the value.\n*\n*  This function gets the fractional seconds part of the interrupt time and checks if the value should be interpreted as negative. If it is, it translates the value to make it positive.\n*\n* @param pps_t The timeval structure containing the interrupt time.\n* @return The fractional seconds part of the interrupt time, translated to a positive value if necessary.\n*/\nint getFractionalSeconds(timeval pps_t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool configHasValue(int config_val, void *value){\n\tint i = round(log2(config_val));\n\tif (g.config_select & config_val){\n\t\tchar *val = strpbrk(g.configVals[i], num);\n\t\tif (strpbrk(val, \".\") != NULL){\n\t\t\tsscanf(val, \"%lf\", (double *)value);\n\t\t}\n\t\telse {\n\t\t\tsscanf(val, \"%d\", (int *)value);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "answer": "/** @brief Checks if a configuration value is present in the /etc/pps-client.conf file and returns its numeric value in the value pointer.\n*\n*  This function checks for the presence of a numeric value in the configuration string array g.configVals[] from the /etc/pps-client.conf file. If a numeric value is found, it is stored in the value pointer as either an int or double depending on the presence of a decimal point.\n*\n* @param config_val The configuration value to check for.\n* @param value A pointer to store the numeric value if present.\n* @return True if a numeric value was found and stored in value, false otherwise.\n*/\nbool configHasValue(int config_val, void *value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void writeErrorDistribFile(void){\n\tif (g.errorCount % SECS_PER_MINUTE == 0 && g.seq_num > SETTLE_TIME){\n\t\tint scaleZero = ERROR_DISTRIB_LEN / 6;\n\t\twriteDistribution(g.errorDistrib, ERROR_DISTRIB_LEN, scaleZero,\n\t\t\t\tg.errorCount, &f.lastErrorFileno, distrib_file, last_distrib_file);\n\t}\n}\n",
        "answer": "/** @brief Writes a distribution to disk approximately once a minute containing 60 additional time correction samples derived from the PPS interrupt. The distribution is rolled over to a new file every 24 hours.\n*\n* @param g A struct that contains information about the error count and sequence number.\n* @param f A struct that contains information about the last error file number and the distribution file.\n* @return None\n*/\nvoid writeErrorDistribFile(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int daemonSaveArray(const char *requestStr, const char *filename){\n\tchar buf[200];\n\n\tint fd = open_logerr(arrayData_file, O_CREAT | O_WRONLY | O_TRUNC);\n\tif (fd == -1){\n\t\tprintf(\"daemonSaveArray() Open arrayData_file failed\\n\");\n\t\treturn -1;\n\t}\n\n\tstrcpy(buf, requestStr);\n\n\tif (filename != NULL){\n\t\tstrcat(buf, \" \");\n\t\tstrcat(buf, filename);\n\t}\n\n\tint rv = write(fd, buf, strlen(buf) + 1);\n\tclose(fd);\n\tif (rv == -1){\n\t\tsprintf(g.logbuf, \"daemonSaveArray() Write to tmpfs memory file failed\\n\");\n\t\twriteToLog(g.logbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Transmits a data save request to the PPS-Client daemon via data written to a tmpfs shared memory file.\n*\n*  This function transmits a data save request to the PPS-Client daemon by writing the request string and an optional filename to a tmpfs shared memory file.\n*\n* @param requestStr The request string to be written to the shared memory file.\n* @param filename An optional filename to be written to the shared memory file, or NULL if no filename is required.\n* @return 0 on success, -1 on failure.\n*/\nint daemonSaveArray(const char *requestStr, const char *filename)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void recordFrequencyVars(void){\n\ttimeval t;\n\tg.freqOffsetSum += g.freqOffset;\n\n\tg.freqOffsetDiff[g.intervalCount] = g.freqOffset - g.lastFreqOffset;\n\n\tg.lastFreqOffset = g.freqOffset;\n\tg.intervalCount += 1;\n\n\tif (g.intervalCount >= FIVE_MINUTES){\n\t\tgettimeofday(&t, NULL);\n\n\t\tdouble norm = 1.0 / (double)FREQDIFF_INTRVL;\n\n\t\tdouble diffSum = 0.0;\n\t\tfor (int i = 0; i < FREQDIFF_INTRVL; i++){\n\t\t\tdiffSum += g.freqOffsetDiff[i] * g.freqOffsetDiff[i];\n\t\t}\n\t\tg.freqAllanDev[g.recIndex] = sqrt(diffSum * norm * 0.5);\n\n\t\tg.timestampRec[g.recIndex] = t.tv_sec;\n\n\t\tg.freqOffsetRec[g.recIndex] = g.freqOffsetSum * norm;\n\n\t\tg.recIndex += 1;\n\t\tif (g.recIndex == NUM_5_MIN_INTERVALS){\n\t\t\tg.recIndex = 0;\n\t\t}\n\n\t\tg.intervalCount = 0;\n\t\tg.freqOffsetSum = 0.0;\n\t}\n}\n",
        "answer": "/**\n* @brief Records frequency variables.\n*\n* This function accumulates the clock frequency offset over the last 5 minutes and records the offset difference each minute over the previous 5-minute interval. It is called once per minute. The values of offset difference, `g.freqOffsetDiff[]`, are used to calculate the Allan deviation of the clock frequency offset, which can be saved to disk. The average clock frequency offset in each 5-minute interval is also calculated and can be saved to disk.\n*\n* @return void\n*/\nvoid recordFrequencyVars(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void buildPulseDistrib(int pulseTime, int pulseVal, int distrib[], int *count){\n\tif (g.seq_num <= SETTLE_TIME){\n\t\treturn;\n\t}\n\tint len = JITTER_DISTRIB_LEN - 1;\n\tint idx = (pulseTime - pulseVal) + len / 6;\n\n\tif (idx < 0){\n\t\tidx = 0;\n\t}\n\telse if (idx > len){\n\t\tidx = len;\n\t}\n\tdistrib[idx] += 1;\n\n\t*count += 1;\n}\n",
        "answer": "/** @brief Constructs a distribution of relative pulse time relative to pulseVal that can be saved to disk for analysis.\n*\n* This function constructs a distribution of the relative pulse time, which is the difference between the current pulse time and the pulse value, and saves it to an array called distrib. The count of the number of elements in the distrib array is also saved to the pointer count.\n*\n* @param pulseTime The current pulse time.\n* @param pulseVal The pulse value.\n* @param distrib An array to save the distribution of relative pulse time.\n* @param count A pointer to the number of elements in the distrib array.\n*/\nvoid buildPulseDistrib(int pulseTime, int pulseVal, int distrib[], int *count)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int sumDigits( int num ) {\n\tif ( num == 0 ) {\n\t\treturn 0;\n\t} else if ( num % 9 == 0 ) {\n\t\treturn 9;\n\t}\n\treturn num % 9;\n}\n",
        "answer": "/** @brief Sum of digits.\n*\n* This function takes a non-negative integer as input and repeatedly adds all its digits until the result has only one digit.\n* For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n* Follow up: Could you do it without any loop/recursion in O(1) runtime?\n* Solution approach: Look at the pattern which emerges when we sum the values and eventually reduce it to single digit. By observing carefully, we will see a pattern.\n*\n* @param num The input non-negative integer.\n* @return The resulting digit after repeatedly adding all digits until the result has only one digit.\n*/\nint sumDigits( int num ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string convertToTitle(int n) {\n\tstd::string result(\"\");\n\twhile ( n > 0) {\n\t\tint rem = n % 26;\n\t\tif ( rem == 0 ) {\n\t\t\tresult += 'Z';\n\t\t\tn = (n/26) - 1;\n\t\t} else {\n\t\t\tresult += char( rem-1 + 'A');\n\t\t\tn = n/26;\n\t\t}\n\t}\n\tstd::reverse(result.begin(), result.end());\n\treturn result;\n}\n",
        "answer": "/** @brief Convert a positive integer to its corresponding column title in an Excel sheet.\n*\n*  This function takes a positive integer as input and returns its corresponding column title as it appears in an Excel sheet. The approach used is to convert the column value to an effective base 26 number, similar to converting a decimal to hexadecimal. However, since the column numbers are not 0-indexed but indexed from 1, we need to be cautious of this and reduce 1 from the remaining number every time n % 26 is 0.\n*\n* @param n The positive integer to convert.\n* @return A string representing the corresponding column title in an Excel sheet.\n*/\nstd::string convertToTitle(int n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int firstMissingPositive(std::vector<int>& nums) {\n\tif( nums.size() == 0 ) {\n\t\treturn 1;\n\t}\n\tsize_t i = 0;\n\tfor ( i = 0; i  < nums.size(); ++i) {\n\t\twhile(nums[i] > 0 && nums[i] < int(nums.size()) && nums[i] != int(i+1) && nums[i] != nums[nums[i] - 1]) {\n\t\t\tstd::swap(nums[i], nums[nums[i]-1]);\n\t\t}\n\t}\n\ti = 0;\n\twhile( i < nums.size() && nums[i] == int(i + 1)) {\n\t\t++i;\n\t}\n\treturn int(i+1);\n}\n",
        "answer": "/** @brief Find the first missing positive integer in an unsorted array.\n*\n* This function takes an unsorted integer array as input and returns the first missing positive integer.\n* The algorithm runs in O(n) time and uses constant space.\n*\n* @param nums A vector of integers representing the input array.\n* @return The first missing positive integer.\n*/\nint firstMissingPositive(std::vector<int>& nums) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void spiral_print_matrix( int ** matrix, int m, int n)\n{\n  int a = 0, b = n-1, c = m-1, d = 0;\n  while( a < c && d < b) {\n    for(int i = d; i <= b; ++i ) {\n      std::cout << matrix[a][i] << \" \";\n    }\n\n    ++a;\n\n    for( int j = a; j <= c; ++j ) {\n      std::cout << matrix[j][b] << \" \";\n    }\n\n    --b;\n\n    for( int i = b; i >= d; --i ) {\n      std::cout << matrix[c][i] << \" \";\n    }\n\n    --c;\n\n    for( int j = c; j >= a; --j) {\n      std::cout << matrix[j][d] << \" \";\n    }\n    ++d;\n  }\n  std::cout << std::endl;\n}\n",
        "answer": "/** @brief Spiral print of a matrix.\n*\n* This function takes an m * n matrix as input and prints the contents of it in a spiral order. The function starts from the top-left corner, moves right, then down, then left, then up, and so on until all elements are printed.\n*\n* @param[in] matrix The input matrix to be printed.\n* @param[in] m The number of rows in the matrix.\n* @param[in] n The number of columns in the matrix.\n* @return None.\n*/\nvoid spiral_print_matrix(int **matrix, int m, int n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int position_of_first_set_bit( int num )\n{\n  return log2(num & -num) + 1;\n}\n",
        "answer": "/** @brief Returns the position of the rightmost bit.\n*\n* This function takes an integer as input and returns the position of the rightmost set bit.\n* The approach used is to take the 2's complement of the number and perform a bitwise AND operation with the original number.\n* Finally, the logarithm of 2 + 1 is taken to give the position of the rightmost set bit.\n*\n* @param num The input integer for which the position of the rightmost set bit needs to be found.\n* @return The position of the rightmost set bit in the input number.\n*/\nint position_of_first_set_bit( int num )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid ClearSampledAnimation()\n\t{\n\t\tsampleKeys.clear();\n\t\tsampleValues.clear();\n\t}\n",
        "answer": "/** @brief Frees up the memory used by any previous call to GenerateSampledAnimation.\n*\n*  It is recommended, but not necessary, to call this function after retrieving and copying locally the keys and values for the generated sampled animation curve.\n*\n* @return Should not return\n*/\nvoid ClearSampledAnimation()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string header_encode(const wstring &str) {\n    string utf8_str(wstring_to_utf8(str));\n    if (contains_special_characters(utf8_str))\n        return \"=?UTF-8?B?\" + base64(utf8_str) + \"?=\";\n    else\n        return utf8_str;\n}\n",
        "answer": "/** @brief Encode a free-form RFC822 header value if necessary.\n*\n*  This function encodes a free-form RFC822 header value using B-encoding or Q-encoding, depending on the contents of the string.\n*\n* @param str The input string to be encoded.\n* @return A string containing the encoded output.\n*/\nstring header_encode(const wstring &str) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static _T calcExcess(const _Vec3<_T> & center, _T radiusSquared, const _Vec3<_T> & point) {\n\treturn point.distanceSquared(center) - radiusSquared;\n}\n",
        "answer": "/** @brief Calculate the excess of a point with respect to a sphere. The sphere is defined by its center and its squared radius.\n*\n*  This function calculates the excess of a point with respect to a sphere, which is the difference between the squared distance from the point to the center of the sphere and the squared radius of the sphere.\n*\n* @param[in] center The center of the sphere.\n* @param[in] radiusSquared The squared radius of the sphere.\n* @param[in] point The point for which the excess is calculated.\n* @return The excess of the point with respect to the sphere.\n*/\nstatic _T calcExcess(const _Vec3<_T> & center, _T radiusSquared, const _Vec3<_T> & point) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "eig::Vector2f compute_centered_ellipse_bound_points(const eig::Matrix2f& ellipse_matrix, float ellipse_scale) {\n\tfloat A = ellipse_matrix(0, 0);\n\tfloat B = ellipse_matrix(0, 1) * 2;\n\tfloat C = ellipse_matrix(1, 1);\n\tfloat F = ellipse_scale;\n\teig::Vector2f bounds_max;\n\tif (std::abs(B) < FLT_EPSILON) {\n\t\tbounds_max << std::sqrt(F / A), std::sqrt(F / C);\n\t} else {\n\t\tfloat B_squared = B * B;\n\t\tbounds_max <<\n\t\t\t\tstd::sqrt(F / (C - B_squared / (4 * A))),\n\t\t\t\tstd::sqrt(F / (A - B_squared / (4 * C)));\n\t}\n\treturn bounds_max;\n}\n",
        "answer": "/** @brief Compute the minimum and maximum of the tight axis-aligned bounding box of the given centered ellipse.\n*\n*  This function computes the minimum and maximum of the tight axis-aligned bounding box of the given centered ellipse. The ellipse is defined by its conic matrix, which is typically denoted as Q = A B/2 B/2 C. The equation of the ellipse becomes p'Qp = F.\n*\n* @param[in] ellipse_matrix The conic matrix of the ellipse.\n* @param[in] ellipse_scale The scale factor for the ellipse.\n* @return The minimum and maximum points of the tight axis-aligned bounding box of the ellipse.\n*/\neig::Vector2f compute_centered_ellipse_bound_points(const eig::Matrix2f& ellipse_matrix, float ellipse_scale) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool system_io_flash_read(uint8* buffer, uint32 bufferLength)\n{\n try\n {\n  FileStream fp(MDFN_MakeFName(MDFNMKF_SAV, 0, \"flash\"), FileStream::MODE_READ);\n\n  fp.read(buffer, bufferLength);\n }\n catch(MDFN_Error &e)\n {\n  if(e.GetErrno() == ENOENT)\n   return(false);\n  else\n   throw;\n }\n\n return(true);\n}\n",
        "answer": "/** @brief Reads the \"appropriate\" (system specific) flash data into the given preallocated buffer. The emulation core doesn't care where from.\n*\n*  This function reads the \"appropriate\" (system specific) flash data into the given preallocated buffer. The emulation core doesn't care where from.\n*\n* @param[in] buffer A pointer to a preallocated buffer that will hold the read data.\n* @param[in] bufferLength The length of the buffer in bytes.\n*\n* @return True if the flash data was successfully read, false otherwise.\n*/\nbool system_io_flash_read(uint8* buffer, uint32 bufferLength)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void G54_59(uint8_t subcode=0) {\n  const int8_t _space = parser.codenum - 54 + subcode;\n  if (gcode.select_coordinate_system(_space)) {\n    SERIAL_PROTOCOLLNPAIR(\"Select workspace \", _space);\n    report_current_position();\n  }\n}\n",
        "answer": "/** @brief G54-G59.3: Select a new workspace A workspace is an XYZ offset to the machine native space. All workspaces default to 0,0,0 at start, or with EEPROM support they may be restored from a previous session. G92 is used to set the current workspace's offset.\n*\n* @param subcode The subcode of the G54-G59 command (default: 0)\n*/\nvoid G54_59(uint8_t subcode=0) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {\n    char str[12];\n    for (uint8_t i = 0; i < n; i++) {\n      SERIAL_CHAR(' ');\n      SERIAL_CHAR(axis_codes[i]);\n      SERIAL_CHAR(':');\n      SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));\n    }\n    SERIAL_EOL();\n  }\n",
        "answer": "/** @brief Reports the position of the XYZ axis.\n*\n*  This function reports the position of the XYZ axis, with a specified precision and number of decimal places.\n*\n* @param pos The position of the XYZ axis.\n* @param n The number of decimal places to display.\n* @param precision The precision of the reported position.\n*/\nvoid report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void line_to_current_position() {\n  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);\n}\n",
        "answer": "/** @brief Move the planner to the current position from wherever it last moved (or from wherever it has been told it is located).\n*\n* This function moves the planner to the current position from wherever it last moved or was told it is located. It uses the planner.buffer_line() function to do this.\n*\n* @param current_position The current position of the planner in millimeters (mm)\n* @param feedrate_mm_s The feedrate of the movement in millimeters per second (mm/s)\n* @param active_extruder The extruder that is currently being used for printing.\n*/\nvoid line_to_current_position(float current_position[XYZE], float feedrate_mm_s, int active_extruder) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isDataProc(uint32_t instr) {\n\n  uint8_t opcode = (instr & 0x01E00000) >> 21;\n  bool    S      = (instr & 0x00100000) ? true : false;\n\n  if ((instr & 0xFC000000) != 0xE0000000) {\n    return false;\n  }\n  else if (!S && opcode >= 8 && opcode <= 11) {\n    /* TST, TEQ, CMP and CMN all require S to be set */\n    return false;\n  }\n  else\n    return true;\n}\n",
        "answer": "/**\n* @brief Checks if an instruction is a data-processing instruction.\n*\n* Decodes the passed instruction, checks if it is a data-processing and verifies that the parameters and operation really indicate a data- processing instruction. This is needed because some parts of the instruction space under this instruction can be extended or represent other operations such as MRS, MSR.\n*\n* @param instr The instruction to check.\n* @return True if the instruction is a data-processing instruction, false otherwise.\n*/\n/* TST, TEQ, CMP and CMN all require S to be set */\nreturn false;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int atomic_add(volatile int *addr, int val)\n{\n\treturn InterlockedExchangeAdd((long*)addr, val);\n}\n",
        "answer": "/** @brief Atomic add.\n*\n*  This function adds `val' to the integer, pointed by `addr', in an interlocked operation. Returns the value of `addr' before the addition\n*\n* @param addr A pointer to the integer to be added to.\n* @param val The value to be added.\n* @return The value of `addr' before the addition.\n*/\nint atomic_add(volatile int *addr, int val)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void waitForUserExit(void)\n{\n\tSDL_Event ev;\n\twhile (!wantToQuit && SDL_WaitEvent(&ev)) {\n\t\thandleEvent(ev);\n\t}\n}\n",
        "answer": "/** @brief Waits for the user to indicate that they want to close the application.\n*\n* This function waits for the user to indicate that they want to close the application by either clicking on the \"X\" of the window or by pressing ESC.\n*\n* @return Should not return\n*/\nvoid waitForUserExit(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: weycoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\" << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/**\n* @brief HTTP POST request with custom headers and message body.\n*\n* This function creates an HTTP POST request with a custom message body and\n* additional headers. The request is sent to the specified host and port, and\n* the response is returned as a string.\n*\n* @param strMsg The message body of the request.\n* @param mapRequestHeaders A map of additional request headers to include in the request.\n* @return The response from the server as a string.\n*/\nstring HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void list_append(struct list *entry, struct list *head)\n{\n\t__list_add(entry, head->prev, head);\n}\n",
        "answer": "/**\n* @brief Appends a new element to the end of the list.\n*\n* This function appends a new element to the end of the list, given with this list head. The list changes from: head  some element  ...  lastelement to head  some element  ...  lastelement  new element.\n*\n* @param entry The new element to be added to the list.\n* @param head The list head of the list to which the new element is being added.\n*/\nvoid list_append(struct list *entry, struct list *head)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual unsigned int Flags()\n    {\n      return NOTREADABLE | WRITEONEONLY;\n    };\n",
        "answer": "/** @brief Virtual function to get flags.\n*\n*  This function returns a bitwise OR of any of the following:\n*   - NOTREADABLE\n*   - READONEONLY\n*   - NOTWRITABLE\n*   - WRITEONEONLY\n*   - DEFAULTFORMAT\n*   - READBINARY\n*   - WRITEBINARY\n*   - READXML\n*\n* @return A bitwise OR of any of the above flags.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual unsigned int Flags()\n  {\n      return NOTREADABLE;\n  };\n",
        "answer": "/** @brief Virtual function to get the flags for the object.\n*\n* This is a pure virtual function that must be implemented by any derived classes. It returns an unsigned integer representing the flags for the object. The possible values are:\n* - NOTREADABLE (0x1): The object is not readable.\n* - READONEONLY (0x2): The object can only be read once.\n* - NOTWRITABLE (0x4): The object is not writable.\n* - WRITEONEONLY (0x8): The object can only be written to once.\n* - DEFAULTFORMAT (0x10): The object uses the default format for output.\n* - READBINARY (0x20): The object can be read in binary format.\n* - WRITEBINARY (0x40): The object can be written to in binary format.\n* - READXML (0x80): The object can be read from an XML file.\n* - WRITEXML (0x100): The object can be written to an XML file.\n*\n* @return An unsigned integer representing the flags for the object.\n*/\nvirtual unsigned int Flags() = 0;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual unsigned int Flags()\n  {\n    return READBINARY|NOTWRITABLE;\n  }\n",
        "answer": "/** @brief Virtual function that returns the flags for the file.\n*\n* This function returns a bitwise OR of any of the following:\n* NOTREADABLE, READONEONLY, NOTWRITABLE, WRITEONEONLY, DEFAULTFORMAT, READBINARY, WRITEBINARY, READXML.\n* The current implementation returns READBINARY|NOTWRITABLE.\n*\n* @return An unsigned integer representing the flags for the file.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual unsigned int Flags()\n  {\n    return READONEONLY | NOTWRITABLE;\n  }\n",
        "answer": "/** @brief Virtual function that returns the flags for the file.\n*\n* This is a bitwise OR of any of the following:\n* - NOTREADABLE: The file cannot be read from.\n* - READONEONLY: The file can only be read once.\n* - NOTWRITABLE: The file cannot be written to.\n* - WRITEONEONLY: The file can only be written to once.\n* - DEFAULTFORMAT: The file uses the default format.\n* - READBINARY: The file is a binary file and should be read as such.\n* - WRITEBINARY: The file is a binary file and should be written as such.\n* - READXML: The file is an XML file and should be read as such.\n*\n* @return A bitwise OR of any of the above flags.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual unsigned int Flags()\n    {\n        return NOTREADABLE | WRITEONEONLY;\n    };\n",
        "answer": "/** @brief Virtual function that returns the flags for the object.\n*\n*  This is a virtual function that returns the flags for the object.\n*  The flags are a bitwise OR of any of the following: NOTREADABLE, READONEONLY, NOTWRITABLE, WRITEONEONLY, DEFAULTFORMAT, READBINARY, WRITEBINARY, READXML.\n*\n* @return A bitwise OR of the flags for the object.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "      virtual unsigned int Flags()\n      {\n        return READONEONLY | WRITEONEONLY;\n      };\n",
        "answer": "/**\n* @brief Returns the flags for the function.\n*\n* This function returns a bitwise OR of any of the following:\n*   - NOTREADABLE\n*   - READONEONLY\n*   - NOTWRITABLE\n*   - WRITEONEONLY\n*   - DEFAULTFORMAT\n*   - READBINARY\n*   - WRITEBINARY\n*   - READXML\n*\n* @return The flags for the function.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual unsigned int Flags()\n    {\n      return NOTWRITABLE | READONEONLY;\n    };\n",
        "answer": "/** @brief Returns the flags for the file.\n*\n*  This function returns a bitwise OR of any of the following:\n*  - NOTREADABLE: The file is not readable.\n*  - READONEONLY: The file can only be read once.\n*  - NOTWRITABLE: The file is not writable.\n*  - WRITEONEONLY: The file can only be written to once.\n*  - DEFAULTFORMAT: The file uses the default format.\n*  - READBINARY: The file should be read in binary mode.\n*  - WRITEBINARY: The file should be written in binary mode.\n*  - READXML: The file should be read as XML.\n*\n* @return A bitwise OR of any of the above flags.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual unsigned int Flags()\n    {\n      return NOTREADABLE | WRITEONEONLY;\n    }\n",
        "answer": "/** @brief Virtual function that returns the flags for the object.\n*\n*  This is a bitwise OR of any of the following:\n*   - NOTREADABLE: The object cannot be read from.\n*   - READONEONLY: The object can only be read once.\n*   - NOTWRITABLE: The object cannot be written to.\n*   - WRITEONEONLY: The object can only be written once.\n*   - DEFAULTFORMAT: The object uses the default format for reading and writing.\n*   - READBINARY: The object is read in binary format.\n*   - WRITEBINARY: The object is written in binary format.\n*   - READXML: The object is read in XML format.\n*   - WRITEXML: The object is written in XML format.\n*\n* @return A bitwise OR of the above flags.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual unsigned int Flags()\n  {\n    return (READXML | NOTWRITABLE);\n  };\n",
        "answer": "/** @brief Returns the flags for the kernel entrypoint.\n*\n* This function returns a bitwise OR of any of the following:\n*   - NOTREADABLE: The kernel entrypoint cannot be read from.\n*   - READONEONLY: The kernel entrypoint can only be read from once.\n*   - NOTWRITABLE: The kernel entrypoint cannot be written to.\n*   - WRITEONEONLY: The kernel entrypoint can only be written to once.\n*   - DEFAULTFORMAT: The kernel entrypoint uses the default format for reading and writing.\n*   - READBINARY: The kernel entrypoint reads data in binary format.\n*   - WRITEBINARY: The kernel entrypoint writes data in binary format.\n*   - READXML: The kernel entrypoint reads data in XML format.\n*   - WRITEXML: The kernel entrypoint writes data in XML format.\n*\n* @return A bitwise OR of any of the above flags.\n*/\nvirtual unsigned int Flags()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual unsigned int Flags() { return ZEROATOMSOK; }\n",
        "answer": "/** @brief Virtual function to get the flags for the object.\n*\n*  This is a virtual function that returns an unsigned integer representing the flags for the object.\n*  The flags are a bitwise OR of any of the following: NOTREADABLE, READONEONLY, NOTWRITABLE, WRITEONEONLY, DEFAULTFORMAT, READBINARY, WRITEBINARY, READXML.\n*\n* @return An unsigned integer representing the flags for the object.\n*/\nvirtual unsigned int Flags() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void rotate_coords(double *c,double m[3][3],unsigned int size)\n  {\n    double x,y,z;\n    for (unsigned int i = 0;i < size;++i)\n      {\n        x = c[i*3]*m[0][0] + c[i*3+1]*m[0][1] + c[i*3+2]*m[0][2];\n        y = c[i*3]*m[1][0] + c[i*3+1]*m[1][1] + c[i*3+2]*m[1][2];\n        z = c[i*3]*m[2][0] + c[i*3+1]*m[2][1] + c[i*3+2]*m[2][2];\n        c[i*3] = x;\n        c[i*3+1] = y;\n        c[i*3+2] = z;\n      }\n  }\n",
        "answer": "/**\n* @brief Rotates a set of coordinates by a transformation matrix.\n*\n* This function rotates the first \"size\" coordinates in the array \"c\" by the\n* transformation matrix \"m[3][3]\". The rotation is performed using the 3x3\n* matrix multiplication formula.\n*\n* @param c Pointer to an array of doubles representing the coordinates to be rotated.\n* @param m Pointer to a 3x3 transformation matrix represented as a 2D array of doubles.\n* @param size The number of coordinates in the \"c\" array to rotate.\n*/\nvoid rotate_coords(double *c, double m[3][3], unsigned int size);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  bool AngleOrder(const vector3 &a, const vector3 &b, const vector3 &c, const vector3 &center)\n  {\n    vector3 t, u, v;\n    t = a - center;\n    t.normalize();\n    u = b - center;\n    u.normalize();\n    v = c - center;\n    v.normalize();\n    return TriangleSign(t, u, v) > 0;\n  }\n",
        "answer": "/** @brief Calculate whether three vectors are arranged in order of increasing angle anticlockwise (true) or clockwise (false) relative to a central point.\n*\n* This function takes four vector3 arguments: a, b, c, and center. It calculates the angle between each pair of vectors and returns true if they are arranged in order of increasing angle anticlockwise, or false if they are arranged clockwise.\n*\n* @param[in] a The first vector.\n* @param[in] b The second vector.\n* @param[in] c The third vector.\n* @param[in] center The central point around which the vectors are arranged.\n* @return True if the vectors are arranged in order of increasing angle anticlockwise, or false if they are arranged clockwise.\n*/\nbool AngleOrder(const vector3 &a, const vector3 &b, const vector3 &c, const vector3 &center)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    if( MinThread < 1 ) {\n        REPORT( \"Number of threads must be positive\\n\" );\n        return Harness::Skipped;\n    }\n    for( int p = MinThread; p <= MaxThread; ++p ) {\n        PriorityNodesTakePrecedence::test( p );\n        LimitingExecutionToPriorityTask::test( p );\n    }\n    NestedCase::test( MaxThread );\n    return Harness::Done;\n}\n",
        "answer": "/** @brief TestMain entrypoint.\n*\n*  This is the entrypoint for your test application.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    if( MinThread<1 ) {\n        REPORT(\"number of threads must be positive\\n\");\n        exit(1);\n    }\n    for( int p=MinThread; p<=MaxThread; ++p ) {\n       test_concurrency(p);\n    }\n    test_ports_return_references<tbb::flow::queueing>();\n    test_ports_return_references<tbb::flow::rejecting>();\n    lightweight_testing::test<tbb::flow::multifunction_node>(10);\n#if TBB_DEPRECATED_FLOW_NODE_EXTRACTION\n    test_extract<tbb::flow::rejecting>();\n    test_extract<tbb::flow::queueing>();\n#endif\n   return Harness::Done;\n}\n",
        "answer": "/** @brief Test entrypoint.\n*\n*  This is the entrypoint for your test.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    tbb::tick_count start = tbb::tick_count::now(), stop;\n    for (int p = 2; p <= 4; ++p) {\n        tbb::task_scheduler_init init(p);\n        test_serial<int>();\n        test_reservation<int>(p);\n        test_reservation<check_type<int> >(p);\n        test_parallel<int>(p);\n    }\n    stop = tbb::tick_count::now();\n    REMARK(\"Priority_Queue_Node Time=%6.6f\\n\", (stop-start).seconds());\n    REMARK(\"Testing resets\\n\");\n    test_resets<int,tbb::flow::priority_queue_node<int> >();\n    test_resets<float,tbb::flow::priority_queue_node<float> >();\n#if TBB_DEPRECATED_FLOW_NODE_EXTRACTION\n    test_buffer_extract<tbb::flow::priority_queue_node<int> >().run_tests();\n#endif\n    return Harness::Done;\n}\n",
        "answer": "/** @brief TestMain entrypoint.\n*\n*  This is the entrypoint for your test application.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    TestArgumentsPassing();\n    TestSetRange();\n    TestChaining();\n    TestConstructor();\n    return Harness::Done;\n}\n",
        "answer": "/** @brief Test entrypoint.\n*\n*  This is the entrypoint for your test application.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void startElement(const XMLCh* const uri, const XMLCh* const localname, const XMLCh* const qname, const Attributes& attrs)\n    {\n        fIsXMLSuite=XMLString::equals(qname, sz_XMLTestSuiteRoot);\n        throw fIsXMLSuite;\n    }\n",
        "answer": "/** @brief Receive notification of the start of an element.\n*\n*  By default, do nothing. Application writers may override this method in a subclass to take specific actions at the start of each element (such as allocating a new tree node or writing output to a file).\n*\n* @param uri The URI of the element.\n* @param localname The local name of the element.\n* @param qname The qualified name of the element.\n* @param attrs The attributes of the element.\n*\n* @return Should not return.\n*/\nvoid startElement(const XMLCh* const uri, const XMLCh* const localname, const XMLCh* const qname, const Attributes& attrs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "            storm::storage::BitVector performProb1E(storm::models::sparse::NondeterministicModel<T, RM> const& model, storm::storage::SparseMatrix<T> const& backwardTransitions, storm::storage::BitVector const& phiStates, storm::storage::BitVector const& psiStates) {\n                return performProb1E(model.getTransitionMatrix(), model.getNondeterministicChoiceIndices(), backwardTransitions, phiStates, psiStates);\n            }\n",
        "answer": "/** @brief Computes the sets of states that have probability 1 of satisfying phi until psi under at least one possible resolution of non-determinism in a non-deterministic model. Stated differently, this means that these states have probability 1 of satisfying phi until psi if the scheduler tries to maximize this probability.\n*\n* @param model The non-deterministic model.\n* @param backwardTransitions The backward transitions of the model.\n* @param phiStates The states that satisfy phi.\n* @param psiStates The states that satisfy psi.\n* @return The sets of states that have probability 1 of satisfying phi until psi under at least one possible resolution of non-determinism in the model.\n*/\nstorm::storage::BitVector performProb1E(storm::models::sparse::NondeterministicModel<T, RM> const& model, storm::storage::SparseMatrix<T> const& backwardTransitions, storm::storage::BitVector const& phiStates, storm::storage::BitVector const& psiStates) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "char getKeyDown( int vKeyCode ) { \n\treturn ((GetAsyncKeyState(vKeyCode) & 0x8000) ? true : false);\n\t}\n",
        "answer": "/** @brief Get the key that is currently being pressed.\n*\n* This function returns a boolean value indicating whether the specified key is currently being pressed or not.\n* It takes an integer parameter vKeyCode, which represents the virtual key code of the key to be checked.\n* The function uses the GetAsyncKeyState() function from the Windows API to check the state of the key.\n* If the most significant bit (MSB) of the return value is set, it means that the key is currently being pressed, and the function returns true.\n* Otherwise, it returns false.\n*\n* @param vKeyCode The virtual key code of the key to be checked.\n* @return A boolean value indicating whether the specified key is currently being pressed or not.\n*/\nchar getKeyDown(int vKeyCode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void logCallbackFunc(const char *msg)\r\n{\r\n    qDebug().nospace() << msg;\r\n}\r\n",
        "answer": "/** @brief Log callback function.\n*\n*  This function is called by the library to log messages.\n*\n* @param msg The message to be logged.\n*/\nvoid logCallbackFunc(const char *msg)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "float Wrap(float x, float low, float high)\n{\n  if (x < low)\n    x = high;\n  else if (x > high)\n    x = low;\n\n  return x;\n}\n",
        "answer": "/** @brief Wrap a value between two bounds.\n*\n* This function wraps a value between two bounds,\n* so that if the value is lower than the lower bound, it is set to the higher bound, and if the value is higher than the higher bound, it is set to the lower bound. Otherwise, the value is unchanged.\n*\n* @param x The value to wrap.\n* @param low The lower bound.\n* @param high The higher bound.\n* @return The wrapped value.\n*/\nfloat Wrap(float x, float low, float high)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void setAndCheckAttribute(std::shared_ptr<JoynrRuntime> runtime, const uint8_t value)\n    {\n        std::shared_ptr<T> testProxy = buildProxy<T>(runtime);\n\n        uint8_t uInt8Result = 0;\n\n        testProxy->setUInt8Attribute1(value);\n        testProxy->getUInt8Attribute1(uInt8Result);\n\n        ASSERT_EQ(value, uInt8Result);\n    }\n",
        "answer": "/**\n* @brief Sets and checks the UInt8Attribute1 attribute of a proxy object.\n*\n* This function builds a proxy object of type T in the specified runtime, sets the value of its\n* UInt8Attribute1 attribute to the specified value, and then checks if the set value can be retrieved\n* correctly.\n*\n* @param runtime The JoynrRuntime object that will be used to build the proxy object.\n* @param value The value that will be set for the UInt8Attribute1 attribute of the proxy object.\n*/\nvoid setAndCheckAttribute(std::shared_ptr<JoynrRuntime> runtime, const uint8_t value)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool IsAudioCompatible(int bitsPerSample, int samplingRate) {\r\n  if (bitsPerSample != 8 && bitsPerSample != 16)\r\n    return false;\r\n  if ((samplingRate % 100) != 0)\r\n    return false;\r\n  return true;\r\n}\r\n",
        "answer": "/** @brief Checks whether the audio is compatible with the system.\n*\n* This function checks if the audio is compatible with the system by checking the bits per sample and sampling rate.\n* It returns true if the audio is compatible, false otherwise.\n*\n* @param bitsPerSample The number of bits per sample in the audio data.\n* @param samplingRate The sampling rate of the audio data.\n* @return True if the audio is compatible, false otherwise.\n*/\nbool IsAudioCompatible(int bitsPerSample, int samplingRate) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void activateEvent() {\n    }\n",
        "answer": "/** @brief Pure virtual function that gets called when the user activates the managed window by tapping on its client area. Re-implement to obtain activate events from the managed window.\n*\n*  This function is a pure virtual function that gets called when the user activates the managed window by tapping on its client area. It is used to obtain activate events from the managed window and should be re-implemented in any derived classes.\n*\n* @return Should not return\n*/\nvirtual void activateEvent() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isSameShapedVectorOrTensor(Type type1, Type type2) {\n  if (auto vType1 = type1.dyn_cast<RankedTensorType>())\n    if (auto vType2 = type2.dyn_cast<RankedTensorType>())\n      return vType1.getShape() == vType2.getShape();\n  if (auto vType1 = type1.dyn_cast<VectorType>())\n    if (auto vType2 = type2.dyn_cast<VectorType>())\n      return vType1.getShape() == vType2.getShape();\n  return false;\n}\n",
        "answer": "/** @brief Checks if two types are both vectors or ranked tensors and have the same shape, regardless of element types.\n*\n* @param type1 The first type to compare.\n* @param type2 The second type to compare.\n* @return True if the two types are both vectors or ranked tensors and have the same shape, false otherwise.\n*/\nstatic bool isSameShapedVectorOrTensor(Type type1, Type type2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void version(uint8_t& major, uint8_t& minor, uint8_t& revision)\n{\n\tmajor = ZMQPP_VERSION_MAJOR;\n\tminor = ZMQPP_VERSION_MINOR;\n\trevision = ZMQPP_VERSION_REVISION;\n}\n",
        "answer": "/** @brief Retrieve the parts of the zmqpp version number.\n*\n*  This function sets the three parameters to values representing the zmqpp version number. These values are generated at library compile time.\n*\n* @param[out] major The major version number.\n* @param[out] minor The minor version number.\n* @param[out] revision The revision version number.\n*/\nvoid version(uint8_t& major, uint8_t& minor, uint8_t& revision)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int openNoInt(const char* name, int flags, mode_t mode) {\n  return wrapNoInt(open, name, flags, mode);\n}\n",
        "answer": "/** @brief Convenience wrapper around the system call open. The *NoInt wrappers retry on EINTR.\n*\n* @param name The file to be opened.\n* @param flags The flags used to open the file.\n* @param mode The mode used to open the file.\n* @return The file descriptor of the opened file.\n*/\nint openNoInt(const char* name, int flags, mode_t mode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isLower(char32_t cp) {\n  if (cp < 0x80) return islower(cp);\n#if FOLLY_UNICODE_JAVA_API\n  return u_islower(cp);\n#else\n  return u_isULowercase(cp);\n#endif\n}\n",
        "answer": "/** @brief Check if a code point has the Lowercase Unicode property. Same as u_hasBinaryProperty(c, UCHAR_LOWERCASE). (JAVA) Determines whether the specified code point has the general category \"Ll\" (lowercase letter).\n*\n* @param cp The code point to check.\n* @return True if the code point has the Lowercase Unicode property, false otherwise.\n*/\nbool isLower(char32_t cp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isXDigit(char32_t cp) {\n  if (cp < 0x80) return isxdigit(cp);\n  return u_isxdigit(cp);\n}\n",
        "answer": "/** @brief Determines whether the specified code point is a hexadecimal digit. This is equivalent to u_digit(c, 16)>=0. True for characters with general category \"Nd\" (decimal digit numbers) as well as Latin letters a-f and A-F in both ASCII and Fullwidth ASCII. (That is, for letters with code points 0041..0046, 0061..0066, FF21..FF26, FF41..FF46.) In order to narrow the definition of hexadecimal digits to only ASCII characters, use (c<=0x7f && u_isxdigit(c)).\n* @param cp The code point to check.\n* @return True if the code point is a hexadecimal digit, false otherwise.\n*/\nbool isXDigit(char32_t cp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isBlank(char32_t cp) {\n  if (cp < 0x80) return isblank(cp);\n  return u_isblank(cp);\n}\n",
        "answer": "/**\n* @brief Determines whether the specified code point is a \"blank\" or \"horizontal space\", a character that visibly separates words on a line.\n*\n* The following are equivalent definitions: TRUE for Unicode White_Space characters except for \"vertical space controls\" where \"vertical space controls\" are the following characters: U+000A (LF) U+000B (VT) U+000C (FF) U+000D (CR) U+0085 (NEL) U+2028 (LS) U+2029 (PS) same as TRUE for U+0009 (TAB) and characters with general category \"Zs\" (space separators) except Zero Width Space (ZWSP, U+200B). Note: There are several ICU whitespace functions; please see the uchar.h file documentation for a detailed comparison. cp: 0009 0020 00a0 1680 2000-200a 202f 205f = kCFCharacterSetWhitespace - 200b\n*\n* @param cp The code point to check.\n* @return TRUE if the code point is a \"blank\" or \"horizontal space\", FALSE otherwise.\n*/\nbool isBlank(char32_t cp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t getUCharCategoryMask(char32_t cp) {\n  return U_GET_GC_MASK(cp);\n}\n",
        "answer": "/** @brief Get a single-bit bit set for the general category of a character.\n*\n* This function returns a single-bit bit set for the general category of a character, which can be compared bitwise with U_GC_SM_MASK, U_GC_L_MASK, etc. It is equivalent to calling U_MASK(u_charType(c)).\n*\n* @param cp The character code point to get the general category mask for.\n* @return The single-bit bit set for the general category of the character.\n*/\nuint32_t getUCharCategoryMask(char32_t cp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ESResult InitProvisioning()\n{\n    if (CreateProvisioningResource() != OC_STACK_OK)\n    {\n        return ES_ERROR;\n    }\n\n    if (CreateNetworkResource() != OC_STACK_OK)\n    {\n        return ES_ERROR;\n    }\n\n    RegisterResourceEventCallBack(EventCallbackInProvisioning);\n\n    return ES_RESOURCECREATED;\n}\n",
        "answer": "/** @brief Initializes Provisioning and Network resources for EasySetup process.\n*\n*  This function performs initialization of Provisioning and Network resources needed for EasySetup process.\n*\n* @return ES_RESOURCECREATED if the resources are created successfully, ES_ERROR otherwise.\n*/\nESResult InitProvisioning()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void subtract (const QRect& a, const QRect& b, QRect* result)\n{\n    result[0].setCoords(a.left(), a.top(), a.right(), b.top() - 1);\n    result[1].setCoords(a.left(), b.top(), b.left() - 1, b.bottom());\n    result[2].setCoords(b.right() + 1, b.top(), a.right(), b.bottom());\n    result[3].setCoords(a.left(), b.bottom() + 1, a.right(), a.bottom());\n}\n",
        "answer": "/** @brief Subtracts the second rectangle from the first, placing the resulting rectangles in the provided array.\n*\n*  This function takes two QRect objects as input and subtracts the second rectangle from the first, placing the resulting rectangles in a QRect array. The resulting rectangles are placed in the order of top-left, top-right, bottom-left, and bottom-right.\n*\n* @param[in] a The first QRect object to be subtracted from.\n* @param[in] b The second QRect object to be subtracted.\n* @param[out] result A pointer to an array of four QRect objects where the resulting rectangles will be placed.\n*/\nvoid subtract (const QRect& a, const QRect& b, QRect* result)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool is_data_dependency(const std::shared_ptr<MKLDNNNode> &parent,\n                               const std::shared_ptr<MKLDNNNode> &child) {\n    std::set<MKLDNNNode*> visited;\n    std::list<MKLDNNNode*> nextLayers {parent.get()};\n\n    for (; !nextLayers.empty();) {\n        auto layer = *nextLayers.begin();\n        if (layer == child.get()) return true;\n        for (auto oe : layer->getChildEdges()) {\n            auto nn = oe.lock()->getChild();\n            if (visited.find(nn.get()) == visited.end()) {\n                nextLayers.push_back(nn.get());\n                visited.insert(nn.get());\n            }\n        }\n        nextLayers.pop_front();\n    }\n    return false;\n}\n",
        "answer": "/**\n* @brief Check if there is a data dependency between parent and child BFS starting from parent and comparing with child.\n*\n* This function performs a breadth-first search (BFS) starting from the parent node, and checks if the child node is reachable.\n* If the child node is found during the BFS, it means that there is a data dependency between the parent and child nodes.\n*\n* @param parent The parent node to start the BFS from.\n* @param child The child node to check for reachability.\n* @return True if there is a data dependency between the parent and child nodes, false otherwise.\n*/\nstatic bool is_data_dependency(const std::shared_ptr<MKLDNNNode> &parent, const std::shared_ptr<MKLDNNNode> &child) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int StringCompareNoCase(char const * const str1, char const * const str2)\n    {\n    char const * p1 = str1;\n    char const * p2 = str2;\n    while(*p1)\n        {\n        if(tolower(*p1) != tolower(*p2))\n            break;\n        p1++;\n        p2++;\n        }\n    return(*p1-*p2);\n    }\n",
        "answer": "/** @brief Compares two strings using a case insensitive comparison.\n*\n*  This function compares the strings using a case insensitive comparison, and returns zero if they match, or greater or less than zero depending on the mismatch. WARNING - this only work for ASCII.\n*\n* @param str1 The first string to compare.\n* @param str2 The second string to compare.\n* @return Zero if the strings match, or greater or less than zero depending on the mismatch.\n*/\nint StringCompareNoCase(char const * const str1, char const * const str2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class AcyclicTest : public tlp::GraphTest {\npublic:\n  PLUGININFORMATION(\"Acyclic\", \"Tulip team\", \"18/04/2012\", \"Tests whether a graph is acyclic or not.\", \"1.0\", \"Topological Test\")\n  AcyclicTest(const tlp::PluginContext* context) : tlp::GraphTest(context) {\n  }\n\n  virtual bool test() {\n    return tlp::AcyclicTest::isAcyclic(graph);\n  }\n\n};\n",
        "answer": "/** @brief Acyclic Test.\n*\n* This is a test to check whether a graph is acyclic or not.\n* It uses the tlp::AcyclicTest class and its isAcyclic method to perform the test.\n* The test returns true if the graph is acyclic, false otherwise.\n*\n* @param context The plugin context.\n* @return True if the graph is acyclic, false otherwise.\n*/\nbool AcyclicTest::test(const tlp::PluginContext* context) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void animationStep(int animationStep) {\n    node n;\n    forEach(n, graph->getNodes()) {\n      const Coord &startPos = srcLayout->getNodeValue(n);\n      const Coord &endPos = destLayout->getNodeValue(n);\n      viewLayout->setNodeValue(n, startPos + (animationStep / (float) nbAnimationSteps) * (endPos - startPos));\n    }\n\n    edge e;\n    forEach(e, graph->getEdges()) {\n      const vector<Coord> &srcBends = srcLayout->getEdgeValue(e);\n      const vector<Coord> &destBends = destLayout->getEdgeValue(e);\n      vector<Coord> newBends;\n\n      for (size_t i = 0 ; i < destBends.size() ; ++i) {\n        newBends.push_back(srcBends[i] + (animationStep / (float) nbAnimationSteps) * (destBends[i] - srcBends[i]));\n      }\n\n      viewLayout->setEdgeValue(e, newBends);\n    }\n  }\n",
        "answer": "/** @brief Animation step.\n*\n*  This is the animation step for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param[in] animationStep The current animation step\n* @return Should not return\n*/\nvoid animationStep(int animationStep) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class TriconnectedTest : public tlp::GraphTest {\npublic:\n  PLUGININFORMATION(\"Triconnected\", \"Tulip team\", \"18/04/2012\", \"Tests whether a graph is triconnected or not.\", \"1.0\", \"Topological Test\")\n  TriconnectedTest(const tlp::PluginContext* context) : tlp::GraphTest(context) {\n  }\n\n  virtual bool test() {\n    return tlp::TriconnectedTest::isTriconnected(graph);\n  }\n};\n",
        "answer": "/** @brief TriconnectedTest entrypoint.\n*\n*  This is the entrypoint for your triconnected test.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid TriconnectedTest::entrypoint()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int backtrace(void **buffer, int size) {\n  void **frame = reinterpret_cast<void **>(__builtin_frame_address(0));\n  void **bp = reinterpret_cast<void **>(*frame);\n  void *ip = frame[1];\n  int i;\n\n  for (i = 0; bp && ip && i < size ; ++i) {\n    ip = bp[1];\n    buffer[i] = ip;\n    bp = reinterpret_cast<void**>(bp[0]);\n  }\n\n  return i;\n}\n",
        "answer": "/** @brief Backtraces the current call stack.\n*\n* This function backtraces the current call stack and stores the return addresses in a buffer.\n* The size of the buffer is specified by the 'size' parameter.\n*\n* @param[out] buffer A pointer to an array of void pointers, where the return addresses will be stored.\n* @param[in] size The size of the buffer.\n* @return The number of return addresses stored in the buffer.\n*/\nint backtrace(void **buffer, int size) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tbool unlock_all(){\r\n\t\t\tsize_t ok = 0;\r\n\t\t\tfor(_InfoNodes::iterator i = connections.begin(); i!= connections.end(); ++i){\r\n\t\t\t\t(*i).begin(this->version,this->writer);\r\n\r\n\t\t\t\tif((*i).unlock_all()) ++ok;\r\n\r\n\t\t\t}\r\n\t\t\treturn ok > 0;\r\n\t\t};\r\n",
        "answer": "/** @brief Unlock all nodes.\n*\n* This function unlocks all nodes in the system.\n* It iterates through all connections and calls the begin() method on each node, passing in the current version and writer.\n* If a node is successfully unlocked, it increments the ok variable.\n* The function returns true if any nodes were unlocked, false otherwise.\n*\n* @param connections A list of all connections in the system.\n* @param version The current version of the system.\n* @param writer The writer object for the system.\n* @return True if any nodes were unlocked, false otherwise.\n*/\nbool unlock_all()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void cellular_cancel(bool cancel, bool calledFromISR, void*)\n{\n    if (cancel) {\n        electronMDM.cancel();\n    } else {\n        electronMDM.resume();\n    }\n}\n",
        "answer": "/** @brief Cancels or resumes the cellular modem from performing AT operations. Called from another thread or ISR context.\n*\n*  This function attempts to stop or resume the cellular modem from performing AT operations. It is called from another thread or ISR context.\n*\n* @param cancel A boolean value indicating whether to cancel (true) or resume (false) the cellular modem's AT operations.\n* @param calledFromISR A boolean value indicating whether this function was called from an interrupt service routine (ISR) context.\n* @param void* A pointer to a data structure containing information about the cellular modem's AT operations.\n*\n* @return None\n*/\nvoid cellular_cancel(bool cancel, bool calledFromISR, void*)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void HAL_Delay_Milliseconds(uint32_t millis)\n{\n    boost::this_thread::sleep(boost::posix_time::milliseconds(millis));\n}\n",
        "answer": "/** @brief Delays execution of the current thread for a specified number of milliseconds.\n*\n*  This function causes the current thread to block for at least the specified number of milliseconds.\n*  It is implemented using the Boost library's `boost::this_thread::sleep` function, which blocks the current thread for the specified duration.\n*\n* @param millis The number of milliseconds to delay execution.\n*/\nvoid HAL_Delay_Milliseconds(uint32_t millis)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void HAL_NET_SetCallbacks(const HAL_NET_Callbacks* callbacks, void* reserved) {\n}\n",
        "answer": "/** @brief Sets notification callbacks.\n*\n*  This function is used when HAL implementation cannot be linked with HAL_NET_notify_*() functions directly.\n*\n* @param[in] callbacks Pointer to a structure containing the callback functions.\n* @param[in] reserved Reserved for future use, must be NULL.\n*\n* @return None.\n*/\nvoid HAL_NET_SetCallbacks(const HAL_NET_Callbacks* callbacks, void* reserved) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline bool in_range(uint32_t test, uint32_t start, uint32_t end)\n{\n    return test>=start && test<=end;\n}\n",
        "answer": "/** @brief Checks if a given value is within a specified range.\n*\n*  This function checks if the value of `test` is greater than or equal to `start` and less than or equal to `end`.\n*\n* @param test The value to be checked.\n* @param start The starting value of the range (inclusive).\n* @param end The ending value of the range (inclusive).\n* @return True if `test` is within the specified range, false otherwise.\n*/\ninline bool in_range(uint32_t test, uint32_t start, uint32_t end)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t compute_variables_checksum()\n{\n\tuint32_t checksum = 0;\n\tfor (int i = vars.size(); i-->0; )\n\t{\n\t\tchecksum += string_crc(vars[i].userVarKey);\n\t\tchecksum += crc(vars[i].userVarType);\n\t}\n\treturn checksum;\n}\n",
        "answer": "/** @brief Computes the checksum of registered variables.\n*\n*  This function computes the checksum of the variable names and types.\n*  The checksum is used to verify the integrity of the data.\n*\n* @return The computed checksum.\n*/\nuint32_t compute_variables_checksum()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void system_initialize_user_backup_ram()\n{\n    size_t len = &link_global_retained_end-&link_global_retained_start;\n    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);\n}\n",
        "answer": "/** @brief Initializes the user region of the backup ram.\n*\n*  This function initializes the user region of the backup ram by copying the initial values from the linker-generated symbol &link_global_retained_initial_values to the start address of the retained region, which is denoted by &link_global_retained_start. The length of the data to be copied is determined by taking the difference between the end and start addresses of the retained region, which is stored in the linker-generated symbol &link_global_retained_end.\n*\n* @return None\n*/\nvoid system_initialize_user_backup_ram()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int wlan_disconnect_now() {\n    return SYSTEM_ERROR_NOT_SUPPORTED;\n}\n",
        "answer": "/** @brief Brings down the primary networking interface, while maintaining power to the WiFi hardware. All open sockets are closed and when the operation is complete, the HAL_NET_notify_disconnected() function is called, either directly, as a result of bringing down the connection.\n*\n* @return Should not return\n*/\nvoid wlan_disconnect_now() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "wlan_result_t wlan_reset_credentials_store()\n{\n    return 0;\n}\n",
        "answer": "/** @brief Resets the WLAN credentials store.\n*\n* This function removes all stored AP credentials by calling wlan_clear_credentials() and clears the wlan_reset_credentials_store_required() flag.\n*\n* @return A wlan_result_t indicating the result of the operation.\n*/\nwlan_result_t wlan_reset_credentials_store()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool wlan_reset_credentials_store_required()\n{\n    return system_flags.NVMEM_SPARK_Reset_SysFlag == 0x0001;\n}\n",
        "answer": "/** @brief Determines if a request has been made to reset the wifi credentials. On platforms that use the Particle bootloader, this is done by issuing a \"full reset\" command.\n*\n* @return true if a request has been made to reset the wifi credentials, false otherwise.\n*/\nbool wlan_reset_credentials_store_required()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "wlan_result_t wlan_disconnect_now()\n{\n    return 0;\n}\n",
        "answer": "/** @brief Brings down the primary networking interface, while maintaining power to the WiFi hardware. All open sockets are closed and when the operation is complete, the HAL_NET_notify_disconnected() function is called, either directly, as a result of bringing down the connection.\n*\n* @return Should not return\n*/\nwlan_result_t wlan_disconnect_now()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string contentsString(boost::filesystem::path const& _file)\n{\n    return contentsGeneric<string>(_file);\n}\n",
        "answer": "/** @brief Retrieves and returns the contents of a file as a std::string.\n*\n*  If the file doesn't exist or isn't readable, returns an empty container / bytes.\n*\n* @param _file The path to the file to read.\n* @return A string containing the contents of the file, or an empty string if the file couldn't be read.\n*/\nstring contentsString(boost::filesystem::path const& _file)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, char *argv[])\n{\n\tstruct mosquittopp_test *mosq;\n\n\tmosqpp::lib_init();\n\n\tmosq = new mosquittopp_test(\"01-will-unpwd-set\");\n\tmosq->username_pw_set(\"oibvvwqw\", \"#'^2hg9a&nm38*us\");\n\tmosq->will_set(\"will-topic\", strlen(\"will message\"), \"will message\", 2, false);\n\n\tmosq->connect(\"localhost\", 1888, 60);\n\n\twhile(run == -1){\n\t\tmosq->loop();\n\t}\n\n\tmosqpp::lib_cleanup();\n\n\treturn run;\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n*  This is the entrypoint for your program.\n*  You will use this to test and debug your\n*  code. Right now, it is a tight while loop.\n*\n* @param argc Number of command-line arguments.\n* @param argv Array of command-line argument strings.\n*\n* @return Should not return.\n*/\nint main(int argc, char *argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, char *argv[])\n{\n\tstruct mosquittopp_test *mosq;\n\tint rc;\n\n\tmosqpp::lib_init();\n\n\tmosq = new mosquittopp_test(\"08-ssl-fake-cacert\");\n\n\tmosq->tls_opts_set(1, \"tlsv1\", NULL);\n\tmosq->tls_set(\"../ssl/test-fake-root-ca.crt\", NULL, \"../ssl/client.crt\", \"../ssl/client.key\");\n\tmosq->connect(\"localhost\", 1888, 60);\n\n\trc = mosq->loop_forever();\n\tif(rc == MOSQ_ERR_ERRNO && errno == EPROTO){\n\t\treturn 0;\n\t}else{\n\t\treturn 1;\n\t}\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n* This is the main entrypoint for the program. It creates a new instance of the\n* mosquittopp_test class and sets up the TLS options, connects to the server, and\n* loops forever. If an error occurs, it returns 1; otherwise, it returns 0.\n*\n* @param argc The number of command-line arguments.\n* @param argv An array of command-line arguments.\n* @return Should not return.\n*/\nint main(int argc, char *argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool releaseMemcpy3DPeerData(JNIEnv *env, Memcpy3DPeerData* &memcpyData)\r\n{\r\n    if (!releasePointerData(env, memcpyData->srcHostPointerData, JNI_ABORT)) return false;\r\n    if (!releasePointerData(env, memcpyData->dstHostPointerData)) return false;\r\n    delete memcpyData;\r\n    memcpyData = NULL;\r\n    return true;\r\n}\r\n",
        "answer": "/** @brief Release all pointers in the given memcpyData, delete it and set it to NULL. Returns whether this operation succeeded.\n*\n*  This function releases all pointers in the given Memcpy3DPeerData structure, deletes it, and sets it to NULL. It returns a boolean value indicating whether the operation succeeded.\n*\n* @param env The JNI environment.\n* @param memcpyData The Memcpy3DPeerData structure to be released.\n* @return True if the operation succeeded, false otherwise.\n*/\nbool releaseMemcpy3DPeerData(JNIEnv *env, Memcpy3DPeerData* &memcpyData) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M150() {\n    set_led_color(\n      code_seen('R') ? (code_has_value() ? code_value_byte() : 255) : 0,\n      code_seen('U') ? (code_has_value() ? code_value_byte() : 255) : 0,\n      code_seen('B') ? (code_has_value() ? code_value_byte() : 255) : 0\n      #if ENABLED(RGBW_LED)\n        , code_seen('W') ? (code_has_value() ? code_value_byte() : 255) : 0\n      #endif\n    );\n  }\n",
        "answer": "/** @brief Set Status LED Color - Use R-U-B-W for R-G-B-W Always sets all 3 or 4 components. If a component is left out, set to 0. Examples: M150 R255 ; Turn LED red M150 R255 U127 ; Turn LED orange (PWM only) M150 ; Turn LED off M150 R U B ; Turn LED white M150 W ; Turn LED white using a white LED\n*  @param r The value of the red component.\n*  @param u The value of the blue component.\n*  @param b The value of the green component.\n*  #if ENABLED(RGBW_LED)\n*    @param w The value of the white component.\n*  #endif\n*/\ninline void gcode_M150() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void bit_clear(uint16_t bits[16], uint8_t x, uint8_t y) { CBI(bits[y], x); }\n",
        "answer": "/** @brief Clears a single bit in a 2D array of bits.\n*\n* This function clears a single bit in a 2D array of bits, where each element in the array represents a row and column of bits. The x and y parameters specify the position of the bit to be cleared.\n*\n* @param[in] bits A 2D array of bits, where each element is a uint16_t representing a row of bits.\n* @param[in] x The x-coordinate of the bit to be cleared (the column number).\n* @param[in] y The y-coordinate of the bit to be cleared (the row number).\n*/\nvoid bit_clear(uint16_t bits[16], uint8_t x, uint8_t y) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sr_stdout_to_file ()\r\n {\r\n   freopen ( \"stdout.txt\", \"w\", stdout );\r\n   setbuf ( stdout, NULL );\r\n   freopen ( \"stderr.txt\", \"w\", stderr );\r\n   setbuf ( stderr, NULL );\r\n }\r\n",
        "answer": "/** @brief Redirects the C streams stdout and stderr to the text files stdout.txt and stderr.txt in the current folder\n*\n* This function redirects the standard output (stdout) and standard error (stderr) streams to two separate text files named \"stdout.txt\" and \"stderr.txt\" in the current working directory.\n* The freopen() function is used to redirect the stdout stream to the file \"stdout.txt\", and the setbuf() function is used to disable buffering for the stdout stream, so that output is written immediately to the file.\n* Similarly, the stderr stream is redirected to the file \"stderr.txt\" using freopen(), and buffering is disabled for the stderr stream using setbuf().\n*\n* @return void\n*/\nvoid sr_stdout_to_file ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool sr_in_triangle ( double p1x, double p1y, double p2x, double p2y, double p3x, double p3y, double px, double py )\r\n {\r\n   return SR_CCW(px,py,p1x,p1y,p2x,p2y)>=0 && \r\n          SR_CCW(px,py,p2x,p2y,p3x,p3y)>=0 && \r\n          SR_CCW(px,py,p3x,p3y,p1x,p1y)>=0 ? true:false;\r\n }\r\n",
        "answer": "/** @brief Checks if a point is inside a triangle.\n*\n*  This function checks whether a point (px, py) is inside or on the border of a triangle defined by three points (p1x, p1y), (p2x, p2y), and (p3x, p3y). The test is based on three counter-clockwise (CCW) tests and no epsilons are used.\n*\n* @param p1x X coordinate of the first point in the triangle.\n* @param p1y Y coordinate of the first point in the triangle.\n* @param p2x X coordinate of the second point in the triangle.\n* @param p2y Y coordinate of the second point in the triangle.\n* @param p3x X coordinate of the third point in the triangle.\n* @param p3y Y coordinate of the third point in the triangle.\n* @param px X coordinate of the point to be checked.\n* @param py Y coordinate of the point to be checked.\n* @return True if the point is inside or on the border of the triangle, false otherwise.\n*/\nbool sr_in_triangle ( double p1x, double p1y, double p2x, double p2y, double p3x, double p3y, double px, double py )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int compare ( const SrVec* v1, const SrVec* v2 )\r\n {\r\n   return compare ( *v1, *v2 );\r\n }\r\n",
        "answer": "/** @brief Compares two vectors using coordinates.\n*\n* This function compares two vectors using their coordinates and returns -1,0, or 1 depending on whether v1 is less than, equal to, or greater than v2. The parameters are passed by pointers.\n*\n* @param v1 A pointer to the first vector.\n* @param v2 A pointer to the second vector.\n* @return -1 if v1 is less than v2, 0 if they are equal, and 1 if v1 is greater than v2.\n*/\nint compare ( const SrVec* v1, const SrVec* v2 )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "PLUGIN_EXPORT void PLUGIN_CALL ProcessTick()\n{\n\tsampgdk::ProcessTick();\n}\n",
        "answer": "/** @brief Processes a tick event.\n*\n*  This function is called by the server every tick, which corresponds to one iteration of the server's internal event loop. The interval between ticks depends on many factors, but it's possible to set the minimum tick rate via server.cfg (default is 5ms).\n*\n* @return Should not return\n*/\nPLUGIN_EXPORT void PLUGIN_CALL ProcessTick()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void init_lock_array_hbw_space() {\n  static int is_initialized = 0;\n  if(! is_initialized)\n    for(int i = 0; i < static_cast<int> (HBW_SPACE_ATOMIC_MASK+1); i++)\n      HBW_SPACE_ATOMIC_LOCKS[i] = 0;\n}\n",
        "answer": "/** @brief Initializes the locks for arbitrary atomics in HBW space.\n*\n* This function initializes the locks to zero (unset) for arbitrary atomics in HBW space. The locks are implemented using a hash table of locks where the hash value is derived from the address of the object for which an atomic operation is performed.\n*\n* @return void\n*/\nvoid init_lock_array_hbw_space() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OSVR_ReturnCode osvrRenderManagerStartPresentRenderBuffers(\n    OSVR_RenderManagerPresentState* presentStateOut) {\n    RenderManagerPresentState* presentState = new RenderManagerPresentState();\n    (*presentStateOut) =\n        reinterpret_cast<OSVR_RenderManagerPresentState*>(presentState);\n    return OSVR_RETURN_SUCCESS;\n}\n",
        "answer": "/** @brief Starts the presentation of render buffers for a single frame.\n*\n* This function is used to bracket the start of the presentation of render buffers for a single frame. Between this function and the associated Finish call below, graphics-library-specific Present calls should be made (for example, osvrRenderManagerPresentRenderBufferD3D11). All buffers must be registered before they are presented.\n*\n* @param [out] presentStateOut A pointer to an OSVR_RenderManagerPresentState object that will be filled in with the current presentation state.\n* @return OSVR_RETURN_SUCCESS if the function succeeds, or an error code otherwise.\n*/\nOSVR_ReturnCode osvrRenderManagerStartPresentRenderBuffers("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OSVR_ReturnCode osvrRenderManagerRegisterRenderBufferD3D11(\n    OSVR_RenderManagerRegisterBufferState registerBufferState,\n    OSVR_RenderBufferD3D11 renderBuffer) {\n    return osvrRenderManagerRegisterRenderBufferImpl(registerBufferState,\n                                                     renderBuffer);\n}\n",
        "answer": "/** @brief Registers a render buffer with the Render Manager.\n*\n*  This function must be bracketed by osvrRenderManagerStartRegisterRenderBuffers and osvrRenderManagerFinishPresentRegisterBuffers.\n*\n* @param registerBufferState The state of the register buffer.\n* @param renderBuffer The render buffer to register.\n*\n* @return OSVR_RETURN_SUCCESS if successful, otherwise an error code.\n*/\nOSVR_ReturnCode osvrRenderManagerRegisterRenderBufferD3D11("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   DLL_HEADER Ng_Result Ng_MergeMesh( Ng_Mesh* mesh1, Ng_Mesh* mesh2)\n   {\n      return NG_ERROR;\n   }\n",
        "answer": "/** @brief Merges two Netgen meshes already present in memory.\n*\n*  This function can be used to merge two Netgen meshes already present in memory.\n*\n* @param[in] mesh1 The first mesh to be merged.\n* @param[in] mesh2 The second mesh to be merged.\n* @return NG_ERROR if the meshes cannot be merged, otherwise returns a pointer to the merged mesh.\n*/\nDLL_HEADER Ng_Result Ng_MergeMesh(Ng_Mesh* mesh1, Ng_Mesh* mesh2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   DLL_HEADER int Ng_GetNSE (Ng_Mesh * mesh)\n   {\n      return ((Mesh*)mesh) -> GetNSE();\n   }\n",
        "answer": "/** @brief Returns the number of surface elements in a Netgen Mesh Structure.\n*\n*  This function takes an already existent Netgen Mesh Structure and returns the number of surface elements currently present within the Mesh.\n*\n* @param mesh A pointer to a Ng_Mesh structure representing the mesh.\n* @return The number of surface elements in the mesh.\n*/\nDLL_HEADER int Ng_GetNSE (Ng_Mesh * mesh)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "jmethodID findConstructorId(JNIEnv *env, References &refs, const std::string &className,\n                            const std::string &methodDescriptor) {\n  return findMethodId(env, refs, className, CONSTRUCTOR_METHOD_NAME, methodDescriptor);\n}\n",
        "answer": "/** @brief Finds constructors.\n*\n* This function finds the constructor for a given class name and method descriptor.\n* The method descriptor should return void (V) (e.g. ([Ljava/lang/String;[FI)V ).\n*\n* @param env The JNI environment.\n* @param refs References to the Java classes, methods, and fields.\n* @param className The name of the class to find the constructor for.\n* @param methodDescriptor The descriptor of the constructor method.\n*\n* @return The ID of the constructor method.\n*/\njmethodID findConstructorId(JNIEnv *env, References &refs, const std::string &className,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool obs_module_load(void)\n{\n\tRegisterAgoraVideoEncoder();\n\tRegisterAgoraAudioEncoder();\n\tRegisterAgoraOutput();\n\tRegisterAgoraService();\n\treturn true;\n}",
        "answer": "/** @brief Called when the module is loaded. Use this function to load all the sources/encoders/outputs/services for your module, or anything else that may need loading.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nbool obs_module_load(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString expandMacro(const QString &name)\n{\n   QString n = name;\n\n   expandExpression(n, nullptr, 0);\n   n = removeMarkers(n);\n\n   return n;\n}\n",
        "answer": "/** @brief Expands the macro definition in name.\n*\n* This function expands the macro definition in name if needed, it may read additional characters from the input.\n*\n* @param[in] name The name of the macro to expand.\n* @return The expanded macro definition.\n*/\nQString expandMacro(const QString &name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DKGL_API void* operator new (size_t s, DKAllocator& a)\n{\n\tvoid* p = a.Alloc(s);\n\tbool b = DKObjectRefCounter::SetRefCounter(p, &a, 0, NULL);\n\tDKASSERT_STD_DESC_DEBUG(b, \"DKObjectRefCounter failed.\");\n\treturn p;\n}\n",
        "answer": "/**\n* @brief Allocates memory and tracks reference count using a DKAllocator object.\n*\n* This function allocates memory using the provided DKAllocator object and sets up reference counting for the allocated memory.\n*\n* @param s The size of the memory block to allocate.\n* @param a The DKAllocator object to use for allocation.\n*\n* @return A pointer to the allocated memory block, or NULL if allocation failed.\n*/\nvoid* operator new (size_t s, DKAllocator& a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool FileStream_Switch(TFileStream * pStream, TFileStream * pNewStream)\r\n{\r\n    if(pStream->dwFlags & STREAM_FLAG_READ_ONLY)\r\n        return false;\r\n\r\n    assert(pStream->StreamSwitch != NULL);\r\n    return pStream->StreamSwitch(pStream, pNewStream);\r\n}\r\n",
        "answer": "/** @brief Switches a stream with another. Used for final phase of archive compacting. Performs these steps: 1) Closes the handle to the existing MPQ 2) Renames the temporary MPQ to the original MPQ, overwrites existing one 3) Opens the MPQ stores the handle and stream position to the new stream structure\n* @param pStream The current stream that needs to be switched.\n* @param pNewStream The new stream that will replace the current stream.\n* @return true if the switch was successful, false otherwise.\n*/\nbool FileStream_Switch(TFileStream * pStream, TFileStream * pNewStream)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void zbar_image_scanner_enable_cache (zbar_image_scanner_t *iscn,\n                                      int enable)\n{\n    if(iscn->cache) {\n        /* recycle all cached syms */\n        _zbar_image_scanner_recycle_syms(iscn, iscn->cache);\n        iscn->cache = NULL;\n    }\n    iscn->enable_cache = (enable) ? 1 : 0;\n}\n",
        "answer": "/** @brief Enable or disable the inter-image result cache.\n*\n* This function enables or disables the inter-image result cache, which is used to filter duplicate results from consecutive images and add consistency checking and hysteresis to the results. The cache is disabled by default.\n*\n* @param iscn A pointer to a zbar_image_scanner_t object.\n* @param enable A boolean value indicating whether to enable or disable the cache.\n*/\n/* recycle all cached syms */\n_zbar_image_scanner_recycle_syms(iscn, iscn->cache);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void b3AlignedAllocSetCustom(b3AllocFunc *allocFunc, b3FreeFunc *freeFunc)\n{\n\tb3s_allocFunc = allocFunc ? allocFunc : b3AllocDefault;\n\tb3s_freeFunc = freeFunc ? freeFunc : b3FreeDefault;\n}\n",
        "answer": "/** @brief Set custom memory allocation functions for Bullet.\n*\n* This function allows the developer to use a custom memory allocator for all Bullet memory allocations.\n* The allocFunc and freeFunc parameters are pointers to functions that will be used for allocation and deallocation, respectively.\n* If either parameter is NULL, the default Bullet allocation/deallocation functions will be used instead.\n*\n* @param[in] allocFunc Pointer to a function that will be used for memory allocation.\n* @param[in] freeFunc Pointer to a function that will be used for memory deallocation.\n*/\nvoid b3AlignedAllocSetCustom(b3AllocFunc *allocFunc, b3FreeFunc *freeFunc)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid node_hypot( const FunctionCallbackInfo<Value>& info ) {\n\t\tif ( info.Length() != 2 ) {\n\t\t\tThrowError( \"invalid invocation. Must provide 2 arguments.\" );\n\t\t\treturn;\n\t\t}\n\t\tif ( !info[ 0 ]->IsNumber() ) {\n\t\t\tThrowTypeError( \"invalid argument. First argument must be a number.\" );\n\t\t\treturn;\n\t\t}\n\t\tif ( !info[ 1 ]->IsNumber() ) {\n\t\t\tThrowTypeError( \"invalid argument. Second argument must be a number.\" );\n\t\t\treturn;\n\t\t}\n\t\tconst double x = info[ 0 ]->NumberValue();\n\t\tconst double y = info[ 1 ]->NumberValue();\n\n\t\tLocal<Number> h = Nan::New( stdlib_base_hypot( x, y ) );\n\t\tinfo.GetReturnValue().Set( h );\n\t}\n",
        "answer": "/** @brief Computes the hypotenuse avoiding overflow and underflow.\n*\n*  This function computes the hypotenuse of a right-angled triangle, given its two sides. It is implemented using the `stdlib_base_hypot` function from the C standard library, which provides a more accurate and efficient way to compute the hypotenuse than the naive approach of squaring and summing the sides.\n*\n*  When called from JavaScript, this function expects two arguments: `x` and `y`, which are the lengths of the two sides of the triangle. These arguments must be numbers, or an error will be thrown. If the arguments are valid, the function returns the hypotenuse as a number.\n*\n* @param info The argument object passed to this function from JavaScript. It contains the `x` and `y` arguments.\n*/\nvoid node_hypot( const FunctionCallbackInfo<Value>& info ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API ssize_t rtcGetParameter1i(const RTCParameter parm)\n  {\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcGetParameter1i);\n    assert(g_device);\n    Lock<MutexSys> lock(g_mutex);\n    return g_device->getParameter1i(parm);\n    RTCORE_CATCH_END(g_device);\n    return 0;\n  }\n",
        "answer": "/** @brief Reads some device parameter. WARNING: This function is deprecated, use rtcDeviceGetParameter1i instead.\n*\n*  This function reads a single integer parameter from the device.\n*\n* @param parm The parameter to read.\n*\n* @return The value of the parameter.\n*/\nRTCORE_API ssize_t rtcGetParameter1i(const RTCParameter parm);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcSetMemoryMonitorFunction(RTCMemoryMonitorFunc func) \n  {\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcSetMemoryMonitorFunction);\n    assert(g_device);\n    if (g_device) g_device->setMemoryMonitorFunction(func);\n    RTCORE_CATCH_END(g_device);\n  }\n",
        "answer": "/**\n* @brief Sets the memory consumption callback function which is called before or after the library allocates or frees memory. WARNING: This function is deprecated, use rtcDeviceSetMemoryMonitorFunction2 instead.\n*\n* @param func The memory monitor function to set.\n*/\nRTCORE_API void rtcSetMemoryMonitorFunction(RTCMemoryMonitorFunc func);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcCommitThread(RTCScene hscene, unsigned int threadID, unsigned int numThreads) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcCommitThread);\n    RTCORE_VERIFY_HANDLE(hscene);\n\n    if (unlikely(numThreads == 0)) \n      throw_RTCError(RTC_INVALID_OPERATION,\"invalid number of threads specified\");\n\n    /* for best performance set FTZ and DAZ flags in the MXCSR control and status register */\n    unsigned int mxcsr = _mm_getcsr();\n    _mm_setcsr(mxcsr | /* FTZ */ (1<<15) | /* DAZ */ (1<<6));\n    \n    /* perform scene build */\n    scene->commit(threadID,numThreads,false);\n\n    /* reset MXCSR register again */\n    _mm_setcsr(mxcsr);\n    \n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/**\n* @brief Commits the geometry of the scene.\n*\n* This function commits the geometry of the scene, using the specified number of threads. The calling threads will be used internally as worker threads on some implementations.\n*\n* @param hscene A handle to the scene object.\n* @param threadID The ID of the calling thread.\n* @param numThreads The number of threads to use for the commit operation.\n*/\nRTCORE_API void rtcCommitThread(RTCScene hscene, unsigned int threadID, unsigned int numThreads);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcSetTransform (RTCScene hscene, unsigned geomID, RTCMatrixType layout, const float* xfm) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcSetTransform);\n    RTCORE_VERIFY_HANDLE(hscene);\n    RTCORE_VERIFY_GEOMID(geomID);\n    RTCORE_VERIFY_HANDLE(xfm);\n    const AffineSpace3fa transform = convertTransform(layout,xfm);\n    ((Scene*) scene)->get_locked(geomID)->setTransform(transform,0);\n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/** @brief Sets transformation of the instance. WARNING: This function is deprecated, use rtcSetTransform2 instead.\n*\n*  This function sets the transformation of an instance in a scene. The transformation is specified as a 4x4 matrix in column-major format.\n*\n*  @param[in] hscene A handle to the scene that contains the instance.\n*  @param[in] geomID The ID of the geometry that represents the instance.\n*  @param[in] layout The layout of the transformation matrix (either RTC_MATRIX_ROW_MAJOR or RTC_MATRIX_COLUMN_MAJOR).\n*  @param[in] xfm A pointer to an array of 16 floats that represents the transformation matrix.\n*\n*  @return void\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API unsigned rtcNewBSplineHairGeometry (RTCScene hscene, RTCGeometryFlags flags, unsigned int numCurves, unsigned int numVertices, unsigned int numTimeSteps) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcNewBSplineHairGeometry);\n    RTCORE_VERIFY_HANDLE(hscene);\n#if defined(EMBREE_GEOMETRY_HAIR)\n    return scene->newCurves(NativeCurves::HAIR,NativeCurves::BSPLINE,flags,numCurves,numVertices,numTimeSteps);\n#else\n    throw_RTCError(RTC_UNKNOWN_ERROR,\"rtcNewBSplineHairGeometry is not supported\");\n#endif\n    RTCORE_CATCH_END(scene->device);\n    return -1;\n  }\n",
        "answer": "/** @brief Creates a new hair geometry, consisting of multiple hairs represented as cubic B-spline curves with varying radii.\n*\n*  This function creates a new hair geometry object and returns its handle. The number of curves (numCurves), number of vertices (numVertices), and number of time steps have to get specified at construction time (1 for normal meshes, and up to RTC_MAX_TIME_STEPS for multi-segment motion blur). Further, the curve index buffer (RTC_INDEX_BUFFER) and the curve vertex buffer (RTC_VERTEX_BUFFER) have to get set by mapping and writing to the appropriate buffers. In case of multi-segment motion blur multiple vertex buffers have to get filled (RTC_VERTEX_BUFFER0, RTC_VERTEX_BUFFER1, etc.), one for each time step. The index buffer has the default layout of a single 32 bit integer index for each curve, that references the start vertex of the curve. The vertex buffer stores 4 control points per curve, each such control point consists of a single precision (x,y,z) position and radius, stored in that order in memory. Individual hairs are considered to be subpixel sized which allows the implementation to approximate the intersection calculation. This in particular means that zooming onto one hair might show geometric artefacts.\n*\n*  @param hscene The handle of the scene to create the geometry in.\n*  @param flags The flags for the geometry, see RTCGeometryFlags.\n*  @param numCurves The number of curves in the geometry.\n*  @param numVertices The number of vertices in the geometry.\n*  @param numTimeSteps The number of time steps in the geometry (1 for normal meshes, and up to RTC_MAX_TIME_STEPS for multi-segment motion blur).\n*\n*  @return A handle to the created hair geometry object.\n*/\nRTCORE_API unsigned rtcNewBSplineHairGeometry(RTCScene hscene, RTCGeometryFlags flags, unsigned int numCurves, unsigned int numVertices, unsigned int numTimeSteps);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcSetBoundaryMode (RTCScene hscene, unsigned geomID, RTCBoundaryMode mode) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcSetBoundaryMode);\n    RTCORE_VERIFY_HANDLE(hscene);\n    RTCORE_VERIFY_GEOMID(geomID);\n    scene->get_locked(geomID)->setSubdivisionMode(0,(RTCSubdivisionMode)mode);\n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/**\n* @brief Sets boundary interpolation mode for default subdivision surface topology. WARNING: This function is deprecated, use rtcSetSubdivisionMode instead.\n*\n* @param hscene A handle to the scene containing the geometry.\n* @param geomID The ID of the geometry.\n* @param mode The new boundary interpolation mode for the geometry.\n*/\nRTCORE_API void rtcSetBoundaryMode (RTCScene hscene, unsigned geomID, RTCBoundaryMode mode);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  RTCORE_API void rtcSetIntersectFunction1Mp (RTCScene hscene, unsigned geomID, RTCIntersectFunc1Mp intersect) \n  {\n    Scene* scene = (Scene*) hscene;\n    RTCORE_CATCH_BEGIN;\n    RTCORE_TRACE(rtcSetIntersectFunction1Mp);\n    RTCORE_VERIFY_HANDLE(hscene);\n    RTCORE_VERIFY_GEOMID(geomID);\n    scene->get_locked(geomID)->setIntersectFunction1Mp(intersect);\n    RTCORE_CATCH_END(scene->device);\n  }\n",
        "answer": "/** @brief Set intersect function for stream of rays. The rtcIntersectN function will call the passed function for intersecting the user geometry.\n*\n*  This is a C++ function that sets the intersect function for a stream of rays. It takes in an RTCScene, unsigned geomID, and an RTCIntersectFunc1Mp intersect function as parameters. The function first casts the hscene parameter to a Scene pointer and then calls the get_locked function on it with the geomID parameter. It then sets the intersect function for the geometry using the setIntersectFunction1Mp function, which takes in an RTCIntersectFunc1Mp parameter.\n*\n* @param hscene The RTCScene handle.\n* @param geomID The unsigned integer geometry ID.\n* @param intersect The RTCIntersectFunc1Mp intersect function.\n* @return void\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    ui32 ReverseBits(ui32 num, ui32 msb)\n    {\n        ui32 result;\n        unsigned char * p = (unsigned char *) &num;\n        unsigned char * q = (unsigned char *) &result;\n        q[3] = reverse_byte(p[0]);\n        q[2] = reverse_byte(p[1]);\n        q[1] = reverse_byte(p[2]);\n        q[0] = reverse_byte(p[3]);\n        return (result) >> (32-msb);\n    }\n",
        "answer": "/** @brief Reverse bits of num and return an unsigned int, for all bits up to an including the designated most significant bit.\n*\n*  This method reverses the bits of a given number and returns an unsigned integer with the reversed bits. The function takes two parameters: num, which is the number to be reversed, and msb, which is the most significant bit up to which the bits should be reversed.\n*\n* @param num The number to be reversed.\n* @param msb The most significant bit up to which the bits should be reversed.\n* @return An unsigned integer with the reversed bits.\n*/\nui32 ReverseBits(ui32 num, ui32 msb)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void collapseTextures(ob_t * ob0, ob_t * ob1, ob_t * ob2, ob_t * ob3)\n{\n    ob_t * tmpob = NULL;\n\n    tmpob = ob0;\n    while (tmpob != NULL)\n    {\n        if (0 == isNamedAndPolygon(tmpob))\n        {\n            tmpob = tmpob->next;\n            continue;\n        }\n\n        collapseMapTiledTextures(tmpob, ob1);\n        collapseSkidsGrassTextures(tmpob, ob2);\n        collapseShadowTextures(tmpob, ob3);\n\n        tmpob = tmpob->next;\n    }\n}\n",
        "answer": "/** @brief Collapse textures from ob1, ob2 and ob3 with ob0.\n*\n*  This function matches textures from ob1, ob2 and ob3 with ob0. In case a match is found, it adds them as additional texture channels in ob0.\n*\n* @param[in] ob0 The first object to collapse textures for.\n* @param[in] ob1 The second object to collapse textures for.\n* @param[in] ob2 The third object to collapse textures for.\n* @param[in] ob3 The fourth object to collapse textures for.\n*/\nvoid collapseTextures(ob_t * ob0, ob_t * ob1, ob_t * ob2, ob_t * ob3)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void createTexCoordArray(double * destarr, tcoord_t * srcidxarr, int numidx)\n{\n    tcoord_t * curidxobj = NULL;\n    int curidx = 0;\n\n    for (curidx = 0; curidx < numidx; curidx++)\n    {\n        curidxobj = &srcidxarr[curidx];\n\n        destarr[curidxobj->indice * 2] = curidxobj->u;\n        destarr[curidxobj->indice * 2 + 1] = curidxobj->v;\n    }\n}\n",
        "answer": "/** @brief Create a texture coordinate array.\n*\n*  This function copies the (u,v) coordinates from the source index array to the corresponding position in the destination array. The destination array needs to have 2 * number of vertices entries.\n*\n* @param destarr The destination array for the texture coordinates.\n* @param srcidxarr The source index array containing the (u,v) coordinates.\n* @param numidx The number of indices in the source index array.\n*/\nvoid createTexCoordArray(double * destarr, tcoord_t * srcidxarr, int numidx);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static double BoxMissMetric(const TBOX& box1, const TBOX& box2) {\n  const int overlap_area = box1.intersection(box2).area();\n  const int a = box1.area();\n  const int b = box2.area();\n  ASSERT_HOST(a != 0 && b != 0);\n  return 1.0 * (a - overlap_area) * (b - overlap_area) / a / b;\n}\n",
        "answer": "/** @brief Helper to compute the dispute resolution metric. Disputed blob resolution. The aim is to give the blob to the most appropriate boxfile box. Most of the time it is obvious, but if two boxfile boxes overlap significantly it is not. If a small boxfile box takes most of the blob, and a large boxfile box does too, then we want the small boxfile box to get it, but if the small box is much smaller than the blob, we don't want it to get it. Details of the disputed blob resolution: Given a box with area A, and a blob with area B, with overlap area C, then the miss metric is (A-C)(B-C)/(AB) and the box with minimum miss metric gets the blob.\n*/\nstatic double BoxMissMetric(const TBOX& box1, const TBOX& box2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void FreeCharDescription(CHAR_DESC CharDesc) {\n  if (CharDesc) {\n    for (size_t i = 0; i < CharDesc->NumFeatureSets; i++)\n      FreeFeatureSet (CharDesc->FeatureSets[i]);\n    Efree(CharDesc);\n  }\n}                                /* FreeCharDescription */\n",
        "answer": "/** @brief Frees the memory consumed by a character description and all of its features.\n*\n* This function releases the memory consumed by the specified character description and all of the features in that description.\n*\n* @param CharDesc The character description to free.\n*/\nvoid FreeCharDescription(CHAR_DESC CharDesc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ComputePaddedBoundingBox (PROTO Proto, float TangentPad,\n                               float OrthogonalPad, FRECT *BoundingBox) {\n  float Length     = Proto->Length / 2.0 + TangentPad;\n  float Angle      = Proto->Angle * 2.0 * M_PI;\n  float CosOfAngle = fabs(cos(Angle));\n  float SinOfAngle = fabs(sin(Angle));\n\n  float Pad = std::max(CosOfAngle * Length, SinOfAngle * OrthogonalPad);\n  BoundingBox->MinX = Proto->X - Pad;\n  BoundingBox->MaxX = Proto->X + Pad;\n\n  Pad = std::max(SinOfAngle * Length, CosOfAngle * OrthogonalPad);\n  BoundingBox->MinY = Proto->Y - Pad;\n  BoundingBox->MaxY = Proto->Y + Pad;\n\n} /* ComputePaddedBoundingBox */\n",
        "answer": "/** @brief Computes a bounding box that encloses the specified proto along with some padding. The amount of padding is specified as separate distances in the tangential and orthogonal directions.\n*\n*  This routine computes a bounding box that encloses the specified proto along with some padding. The amount of padding is specified as separate distances in the tangential and orthogonal directions.\n*\n* @param Proto A pointer to the PROTO structure representing the object for which the bounding box is being computed.\n* @param TangentPad The distance in the tangential direction from the center of the object to the edge of the bounding box.\n* @param OrthogonalPad The distance in the orthogonal direction from the center of the object to the edge of the bounding box.\n* @param BoundingBox A pointer to an FRECT structure that will be filled with the coordinates of the bounding box.\n*/\nvoid ComputePaddedBoundingBox (PROTO Proto, float TangentPad,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CreateObject( int modelid, float x, float y, float z, float rX, float rY, float rZ, float drawDistance)\n{\n\tstatic amx_native_t func = amx_FindNative(pAMX, __FUNCTION__);\n\n\tcell args[9] =\n\t{\n\t\tsizeof(args)- sizeof(cell),\n\t\tmodelid, amx_ftoc(x), amx_ftoc(y), amx_ftoc(z), amx_ftoc(rX), amx_ftoc(rY), amx_ftoc(rZ), amx_ftoc(drawDistance)\n\t};\n\n\treturn func(pAMX, args);\n}\n",
        "answer": "/** @brief Create an object in the game world.\n*\n*  This function creates an object in the game world with a specified model ID, position, rotation, and draw distance.\n*\n* @param[in] modelid The model ID of the object to create.\n* @param[in] x The X coordinate of the object's position.\n* @param[in] y The Y coordinate of the object's position.\n* @param[in] z The Z coordinate of the object's position.\n* @param[in] rX The rotation around the X axis of the object.\n* @param[in] rY The rotation around the Y axis of the object.\n* @param[in] rZ The rotation around the Z axis of the object.\n* @param[in] drawDistance The maximum distance from the camera at which the object will be drawn.\n*\n* @return The ID of the created object, or -1 if an error occurred.\n*/\nint CreateObject( int modelid, float x, float y, float z, float rX, float rY, float rZ, float drawDistance)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool im_open_decoder_fd(int sys_fd, long start_offset, long length, const char* fn_usr_dict) {\n  if (NULL != matrix_search) delete matrix_search;\n\n  matrix_search = new MatrixSearch();\n  if (NULL == matrix_search) return false;\n\n  return matrix_search->init_fd(sys_fd, start_offset, length, fn_usr_dict);\n}\n",
        "answer": "/** @brief Open the decoder engine via the system dictionary FD and user dictionary file name.\n*\n*  This function opens the decoder engine using the system dictionary FD and user dictionary file name.\n*  It first deletes any existing matrix search object, then creates a new one and initializes it with the given parameters.\n*\n* @param sys_fd The system dictionary FD.\n* @param start_offset The starting offset of the user dictionary.\n* @param length The length of the user dictionary.\n* @param fn_usr_dict The file name of the user dictionary.\n* @return True if the decoder engine was successfully opened, false otherwise.\n*/\nbool im_open_decoder_fd(int sys_fd, long start_offset, long length, const char* fn_usr_dict) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned im_choose(unsigned choice_id) {\n  if (NULL == matrix_search) return 0;\n\n  return matrix_search->choose(choice_id);\n}\n",
        "answer": "/** @brief Chooses a candidate based on the provided choice ID.\n*\n* This function chooses a candidate based on the provided choice ID, which is used to search for the corresponding matrix search object. If the matrix search object is not found or if the candidate does not match the end of all spelling IDs, new candidates will be provided from the first unfixed position. If the candidate matches the end of all spelling IDs, there will only be one new candidate or the whole fixed sentence.\n*\n* @param choice_id The ID of the choice to make.\n*\n* @return The chosen candidate.\n*/\nunsigned im_choose(unsigned choice_id) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "codepoint_t ucd_tolower(codepoint_t c)\n{\n\tint begin = 0;\n\tint end   = sizeof(case_conversion_data)/sizeof(case_conversion_data[0]);\n\twhile (begin <= end)\n\t{\n\t\tint pos = (begin + end) / 2;\n\t\tconst struct case_conversion_entry *item = (case_conversion_data + pos);\n\t\tif (c == item->codepoint)\n\t\t\treturn item->lowercase == 0 ? c : item->lowercase;\n\t\telse if (c > item->codepoint)\n\t\t\tbegin = pos + 1;\n\t\telse\n\t\t\tend = pos - 1;\n\t}\n\treturn c;\n}\n",
        "answer": "/** @brief Convert a Unicode codepoint to lowercase.\n*\n* This function converts a single Unicode codepoint to its lowercase equivalent using the simple case mapping present in the UnicodeData file.\n*\n* @param c The Unicode codepoint to convert.\n* @return The lowercase equivalent of the input codepoint, or the original codepoint if no lowercase equivalent exists.\n*/\ncodepoint_t ucd_tolower(codepoint_t c)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "byte_array_t read_stream(std::istream& stream)\n{\n\treturn detail::read_stream_into_container<byte_array_t>(stream);\n}\n",
        "answer": "/** @brief Load a byte array with the contents of a file.\n*\n*  This function loads the contents of a file into a byte array, whether the file is in a package or the main file system.\n*\n* @param stream The input stream to read from.\n* @return A byte array containing the contents of the file.\n*/\nbyte_array_t read_stream(std::istream& stream)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void reset_rise(void)\n{\n    if (!buttonBusy) {\n        buttonBusy = true;\n        eventQueue.post(button_task);\n    }\n}\n",
        "answer": "/** @brief Reset button IRQ handler.\n*\n*  This function handles the rising edge of the reset button. It queues a callback to the event queue, which will be executed later. This has the advantage of serializing actions, so if the button press happens during the config->beacon mode transition timeout, the button_task won't happen until the previous task has finished. If your buttons aren't debounced, you should do this in software, or button_task might get queued multiple times.\n*\n* @return Should not return\n*/\nstatic void reset_rise(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void handle_cs_property(chunk_t *bro)\n{\n   chunk_t *pc;\n   bool    did_prop = false;\n\n   set_paren_parent(bro, CT_CS_PROPERTY);\n\n   pc = bro;\n   while ((pc = chunk_get_prev_nnl(pc)) != NULL)\n   {\n      if (pc->level == bro->level)\n      {\n         if (!did_prop && ((pc->type == CT_WORD) || (pc->type == CT_THIS)))\n         {\n            pc->type = CT_CS_PROPERTY;\n            did_prop = true;\n         }\n         else\n         {\n            pc->parent_type = CT_CS_PROPERTY;\n            make_type(pc);\n         }\n         if (pc->flags & PCF_STMT_START)\n         {\n            break;\n         }\n      }\n   }\n}\n",
        "answer": "/**\n* @brief Handles a C# property.\n*\n* This function sets the parent of the current chunk to CT_CS_PROPERTY and finds the first item in the property and sets its parent, too.\n*\n* @param bro The current chunk.\n*/\nstatic void handle_cs_property(chunk_t *bro)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool parse_bs_newline(tok_ctx& ctx, chunk_t& pc)\n{\n   ctx.save();\n   ctx.get(); /* skip the '\\' */\n\n   int ch;\n   while (isspace(ch = ctx.peek()))\n   {\n      ctx.get();\n      if ((ch == '\\r') || (ch == '\\n'))\n      {\n         if (ch == '\\r')\n         {\n            ctx.expect('\\n');\n         }\n         pc.str      = \"\\\\\";\n         pc.type     = CT_NL_CONT;\n         return(true);\n      }\n   }\n\n   ctx.restore();\n   return(false);\n}\n",
        "answer": "/** @brief parse_bs_newline function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param ctx The context of the tokenizer.\n* @param pc The current chunk being parsed.\n* @return Should not return\n*/\nstatic bool parse_bs_newline(tok_ctx& ctx, chunk_t& pc)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: imada-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    for (const PAIRTYPE(string, string) & item : mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\"\n      << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/** @brief Makes an HTTP POST request with the given message and headers.\n*\n*  This function creates an HTTP POST request with the given message and headers,\n*  using the HTTP protocol. The request is returned as a string.\n*\n* @param strMsg The message to be sent in the request body.\n* @param mapRequestHeaders A map of request headers to include in the request.\n*\n* @return The HTTP POST request as a string.\n*/\nstring HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void activate_cell_renderer_toggle_tree_mode(void)\n{\n\tGtkCellRendererClass *cell_class;\n\tGtkCellRendererToggle *toggle_renderer;\n\n\ttoggle_renderer = GTK_CELL_RENDERER_TOGGLE(gtk_cell_renderer_toggle_new());\n\tcell_class = GTK_CELL_RENDERER_CLASS(GTK_WIDGET_GET_CLASS(toggle_renderer));\n\tcell_class->activate = gtk_cell_renderer_toggle_activate;\n\tgtk_object_destroy(GTK_OBJECT(toggle_renderer));\n}\n",
        "answer": "/** @brief Activates the cell renderer toggle tree mode.\n*\n*  This function activates the cell renderer toggle tree mode, which allows for the use of a toggle button in a tree view.\n*\n* @param void\n* @return void\n*/\nvoid activate_cell_renderer_toggle_tree_mode(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void app_confirmDefaultSession()\n{\n    WCHAR oldFile[MAX_PATH], newFile[MAX_PATH];\n\n    ::StringCchCopyW(oldFile, MAX_PATH, sys_getCfgDir());\n    ::StringCchCatW(oldFile, MAX_PATH, L\"default\");\n    ::StringCchCatW(oldFile, MAX_PATH, cfg::getStr(kSessionExtension));\n    ::StringCchCopyW(newFile, MAX_PATH, cfg::getStr(kSessionDirectory));\n    ::StringCchCatW(newFile, MAX_PATH, cfg::getStr(kDefaultSession));\n    ::StringCchCatW(newFile, MAX_PATH, cfg::getStr(kSessionExtension));\n    if (pth::fileExists(oldFile)) {\n        if (!::CopyFileW(oldFile, newFile, TRUE)) {\n            pth::createFileIfMissing(newFile, SES_DEFAULT_CONTENTS);\n        }\n        ::DeleteFileW(oldFile);\n    }\n    else {\n        pth::createFileIfMissing(newFile, SES_DEFAULT_CONTENTS);\n    }\n}\n",
        "answer": "/** @brief Creates the default session file if it doesn't already exist.\n*\n*  This function creates the default session file in the sessions directory if it doesn't already exist. Having default session files in the sessions directory was implemented in v1.1. For now this provides backwards-compatibility by copying the default file from the old location to the new and then deleting the old file.\n*\n* @return Should not return\n*/\nvoid app_confirmDefaultSession()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void init(){\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            keys[i][j]=ini_keys[i][j];\n\n}\n",
        "answer": "/** @brief Initializes the game's board with tiles numbered 1 through d*d - 1 (i.e., fills 2D array with values but does not actually print them).\n*\n* @param keys The 2D array to be initialized\n* @param ini_keys The initial values for the 2D array\n* @param d The dimension of the board\n*/\nvoid init(int keys[][], int ini_keys[][], int d) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int set_cloexec_flag(int desc, int value)\n{\n    int oldflags = fcntl(desc, F_GETFD, 0);\n\n    /* If reading the flags failed, return error indication now. */\n    if (oldflags < 0) {\n        return oldflags;\n    }\n\n    /* Set just the flag we want to set. */\n    if (value != 0) {\n        oldflags |= FD_CLOEXEC;\n    } else {\n        oldflags &= ~FD_CLOEXEC;\n    }\n\n    /* Store modified flag word in the descriptor. */\n    return fcntl(desc, F_SETFD, oldflags);\n}\n",
        "answer": "/**\n* @brief Set or clear the `FD_CLOEXEC` flag of a file descriptor.\n*\n* This function sets or clears the `FD_CLOEXEC` flag of a file descriptor, which determines whether the file descriptor is closed on exec.\n*\n* @param desc The file descriptor to modify.\n* @param value If nonzero, set the `FD_CLOEXEC` flag; otherwise, clear it.\n* @return 0 if successful, or -1 if an error occurred (in which case errno is set appropriately).\n*/\nint set_cloexec_flag(int desc, int value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint64_t NanosFromNow(uint64_t nanos) {\n  anarch::Clock & clock = anarch::ClockModule::GetGlobal().GetClock();\n  uint64_t ticks = clock.GetTicks();\n  return ticks + clock.GetMicrosPerTick().Flip().ScaleInteger(nanos / 1000);\n}\n",
        "answer": "/** @brief Returns the time on the global clock (in ticks) that represents the time a certain number of nanoseconds from now.\n*\n* This function returns the time on the global clock (in ticks) that represents the time a certain number of nanoseconds from now.\n* The function takes a single parameter, `nanos`, which is the number of nanoseconds from now for which the time should be returned.\n* The function first retrieves the global clock using the `anarch::ClockModule::GetGlobal().GetClock()` method.\n* It then gets the current tick count using the `clock.GetTicks()` method and stores it in a variable called `ticks`.\n* Next, it calculates the number of ticks that represent the given number of nanoseconds using the `clock.GetMicrosPerTick().Flip().ScaleInteger(nanos / 1000)` method.\n* Finally, it adds the calculated number of ticks to the current tick count and returns the result.\n* @param nanos The number of nanoseconds from now for which the time should be returned.\n* @return The time on the global clock (in ticks) that represents the given number of nanoseconds from now.\n*/\nuint64_t NanosFromNow(uint64_t nanos) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "/* Override */ void SDL_ClearQueuedAudio(SDL_AudioDeviceID dev)\n{\n    DEBUGLOGCALL(LCF_SDL | LCF_SOUND);\n\n    if (sourceSDL->source == AudioSource::SOURCE_CALLBACK) {\n        /* We cannot get queue samples when using the callback mechanism */\n        return;\n    }\n\n    std::lock_guard<std::mutex> lock(audiocontext.mutex);\n    /* We simulate clearing the queue by setting the position to the end\n     * of the queue.\n     */\n    sourceSDL->setPosition(sourceSDL->queueSize());\n}\n",
        "answer": "/**\n* @brief Clears any queued audio data waiting to be sent to the hardware.\n*\n* This function drops any queued audio data that has not yet been sent to the hardware, preventing it from being played.\n* It does not affect playback of already-sent audio, so a small amount of audio may still be heard after calling this function.\n* This can be useful for games that need to drop music during level changes or other events.\n*\n* @param dev The ID of the audio device to clear the queue for.\n*\n* @return void\n*/\nvoid SDL_ClearQueuedAudio(SDL_AudioDeviceID dev);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "/* Override */ int SDL_JoystickNumBalls(SDL_Joystick* joystick)\n{\n    DEBUGLOGCALL(LCF_SDL | LCF_JOYSTICK);\n    if (!isIdValid(joystick))\n        return 0;\n    return 0;\n}\n",
        "answer": "/**\n* @brief Get the number of trackballs on a joystick.\n*\n* Joystick trackballs have only relative motion events associated with them and their state cannot be polled.\n*\n* @param[in] joystick The joystick to query for the number of trackballs.\n* @return The number of trackballs on the given joystick.\n*/\nint SDL_JoystickNumBalls(SDL_Joystick* joystick);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int SDL_EnableUNICODE(int enable)\n{\n    DEBUGLOGCALL(LCF_SDL | LCF_KEYBOARD);\n\n    if (enable == -1) {\n        return isUnicodeEnabled?1:0;\n    }\n    isUnicodeEnabled = enable;\n    return enable;\n}\n",
        "answer": "/** @brief Enable/Disable UNICODE translation of keyboard input.\n*\n*  This function enables or disables the UNICODE translation of keyboard input.\n*  The translation has some overhead, so it defaults off.\n*\n* @param enable - If non-zero, enable UNICODE translation. If zero, disable UNICODE translation.\n* @return The previous state of the UNICODE translation (1 if enabled, 0 if disabled).\n*/\nint SDL_EnableUNICODE(int enable)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int SDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h)\n{\n    debuglog(LCF_SDL | LCF_WINDOW, __func__, \" called with new size: \", w, \" x \", h);\n\n    /* Don't let the game have logical size that differs from screen size,\n     * so we resize the window instead.\n     */\n    SDL_SetWindowSize(gameSDLWindow, w, h);\n    logical_w = w;\n    logical_h = h;\n\n    return 0;\n}\n",
        "answer": "/** @brief Sets the logical size of an SDL renderer.\n*\n* This function sets the logical size of an SDL renderer, which is used to filter and scale mouse events in the window so they seem to arrive within the logical resolution.\n*\n* @param renderer The SDL renderer to set the logical size for.\n* @param w The width of the logical size.\n* @param h The height of the logical size.\n*\n* @return 0 on success, -1 on error.\n*/\n/* Don't let the game have logical size that differs from screen size,\n* so we resize the window instead.\n*/\nSDL_SetWindowSize(gameSDLWindow, w, h);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual void Initialize() {\n\t\t\tluabind::call_member<void>(this, \"Initialize\");\n\t\t}\n",
        "answer": "/** @brief Initializes the object.\n*\n*  This function initializes the object by calling the \"Initialize\" member function using luabind::call_member.\n*\n* @return void\n*/\nvoid Initialize() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid processMessages() {\n\t\twhile (MessageSubscriber::updateBuffer());\n\t\tMessageSubscriber::swapMessageBuffer();\n\n\t\tfor (ReceivedMessagePtr & rm : *MessageSubscriber::_objInActiveMessageVector) {\n\t\t\tMailbox(rm->message);\n\t\t}\n\t\tMessageSubscriber::_objInActiveMessageVector->clear();\n\t}\n",
        "answer": "/** @brief Processes messages from the message subscriber.\n*\n*  This function is called prior to a tick in the main loop of every subsystem. It processes messages from the message subscriber and updates the buffer.\n*  Subject to future refactoring to private scope.\n*\n* @return Should not return\n*/\nvoid processMessages() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void matMaxima(const cv::Mat &mat, std::vector<Point> &locations, float rangeMin, float rangeMax) {\n    assert(mat.isContinuous());\n    assert(mat.channels()==1);\n    assert(mat.rows > 0 && mat.cols > 1);\n    assert(mat.type() == CV_8U || mat.type() == CV_32F);\n\n    LOGTRACE3(\"matMaxima(%s,%f,%f)\", matInfo(mat).c_str(), rangeMin, rangeMax);\n    if (mat.type() == CV_8U) {\n        _matMaxima<uchar>(mat, locations, (uchar)std::max(0.0f, rangeMin), (uchar)std::min(255.0f, rangeMax));\n    } else if (mat.type() == CV_32F) {\n        _matMaxima<float>(mat, locations, rangeMin, rangeMax);\n    }\n}\n",
        "answer": "/**\n* @brief Finds the local maxima in a matrix.\n*\n* This function finds the local maxima in a matrix, where the maxima are defined as points that have a value greater than or equal to `rangeMin` and less than or equal to `rangeMax`. The function returns a vector of Points indicating the locations of the local maxima. Multi-point maxima with convex shapes are represented with an upper-right-most point. Concave maxima sets don't fare as well and multiple points along the top of the point set will be reported. For CV_32F matrices, this is infrequent, however, the situation may arise for CV_8U matrices and the caller may need to process the returned locations further for centroids, etc.\n*\n* @param mat The input matrix.\n* @param locations A vector of Points indicating the locations of the local maxima.\n* @param rangeMin The minimum value that a point must have in order to be considered a maximum.\n* @param rangeMax The maximum value that a point can have in order to be considered a maximum.\n*/\nvoid matMaxima(const cv::Mat &mat, std::vector<Point> &locations, float rangeMin, float rangeMax) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, char** argv) {\n  if(argc > 1) {\n    int depth = atoi(argv[1]);\n    char pos_str[depth + 1] = {0};\n    explore(Position(), pos_str, depth);\n  } else generate_opening_book();\n}\n",
        "answer": "/** @brief Main entrypoint for the program.\n*\n* This is the main entrypoint for the program, it will either explore all unique positions up to a given depth or read scored positions from standard input to store in an opening book.\n*\n* @param argc The number of command line arguments passed to the program.\n* @param argv An array of strings containing the command line arguments.\n* @return 0 if the program executed successfully, non-zero otherwise.\n*/\nint main(int argc, char** argv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void addDispatchOperation(const MethodInvocationContextPtr<> &context,\n            const ChannelDispatchOperationPtr &dispatchOperation)\n    {\n        mAddDispatchOperationChannels = dispatchOperation->channels();\n        mAddDispatchOperationDispatchOperation = dispatchOperation;\n\n        QVERIFY(connect(dispatchOperation->claim(AbstractClientHandlerPtr(this)),\n                    SIGNAL(finished(Tp::PendingOperation*)),\n                    SIGNAL(claimFinished())));\n\n        context->setFinished();\n        QTimer::singleShot(0, this, SIGNAL(addDispatchOperationFinished()));\n    }\n",
        "answer": "/** @brief Adds a dispatch operation to the channel.\n*\n*  This function is called by the channel dispatcher when a dispatch operation in which the approver has registered an interest is created, or when the approver starts up while such channel dispatch operations already exist. Specialized approvers must reimplement this method.\n*\n* @param context The method invocation context pointer.\n* @param dispatchOperation The channel dispatch operation pointer.\n*/\nvoid addDispatchOperation(const MethodInvocationContextPtr<> &context,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int my_snprintf(char * buf, size_t size, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = my_vsnprintf(buf,size,fmt,args);\n\tva_end(args);\n\treturn i;\n}\n",
        "answer": "/** @brief Format a string and place it in a buffer.\n*\n*  This function formats a string according to the format string and places it in the buffer.\n*  The size of the buffer, including the trailing null space, is also specified.\n*  Arguments for the format string are passed as a va_list.\n*  The return value is the number of characters which would be generated for the given input, excluding the trailing null, as per ISO C99. If the return is greater than or equal to , the resulting string is truncated.\n*\n* @param buf The buffer to place the result into.\n* @param size The size of the buffer, including the trailing null space.\n* @param fmt The format string to use.\n* @param args Arguments for the format string.\n* @return The number of characters which would be generated for the given input, excluding the trailing null, as per ISO C99. If the return is greater than or equal to , the resulting string is truncated.\n*/\nint my_snprintf(char * buf, size_t size, const char *fmt, ...)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void mdrunner_start_fn(void *arg)\n{\n    try\n    {\n        auto masterMdrunner = reinterpret_cast<const gmx::Mdrunner *>(arg);\n        /* copy the arg list to make sure that it's thread-local. This\n           doesn't copy pointed-to items, of course, but those are all\n           const. */\n        gmx::Mdrunner mdrunner = *masterMdrunner;\n        mdrunner.reinitializeOnSpawnedThread();\n        mdrunner.mdrunner();\n    }\n    GMX_CATCH_ALL_AND_EXIT_WITH_FATAL_ERROR;\n}\n",
        "answer": "/** @brief Launches a new thread for the simulation.\n*\n*  Obtains the pointer to the master mdrunner object from the one argument permitted to the thread-launch API call, copies it to make a new runner for this thread, reinitializes necessary data, and proceeds to the simulation.\n*\n* @param arg The argument passed to the thread-launch API call, which should be a pointer to the master mdrunner object.\n* @return Should not return\n*/\n/* copy the arg list to make sure that it's thread-local. This\ndoesn't copy pointed-to items, of course, but those are all"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int linearSearch(int itemList[],int itemListSize,int item)\n{\n    int index=0;\n    while (index < itemListSize)\n    {\n        if (itemList[index] == item)\n        {\n            return index;\n        }\n        index++;\n    }\n    return -1;\n    \n}\n",
        "answer": "/** @brief Linear search algorithm.\n*\n*  This is the exact implementation of the pseudocode written in README. Notice that even if the array list contains multiple items, it will return only one index. Thus this algorithm is well suited to find if a item is present. And not for finding the exact index if multiple items are present. With C++ you have to be careful of integer overflows. So we must make sure that the length of itemList is below that of int.\n*\n* @param[in] itemList The list of items to search in.\n* @param[in] itemListSize The size of the item list.\n* @param[in] item The item to search for.\n* @return The index of the first occurrence of the item, or -1 if not found.\n*/\nint linearSearch(int itemList[], int itemListSize, int item)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint64_t eval_unsigned_int_constant( const TxExpressionNode* exprNode ) {\n    Constant* value = exprNode->code_gen_const_value( *exprNode->get_parser_context()->get_llvm_gen_context() );\n    ConstantInt* CI = cast<ConstantInt>( value );\n    uint64_t constUIntValue = CI->getZExtValue();\n    return constUIntValue;\n}\n",
        "answer": "/** @brief Evaluates an unsigned integer constant expression.\n*\n*  This function evaluates a statically constant expression of unsigned integer or boolean type. It is the caller's responsibility to ensure the expression is statically constant and of the proper type.\n*\n* @param exprNode The expression node representing the constant expression.\n* @return The result value of the constant expression as an unsigned integer.\n*/\nuint64_t eval_unsigned_int_constant( const TxExpressionNode* exprNode ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool dsn_config_load(const char *file, const char *arguments)\n{\n    return g_config.load(file, arguments);\n}\n",
        "answer": "/** @brief Loads a configuration file and replaces specific strings with arguments.\n*\n* This function loads an ini configuration file and replaces specific strings in the file with arguments. For example: the file content: \" [example_section] replace_key% = real_value real_port = host_port% \" and the arguments \"replace_key=key,host_port=8080\" so the loaded config will be: \" [example_section] key = real_value real_port = 8080\".\n*\n* @param file The path to the configuration file.\n* @param arguments A string containing the arguments to replace in the configuration file.\n*\n* @return True if the configuration file was loaded successfully, false otherwise.\n*/\nbool dsn_config_load(const char *file, const char *arguments)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dsn_config_get_all_sections(/*out*/ std::vector<std::string> &sections)\n{\n    g_config.get_all_sections(sections);\n}\n",
        "answer": "/** @brief Get the names of all sections in the configuration file.\n*\n*  This function is not thread safe if dsn_config_set is concurrently called.\n*\n* @param[out] sections A vector of strings containing the names of all sections in the configuration file.\n*/\nvoid dsn_config_get_all_sections(std::vector<std::string> &sections)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DSN_API bool dsn_rpc_unregiser_handler(dsn::task_code code)\n{\n    return ::dsn::task::get_current_node()->rpc_unregister_handler(code);\n}\n",
        "answer": "/** @brief Unregister callback to handle RPC request, returns true if unregister ok, false if no handler was registered.\n*\n*  This function is used to unregister a callback for handling RPC requests. It takes a dsn::task_code code as input and returns a bool indicating whether the unregister operation was successful or not.\n*\n* @param[in] code The task code associated with the handler to be unregistered.\n* @return True if the unregister operation was successful, false otherwise.\n*/\nDSN_API bool dsn_rpc_unregiser_handler(dsn::task_code code);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static gboolean collect_account(gpointer key, gpointer v, gpointer data) {\n\tAccountCollector *collector = (AccountCollector*) data;\n\tPurpleAccount *account = (PurpleAccount *) v;\n\tcollector->collectNow(account, false);\n\treturn TRUE;\n}\n",
        "answer": "/** @brief Collects accounts from the account manager.\n*\n*  This function collects all accounts from the account manager and adds them to the account collector.\n*\n* @param[in] am The account manager.\n* @param[out] collector The account collector.\n*/\nstatic gboolean collect_account(gpointer key, gpointer v, gpointer data) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static gboolean removeRepeater(gpointer data){\n\tSearchRepeater *repeater = (SearchRepeater*) data;\n\tpurple_request_close(repeater->type(),repeater);\n\tLog(\"SearchRepeater\", \"repeater closed\");\n\treturn FALSE;\n}\n",
        "answer": "/**\n* @brief Removes a repeater from the search.\n*\n* This function removes a repeater from the search by closing it and logging the action.\n*\n* @param data The data pointer passed to the function.\n* @return FALSE, indicating that the repeater was not closed successfully.\n*/\nstatic gboolean removeRepeater(gpointer data) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int SDL_setFramerate(FPSmanager * manager, Uint32 rate)\n{\n    if ((rate >= FPS_LOWER_LIMIT) && (rate <= FPS_UPPER_LIMIT))\n    {\n        manager->framecount = 0;\n        manager->rate = rate;\n        manager->rateticks = (1000.0F / static_cast<float>(rate));\n        return (0);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n",
        "answer": "/** @brief Sets a new framerate for the manager and reset delay interpolation. Rate values must be between FPS_LOWER_LIMIT and FPS_UPPER_LIMIT inclusive to be accepted.\n*\n*  This function sets a new framerate for the manager and resets the delay interpolation. The rate value must be within the range of FPS_LOWER_LIMIT and FPS_UPPER_LIMIT, inclusive. If the rate is not within this range, the function returns -1.\n*\n* @param manager A pointer to the FPSmanager struct.\n* @param rate The new framerate value.\n* @return 0 if successful, -1 otherwise.\n*/\nint SDL_setFramerate(FPSmanager * manager, Uint32 rate)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, char *argv[])\n{\n\tQApplication a(argc, argv);\n\tMainWindow w;\n\tw.show();\n\treturn a.exec();\n}\n",
        "answer": "/** @brief Main entrypoint for the program.\n*\n*  This is the main entrypoint for the program, it initializes the QApplication and shows the main window.\n*\n* @param argc The number of command line arguments passed to the program.\n* @param argv An array of strings containing the command line arguments.\n* @return The exit code of the program.\n*/\nint main(int argc, char *argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool fgSetBool(char const * name, bool val) { return false; }\n",
        "answer": "/** @brief Set a bool value for a property.\n*\n*  Assign a bool value to a property. If the property does not yet exist, it will be created and its type will be set to BOOL; if it has a type of UNKNOWN, the type will also be set to BOOL; otherwise, the bool value will be converted to the property's type.\n*\n* @param name The name of the property to set.\n* @param val The bool value to assign to the property.\n* @return True if the operation was successful, false otherwise.\n*/\nbool fgSetBool(char const * name, bool val) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool fgSetDouble (const char * name, double defaultValue) { return false; }\n",
        "answer": "/** @brief Set a double value for a property.\n*\n*  Assign a double value to a property. If the property does not yet exist, it will be created and its type will be set to DOUBLE; if it has a type of UNKNOWN, the type will also be set to DOUBLE; otherwise, the double value will be converted to the property's type.\n*\n* @param name The name of the property to set.\n* @param defaultValue The double value to assign to the property.\n* @return True if the operation was successful, false otherwise.\n*/\nbool fgSetDouble (const char * name, double defaultValue) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool getSwitch00( int8_t swtch )\n{\n\treturn getSwitch( swtch, 0, 0 ) ;\n}\n",
        "answer": "/** @brief Gets the state of a switch.\n*\n* This function returns the state of a switch based on its number. The numbers are as follows: 1=SW_ON, 2=SW_ThrCt, 10=SW_Trainer. 0 means not connected. Negative values produce inverted results. The putsDrSwitches(..) function creates the appropriate expression.\n* @param swtch The number of the switch to get the state for.\n* @return The state of the switch.\n*/\nbool getSwitch00( int8_t swtch )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void GrepStream(std::istream& stream, const Pire::Scanner& sc, const std::string& prefix)\n{\n    std::string line;\n    while (getline(stream, line)) {\n        if (Pire::Runner(sc).Begin().Run(line).End())\n            std::cout << prefix << line << std::endl;\n    }\n}\n",
        "answer": "/** @brief GrepStream is a function that takes in an input stream, a scanner object, and a string prefix. It then uses the getline() function to read each line from the input stream and checks if it matches the given regexp using the Pire::Runner class. If it does, it prints out the line with the specified prefix.\n*\n* @param stream The input stream to be searched for matching lines.\n* @param sc The Pire::Scanner object that contains the regular expression pattern to search for.\n* @param prefix The string to be printed before each matching line.\n* @return void\n*/\nvoid GrepStream(std::istream& stream, const Pire::Scanner& sc, const std::string& prefix)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   virtual raft::kstatus run()\n   {\n      fprintf( stdout, \"source processing frame %\" PRIu64 \"\\n\", counter++ );\n      auto &img_in( input[ \"0\" ].template peek< T >() );\n      auto &out( output[ \"0\" ].template allocate< T >() );\n      cv::cvtColor( img_in, \n                    out, \n                    CV_BGR2GRAY );\n      cv::blur(     out, \n                    out, \n                    cv::Size( 3, 3) );\n      cv::Canny( img_in, \n                 out, \n                 thresh, \n                 thresh * 2, \n                 3 \n           );\n\n      input[ \"0\" ].unpeek();\n      input[ \"0\" ].recycle( 1 );\n      output[ \"0\" ].send();\n      return( raft::proceed );\n   }\n",
        "answer": "/**\n* @brief Runs the kernel.\n*\n* This function is called by the scheduler to execute the kernel. It performs the necessary operations on the input and output images, and then sends the output image back to the scheduler.\n*\n* @return raft::kstatus The status of the kernel execution.\n*/\nvirtual raft::kstatus run()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual raft::kstatus run()\n    {\n        SomeNonTrivialObject test;\n        input[ \"in\" ].pop( test );\n        /** ok, let's see if we get all one's or something else **/\n        if( (*test.value) == std::numeric_limits< std::int64_t >::max() )\n        {\n            global_bool = true;\n        }\n        else\n        {\n            global_bool = false;\n        }\n        return( raft::proceed );\n    }\n",
        "answer": "/**\n* @brief Virtual run function.\n*\n* This function is called by the scheduler to execute the task.\n* It should be overridden by derived classes to provide specific behavior.\n*\n* @return raft::kstatus The status of the task after execution.\n*/\n/** ok, let's see if we get all one's or something else **/\nif( (*test.value) == std::numeric_limits< std::int64_t >::max() )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n{\n    const char* pszTimestamp = \"GST Roll out From July 1\";\n    const CScript genesisOutputScript = CScript() << ParseHex(\"04c6387a96bae5d94ad0c153f65967784240da6bd437f336ff5a7a6660941b3275df218db45c755b7297fd3f20c70e58d919aec798e9c10493463abd7fa6557786\") << OP_CHECKSIG;\n    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n}\n",
        "answer": "/** @brief Creates the genesis block.\n*\n*  This function builds the genesis block for the blockchain. The output of its generation transaction cannot be spent since it did not originally exist in the database.\n*\n* @param nTime Timestamp of when the block was created.\n* @param nNonce Nonce used to generate the block.\n* @param nBits Difficulty target for the block.\n* @param nVersion Version number for the block.\n* @param genesisReward Reward given to the miner who solved the proof-of-work puzzle.\n* @return The created genesis block.\n*/\nstatic CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool unitCanAttack(const CUnit *unit) {\r\n  if (unit->id == UnitId::lurker) {\r\n    if (unit->status & UnitStatus::Burrowed\r\n        && Unit::GroundWeapon[unit->id] != WeaponId::None)\r\n      return true;\r\n  }\r\n  else if (unit->id == UnitId::carrier || unit->id == UnitId::gantrithor) {\r\n    if ((unit->carrier.inHangarCount + unit->carrier.outHangarCount) > 0)\r\n      return true;\r\n  }\r\n  else if (unit->id == UnitId::reaver || unit->id == UnitId::warbringer) {\r\n    if (unit->carrier.inHangarCount > 0)\r\n      return true;\r\n  }\r\n  else {\r\n    if (Unit::GroundWeapon[unit->id] != WeaponId::None\r\n        || Unit::AirWeapon[unit->id] != WeaponId::None)\r\n      return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Checks whether a unit can attack.\n*\n*  This function checks whether a unit has a means of attacking, taking into account the unit's type and status.\n*  For carriers and reavers, it checks whether they have scarabs or interceptors available in their hangars.\n*  For lurkers, it checks whether they are burrowed and have a ground weapon.\n*  For all other units, it checks whether they have a ground or air weapon.\n*\n* @param unit The unit to check for attack capabilities.\n* @return True if the unit can attack, false otherwise.\n*/\nbool unitCanAttack(const CUnit *unit) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "s32 getPolarX(s32 distance, u8 angle) {\r\n  return distance * angleDistance[angle].x >> 8;\r\n}\r\n",
        "answer": "/** @brief Calculates the X Cartesian coordinate from the given polar coordinates (distance, angle), using StarCraft's internal data.\n*\n* @param distance The distance in pixels from the origin to the point.\n* @param angle The angle in degrees of the point from the positive x-axis.\n* @return The X Cartesian coordinate of the point.\n*/\ns32 getPolarX(s32 distance, u8 angle) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void refreshConsole() {\r\n  u32*  const bCanUpdateCurrentButtonSet      = (u32*)  0x0068C1B0;\r\n  u8*   const bCanUpdateSelectedUnitPortrait  = (u8*)   0x0068AC74;\r\n  u8*   const bCanUpdateStatDataDialog        = (u8*)   0x0068C1F8;\r\n  u32*  const someDialogUnknown               = (u32*)  0x0068C1E8;\r\n  u32*  const unknown2                        = (u32*)  0x0068C1EC;\r\n\r\n  *bCanUpdateCurrentButtonSet = 1;\r\n  *bCanUpdateSelectedUnitPortrait = 1;\r\n  *bCanUpdateStatDataDialog = 1;\r\n  *someDialogUnknown = 0;\r\n  *unknown2 = 0;\r\n}\r\n",
        "answer": "/** @brief Refreshes the StarCraft console.\n*\n*  This function tells StarCraft to refresh the console, including the current button set, unit portrait, and status bar.\n*\n* @param bCanUpdateCurrentButtonSet A pointer to a u32 value that indicates whether the current button set can be updated.\n* @param bCanUpdateSelectedUnitPortrait A pointer to a u8 value that indicates whether the selected unit portrait can be updated.\n* @param bCanUpdateStatDataDialog A pointer to a u8 value that indicates whether the stat data dialog can be updated.\n* @param someDialogUnknown A pointer to a u32 value that is related to an unknown dialog.\n* @param unknown2 A pointer to a u32 value that is related to an unknown functionality.\n*/\n*bCanUpdateCurrentButtonSet = 1;\n*bCanUpdateSelectedUnitPortrait = 1;\n*bCanUpdateStatDataDialog = 1;\n*someDialogUnknown = 0;\n*unknown2 = 0;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void applySparseConditionalConstantPropagation(\n    IRModule*       module)\n{\n    SharedSCCPContext shared;\n    shared.module = module;\n    shared.sharedBuilder.module = module;\n    shared.sharedBuilder.session = module->getSession();\n\n    applySparseConditionalConstantPropagationRec(&shared, module->getModuleInst());\n}\n",
        "answer": "/** @brief Apply Sparse Conditional Constant Propagation (SCCP) to a module.\n* This optimization replaces instructions that can only ever evaluate to a single (well-defined) value with that constant value, and also eliminates conditional branches where the condition will always evaluate to a constant (which can lead to entire blocks becoming dead code).\n* @param[in] module The module to apply SCCP to.\n*/\nvoid applySparseConditionalConstantPropagation(IRModule* module) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SLANG_API size_t spReflectionType_GetElementCount(SlangReflectionType* inType)\n{\n    auto type = convert(inType);\n    if(!type) return 0;\n\n    if(auto arrayType = as<ArrayExpressionType>(type))\n    {\n        return arrayType->ArrayLength ? (size_t) GetIntVal(arrayType->ArrayLength) : 0;\n    }\n    else if( auto vectorType = as<VectorExpressionType>(type))\n    {\n        return (size_t) GetIntVal(vectorType->elementCount);\n    }\n\n    return 0;\n}\n",
        "answer": "/** @brief Returns the number of elements in a given type.\n*\n* This function returns the number of elements in a vector or array type, and zero for other types. If the size of a type cannot be statically computed, this function returns zero.\n*\n* @param[in] inType The type to get the element count for.\n* @return The number of elements in the given type.\n*/\nSLANG_API size_t spReflectionType_GetElementCount(SlangReflectionType* inType)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hdfsFreeBuilder(struct hdfsBuilder * bld) {\n    delete bld;\n}\n",
        "answer": "/** @brief Free an HDFS builder.\n*\n*  This function frees the memory allocated for an HDFS builder. It is normally not necessary to call this function since hdfsBuilderConnect frees the builder.\n*\n* @param[in] bld The HDFS builder to be freed.\n* @return None.\n*/\nvoid hdfsFreeBuilder(struct hdfsBuilder * bld) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void DTK_applyMap( DTK_MapHandle handle, const char *source_field,\n                   const char *target_field )\n{\n    if ( !DTK_isValidMap( handle ) )\n    {\n        errno = DTK_INVALID_HANDLE;\n        return;\n    }\n\n    reinterpret_cast<DataTransferKit::DTK_Map *>( handle )->apply(\n        std::string( source_field ), std::string( target_field ) );\n\n    errno = DTK_SUCCESS;\n}\n",
        "answer": "/**\n* @brief Applies a map to transfer data from a source user application to a target user application.\n*\n* This function transfers the data from the source user application to the target user application. The fields transferred by this function are indicated by their given names. In practice, an application could implement their field function callbacks to handle multiple fields, thereby allowing the same map instance to transfer many different fields based on the field name.\n*\n* @param handle A valid DTK_MapHandle that represents a map.\n* @param source_field The name of the source field.\n* @param target_field The name of the target field.\n*\n* @return Should not return.\n*/\nvoid DTK_applyMap(DTK_MapHandle handle, const char* source_field, const char* target_field);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   virtual void serviceRequest(\n      HttpRequest* request, HttpResponse* response)\n   {\n      response->getHeader()->setStatus(204, \"No Content\");\n      response->getHeader()->setField(\"Content-Length\", 0);\n      response->getHeader()->setField(\"Connection\", \"close\");\n      response->sendHeader();\n      mPingPong->quit();\n   }\n",
        "answer": "/** @brief Services the passed HttpRequest.\n*\n*  This function services the passed HttpRequest. The header for the request has already been received, but the body has not. The HttpResponse object is used to send an appropriate response, if necessary, according to the servicer's specific implementation.\n*\n* @param[in] request The HttpRequest object to be serviced.\n* @param[out] response The HttpResponse object used to send a response, if necessary.\n*\n* @return void\n*/\nvoid serviceRequest(HttpRequest* request, HttpResponse* response)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   virtual void mutatePostExecutionState(Operation& op)\n   {\n      TestState* state = static_cast<TestState*>(op->getUserData());\n      --state->ops;\n      if(mLogout)\n      {\n         state->loggedOut = true;\n#ifdef DEBUG_ON\n         printf(\"Logged out.\\n\");\n#endif\n      }\n   }\n",
        "answer": "/** @brief Mutate post-execution state.\n*\n*  This function alters the current state directly after an Operation finishes or was canceled. The passed Operation may be checked to see if it finished or was canceled, etc.\n*\n* @param op The operation that has finished or been canceled.\n*/\nvirtual void mutatePostExecutionState(Operation& op)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_to_string(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<class value> value;\n\n    if (!ctx->pop(value))\n    {\n      return;\n    }\n    else if (value)\n    {\n      ctx->push_string(value->to_string());\n    } else {\n      ctx->push_string(U\"\");\n    }\n  }\n",
        "answer": "/** @brief Converts the topmost value of the stack into a string. Null will become an empty string.\n*\n*  This function converts the topmost value of the stack into a string. If the value is null, it will be converted to an empty string.\n*\n* @param ctx A shared pointer to the context object.\n*/\nstatic void w_to_string(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_type_error(const std::shared_ptr<context>& ctx)\n  {\n    make_error(ctx, error::code::type);\n  }\n",
        "answer": "/** @brief Construct an instance of type error with given optional error message and places it on the stack.\n*\n* This function creates a new instance of type error with the given optional error message and places it on the stack.\n*\n* @param ctx The context in which to construct the error object.\n* @return Should not return\n*/\nstatic void w_type_error(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_emit(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<number> num;\n\n    if (ctx->pop_number(num))\n    {\n      number::int_type c = num->as_int();\n\n      if (!unicode_validate(c))\n      {\n        ctx->error(error::code::range, U\"Invalid Unicode code point.\");\n      } else {\n        ctx->runtime()->print(std::u32string(1, static_cast<char32_t>(c)));\n      }\n    }\n  }\n",
        "answer": "/** @brief Emit a Unicode code point into the standard output stream.\n*\n* This function emits the given Unicode code point into the standard output stream. If the given number is not a valid Unicode code point, a range error will be thrown.\n*\n* @param ctx The context in which to emit the code point.\n*/\nstatic void w_emit(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_find(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<array> ary;\n    std::shared_ptr<quote> quo;\n\n    if (ctx->pop_array(ary) && ctx->pop_quote(quo))\n    {\n      ctx->push(ary);\n      for (const auto& element : ary)\n      {\n        bool result;\n\n        ctx->push(element);\n        if (!quo->call(ctx) || !ctx->pop_boolean(result))\n        {\n          return;\n        }\n        else if (result)\n        {\n          ctx->push(element);\n          return;\n        }\n      }\n      ctx->push_null();\n    }\n  }\n",
        "answer": "/** @brief Finds the first element in an array that satisfies a given testing quote.\n*\n* This function takes an array and a quote as input, and returns the first element from the array that satisfies the provided testing quote. If no such element is found, null is returned.\n*\n* @param ctx The context object used to store the array and quote.\n* @return The first element in the array that satisfies the testing quote, or null if no such element is found.\n*/\nstatic void w_find(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_flatten(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<array> ary;\n\n    if (ctx->pop_array(ary))\n    {\n      std::vector<std::shared_ptr<value>> result;\n\n      result.reserve(ary->size());\n      do_flatten(ary, result);\n      ctx->push_array(result.data(), result.size());\n    }\n  }\n",
        "answer": "/** @brief Flattens a nested array into a new array with all sub-array elements concatenated into it recursively.\n*\n*  This function creates a new array with all sub-array elements concatenated into it recursively. It takes a const reference to a shared pointer of type context as an argument and returns void.\n*\n* @param ctx A const reference to a shared pointer of type context.\n* @return Void.\n*/\nstatic void w_flatten(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_reduce(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<class array> array;\n    std::shared_ptr<class quote> quote;\n    std::shared_ptr<value> result;\n    array::size_type size;\n\n    if (!ctx->pop_array(array) || !ctx->pop_quote(quote))\n    {\n      return;\n    }\n\n    size = array->size();\n\n    if (size == 0)\n    {\n      ctx->error(error::code::range, U\"Cannot reduce empty array.\");\n      return;\n    }\n\n    result = array->at(0);\n\n    for (array::size_type i = 1; i < size; ++i)\n    {\n      ctx->push(result);\n      ctx->push(array->at(i));\n      if (!quote->call(ctx) || !ctx->pop(result))\n      {\n        return;\n      }\n    }\n\n    ctx->push(result);\n  }\n",
        "answer": "/** @brief Reduces an array into a single value using a given quote.\n*\n*  This function applies the given quote against an accumulator and each element in the array to reduce it into a single value.\n*\n* @param ctx The context of the function call.\n* @return Should not return.\n*/\nstatic void w_reduce(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_gte(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<number> a;\n    std::shared_ptr<number> b;\n\n    if (ctx->pop_number(b) && ctx->pop_number(a))\n    {\n      if (a->is(number::number_type::real) || b->is(number::number_type::real))\n      {\n        ctx->push_boolean(a->as_real() >= b->as_real());\n      } else {\n        ctx->push_boolean(a->as_int() >= b->as_int());\n      }\n    }\n  }\n",
        "answer": "/** @brief Checks if the first number is greater than or equal to the second one.\n*\n*  This function checks if the first number is greater than or equal to the second one.\n*\n* @param ctx The context in which the function is called.\n*\n* @return Returns true if the first number is greater than or equal to the second one, false otherwise.\n*/\nstatic void w_gte(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_get(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<object> obj;\n    std::shared_ptr<string> id;\n\n    if (ctx->pop_object(obj) && ctx->pop_string(id))\n    {\n      std::shared_ptr<value> val;\n\n      ctx->push(obj);\n      if (obj->property(ctx->runtime(), id->to_string(), val))\n      {\n        ctx->push(val);\n      } else {\n        ctx->error(\n          error::code::range,\n          U\"No such property: `\" + id->to_string() + U\"'\"\n        );\n      }\n    }\n  }\n",
        "answer": "/** @brief Retrieves the value identified by given string from properties of the object. If the object does not have such a property, range error will be thrown. Notice that inherited properties are also included in the search.\n*\n*  This function retrieves the value identified by the given string from the properties of the object. If the object does not have such a property, a range error will be thrown. Notice that inherited properties are also included in the search.\n*\n* @param ctx The context in which to retrieve the value.\n* @return Should return the value if it exists, or throw an error if it doesn't.\n*/\nstatic void w_get(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_negate(const std::shared_ptr<context>& ctx)\n  {\n    const auto& runtime = ctx->runtime();\n    std::shared_ptr<quote> quo;\n\n    if (ctx->pop_quote(quo))\n    {\n      ctx->push_quote({\n        quo,\n        runtime->symbol(U\"call\"),\n        runtime->symbol(U\"not\")\n      });\n    }\n  }\n",
        "answer": "/** @brief negate Prototype: quote Constructs a negated version of given quote which negates the boolean result returned by the original quote.\n*\n* This is the description of the functionality of the function.\n*\n* @param ctx The context in which the function is called.\n*/\nstatic void w_negate(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_is_lower_case(const std::shared_ptr<context>& ctx)\n  {\n    str_test(ctx, unicode_islower);\n  }\n",
        "answer": "/** @brief Tests whether the string contains only lower case characters. Empty strings return false.\n*\n* This is the description of the functionality of the function.\n*\n* @param ctx The context object for the test.\n* @return Should not return\n*/\nstatic void w_is_lower_case(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_capitalize(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<string> str;\n\n    if (ctx->pop_string(str))\n    {\n      const auto length = str->length();\n      char32_t output[length];\n\n      for (string::size_type i = 0; i < length; ++i)\n      {\n        auto c = str->at(i);\n\n        if (i == 0)\n        {\n          c = unicode_toupper(c);\n        } else {\n          c = unicode_tolower(c);\n        }\n        output[i] = c;\n      }\n      ctx->push_string(output, length);\n    }\n  }\n",
        "answer": "/** @brief Capitalizes the first character of a string and converts the remaining characters to lower case.\n*\n*  This function takes a shared pointer to a context object as its parameter. It then pops a string from the context using the `pop_string` method, and if successful, it capitalizes the first character of the string and converts the remaining characters to lower case using the `unicode_toupper` and `unicode_tolower` functions. Finally, it pushes the resulting string back onto the context using the `push_string` method.\n*\n* @param ctx A shared pointer to a context object.\n*/\nstatic void w_capitalize(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static void w_quote(const std::shared_ptr<context>& ctx)\n  {\n    std::shared_ptr<word> wrd;\n\n    if (ctx->pop_word(wrd))\n    {\n      ctx->push(wrd);\n      ctx->push(wrd->quote());\n    }\n  }\n",
        "answer": "/** @brief Extracts quote which acts as the body of the word and places it onto top of the stack.\n*\n* This function extracts the quote from a word and places it on top of the stack.\n* It first pops the word from the context, then checks if the word is valid. If the word is valid, it pushes the word onto the stack and then pushes the quote onto the stack.\n*\n* @param ctx The context in which the function is executed.\n*\n* @return void\n*/\nstatic void w_quote(const std::shared_ptr<context>& ctx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    bio::filtering_istream fis;\n    {\n        bio::zlib_params p;\n        p.window_bits |= 16;\n        fis.push(bio::zlib_decompressor(p));\n    }\n    fis.push(std::cin);\n    fis.exceptions(std::ios::badbit | std::ios::failbit);\n\n    bio::copy(fis, std::cout);\n    std::cout.flush();\n\n    return EXIT_SUCCESS;\n}\n",
        "answer": "/** @brief Main entrypoint of the program.\n*\n*  This is the main entrypoint of the program, where the program starts executing.\n*  It sets up the input and output streams, and then calls the `bio::copy` function to copy the data from the input stream to the output stream.\n*  Finally, it flushes the output stream and returns a success exit code.\n*\n* @return EXIT_SUCCESS if the program exits successfully, or an error code otherwise.\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid OnSelected( wxObject* wxobject )\n\t{\n\t\tBookUtils::OnSelected< wxAuiNotebook >( wxobject, GetManager() );\n\t}\n",
        "answer": "/** @brief Allows components to respond when selected in object tree. For example, when a wxNotebook's page is selected, it can switch to that page.\n*\n* This function allows components to respond when they are selected in the object tree. It takes a wxObject as an argument and uses the BookUtils::OnSelected template function to handle the selection event. The GetManager() function is used to retrieve the manager for the component.\n*\n* @param wxobject The wxObject that was selected.\n*\n* @return void\n*/\nvoid OnSelected(wxObject* wxobject) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid OnCreated( wxObject* wxobject, wxWindow* wxparent )\n\t{\n\t\tBookUtils::OnCreated< wxNotebook >( wxobject, wxparent, GetManager(), _(\"NotebookPageComponent\") );\n\t}\n",
        "answer": "/** @brief Allows components to do something after they have been created. For example, Abstract components like NotebookPage and SizerItem can add the actual widget to the Notebook or sizer.\n*\n* @param wxobject The wxObject that was created.\n* @param wxparent The parent of the wxObject that was created.\n* @return void\n*/\nvoid OnCreated( wxObject* wxobject, wxWindow* wxparent )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid OnCreated( wxObject* wxobject, wxWindow* wxparent )\n\t{\n\t\tIObject* obj = GetManager()->GetIObject( wxobject );\n\t\twxTreeListCtrl* treeList = wxDynamicCast( wxparent, wxTreeListCtrl );\n\n\t\tif ( !( obj && treeList ) )\n\t\t{\n\t\t\twxLogError( _(\"wxcoreTreeListCtrlColumnComponent is missing its wxFormBuilder object(%i) or its parent(%i)\"), obj,treeList );\n\t\t\treturn;\n\t\t}\n\n\t\ttreeList->AppendColumn( obj->GetPropertyAsString( _(\"name\") ),\n\t\t\tobj->GetPropertyAsInteger( _(\"width\") ),\n\t\t\tstatic_cast< wxAlignment >( obj->GetPropertyAsInteger( _(\"alignment\") ) ),\n\t\t\tobj->GetPropertyAsInteger( _(\"flag\") ) );\n\t}\n",
        "answer": "/** @brief Called after a component has been created.\n*\n*  This function is called by wxFormBuilder after a component has been created. It allows components to do something after they have been created, such as adding the actual widget to the Notebook or sizer.\n*\n*  @param wxobject The wxObject that was created.\n*  @param wxparent The parent of the wxObject that was created.\n*/\nvoid OnCreated(wxObject* wxobject, wxWindow* wxparent) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int detour_chain(const char *dll_name, int return_old_ptrs, ...)\n{\n\tint ret = 0;\n\tjson_t *dll = detour_get_create(dll_name);\n\tconst char *func_name = NULL;\n\tva_list va;\n\n\tva_start(va, return_old_ptrs);\n\twhile(func_name = va_arg(va, const char*)) {\n\t\tFARPROC *old_ptr = NULL;\n\t\tFARPROC chain_ptr;\n\t\tconst void *func_ptr = va_arg(va, const void*);\n\t\tif(\n\t\t\treturn_old_ptrs\n\t\t\t&& (old_ptr = va_arg(va, FARPROC*))\n\t\t\t&& (chain_ptr = (FARPROC)json_object_get_hex(dll, func_name))\n\t\t\t&& (chain_ptr != func_ptr)\n\t\t) {\n\t\t\t*old_ptr = chain_ptr;\n\t\t}\n\t\tjson_object_set_new(dll, func_name, json_integer((size_t)func_ptr));\n\t}\n\tva_end(va);\n\treturn ret;\n}\n",
        "answer": "/** @brief Detour chain function.\n*\n*  This function is used to create a detour chain for a given DLL and function name.\n*  It takes in the DLL name, a flag indicating whether or not to return old pointers,\n*  and a variable number of arguments that consist of pairs of function names and pointers.\n*  For each pair, it sets the function pointer for the given function name to the provided pointer,\n*  and if the return_old_ptrs flag is set, it also returns the previous function pointer in the chain.\n*\n* @param dll_name The name of the DLL to detour.\n* @param return_old_ptrs A flag indicating whether or not to return old pointers.\n* @param ... A variable number of arguments consisting of pairs of function names and pointers.\n* @return Should not return.\n*/\n*old_ptr = chain_ptr;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BOOL WINAPI tsa_GetWindowRect(\n\tHWND hWnd,\n\tLPRECT lpRect\n)\n{\n\tBOOL ret;\n\tWINDOWPLACEMENT wp;\n\tif(!lpRect) {\n\t\treturn FALSE;\n\t}\n\tZeroMemory(&wp, sizeof(WINDOWPLACEMENT));\n\twp.length = sizeof(WINDOWPLACEMENT);\n\tret = GetWindowPlacement(hWnd, &wp);\n\tmemcpy(lpRect, &wp.rcNormalPosition, sizeof(RECT));\n\treturn ret;\n}\n",
        "answer": "/** @brief A function that replaces the functionality of GetWindowRect() with GetWindowPlacement().\n*\n*  This function is used to store the current position of a game window in its configuration file. The next time the game is started, this position is used as the parameter for CreateWindowEx(). The best solution seems to be replacing GetWindowRect() with GetWindowPlacement(), which always reports the expected window coordinates, even when the window in question is minimized.\n*\n* @param hWnd A handle to the window that will have its rectangle retrieved.\n* @param lpRect A pointer to a RECT structure that will receive the screen coordinates of the upper-left and lower-right corners of the window.\n*\n* @return TRUE if the function succeeds, FALSE otherwise.\n*/\nBOOL WINAPI tsa_GetWindowRect("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Usage()\n\n{\n    printf( \"Usage: compositor --help --help-general\\n\" );\n    printf( \"         [-j control.json]\\n\" );\n    printf( \"         -o output_file [-st source_trace_file] [-qo quality]\\n\" );\n    printf( \"         [-s name value]* [-q] [-v] [-dp pixel line]\\n\" );\n    printf( \"         [-i input_file [-c cloudmask] [-qm name value]*]*\\n\" );\n    exit(1);\n}\n",
        "answer": "/**\n* @brief Prints usage information and exits.\n*\n* This function prints a message to standard output with information about the\n* command-line arguments accepted by the program, and then exits with status 1.\n*/\nvoid Usage() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LCSDeleteFile(const char* filename,int flags)\n{\n   if(!initialized)\n   {\n      LCSInitHomeDir();\n      LCSInitArtDir();\n      initialized=true;\n   }\n\n   std::string str;\n\n   if(flags & LCSIO_PRE_ART)\n      str.append(artdir);\n   else if(flags & LCSIO_PRE_HOME)\n      str.append(homedir);\n\n   str.append(filename);\n\n   remove(str.c_str());\n}\n",
        "answer": "/**\n* @brief Deletes a file.\n*\n* This function unlinks the filename you specify. You may use prefix flags to delete files in other directories. Do not try to delete files in the art directory.\n*\n* @param filename Name of file to delete.\n* @param flags Prefix flags. See enum LCSIO_FLAGS.\n*\n* @return False on error, true if no error.\n*/\nvoid LCSDeleteFile(const char* filename, int flags)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void set_translation(float xoff, float yoff) {\n    stage_matrix.set_translation(xoff, yoff);\n  }\n",
        "answer": "/** @brief Sets the x/y offset for the movie in pixels.\n*\n* This applies to all graphics drawn except the background, which must be drawn for the entire canvas, regardless of the translation.\n*\n* @param xoff The x-offset in pixels.\n* @param yoff The y-offset in pixels.\n*/\nvoid set_translation(float xoff, float yoff) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dump_ctrl(void *inmem)\n{\n    Shm *ptr = static_cast<Shm *>(inmem);\n    \n    cerr << _(\"\\tBase address of this segment: \")\n         << static_cast<void *>(ptr->getAddr()) << endl;\n    cerr << _(\"\\tFilespec: \") << ptr->getName() << endl;\n    cerr << _(\"\\t# Bytes allocated: \") << ptr->getAllocated() << endl;\n    cerr << _(\"\\tTotal # of bytes: \") << ptr->getSize() << endl;\n}\n",
        "answer": "/** @brief Dumps the internal data of the found ShmControl block.\n*\n*  This function dumps the internal data of the found ShmControl block, rather than letting ShmControl::dump() do it, cause that's for debugging, and this is for user display purposes.\n*\n* @param inmem A pointer to the memory location where the ShmControl block is located.\n*/\nvoid dump_ctrl(void *inmem)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void tearDown()\n        {\n            delete _acceptor;\n        }\n",
        "answer": "/** @brief Tear down function.\n*\n*  This function is called after each registered tester function is invoked. It is meant to remove any resources previously initialized in TestSuite::setUp.\n*\n* @return Should not return\n*/\nvoid tearDown()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void namesAdd(plotstring addname) {\n  long bucket = namesGetBucket(addname);\n  namenode *hp, *temp;\n\n  temp = hashp[bucket];\n  hashp[bucket] = (namenode *)Malloc(sizeof(namenode));\n  hp = hashp[bucket];\n  strcpy(hp->naym, addname);\n  hp->next = temp;\n  hp->hitCount = 0;\n}\n",
        "answer": "/** @brief Add a name to the hash table.\n*\n* This function adds a name to the hash table, at the head of the appropriate linked list. No checking is done for duplicates. The caller can call namesSearch to check for an existing name prior to calling namesAdd.\n*\n* @param addname The name to be added to the hash table.\n* @return None.\n*/\nvoid namesAdd(plotstring addname) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void setParameter (int index, float newValue)\n    {\n        if (plugin != nullptr && isPositiveAndBelow (index, parameters.size()))\n        {\n            const ScopedLock sl (lock);\n\n            ParameterValue& p = parameterValues[index];\n\n            if (p.unscaled != newValue)\n                p = ParameterValue (getNewParamScaled (plugin->PortRangeHints [parameters[index]], newValue), newValue);\n        }\n    }\n",
        "answer": "/** @brief Set the value of a parameter.\n*\n*  This method sets the value of one of the processor's parameters. The host may call this at any time, including during the audio processing callback, so the processor has to process this very fast and avoid blocking. The value passed will be between 0 and 1.0.\n*\n* @param index The index of the parameter to set.\n* @param newValue The new value for the parameter.\n*/\nvoid setParameter (int index, float newValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    static bool getAllDescriptionsForFile (OwnedArray<PluginDescription>& results,\n                                           const String& fileOrIdentifier)\n    {\n        DLLHandle tempModule (fileOrIdentifier);\n\n        ComSmartPtr<IPluginFactory> pluginFactory (tempModule.getPluginFactory());\n\n        if (pluginFactory != nullptr)\n        {\n            ComSmartPtr<VST3HostContext> host (new VST3HostContext());\n            DescriptionLister lister (host, pluginFactory);\n            auto result = lister.findDescriptionsAndPerform (File (fileOrIdentifier));\n\n            results.addCopiesOf (lister.list);\n\n            return result.wasOk();\n        }\n\n        jassertfalse;\n        return false;\n    }\n",
        "answer": "* Here is the Doxygen comment for the function `getAllDescriptionsForFile`:\n/** @brief Gets all descriptions for a file.\n*\n*  This function retrieves all descriptions for a given file or identifier. It first creates a temporary module using the provided file or identifier, and then uses this module to get the plugin factory. If the plugin factory is not nullptr, it creates a new VST3 host context and description lister, and uses these objects to find and perform the descriptions for the given file. The results are added to the `results` array, and the function returns true if the operation was successful.\n*\n* @param results An owned array of plugin descriptions that will be filled with the results of the function.\n* @param fileOrIdentifier A string containing the file or identifier for which to retrieve the descriptions.\n* @return True if the operation was successful, false otherwise.\n*/\nstatic bool getAllDescriptionsForFile (OwnedArray<PluginDescription>& results, const String& fileOrIdentifier)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n{\n    return new SimpleEqualizerAudioProcessor();\n}\n",
        "answer": "/** @brief Creates a new instance of the filter subclass.\n*\n* This function is used to implement the plugin's filter and make it return a new instance of the filter subclass that you're building.\n*\n* @return A new instance of the SimpleEqualizerAudioProcessor class.\n*/\nAudioProcessor* JUCE_CALLTYPE createPluginFilter()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool shouldPerformDirection(\n    const DirectionSymbol &symbol,\n    DirectionSymbol::ActiveSymbolType activeSymbol, int activeRepeat)\n{\n    return (symbol.getActiveSymbolType() == DirectionSymbol::ActiveNone ||\n            symbol.getActiveSymbolType() == activeSymbol) &&\n           symbol.getSymbolType() >= DirectionSymbol::Fine &&\n           (symbol.getRepeatNumber() == 0 ||\n            symbol.getRepeatNumber() == activeRepeat);\n}\n",
        "answer": "/** @brief Determines whether a direction should be performed, based on the active symbol and repeat number.\n*\n*  If the direction's activation symbol is None, it will always be able to activate regardless of the currently active symbol.\n*\n* @param[in] symbol The direction symbol to check.\n* @param[in] activeSymbol The currently active symbol.\n* @param[in] activeRepeat The repeat number for the currently active symbol.\n* @return Whether the direction should be performed.\n*/\nstatic bool shouldPerformDirection(const DirectionSymbol &symbol, DirectionSymbol::ActiveSymbolType activeSymbol, int activeRepeat)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void createLowLevelImpl(void) {}\n",
        "answer": "/** @brief Internal method for creating an appropriate low-level program from this high-level program, must be implemented by subclasses.\n*\n*  This method is used to create a low-level program that can be executed by the operating system. It must be implemented by subclasses of the `createLowLevelImpl` function.\n*\n* @return Should not return\n*/\nvoid createLowLevelImpl(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void serialboxStateErrorHandler(const char* reason) {\n  internal::errorState.hasError = true;\n  internal::errorState.errMsg = reason;\n}\n",
        "answer": "/** @brief Store the current state of the error which can be queried via serialboxStateErrorHandlerGetLastError.\n*\n* This function stores the current state of the error and makes it available for querying via the serialboxStateErrorHandlerGetLastError function.\n*\n* @param reason The reason for the error.\n*/\nvoid serialboxStateErrorHandler(const char* reason) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void bufferWrite(char *buf, int position, uint16_t val)\n{\n\tbuf[position]     = (char)(val & 0xFF);\n\tbuf[position + 1] = (char)(val >> 8);\n}\n",
        "answer": "/** @brief Writes a uint16_t value to a buffer at the specified position.\n*\n* This function writes a uint16_t value to a buffer at the specified position.\n* The value is written in little-endian byte order, with the least significant byte first.\n*\n* @param buf The buffer to write to.\n* @param position The position in the buffer where the value should be written.\n* @param val The uint16_t value to write.\n*/\ninline void bufferWrite(char *buf, int position, uint16_t val)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class RepeatNode : public DecoratorNode\n{\n  public:\n\n    RepeatNode(const std::string& name, unsigned int NTries);\n\n    RepeatNode(const std::string& name, const NodeConfiguration& config);\n\n    virtual ~RepeatNode() override = default;\n\n    static PortsList providedPorts()\n    {\n        return { InputPort<unsigned>(NUM_CYCLES, \"Repeat a succesful child up to N times\") };\n    }\n\n  private:\n    unsigned num_cycles_;\n    unsigned try_index_;\n\n    bool read_parameter_from_ports_;\n    static constexpr const char* NUM_CYCLES = \"num_cycles\";\n\n    virtual NodeStatus tick() override;\n\n    void halt() override;\n};\n",
        "answer": "/**\n* @brief A decorator node that repeats a child up to N times.\n*\n* This node has one input port, \"num_cycles\", which accepts an unsigned integer value. The node will repeat its child up to the specified number of times before returning SUCCESS. If the child returns FAILURE, the loop is stopped and this node returns FAILURE.\n*/\n/**\n* @brief Construct a new Repeat Node object with the given name and number of tries.\n*\n* @param name The name of the node.\n* @param NTries The number of times to repeat the child.\n*/\n/**\n* @brief Construct a new Repeat Node object with the given name and configuration.\n*\n* @param name The name of the node.\n* @param config The configuration for the node.\n*/\n/**\n* @brief Destroy the Repeat Node object.\n*/\n/**\n* @brief Get the list of ports provided by this node.\n*\n* @return The list of ports.\n*/\n/**\n* @brief The number of cycles to repeat the child.\n*/\n/**\n* @brief The current try index.\n*/\n/**\n* @brief Whether or not to read the parameter from the ports.\n*/\n/**\n* @brief The name of the input port for the number of cycles.\n*/\n/**\n* @brief Tick function for the node.\n*\n* This function will repeat its child up to the specified number of times before returning SUCCESS. If the child returns FAILURE, the loop is stopped and this node returns FAILURE.\n*\n* @return The status of the tick.\n*/\n/**\n* @brief Halt function for the node.\n*\n* This function will stop the loop and return FAILURE if the child returns FAILURE.\n*/\nvoid halt() override;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool lineIntersection(const cv::Point2f &a1, const cv::Point2f &b1, const cv::Point2f &a2,\n                             const cv::Point2f &b2, cv::Point2f &intersection) {\n    double A1 = b1.y - a1.y;\n    double B1 = a1.x - b1.x;\n    double C1 = (a1.x * A1) + (a1.y * B1);\n\n    double A2 = b2.y - a2.y;\n    double B2 = a2.x - b2.x;\n    double C2 = (a2.x * A2) + (a2.y * B2);\n\n    double det = (A1 * B2) - (A2 * B1);\n\n    if (!almostEqual(det, 0)) {\n        intersection.x = static_cast<float>(((C1 * B2) - (C2 * B1)) / (det));\n        intersection.y = static_cast<float>(((C2 * A1) - (C1 * A2)) / (det));\n\n        return true;\n    }\n\n    return false;\n}\n",
        "answer": "/**\n* @brief Determines if two lines intersect.\n*\n* The lines are specified by a pair of points each. If they intersect, then the function returns true, else it returns false. Lines can be specified in the following form: A1x + B1x = C1 A2x + B2x = C2 If det (= A1*B2 - A2*B1) == 0, then lines are parallel else they intersect If they intersect, then let us denote the intersection point with P(x, y) where: x = (C1*B2 - C2*B1) / (det) y = (C2*A1 - C1*A2) / (det)\n*\n* @param a1 The first point on the first line.\n* @param b1 The second point on the first line.\n* @param a2 The first point on the second line.\n* @param b2 The second point on the second line.\n* @param intersection The intersection point of the two lines, if they intersect.\n*\n* @return True if the lines intersect, false otherwise.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void reset(  ){\n        bp::override func_reset = this->get_override( \"reset\" );\n        func_reset(  );\n    }\n",
        "answer": "/** @brief Resets the GeometryBuffer to its default state.\n*\n* This function clears all buffered data and resets the GeometryBuffer to its default state, excluding vertex attributes.\n*\n* @return void\n*/\nvoid reset() override;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void beginRendering(  ) {\n        if( bp::override func_beginRendering = this->get_override( \"beginRendering\" ) )\n            func_beginRendering(  );\n        else{\n            this->CEGUI::OgreRenderer::beginRendering(  );\n        }\n    }\n",
        "answer": "/** @brief Begin rendering.\n*\n* This function performs any operations required to put the system into a state ready for rendering operations to begin.\n*\n* @return Should not return\n*/\nvoid beginRendering();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void draw(  ) {\n        if( bp::override func_draw = this->get_override( \"draw\" ) )\n            func_draw(  );\n        else{\n            this->CEGUI::RenderingSurface::draw(  );\n        }\n    }\n",
        "answer": "/**\n* @brief Draws the rendering surface.\n*\n* This function draws the rendering surface by calling the `CEGUI::RenderingSurface::draw()` method.\n* The GeometryBuffers remain in the rendering queues after the draw operation is complete, allowing the next draw operation to occur without needing to requeue all the GeometryBuffers (if for instance the sequence of buffers to be drawn remains unchanged).\n*\n* @return Should not return.\n*/\nvoid draw() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void performChildWindowLayout( bool nonclient_sized_hint=false, bool client_sized_hint=false ){\n        if( bp::override func_performChildWindowLayout = this->get_override( \"performChildWindowLayout\" ) )\n            func_performChildWindowLayout( nonclient_sized_hint, client_sized_hint );\n        else{\n            this->CEGUI::TabControl::performChildWindowLayout( nonclient_sized_hint, client_sized_hint );\n        }\n    }\n",
        "answer": "/** @brief Performs child window layout.\n*\n*  This function is called to perform the layout of any child windows. It is typically called when the size of the parent window changes, or when a new child window is added.\n*\n* @param nonclient_sized_hint Whether the non-client area should be sized to fit the content.\n* @param client_sized_hint Whether the client area should be sized to fit the content.\n*/\nvoid performChildWindowLayout(bool nonclient_sized_hint = false, bool client_sized_hint = false) override "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getSizeInUnits()    { return (endPos - startPos) + 32; }\n",
        "answer": "/** @brief Returns a value to indicate how much memory this object takes up. The default value returned here is 10 - units are arbitrary and don't have to be accurate.\n*\n* @return int The size of the object in units.\n*/\nint getSizeInUnits() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void audioProcessorParameterChangeGestureEnd (AudioProcessor*, int index)\n    {\n        ReleaseControl (index + 2);\n    }\n",
        "answer": "/** @brief Indicates that a parameter change gesture has finished. E.g. if the user is dragging a slider, this would be called when they release the mouse button.\n*\n*  This function is called when a parameter change gesture has finished. It is used to indicate that the user has released the mouse button after dragging a slider or other control.\n*\n* @param AudioProcessor*: A pointer to the audio processor object that contains the parameter being changed.\n* @param int index: The index of the parameter being changed.\n*\n* @return void\n*/\nvoid audioProcessorParameterChangeGestureEnd (AudioProcessor*, int index)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void getIdealSize (int& idealWidth, int& idealHeight)\n    {\n        idealWidth = getWidth();\n        idealHeight = getHeight();\n    }\n",
        "answer": "/** @brief Gets the ideal size for this component.\n*\n*  This function returns a rectangle with the size that this component would like to have. Note that the size which this method returns isn't necessarily the one that the menu will give it, as the items will be stretched to have a uniform width.\n*\n* @param idealWidth The ideal width of the component.\n* @param idealHeight The ideal height of the component.\n* @return A rectangle with the ideal size for this component.\n*/\nvoid getIdealSize (int& idealWidth, int& idealHeight)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void audioProcessorChanged (AudioProcessor*)  {}\n",
        "answer": "/** @brief Called to indicate that something else in the plugin has changed, like its program, number of parameters, etc.\n*\n* This function is called when another part of the plugin changes, such as its program or number of parameters.\n* It is used to notify the audio processor that it needs to update its state.\n*\n* @param processor The audio processor that has changed.\n*/\nvoid audioProcessorChanged (AudioProcessor*) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool mightContainSubItems()             { return true; }\n",
        "answer": "/** @brief Tells the tree whether this item can potentially be opened. If your item could contain sub-items, this should return true; if it returns false then the tree will not try to open the item. This determines whether or not the item will be drawn with a 'plus' button next to it.\n*\n* @return Should return true if the item can potentially be opened, false otherwise.\n*/\nbool mightContainSubItems() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool setPosition (int64 newPos)\n    {\n        pos = jlimit ((int64) 0, (int64) zipEntryHolder.compressedSize, newPos);\n        return true;\n    }\n",
        "answer": "/** @brief setPosition function.\n*\n* This function tries to move the current read position of the stream. The position is an absolute number of bytes from the stream's start. Some streams might not be able to do this, in which case they should do nothing and return false. Others might be able to manage it by resetting themselves and skipping to the correct position, although this is obviously a bit slow.\n* @param newPos The new position of the stream.\n* @return true if the operation was successful, false otherwise.\n*/\nbool setPosition (int64 newPos)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int roundTo( int value, int multipleOf )\n{\n    if ( value < multipleOf )\n        return multipleOf;\n\n    return ( int )( multipleOf * round( value / multipleOf ));\n}\n",
        "answer": "/** @brief Rounds a given value to the nearest multiple of a given multiple.\n*\n*  This function rounds a given value to the nearest multiple of a given multiple.\n*  It should only be used on positive numbers.\n*\n* @param value The value to round.\n* @param multipleOf The multiple to round to.\n* @return The rounded value.\n*/\nint roundTo( int value, int multipleOf )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept, bool rawTx)\n{\n    const CChainParams& chainparams = Params();\n    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, pfMissingInputs, GetTime(), plTxnReplaced, bypass_limits, nAbsurdFee, test_accept, rawTx);\n}\n",
        "answer": "/** @brief Add a transaction to the memory pool.\n*\n*  This function is used to add a transaction to the memory pool. It takes a reference to a CValidationState object, which is used to store the validation state of the transaction. If the transaction is valid, it will be added to the memory pool and the function will return true. If the transaction is not valid, the function will return false and the CValidationState object will contain information about why the transaction was rejected.\n*\n* @param[in] pool The memory pool to which the transaction should be added.\n* @param[in] state A reference to a CValidationState object that will be used to store the validation state of the transaction.\n* @param[in] tx A reference to the transaction that should be added to the memory pool.\n* @param[out] pfMissingInputs If the function returns false, this parameter will be set to true if the transaction was rejected because it was missing inputs, and false otherwise.\n* @param[out] plTxnReplaced If the function returns true, this parameter will be appended with all transactions that were replaced from the memory pool.\n* @param[in] bypass_limits If set to true, the transaction will be added to the memory pool even if it would exceed the size or fee limits of the pool.\n* @param[in] nAbsurdFee If the transaction's fees are higher than this value, it will not be added to the memory pool.\n* @param[in] test_accept If set to true, the function will only simulate adding the transaction to the memory pool and return a result without actually modifying the pool.\n* @param[in] rawTx If set to true, the transaction will be treated as a raw transaction (i.e., it will not be deserialized before being added to the memory pool).\n*\n* @return True if the transaction was successfully added to the memory pool, false otherwise.\n*/\nbool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VALUE rb_cipher_rng_eq(VALUE self, VALUE r)\n{\n  JBase *cipher = NULL;\n  RNGEnum rng = rng_sym_to_const(r);\n\n  if (!VALID_RNG(rng)) {\n    rb_raise(rb_eCryptoPP_Error, \"invalid cipher RNG\");\n  }\n  Data_Get_Struct(self, JBase, cipher);\n  ((JCipher*) cipher)->setRNG(rng);\n  if (((JCipher*) cipher)->getRNG() != rng) {\n    rb_raise(rb_eCryptoPP_Error, \"RNG '%s' is unavailable\", JBase::getRNGName(rng).c_str());\n  }\n  else {\n    return r;\n  }\n}\n",
        "answer": "/** @brief Set the random number generator to use for IVs. A CryptoPPError will be raised if an RNG is not available on the system.\n*\n* @param self The object pointer\n* @param r The RNGEnum value representing the RNG to use\n* @return The RNGEnum value representing the RNG that was set\n*/\nVALUE rb_cipher_rng_eq(VALUE self, VALUE r)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VALUE rb_cipher_key_eq(VALUE self, VALUE key)\n{\n  cipher_key_eq(self, key, false);\n  return key;\n}\n",
        "answer": "/** @brief Sets the key on the Cipher in binary and returns the same.\n*\n* This function sets the key on the Cipher in binary and returns the same. Note that the key being set may be truncated or padded depending on its length. Some ciphers have fixed key lengths while others have specific requirements on their size. For instance, the Threeway cipher has a fixed key length of 12 bytes, while Blowfish can use keys of 1 to 72 bytes. When the key being used is shorter than an allowed key length, the key will be padded with \\0's before being set. When the key is longer than an allowed key length, the key will be truncated before being set.\n* @param self The Cipher object on which to set the key.\n* @param key The key to set on the Cipher in binary form.\n* @return The same key that was passed as a parameter.\n*/\nVALUE rb_cipher_key_eq(VALUE self, VALUE key)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VALUE rb_cipher_rounds_eq(VALUE self, VALUE r)\n{\n  JBase *cipher = NULL;\n  unsigned int rounds = NUM2UINT(rb_funcall(r, rb_intern(\"to_i\"), 0));\n  Data_Get_Struct(self, JBase, cipher);\n  if (IS_STREAM_CIPHER(cipher->getCipherType())) {\n    rb_raise(rb_eCryptoPP_Error, \"can't set rounds on stream ciphers\");\n  }\n  else {\n    ((JCipher*) cipher)->setRounds(rounds);\n    if (((JCipher*) cipher)->getRounds() != rounds) {\n      rb_raise(rb_eCryptoPP_Error, \"tried set the number of rounds to %d but %d was used instead\", rounds, ((JCipher*) cipher)->getRounds());\n    }\n    else {\n      return r;\n    }\n  }\n}\n",
        "answer": "/** @brief Sets the number of rounds to perform on block ciphers.\n*\n* This function sets the number of rounds to perform on block ciphers. Some block ciphers have different requirements for their rounds than others. An exception will be raised on invalid round settings.\n* @param self The JBase object.\n* @param r The number of rounds to set.\n* @return Should not return.\n*/\nVALUE rb_cipher_rounds_eq(VALUE self, VALUE r)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VALUE rb_cipher_decrypt_hex(VALUE self)\n{\n  return cipher_decrypt(self, true);\n}\n",
        "answer": "/** @brief Decrypt the ciphertext using the options set on the Cipher. This method will return the plaintext in hex. The raw plaintext will always be available through the plaintext and plaintext_hex methods afterwards.\n*\n* @param self The Ruby object that holds the cipher instance.\n* @return A string containing the decrypted plaintext in hex.\n*/\nVALUE rb_cipher_decrypt_hex(VALUE self)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VALUE rb_module_rng_name(VALUE self, VALUE r)\n{\n  return rb_tainted_str_new2(JCipher::getRNGName(rng_sym_to_const(r)).c_str());\n}\n",
        "answer": "/** @brief Returns the name of the random number generator being used.\n*\n*  This is a singleton method to return the name of the random number generator being used.\n*\n* @param self The object that holds the rng_name method.\n* @param r The rng symbol to convert to a constant.\n* @return A string representing the name of the random number generator being used.\n*/\nVALUE rb_module_rng_name(VALUE self, VALUE r)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VALUE rb_module_digest_hex(int argc, VALUE *argv, VALUE self)\n{\n  string retval = module_digest(argc, argv, self, true);\n  return rb_tainted_str_new(retval.data(), retval.length());\n}\n",
        "answer": "/** @brief Digest the plaintext and returns the result in hex.\n*\n* This function takes an algorithm and a plaintext as input, digests the plaintext using the specified algorithm, and returns the result in hex format.\n*\n* @param[in] algorithm The algorithm to use for digestion.\n* @param[in] plaintext The plaintext to be digested.\n* @return A string containing the digest of the plaintext in hex format.\n*/\nVALUE rb_module_digest_hex(int argc, VALUE *argv, VALUE self)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "intptr_t GetMethodOriginalAddress(ThreadContextInfo * context, JnHelperMethod helperMethod)\n{\n    AssertOrFailFast(helperMethod >= 0 && helperMethod < IR::JnHelperMethodCount);\n    intptr_t address = GetHelperMethods()[static_cast<WORD>(helperMethod)];\n    if (address == 0)\n    {\n        return GetNonTableMethodAddress(context, helperMethod);\n    }\n\n    return ShiftAddr(context, address);\n}\n",
        "answer": "/** @brief Returns the memory address of the helper method.\n*\n*  This function returns the memory address of a given helper method.\n*  It first checks if the helper method is valid and then retrieves its address from the helper methods table.\n*  If the address is not found in the table, it uses the GetNonTableMethodAddress() function to retrieve the address.\n*\n* @param context The thread context information.\n* @param helperMethod The helper method to get the address of.\n* @return The memory address of the helper method.\n*/\nintptr_t GetMethodOriginalAddress(ThreadContextInfo *context, JnHelperMethod helperMethod)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CHAKRA_API JsDisableRuntimeExecution(_In_ JsRuntimeHandle runtimeHandle)\n{\n    VALIDATE_INCOMING_RUNTIME_HANDLE(runtimeHandle);\n\n    ThreadContext * threadContext = JsrtRuntime::FromHandle(runtimeHandle)->GetThreadContext();\n    if (!threadContext->TestThreadContextFlag(ThreadContextFlagCanDisableExecution))\n    {\n        return JsErrorCannotDisableExecution;\n    }\n\n    if (threadContext->GetRecycler() && threadContext->GetRecycler()->IsHeapEnumInProgress())\n    {\n        return JsErrorHeapEnumInProgress;\n    }\n    else if (threadContext->IsInThreadServiceCallback())\n    {\n        return JsErrorInThreadServiceCallback;\n    }\n\n    threadContext->DisableExecution();\n    return JsNoError;\n}\n",
        "answer": "/** @brief Disables runtime execution.\n*\n*  This API disables runtime execution, which means that any executing scripts will be terminated with an uncatchable exception as soon as possible. Suspending execution in a runtime that is already suspended is a no-op.\n*\n* @param [in] runtimeHandle The handle of the runtime to disable execution for.\n* @return JsErrorCannotDisableExecution if the thread context cannot be disabled, JsErrorHeapEnumInProgress if a heap enumeration is in progress, or JsErrorInThreadServiceCallback if the thread service callback is currently executing. Returns JsNoError otherwise.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CHAKRA_API JsRunScriptWithParserState(\n    _In_ JsValueRef script,\n    _In_ JsSourceContext sourceContext,\n    _In_ JsValueRef sourceUrl,\n    _In_ JsParseScriptAttributes parseAttributes,\n    _In_ JsValueRef parserState,\n    _Out_ JsValueRef *result)\n{\n    WCHAR *url = nullptr;\n    if (sourceUrl && Js::VarIs<Js::JavascriptString>(sourceUrl))\n    {\n        url = const_cast<WCHAR*>(((Js::JavascriptString*)(sourceUrl))->GetSz());\n        return RunScriptWithParserStateCore(0, script, sourceContext, url, parseAttributes, parserState, false, result);\n    }\n    else\n    {\n        return JsErrorInvalidArgument;\n    }\n}\n",
        "answer": "/** @brief Runs a script with the given parser state.\n*\n*  This function runs a script with the given parser state. The script can be either a JavascriptString or a JavascriptExternalArrayBuffer. If it is an ExternalArrayBuffer, and the encoding of the buffer is Utf16, JsParseScriptAttributeArrayBufferIsUtf16Encoded is expected on parseAttributes. Use JavascriptExternalArrayBuffer with Utf8/ASCII script source for better performance and smaller memory footprint.\n*\n* @param script The script to run.\n* @param sourceContext A cookie identifying the script that can be used by debuggable script contexts.\n* @param sourceUrl The location the script came from.\n* @param parseAttributes Attribute mask for parsing the script.\n* @param parserState The parser state to use.\n* @param result The result of the script execution.\n* @return JsNoError if the operation succeeded, a failure code otherwise.\n*/\nCHAKRA_API JsRunScriptWithParserState("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, /* uint32_t nENonce,*/ uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n{\n    const char* pszTimestamp = \"BBC News 20/Oct/2018 US Mega Millions lottery jackpot hits record $1.6bn\";\n    const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, /*nENonce,*/ nBits, nVersion, genesisReward);\n}\n",
        "answer": "/** @brief Build the genesis block.\n*\n*  This function creates a new block that is used as the starting point for the blockchain. The output of its generation transaction cannot be spent since it did not originally exist in the database.\n*\n* @param nTime Timestamp of when the block was created.\n* @param nNonce Arbitrary number that is used to fulfill the proof-of-work requirement.\n* @param nBits Difficulty target for the proof-of-work algorithm.\n* @param nVersion Version number of the block.\n* @param genesisReward Reward given to the miner who solved the proof-of-work.\n* @return A new block that is used as the starting point for the blockchain.\n*/\nstatic CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, /* uint32_t nENonce,*/ uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\nvoid TestInstantiations_MQV()\n{\n\tMQV mqv;\n}\n",
        "answer": "/** @brief Test instantiations for MQV.\n*\n*  This function tests the instantiation of the MQV class.\n*\n* @return Should not return\n*/\nvoid TestInstantiations_MQV()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\nvoid WAKE_TestInstantiations()\n{\n\tWAKE_OFB<>::Encryption x2;\n\tWAKE_OFB<>::Decryption x4;\n}\n",
        "answer": "/** @brief WAKE Test Instantiations.\n*\n* This function tests the instantiation of the WAKE encryption and decryption classes.\n*\n* @return None\n*/\nvoid WAKE_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Online_Stop()\n{\n  Msgs->debug(cerr, \"Stopping the online-analysis\");\n\n  Online_Disable();\n\n  if (I_am_master_BE)\n  {\n    /* Tell the root to quit */\n    Stop_FE();\n  }\n\n  Msgs->debug(cerr, \"Waiting for back-end to finish...\");\n  \n  if (BE_thread_started)\n    pthread_join(BE_thread, NULL);\n\n  Msgs->debug(cerr, \"Back-end closed!\");\n\n  /* Barrier synchronization */\n  SyncWaitAll(); \n}\n",
        "answer": "/** @brief Online_Stop function.\n*\n*  This function stops the online analysis and waits for the back-end to finish.\n*\n* @param Msgs: A pointer to a message object.\n* @param cerr: A pointer to an error stream.\n* @param Stop_FE: A function that tells the root process to quit.\n* @param SyncWaitAll: A function that performs barrier synchronization.\n* @return void\n*/\n/* Tell the root to quit */\n/* Barrier synchronization */\nSyncWaitAll();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double GetGroupDegreeCentr(const PUNGraph& Graph, const TIntH& GroupNodes) {\r\n  int deg;\r\n  TIntH NN;\r\n  TIntH GroupNodes1;\r\n\r\n  for (THashKeyDatI<TInt,TInt> NI = GroupNodes.BegI(); NI < GroupNodes.EndI(); NI++)\r\n    GroupNodes1.AddDat(NI.GetDat(),NI.GetDat());\r\n\r\n  for (THashKeyDatI<TInt,TInt> NI = GroupNodes1.BegI(); NI < GroupNodes1.EndI(); NI++){\r\n    TUNGraph::TNodeI node = Graph->GetNI(NI.GetKey());\r\n    deg = node.GetDeg();\r\n    for (int j = 0; j < deg; j++){\r\n      if (GroupNodes1.IsKey(node.GetNbrNId(j))==0 && NN.IsKey(node.GetNbrNId(j))==0)\r\n        NN.AddDat(node.GetNbrNId(j),NI.GetKey());\r\n    }\r\n  }\r\n\r\n  return (double)NN.Len();\r\n}\r\n",
        "answer": "/** @brief GetGroupDegreeCentr\n*\n*  This function calculates the degree centrality of a given group NId in a graph. Degree centrality is defined as the node's degree divided by the number of nodes in the network minus one.\n*\n* @param Graph The graph to calculate the degree centrality for.\n* @param GroupNodes A hash table containing the group NIds and their corresponding degrees.\n* @return The degree centrality of the given group NId.\n*/\ndouble GetGroupDegreeCentr(const PUNGraph& Graph, const TIntH& GroupNodes) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void PlotInvParticipRat(const PUNGraph& Graph, const int& MaxEigVecs, const int& TimeLimit, const TStr& FNmPref, TStr DescStr) {\r\n  TFltPrV EigIprV;\r\n  GetInvParticipRat(Graph, MaxEigVecs, TimeLimit, EigIprV);\r\n  if (DescStr.Empty()) { DescStr = FNmPref; }\r\n  if (EigIprV.Empty()) { DescStr+=\". FAIL\"; EigIprV.Add(TFltPr(-1,-1)); return; }\r\n  TGnuPlot::PlotValV(EigIprV, \"eigIPR.\"+FNmPref, TStr::Fmt(\"%s. G(%d, %d). Largest eig val = %f (%d values)\",\r\n    DescStr.CStr(), Graph->GetNodes(), Graph->GetEdges(), EigIprV.Last().Val1(), EigIprV.Len()),\r\n    \"Eigenvalue\", \"Inverse Participation Ratio of corresponding Eigenvector\", gpsLog10Y, false, gpwPoints);\r\n}\r\n",
        "answer": "/**\n* @brief Plots the inverse participation ratio of a graph.\n*\n* This function plots the inverse participation ratio of a graph using Gnuplot. The inverse participation ratio is defined as the ratio of the largest eigenvalue to the sum of all eigenvalues. See Spectra of \"real-world\" graphs: Beyond the semicircle law by Farkas, Derenyi, Barabasi and Vicsek.\n*\n* @param Graph The graph to plot the inverse participation ratio for.\n* @param MaxEigVecs The maximum number of eigenvectors to use in the calculation.\n* @param TimeLimit The time limit for the calculation, in seconds.\n* @param FNmPref The prefix for the output file name.\n* @param DescStr A description string for the plot.\n*/\nvoid PlotInvParticipRat(const PUNGraph& Graph, const int& MaxEigVecs, const int& TimeLimit, const TStr& FNmPref, TStr DescStr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double CalcEffDiamPdf(const TFltPrV& DistNbrsPdfV, const double& Percentile) {\r\n  TFltPrV CdfV;\r\n  TGUtil::GetCdf(DistNbrsPdfV, CdfV);\r\n  return CalcEffDiam(CdfV, Percentile);\r\n}\r\n",
        "answer": "/** @brief Calculates the effective diameter of a graph using a given percentile of its probability distribution function.\n*\n* This is a helper function for computing a given Percentile of a (unnormalized) probability distribution function.\n*\n* @param DistNbrsPdfV A vector of pairs containing the probability distribution function of the graph.\n* @param Percentile The percentile to use in the calculation.\n* @return The effective diameter of the graph using the given percentile.\n*/\ndouble CalcEffDiamPdf(const TFltPrV& DistNbrsPdfV, const double& Percentile) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class SightPersonRedispatch : public Redispatch\n\n{\npublic:\n    SightPersonRedispatch(Connection* con, const std::string& pid, const Root& obj) :\n        Redispatch(con, obj),\n        m_person(pid)\n    {;}\n    \n    void onSightPerson(Person* p)\n    {\n        if ( p->getAccount() == m_person) post();\n    }\nprivate:\n    std::string m_person;\n};\n",
        "answer": "/** @brief Helper to buffer operations when waiting on sight of a person. Used by private chat in the first instance, and potentially more later.\n*\n* This is a helper class that buffers operations when waiting on sight of a person. It is used by the private chat feature to ensure that messages are delivered only when the recipient is online and has been sighted.\n*\n* @param con The connection object for the current session.\n* @param pid The ID of the person being sighted.\n* @param obj The root object for the current session.\n*/\nclass SightPersonRedispatch : public Redispatch"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void AddSpecials ( const char * sSpecials )\n\t{\n\t\tassert ( m_eMode!=SPH_CLONE_QUERY_LIGHTWEIGHT );\n\t\tISphTokenizer::AddSpecials ( sSpecials );\n\t}\n",
        "answer": "/** @brief Add special characters to the translation table.\n*\n*  This function updates the lowercaser so that special characters remap to -1.\n*\n* @param sSpecials A string containing the special characters to add.\n*/\nvirtual void AddSpecials ( const char * sSpecials )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void fm_alarm_to_list(const SFmAlarmDataT *a, std::vector<std::string> &list) {\n\tsize_t ix = 0;\n\tsize_t mx = FM_ALM_IX_INHIBIT_ALARM ;\n\tstd::string field;\n\tfor ( ; ix <= mx ; ++ix ) {\n\t\tfm_alarm_get_field(((EFmAlarmIndexMap)ix),a,field);\n\t\tlist.push_back(field);\n\t}\n}\n",
        "answer": "/** @brief Converts an alarm to a list of strings.\n*\n*  This function takes an SFmAlarmDataT object and converts it into a list of strings, using the EFmAlarmIndexMap enum to determine the indexes of the fields to be extracted. The resulting list is stored in the vector passed as the second argument.\n*\n* @param [in] a A pointer to an SFmAlarmDataT object representing the alarm to be converted.\n* @param [out] list A reference to a vector of strings where the resulting list will be stored.\n*/\nvoid fm_alarm_to_list(const SFmAlarmDataT *a, std::vector<std::string> &list) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int get_list_length(ListNode* head){\n    int len = 0;\n    while(head){\n        len++;\n        head = head->next;\n    }\n    return len;\n}\n",
        "answer": "/** @brief Get the length of a singly-linked list.\n*\n*  This function calculates and returns the length of a singly-linked list.\n*\n* @param head A pointer to the head node of the linked list.\n* @return The length of the linked list.\n*/\nint get_list_length(ListNode* head)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int height(TreeNode* node)\n{\n    if (!node)\n        return 0;\n    if (!node->left && !node->right)\n        return 1;\n    \n    auto l = 1 + height(node->left);\n    auto r = 1 + height(node->right);\n    \n    if (l<0 || r<0)\n        return INT_MIN;\n    if (abs(l-r)>1)\n        return INT_MIN;\n    return max(l, r);\n}\n",
        "answer": "/** @brief Calculates the height of a binary tree.\n*\n*  This function calculates the height of a binary tree by recursively traversing its nodes.\n*  The height is defined as the number of edges on the longest path between the root node and a leaf node.\n*\n* @param[in] node A pointer to the root node of the binary tree.\n* @return The height of the binary tree, or INT_MIN if the tree is not balanced.\n*/\nint height(TreeNode* node)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void inorder(TreeNode* root, int& smallest, int k, int& it)\n{\n    if (!root)\n        return;\n    inorder(root->left, smallest, k, it);\n    ++it;\n    if (it == k)\n    {\n        smallest = root->val;\n        return;\n    }\n    inorder(root->right, smallest, k, it);\n}\n",
        "answer": "/** @brief Finds the kth smallest element in a binary search tree (BST).\n*\n*  This function uses an inorder traversal to find the kth smallest element in a BST. It starts by recursively traversing the left subtree, then increments a counter for each node it visits, and finally recursively traverses the right subtree. If the counter reaches k during the traversal, the function returns the value of that node as the kth smallest element.\n*\n* @param root The root node of the BST.\n* @param smallest A reference to an integer that will be set to the value of the kth smallest element.\n* @param k An integer representing the rank of the element to find (1 is the smallest, 2 is the second smallest, etc.).\n* @param it The current count of nodes visited during the traversal.\n*/\nvoid inorder(TreeNode* root, int& smallest, int k, int& it)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void allpaths(vector<vector<int>>& res, vector<int>& temp, TreeNode* A, int sum)\n{\n    if (!A)\n        return;\n    sum -= A->val;\n    temp.emplace_back(A->val);\n    if (!A->left && !A->right && sum == 0)\n        res.emplace_back(temp);\n    if (A->left)\n        allpaths(res, temp, A->left, sum);\n    if (A->right)\n        allpaths(res, temp, A->right, sum);\n    temp.pop_back();\n}\n",
        "answer": "/** @brief Finds all paths in a binary tree that add up to a given sum.\n*\n*  This function uses a recursive approach to find all paths in a binary tree that add up to a given sum. It returns a vector of vectors, where each inner vector represents a path and contains the values of the nodes in that path. The outer vector contains all possible paths that add up to the given sum.\n*\n* @param res A reference to an empty vector of vectors, which will be populated with the results of the function.\n* @param temp A temporary vector used to store the current path being explored.\n* @param A A pointer to the root node of the binary tree.\n* @param sum The target sum that the paths must add up to.\n* @return void\n*/\nvoid allpaths(vector<vector<int>>& res, vector<int>& temp, TreeNode* A, int sum)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   bool error(QFile & f) {\n      m_error = f.errorString();\n      m_error.append(QStringLiteral(\"(in %1 file\").arg(f.objectName()));\n      emit finished(false, m_error);\n      close();\n      return false;\n   }\n",
        "answer": "/** @brief Error function.\n*\n*  This function takes the error string from a given file and emits an error indication. Closes the files and stops the copy. Always returns false\n*\n* @param f The QFile object to get the error string from.\n* @return Should not return\n*/\nvoid error(QFile & f) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString removeBidiControlChars(const QString &input)\n{\n    const int LRO = 0x202D;\n    const int RLO = 0x202E;\n    const int LRE = 0x202A;\n    const int RLE = 0x202B;\n    QString result = input;\n    result.remove(LRO);\n    result.remove(RLO);\n    result.remove(LRE);\n    result.remove(RLE);\n    return result;\n}\n",
        "answer": "/** @brief Removes Bidi control characters from a QString.\n*\n*  This function takes a QString as input and removes any Bidi control\n*  characters (LRO, RLO, LRE, RLE) from it. The modified string is then\n*  returned.\n*\n* @param input The input QString to remove Bidi control characters from.\n* @return A new QString with the Bidi control characters removed.\n*/\nQString removeBidiControlChars(const QString &input)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void handleNodeInfoUnavailable(uavcan::NodeID node_id)\n    {\n        std::cout << \"NODE INFO FOR \" << int(node_id.get()) << \" IS UNAVAILABLE\" << std::endl;\n        last_node_id = node_id;\n        info_unavailable_cnt++;\n    }\n",
        "answer": "/** @brief Handles the case where the retriever decides that a node does not support the GetNodeInfo service.\n*\n*  This method is called when the number of attempts to retrieve the NodeInfo from a node is unlimited.\n*\n* @param node_id The ID of the node for which the NodeInfo is unavailable.\n*/\nvoid handleNodeInfoUnavailable(uavcan::NodeID node_id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(void)\n{\n\tinit();\n\n#if defined(USBCON)\n\tUSBDevice.attach();\n#endif\n\t\n\tsetup();\n    \n\tfor (;;) {\n\t\tloop();\n\t\tif (serialEventRun) serialEventRun();\n\t}\n        \n\treturn 0;\n}\n",
        "answer": "/** @brief Main program entry point.\n*\n* This routine configures the hardware required by the bootloader, then continuously runs the bootloader processing routine until instructed to soft-exit, or hard-reset via the watchdog to start the loaded application code.\n*\n* @return Should not return\n*/\nvoid main(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void extract_containing_graph(const HandleGraph* source, MutableHandleGraph* into, const vector<pos_t>& positions,\n                              size_t max_dist, size_t reversing_walk_length) {\n    \n    extract_containing_graph(source, into, positions, vector<size_t>(positions.size(), max_dist),\n                             reversing_walk_length);\n}\n",
        "answer": "/**\n* @brief Extracts a subgraph from a handle graph that contains all of the positions in the positions vector and all other nodes and edges that can be reached within a maximum distance from any of these positions. Optionally also finds nodes and edges that can be reached within some distance from the previously mentioned nodes, except along non-proper bidirected walks. Node IDs in the subgraph are retained from the source graph.\n*\n* @param source The handle graph to extract the subgraph from.\n* @param into The graph to extract into.\n* @param positions The positions to search outward from.\n* @param max_dist The maximum distance to include nodes and edges that can be reached.\n* @param reversing_walk_length The number of steps to take in the reverse direction when searching for nodes and edges that can be reached within some distance from the previously mentioned nodes, except along non-proper bidirected walks.\n*/\nvoid extract_containing_graph(const HandleGraph* source, MutableHandleGraph* into, const vector<pos_t>& positions, size_t max_dist, size_t reversing_walk_length);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ecall_function_calling_convs(void)\n{\n    sgx_status_t ret = SGX_ERROR_UNEXPECTED;\n\n    char s1[] = \"1234567890\";\n    char s2[] = \"0987654321\";\n\n    char buf[BUFSIZ] = {'\\0'};\n    memcpy(buf, s1, strlen(s1));\n\n    ret = memccpy(NULL, s1, s2, '\\0', strlen(s1));\n    \n    if (ret != SGX_SUCCESS)\n        abort();\n    assert(memcmp(s1, s2, strlen(s1)) == 0);\n\n    return;\n}\n",
        "answer": "/** @brief Function that demonstrates the use of the memccpy and memcmp functions.\n*\n*  This function uses the memccpy function to copy a string from one buffer to another,\n*  while also checking for the presence of a specific character in the source buffer.\n*  If the character is found, the function aborts and returns an error code.\n*  Otherwise, it continues copying the rest of the string using memcpy.\n*\n* @param[in] s1 The first string to be copied.\n* @param[in] s2 The second string to be copied.\n* @param[out] buf The buffer where the strings will be copied.\n* @return SGX_SUCCESS if the function succeeds, or an error code otherwise.\n*/\nvoid ecall_function_calling_convs(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void h2o_send_error_deferred(h2o_req_t *req, int status, const char *reason, const char *body, int flags)\n{\n    struct st_send_error_deferred_t *args = h2o_mem_alloc_pool(&req->pool, sizeof(*args));\n    *args = (struct st_send_error_deferred_t){req, status, reason, body, flags};\n    args->_timeout.cb = send_error_deferred_cb;\n    h2o_timeout_link(req->conn->ctx->loop, &req->conn->ctx->zero_timeout, &args->_timeout);\n}\n",
        "answer": "/** @brief Sends an error response using zero timeout.\n*\n*  This function sends an error response to the client using a zero timeout. It can be called by output filters while processing the headers.\n*\n* @param req The request object.\n* @param status The HTTP status code of the error.\n* @param reason A brief description of the error.\n* @param body The error message body.\n* @param flags Flags for the error response.\n* @return Should not return.\n*/\n*args = (struct st_send_error_deferred_t){req, status, reason, body, flags};\nargs->_timeout.cb = send_error_deferred_cb;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t h2o_strtosizefwd(char **s, size_t len)\n{\n    uint64_t v, c;\n    char *p = *s, *p_end = *s + len;\n\n    if (len == 0)\n        goto Error;\n\n{\n    int ch = *p++;\n    if (!('0' <= ch && ch <= '9'))\n        goto Error;\n    v = ch - '0';\n    c = 1;\n\n    while (1) {\n        ch = *p;\n        if (!('0' <= ch && ch <= '9'))\n            break;\n        v *= 10;\n        v += ch - '0';\n        p++;\n        c++;\n        if (p == p_end)\n            break;\n        /* similar as above, do not even try to overflow */\n        if (c == 20)\n            goto Error;\n    }\n\n    if (v >= SIZE_MAX)\n        goto Error;\n    *s = p;\n    return v;\n}\n\nError:\n    return SIZE_MAX;\n}\n",
        "answer": "/** @brief Parses the first positive number contained in a string.\n*\n*  This function parses the first positive number contained in a string, or returns SIZE_MAX if failed. The *s pointer will be set to the right after the number in the string or right after the end of the string.\n*\n* @param s A pointer to the string to parse.\n* @param len The length of the string.\n* @return The parsed size, or SIZE_MAX if failed.\n*/\n/* similar as above, do not even try to overflow */\n*s = p;\nreturn v;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool StartHTTPServer() {\n    LogPrint(BCLog::HTTP, \"Starting HTTP server\\n\");\n    int rpcThreads =\n        std::max((long)gArgs.GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n    LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n    std::packaged_task<bool(event_base *)> task(ThreadHTTP);\n    threadResult = task.get_future();\n    threadHTTP = std::thread(std::move(task), eventBase);\n\n    for (int i = 0; i < rpcThreads; i++) {\n        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue);\n    }\n    return true;\n}\n",
        "answer": "/** @brief Starts the HTTP server.\n*\n*  This function starts the HTTP server and creates worker threads for handling requests.\n*\n* @return Returns a boolean value indicating whether the operation was successful or not.\n*/\nbool StartHTTPServer() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void RPCTypeCheck(const UniValue &params,\n                  const std::list<UniValue::VType> &typesExpected,\n                  bool fAllowNull) {\n    unsigned int i = 0;\n    for (UniValue::VType t : typesExpected) {\n        if (params.size() <= i) {\n            break;\n        }\n\n        const UniValue &v = params[i];\n        if (!(fAllowNull && v.isNull())) {\n            RPCTypeCheckArgument(v, t);\n        }\n        i++;\n    }\n}\n",
        "answer": "/** @brief Type-check arguments; throws JSONRPCError if wrong type given. Does not check that the right number of arguments are passed, just that any passed are the correct type.\n*\n*  This function is used to type-check the arguments passed to an RPC call. It checks that each argument has the expected type and throws a JSONRPCError if any argument has the wrong type. The function does not check that the right number of arguments are passed, just that any passed are the correct type.\n*\n* @param params A list of UniValue objects representing the arguments to be checked.\n* @param typesExpected A list of expected types for each argument.\n* @param fAllowNull Whether null values should be allowed or not.\n*\n* @return None.\n*/\nvoid RPCTypeCheck(const UniValue &params,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool InterpretBool(const std::string &strValue) {\n    if (strValue.empty()) {\n        return true;\n    }\n    return (atoi(strValue) != 0);\n}\n",
        "answer": "/** @brief Interpret a string argument as a boolean.\n*\n* This function interprets a string argument as a boolean value. The definition of atoi() requires that non-numeric string values like \"foo\", return 0. This means that if a user unintentionally supplies a non-integer argument here, the return value is always false. This means that -foo=false does what the user probably expects, but -foo=true is well defined but does not do what they probably expected. The return value of atoi() is undefined when given input not representable as an int. On most systems this means string value between \"-2147483648\" and \"2147483647\" are well defined (this method will return true). Setting -txindex=2147483648 on most systems, however, is probably undefined. For a more extensive discussion of this topic (and a wide range of opinions on the Right Way to change this code), see PR12713.\n* @param strValue The string value to interpret as a boolean.\n* @return true if the string value represents a non-zero integer, false otherwise.\n*/\nstatic bool InterpretBool(const std::string &strValue) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool SplitZeroTerminatedStrings(const AString & a_Strings, AStringVector & a_Output)\n{\n\ta_Output.clear();\n\tsize_t size = a_Strings.size();\n\tsize_t start = 0;\n\tbool res = false;\n\tfor (size_t i = 0; i < size; i++)\n\t{\n\t\tif (a_Strings[i] == 0)\n\t\t{\n\t\t\ta_Output.push_back(a_Strings.substr(start, i - start));\n\t\t\tstart = i + 1;\n\t\t\tres = true;\n\t\t}\n\t}\n\tif (start < size)\n\t{\n\t\ta_Output.push_back(a_Strings.substr(start, size - start));\n\t\tres = true;\n\t}\n\n\treturn res;\n}\n",
        "answer": "/**\n* @brief Splits a string that has embedded \\0 characters, on those characters.\n*\n* a_Output is first cleared and then each separate string is pushed back into a_Output.\n* Returns true if there are at least two strings in a_Output (there was at least one \\0 separator).\n*\n* @param a_Strings The input string to be split.\n* @param a_Output The output vector of separated strings.\n* @return True if there are at least two strings in a_Output, false otherwise.\n*/\nbool SplitZeroTerminatedStrings(const AString &a_Strings, AStringVector &a_Output)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static long spech_dynstring( vappendf_appender pf,\n\t\t\t     void * pfArg,\n\t\t\t     void * varg )\n{\n  long ret = spech_string( pf, pfArg, varg );\n  free( (char *) varg );\n  return ret;\n}\n",
        "answer": "/** @brief Handles vappendf_spec_handler for etDYNSTRING types.\n*\n*  This function behaves identically to spec_string() and then calls free() on that (char *).\n*\n* @param pf The vappendf_appender object.\n* @param pfArg The argument passed to the appender.\n* @param varg The variable argument list.\n*\n* @return Should not return\n*/\nstatic long spech_dynstring(vappendf_appender pf, void *pfArg, void *varg) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void TranslateJavaException() {\n    jobject exception=GetEnv()->ExceptionOccurred();\n    if (!exception) {\n        return;\n    }\n    LObject throwable=LObject::WrapLocal(exception);\n    GetEnv()->ExceptionClear();\n    throw java::PThrowable::Wrap(throwable);\n}\n",
        "answer": "/** @brief Converts currently pending Java exception to C++ exception. If no Java exception is pending this function does nothing. If Java exception is pending this function wraps it in private object derived from jni::AbstractObject, clears pending exception status and throws exception object by value. Use java::Cast() to cast exception object to concrete type. You can safely cast to java::Throwable class. See also jni::TranslateCppException().\n*  @param GetEnv()->ExceptionOccurred() The current Java exception that is pending.\n*  @return Should not return\n*/\nvoid TranslateJavaException() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    level infer_resultant_universe(unsigned num_intro_rules, expr const * intro_rules) {\n        lean_assert(m_infer_result_universe);\n        buffer<level> r_lvls;\n        for (unsigned i = 0; i < num_intro_rules; i++) {\n            accumulate_levels(local_type_p(intro_rules[i]), r_lvls);\n        }\n        return mk_result_level(r_lvls);\n    }\n",
        "answer": "/** @brief Infer resultant universe.\n*\n*  This function takes a sequence of introduction rules (encoded as local constants) and computes the resultant universe for the inductive datatype declaration.\n*\n* @param num_intro_rules The number of introduction rules in the sequence.\n* @param intro_rules The sequence of introduction rules.\n* @return The resultant universe for the inductive datatype declaration.\n*/\nlevel infer_resultant_universe(unsigned num_intro_rules, expr const * intro_rules) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "expr deep_copy(expr const & e) {\n    return replace(e, [](expr const & e) {\n            if (is_atomic(e))\n                return some_expr(copy(e));\n            else\n                return none_expr();\n        });\n}\n",
        "answer": "/** @brief Creates a new expression that is equal to the given argument, but does not share any memory cell with it.\n*\n*  This function creates a deep copy of an expression, which means that it returns a new expression that is equal to the given argument, but does not share any memory cell with it.\n*\n* @param e The expression to be copied.\n* @return A new expression that is equal to the given argument, but does not share any memory cell with it.\n*/\nexpr deep_copy(expr const & e) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT int STDCALL FPDFAvail_IsDocAvail(FPDF_AVAIL avail, FX_DOWNLOADHINTS* hints)\n{\n\tif (avail == NULL || hints == NULL) return 0;\n\tCFPDF_DownloadHintsWrap hints_wrap(hints);\n\treturn ((CFPDF_DataAvail*)avail)->m_pDataAvail->IsDocAvail(&hints_wrap);\n}\n",
        "answer": "/**\n* @brief Check whether the document is ready for loading, if not, get download hints.\n*\n* This function checks whether the document is fully available and ready to be loaded. If it is not, it generates download hints that can be used to retrieve the missing data.\n*\n* @param avail Handle to document availability provider returned by FPDFAvail_Create\n* @param hints Pointer to a download hints interface, receiving generated hints\n* @return Non-zero for page is fully available, 0 for page not yet available.\n*\n* @comments The application should call this function whenever new data arrived, and process all the generated download hints if any, until the function returns non-zero value. Then the application can call FPDFAvail_GetDocument() to get a document handle.\n*/\nDLLEXPORT int STDCALL FPDFAvail_IsDocAvail(FPDF_AVAIL avail, FX_DOWNLOADHINTS* hints);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT FPDF_BOOL STDCALL FPDFAvail_IsLinearized(FPDF_AVAIL avail)\n{\n\t\tif (avail == NULL) return -1;\n\treturn ((CFPDF_DataAvail*)avail)->m_pDataAvail->IsLinearizedPDF();\n\n}\n",
        "answer": "/**\n* @brief Checks whether a document is a linearized PDF file.\n*\n* This function checks whether a document is a linearized PDF file by checking if the first 1K bytes of the file contain the \"%PDF\" signature. If the file size is less than 1K, it returns FSDK_UNKNOW_LINEARIZED to indicate that it cannot determine whether the file is linearized or not.\n*\n* @param avail Handle to document availability provider returned by FPDFAvail_Create.\n* @return TRUE if the document is a linearized PDF file, FALSE otherwise.\n*/\nDLLEXPORT FPDF_BOOL STDCALL FPDFAvail_IsLinearized(FPDF_AVAIL avail);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT int STDCALL FPDPage_HasFormFieldAtPoint(FPDF_FORMHANDLE hHandle, FPDF_PAGE page,double page_x, double page_y)\n{\n\tif(!page || !hHandle)\n\t\treturn -1;\n\tCPDF_Page * pPage = (CPDF_Page*) page;\n\n\tCPDF_InterForm * pInterForm = NULL;\n\tpInterForm = new CPDF_InterForm(pPage->m_pDocument,FALSE);\n\tif (!pInterForm)\n\t\treturn -1;\n\tCPDF_FormControl* pFormCtrl = pInterForm->GetControlAtPoint(pPage, (FX_FLOAT)page_x, (FX_FLOAT)page_y);\n\tif(!pFormCtrl)\n\t{\n\t\tdelete pInterForm;\n\t\treturn -1;\n\t}\n\tCPDF_FormField* pFormField = pFormCtrl->GetField();\n\tif(!pFormField)\n\t{\n\t\tdelete pInterForm;\n\t\treturn -1;\n\t}\n\t\n\tint nType = pFormField->GetFieldType();\n\tdelete pInterForm;\n\treturn nType;\n}\n",
        "answer": "/** @brief Check the form field position by point.\n*\n*  This function checks the form field position by point.\n*  It takes in a handle to the form fill module, a handle to the page, and X and Y positions in PDF \"user space\".\n*  It returns the type of the formfield; -1 indicates no fields.\n*\n* @param hHandle Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.\n* @param page Handle to the page. Returned by FPDF_LoadPage function.\n* @param page_x X position in PDF \"user space\".\n* @param page_y Y position in PDF \"user space\".\n* @return The type of the formfield; -1 indicates no fields.\n*/\nDLLEXPORT int STDCALL FPDPage_HasFormFieldAtPoint(FPDF_FORMHANDLE hHandle, FPDF_PAGE page,double page_x, double page_y)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT FPDF_BOOL STDCALL FORM_OnChar(FPDF_FORMHANDLE hHandle, FPDF_PAGE page, int nChar,  int modifier)\n{\n\tif (!hHandle || !page)\n\t\treturn FALSE;\n\tCPDFSDK_Document* pFXDoc = ((CPDFDoc_Environment*)hHandle)->GetCurrentDoc();\n\tif(!pFXDoc)\n\t\treturn FALSE;\n\tCPDFSDK_PageView* pPageView = pFXDoc->GetPageView((CPDF_Page*)page);\n\tif(!pPageView)\n\t\treturn FALSE;\n\treturn pPageView->OnChar(nChar, modifier);\n\n}\n",
        "answer": "/** @brief FORM_OnChar is a member function that can be called when a keystroke translates to a nonsystem character.\n*\n*  This function takes in four parameters: hHandle, which is the handle to the form fill module and is returned by FPDFDOC_InitFormFillEnvironment; page, which is the handle to the page and is returned by FPDF_LoadPage; nChar, which is the character code value of the key; and modifier, which contains the scan code, key-transition code, previous key state, and context code.\n*  The function first checks if hHandle or page are NULL, and if so, returns FALSE. It then retrieves the current document using GetCurrentDoc() and checks if it is NULL. If it is NULL, the function returns FALSE. Next, it retrieves the page view using GetPageView() and checks if it is NULL. If it is NULL, the function returns FALSE. Finally, the function calls OnChar() on the page view with nChar and modifier as parameters and returns the result.\n*\n* @param hHandle Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.\n* @param page Handle to the page. Returned by FPDF_LoadPage.\n* @param nChar The character code value of the key.\n* @param modifier Contains the scan code, key-transition code, previous key state, and context code.\n* @return TRUE indicates success; otherwise false.\n*/\nDLLEXPORT FPDF_BOOL STDCALL FORM_OnChar(FPDF_FORMHANDLE hHandle, FPDF_PAGE page, int nChar,  int modifier)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT void STDCALL FORM_DoDocumentAAction(FPDF_FORMHANDLE hHandle, int aaType)\n{\n\tif(!hHandle)\n\t\treturn;\n\tCPDFSDK_Document* pSDKDoc = ((CPDFDoc_Environment*)hHandle)->GetCurrentDoc();\n\tif(pSDKDoc)\n\t{\n\t\tCPDF_Document* pDoc = pSDKDoc->GetDocument();\n\t\tCPDF_Dictionary* pDic = pDoc->GetRoot();\n\t\tif (!pDic)\n\t\t\treturn;\n\t\tCPDF_AAction aa = pDic->GetDict(FX_BSTRC(\"AA\"));\n\t\t\n\t\tif(aa.ActionExist((CPDF_AAction::AActionType)aaType))\n\t\t{\n\t\t\tCPDF_Action action = aa.GetAction((CPDF_AAction::AActionType)aaType);\n\t\t\tCPDFSDK_ActionHandler *pActionHandler = ((CPDFDoc_Environment*)hHandle)->GetActionHander();\n\t\t\tASSERT(pActionHandler != NULL);\n\t\t\tpActionHandler->DoAction_Document(action, (CPDF_AAction::AActionType)aaType, pSDKDoc);\n\t\t}\n\t}\n}\n",
        "answer": "/**\n* @brief Performs the document's additional action.\n*\n* This method is required for performing the document's additional-action.\n*\n* @param hHandle Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.\n* @param aaType The type of the additional-actions which defined above.\n*\n* @return NONE\n*\n* @comments This method will do nothing if there is no document additional-action corresponding to the specified aaType.\n*/\nDLLEXPORT void STDCALL FORM_DoDocumentAAction(FPDF_FORMHANDLE hHandle, int aaType);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void merge(const ValidatorResult &ToMerge) {\n    Type = std::max(Type, ToMerge.Type);\n    addParamsFrom(ToMerge);\n  }\n",
        "answer": "/** @brief Merges a result. This means to merge the parameters and to set the Type to the most specific Type that matches both.\n*\n* @param ToMerge The ValidatorResult to be merged with this one.\n*/\nvoid merge(const ValidatorResult &ToMerge) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isDimBoundedByConstant(isl::set Set, unsigned dim) {\n  auto ParamDims = Set.dim(isl::dim::param);\n  Set = Set.project_out(isl::dim::param, 0, ParamDims);\n  Set = Set.project_out(isl::dim::set, 0, dim);\n  auto SetDims = Set.dim(isl::dim::set);\n  Set = Set.project_out(isl::dim::set, 1, SetDims - 1);\n  return bool(Set.is_bounded());\n}\n",
        "answer": "/** @brief Checks if a dimension of a set is bounded by a constant.\n*\n* This function checks whether a dimension of a set is bounded (lower and upper) by a constant, i.e. there are two constants Min and Max, such that every value x of the chosen dimensions is Min <= x <= Max.\n*\n* @param Set The input set.\n* @param dim The dimension to check.\n* @return True if the dimension is bounded by a constant, false otherwise.\n*/\nstatic bool isDimBoundedByConstant(isl::set Set, unsigned dim) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isOrderedInstruction(Instruction *Inst) {\n  return Inst->mayHaveSideEffects() || Inst->mayReadOrWriteMemory();\n}\n",
        "answer": "/** @brief Determines if an instruction is ordered.\n*\n*  An unordered instruction is one that can be permuted without changing the semantics of the program. This function checks whether an instruction has any side effects or reads or writes memory, which are conditions for an instruction to be considered ordered.\n*\n* @param Inst The instruction to check.\n* @return True if the instruction is ordered, false otherwise.\n*/\nstatic bool isOrderedInstruction(Instruction *Inst) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool onlySameValueWrites(ScopStmt *Stmt) {\n  Value *V = nullptr;\n\n  for (auto *MA : *Stmt) {\n    if (!MA->isLatestArrayKind() || !MA->isMustWrite() ||\n        !MA->isOriginalArrayKind())\n      continue;\n\n    if (!V) {\n      V = MA->getAccessValue();\n      continue;\n    }\n\n    if (V != MA->getAccessValue())\n      return false;\n  }\n  return true;\n}\n",
        "answer": "/**\n* @brief Checks if all writes to an array are of the same value.\n*\n* This function checks if all writes to an array are of the same value, which is a common situation in Polybench's covariance/correlation (which is typical for algorithms that cover symmetric matrices).\n* For example, in the following code:\n* @code{.cpp}\n* for (int i = 0; i < n; i += 1) {\n*   for (int j = 0; j <= i; j += 1) {\n*     double x = ...;\n*     C[i][j] = x;\n*     C[j][i] = x;\n*   }\n* }\n* @endcode\n* For `i == j`, the same value is written twice to the same element. Double writes to the same element are not allowed in DeLICM because its algorithm does not see which of the writes is effective. But if it's the same value anyway, it doesn't matter. LLVM passes, however, cannot simplify this because the write is necessary for `i != j` (unless it would add a condition for one of the writes to occur only if `i != j`).\n*\n* @param Stmt The statement to check.\n* @return True if all writes to the array are of the same value, false otherwise.\n*/\nstatic bool onlySameValueWrites(ScopStmt *Stmt) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  unsigned getSliceAlign(Type *Ty = nullptr) {\r\n    unsigned NewAIAlign = NewAI.getAlignment();\r\n    if (!NewAIAlign)\r\n      NewAIAlign = DL.getABITypeAlignment(NewAI.getAllocatedType());\r\n    unsigned Align =\r\n        MinAlign(NewAIAlign, NewBeginOffset - NewAllocaBeginOffset);\r\n    return (Ty && Align == DL.getABITypeAlignment(Ty)) ? 0 : Align;\r\n  }\r\n",
        "answer": "/** @brief Get the alignment of a slice in an alloca.\n*\n* This function returns the alignment of a slice in an alloca, taking into account the alignment of the allocated type and the offset of the slice within the alloca.\n*\n* @param Ty The type of the slice. If this is not provided, the alignment will be calculated based on the allocated type and the offset of the slice.\n* @return The alignment of the slice in the alloca. If the alignment of the slice is equal to the ABI alignment of the type, 0 will be returned.\n*/\nunsigned getSliceAlign(Type *Ty = nullptr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void addInstruction(uint8_t Opcode) {\r\n    Instructions.push_back(Instruction(Opcode));\r\n  }\r\n",
        "answer": "/** @brief Adds a new instruction with the given opcode to the Instructions vector.\n*\n* This is a convenience method for adding a new instruction with the given opcode and no operands to the Instructions vector.\n*\n* @param Opcode The opcode of the instruction to add.\n*/\nvoid addInstruction(uint8_t Opcode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static unsigned CreateEmptyPHI(MachineBasicBlock *BB, unsigned NumPreds,\r\n                                 MachineSSAUpdater *Updater) {\r\n    MachineBasicBlock::iterator Loc = BB->empty() ? BB->end() : BB->begin();\r\n    MachineInstr *PHI = InsertNewDef(TargetOpcode::PHI, BB, Loc,\r\n                                     Updater->VRC, Updater->MRI,\r\n                                     Updater->TII);\r\n    return PHI->getOperand(0).getReg();\r\n  }\r\n",
        "answer": "/** @brief Create a PHI instruction that defines a new register. Add it into the specified block and return the register.\n*\n* This function creates an empty PHI instruction and adds it to the specified basic block. It then returns the register defined by the PHI instruction.\n*\n* @param BB The basic block to add the PHI instruction to.\n* @param NumPreds The number of predecessors for the PHI instruction.\n* @param Updater The machine SSA updater used to update the SSA form of the function.\n* @return The register defined by the PHI instruction.\n*/\nstatic unsigned CreateEmptyPHI(MachineBasicBlock *BB, unsigned NumPreds, MachineSSAUpdater *Updater) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void fixup_6_adiw(const MCFixup &Fixup, uint64_t &Value,\r\n                  MCContext *Ctx = nullptr) {\r\n  unsigned_width(6, Value, std::string(\"immediate\"), Fixup, Ctx);\r\n\r\n  Value = ((Value & 0x30) << 2) | (Value & 0x0f);\r\n}\r\n",
        "answer": "/** @brief 6-bit fixup for the immediate operand of the ADIW family of instructions. Resolves to: 0000 0000 kk00 kkkk\n*\n* This function is used to resolve the immediate operand of the ADIW family of instructions. It takes a MCFixup object and a uint64_t value as input, and returns the resolved value. The function uses the unsigned_width() function to check that the value is within the range of 6 bits. If it is not, an error is reported using the MCContext object.\n*\n* @param Fixup A MCFixup object containing information about the fixup.\n* @param Value A uint64_t value representing the immediate operand of the instruction.\n* @param Ctx An optional MCContext object that can be used to report errors.\n* @return The resolved value of the immediate operand, with the upper 2 bits set to zero and the lower 4 bits set to the original value.\n*/\nvoid fixup_6_adiw(const MCFixup &Fixup, uint64_t &Value, MCContext *Ctx = nullptr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AliasAttrs getAttrCaller() { return AttrCaller; }\r\n",
        "answer": "/** @brief Get the attribute caller.\n*\n*  This function returns the attribute caller, which represents whether the said pointer comes from a source not known to the current function but known to the caller. Values pointed to by the arguments of the current function have this attribute set.\n*\n* @return The attribute caller.\n*/\nAliasAttrs getAttrCaller() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isBitfieldDstMask(uint64_t DstMask, const APInt &BitsToBeInserted,\r\n                              unsigned NumberOfIgnoredHighBits, EVT VT) {\r\n  assert((VT == MVT::i32 || VT == MVT::i64) &&\r\n         \"i32 or i64 mask type expected!\");\r\n  unsigned BitWidth = VT.getSizeInBits() - NumberOfIgnoredHighBits;\r\n\r\n  APInt SignificantDstMask = APInt(BitWidth, DstMask);\r\n  APInt SignificantBitsToBeInserted = BitsToBeInserted.zextOrTrunc(BitWidth);\r\n\r\n  return (SignificantDstMask & SignificantBitsToBeInserted) == 0 &&\r\n         (SignificantDstMask | SignificantBitsToBeInserted).isAllOnesValue();\r\n}\r\n",
        "answer": "/** @brief Checks if the destination mask is complementary to the bits to be inserted.\n*\n*  This function checks whether DstMask zeroes precisely those bits that will be set by the other half.\n*\n* @param DstMask The destination mask.\n* @param BitsToBeInserted The bits to be inserted.\n* @param NumberOfIgnoredHighBits The number of high bits to ignore.\n* @param VT The type of the mask.\n* @return True if the destination mask is complementary, false otherwise.\n*/\nstatic bool isBitfieldDstMask(uint64_t DstMask, const APInt &BitsToBeInserted,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isUZP_v_undef_Mask(ArrayRef<int> M, EVT VT, unsigned &WhichResult) {\r\n  unsigned Half = VT.getVectorNumElements() / 2;\r\n  WhichResult = (M[0] == 0 ? 0 : 1);\r\n  for (unsigned j = 0; j != 2; ++j) {\r\n    unsigned Idx = WhichResult;\r\n    for (unsigned i = 0; i != Half; ++i) {\r\n      int MIdx = M[i + j * Half];\r\n      if (MIdx >= 0 && (unsigned)MIdx != Idx)\r\n        return false;\r\n      Idx += 2;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n",
        "answer": "/**\n* @brief Determines whether a mask is a special case of \"vector_shuffle v, undef\".\n*\n* This function checks if a given mask is a special case of the \"vector_shuffle v, undef\" instruction.\n* In this case, the mask should be in the form <0, 2, 0, 2> instead of <0, 2, 4, 6>.\n*\n* @param M The mask to check.\n* @param VT The vector type associated with the mask.\n* @param WhichResult A reference to an unsigned integer that will be set to the result of the check.\n* @return True if the mask is a special case of \"vector_shuffle v, undef\", false otherwise.\n*/\nstatic bool isUZP_v_undef_Mask(ArrayRef<int> M, EVT VT, unsigned &WhichResult) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isSuitableForMask(MachineInstr *&MI, unsigned SrcReg,\r\n                              int CmpMask, bool CommonUse) {\r\n  switch (MI->getOpcode()) {\r\n    case ARM::ANDri:\r\n    case ARM::t2ANDri:\r\n      if (CmpMask != MI->getOperand(2).getImm())\r\n        return false;\r\n      if (SrcReg == MI->getOperand(CommonUse ? 1 : 0).getReg())\r\n        return true;\r\n      break;\r\n  }\r\n\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Identify a suitable 'and' instruction that operates on the given source register and applies the same mask as a 'tst' instruction. Provide a limited look-through for copies. When successful, MI will hold the found instruction.\n*\n*  This function checks if an instruction is suitable for a mask by checking its opcode and operands. If the instruction is an 'and' or 't2ANDri' instruction with the same mask as the comparison mask, it returns true. Otherwise, it returns false.\n*\n* @param MI The machine instruction to check.\n* @param SrcReg The source register of the instruction.\n* @param CmpMask The comparison mask of the instruction.\n* @param CommonUse Whether the common use of the instruction is to compare with the mask or not.\n* @return True if the instruction is suitable for the mask, false otherwise.\n*/\nstatic bool isSuitableForMask(MachineInstr *&MI, unsigned SrcReg, int CmpMask, bool CommonUse) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uint32_t alignToARMConstant(uint32_t Value) {\r\n  unsigned Shifted = 0;\r\n\r\n  if (Value == 0)\r\n      return 0;\r\n\r\n  while (!(Value & 0xC0000000)) {\r\n      Value = Value << 2;\r\n      Shifted += 2;\r\n  }\r\n\r\n  bool Carry = (Value & 0x00FFFFFF);\r\n  Value = ((Value & 0xFF000000) >> 24) + Carry;\r\n\r\n  if (Value & 0x0000100)\r\n      Value = Value & 0x000001FC;\r\n\r\n  if (Shifted > 24)\r\n      Value = Value >> (Shifted - 24);\r\n  else\r\n      Value = Value << (24 - Shifted);\r\n\r\n  return Value;\r\n}\r\n",
        "answer": "/** @brief Aligns a value to the nearest ARM constant.\n*\n*  This function takes an unsigned 32-bit integer value and aligns it to the nearest ARM constant, which can be any value that can be produced by rotating an 8-bit value to the right by an even number of bits within a 32-bit word. The function returns the aligned value.\n*\n* @param Value The value to align to the nearest ARM constant.\n* @return The aligned value.\n*/\nstatic uint32_t alignToARMConstant(uint32_t Value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool allUsersAreInFunctions(const Value *V) {\r\n  SmallVector<const User*,4> Worklist;\r\n  for (auto *U : V->users())\r\n    Worklist.push_back(U);\r\n  while (!Worklist.empty()) {\r\n    auto *U = Worklist.pop_back_val();\r\n    if (isa<ConstantExpr>(U)) {\r\n      for (auto *UU : U->users())\r\n        Worklist.push_back(UU);\r\n      continue;\r\n    }\r\n\r\n    if (!isa<Instruction>(U))\r\n      return false;\r\n  }\r\n  return true;\r\n}\r\n",
        "answer": "/** @brief Checks whether all users of a value are within some function, looking through constant expressions.\n*\n* This function checks if there are any global constant users of the given value. It does this by iterating over the users of the value and checking if they are instructions or constant expressions. If a user is a constant expression, it adds its users to the worklist and continues. If a user is not an instruction, it returns false.\n*\n* @param V The value whose users will be checked.\n* @return True if all users of V are within some function, looking through constant expressions. False otherwise.\n*/\nstatic bool allUsersAreInFunctions(const Value *V) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void PrintLLVMName(raw_ostream &OS, const Value *V) {\r\n  PrintLLVMName(OS, V->getName(),\r\n                isa<GlobalValue>(V) ? GlobalPrefix : LocalPrefix);\r\n}\r\n",
        "answer": "/**\n* @brief Prints an LLVM name.\n*\n* This function takes a raw_ostream, a const Value pointer, and a string prefix. It then prints the LLVM name of the value to the output stream, using the specified prefix if necessary.\n*\n* @param OS The output stream to print to.\n* @param V The value to print.\n* @param Prefix The prefix to use for the LLVM name.\n*/\nstatic void PrintLLVMName(raw_ostream &OS, const Value *V) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned CountTerminators(MachineBasicBlock *MBB,\r\n                                 MachineBasicBlock::iterator &I) {\r\n  I = MBB->end();\r\n  unsigned NumTerms = 0;\r\n  while (true) {\r\n    if (I == MBB->begin()) {\r\n      I = MBB->end();\r\n      break;\r\n    }\r\n    --I;\r\n    if (!I->isTerminator()) break;\r\n    ++NumTerms;\r\n  }\r\n  return NumTerms;\r\n}\r\n",
        "answer": "/** @brief Count the number of terminators in the given block and set I to the position of the first non-terminator, if there is one, or MBB->end() otherwise.\n*\n*  This function counts the number of terminators in a given block and sets the iterator I to the position of the first non-terminator, if there is one, or MBB->end() otherwise.\n*\n* @param [in] MBB - A pointer to a MachineBasicBlock object.\n* @param [in,out] I - An iterator pointing to the current position in the block.\n* @return The number of terminators found in the block.\n*/\nstatic unsigned CountTerminators(MachineBasicBlock *MBB,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool makeBitReverse(Instruction &I, const DataLayout &DL,\r\n                           const TargetLowering &TLI) {\r\n  if (!I.getType()->isIntegerTy() ||\r\n      !TLI.isOperationLegalOrCustom(ISD::BITREVERSE,\r\n                                    TLI.getValueType(DL, I.getType(), true)))\r\n    return false;\r\n\r\n  SmallVector<Instruction*, 4> Insts;\r\n  if (!recognizeBSwapOrBitReverseIdiom(&I, false, true, Insts))\r\n    return false;\r\n  Instruction *LastInst = Insts.back();\r\n  I.replaceAllUsesWith(LastInst);\r\n  RecursivelyDeleteTriviallyDeadInstructions(&I);\r\n  return true;\r\n}\r\n",
        "answer": "/**\n* @brief Creates a bitreverse idiom if possible.\n*\n* This function checks whether an instruction is an OR instruction and, if so,\n* it checks to see if it can be replaced with a bitreverse intrinsic. If the\n* instruction can be replaced, the new intrinsic is inserted and true is returned.\n* Otherwise, false is returned.\n*\n* @param I The instruction to check.\n* @param DL The data layout of the module.\n* @param TLI The target lowering interface for the current target.\n*\n* @return True if a bitreverse idiom was created, false otherwise.\n*/\nstatic bool makeBitReverse(Instruction &I, const DataLayout &DL,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMTypeRef LLVM_STDCALL LLVMArrayType(LLVMTypeRef ElementType, unsigned ElementCount) {\r\n  return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\r\n}\r\n",
        "answer": "/** @brief Creates a fixed size array type that refers to a specific type.\n*\n* This function creates a fixed size array type that refers to a specific type, which exists in the context of its element type.\n*\n* @param ElementType The type of elements in the array.\n* @param ElementCount The number of elements in the array.\n* @return A fixed size array type that refers to the specified type.\n*/\nLLVMTypeRef LLVM_STDCALL LLVMArrayType(LLVMTypeRef ElementType, unsigned ElementCount) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LLVM_STDCALL LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest) {\r\n  auto *MD = cast<MetadataAsValue>(unwrap(V));\r\n  if (auto *MDV = dyn_cast<ValueAsMetadata>(MD->getMetadata())) {\r\n    *Dest = wrap(MDV->getValue());\r\n    return;\r\n  }\r\n  const auto *N = cast<MDNode>(MD->getMetadata());\r\n  const unsigned numOperands = N->getNumOperands();\r\n  LLVMContext &Context = unwrap(V)->getContext();\r\n  for (unsigned i = 0; i < numOperands; i++)\r\n    Dest[i] = getMDNodeOperandImpl(Context, N, i);\r\n}\r\n",
        "answer": "/** @brief Obtain the given MDNode's operands.\n*\n*  This function obtains the operands of a given MDNode. The passed LLVMValueRef pointer should point to enough memory to hold all of the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the MDNode's operands.\n*\n* @param V The LLVMValueRef pointer that points to the MDNode whose operands are to be obtained.\n* @param Dest The LLVMValueRef pointer that points to enough memory to hold all of the operands of the given MDNode as LLVMValueRefs.\n* @return Should not return\n*/\n*Dest = wrap(MDV->getValue());\nreturn;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LLVM_STDCALL LLVMDeleteBasicBlock(LLVMBasicBlockRef BBRef) {\r\n  unwrap(BBRef)->eraseFromParent();\r\n}\r\n",
        "answer": "/** @brief Deletes a basic block from a function and deletes the basic block itself.\n*\n* This function removes a basic block from its containing function and deletes the basic block itself.\n*\n* @param BBRef A reference to the basic block to be deleted.\n*/\nvoid LLVM_STDCALL LLVMDeleteBasicBlock(LLVMBasicBlockRef BBRef) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMBasicBlockRef LLVM_STDCALL LLVMGetSwitchDefaultDest(LLVMValueRef Switch) {\r\n  return wrap(unwrap<SwitchInst>(Switch)->getDefaultDest());\r\n}\r\n",
        "answer": "/** @brief Obtain the default destination basic block of a switch instruction.\n*\n* This function returns the default destination basic block of a switch instruction. It only works on llvm::SwitchInst instructions.\n*\n* @param Switch The switch instruction for which to get the default destination basic block.\n* @return The default destination basic block of the switch instruction.\n*/\nLLVMBasicBlockRef LLVM_STDCALL LLVMGetSwitchDefaultDest(LLVMValueRef Switch) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned NumRetVals(const Function *F) {\r\n  Type *RetTy = F->getReturnType();\r\n  if (RetTy->isVoidTy())\r\n    return 0;\r\n  else if (StructType *STy = dyn_cast<StructType>(RetTy))\r\n    return STy->getNumElements();\r\n  else if (ArrayType *ATy = dyn_cast<ArrayType>(RetTy))\r\n    return ATy->getNumElements();\r\n  else\r\n    return 1;\r\n}\r\n",
        "answer": "/** @brief Convenience function that returns the number of return values.\n*\n* This is a static function that takes in a pointer to a Function object as its parameter. It returns an unsigned integer representing the number of return values. If the function returns void, it will return 0. If the function does not return a struct, it will return 1. If the function returns a struct, it will return the number of elements in the struct.\n*\n* @param F A pointer to a Function object.\n* @return An unsigned integer representing the number of return values.\n*/\nstatic unsigned NumRetVals(const Function *F) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool IsSafeComputationToRemove(Value *V, const TargetLibraryInfo *TLI) {\r\n  do {\r\n    if (isa<Constant>(V))\r\n      return true;\r\n    if (!V->hasOneUse())\r\n      return false;\r\n    if (isa<LoadInst>(V) || isa<InvokeInst>(V) || isa<Argument>(V) ||\r\n        isa<GlobalValue>(V))\r\n      return false;\r\n    if (isAllocationFn(V, TLI))\r\n      return true;\r\n\r\n    Instruction *I = cast<Instruction>(V);\r\n    if (I->mayHaveSideEffects())\r\n      return false;\r\n    if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {\r\n      if (!GEP->hasAllConstantIndices())\r\n        return false;\r\n    } else if (I->getNumOperands() != 1) {\r\n      return false;\r\n    }\r\n\r\n    V = I->getOperand(0);\r\n  } while (true);\r\n}\r\n",
        "answer": "/**\n* @brief Determines whether it is safe to remove a computation that stores a value to a global variable.\n*\n* This function checks if the given value is stored to a global but never read, and determines whether it's safe to remove the store and the chain of computation that feeds the store.\n*\n* @param V The value to check.\n* @param TLI The target library info.\n*\n* @return True if it is safe to remove the computation, false otherwise.\n*/\nstatic bool IsSafeComputationToRemove(Value *V, const TargetLibraryInfo *TLI) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline void parseOperands(const MachineInstr &MI,\r\n      SmallVector<unsigned, 4> &Defs, SmallVector<unsigned, 8> &Uses) {\r\n  Defs.clear();\r\n  Uses.clear();\r\n\r\n  for (unsigned i = 0, e = MI.getNumOperands(); i != e; ++i) {\r\n    const MachineOperand &MO = MI.getOperand(i);\r\n\r\n    if (!MO.isReg())\r\n      continue;\r\n\r\n    unsigned Reg = MO.getReg();\r\n    if (!Reg)\r\n      continue;\r\n\r\n    if (MO.isUse())\r\n      Uses.push_back(MO.getReg());\r\n\r\n    if (MO.isDef())\r\n      Defs.push_back(MO.getReg());\r\n  }\r\n}\r\n",
        "answer": "/** @brief Parse operands from a MachineInstr.\n*\n* This function gathers register def/uses from a MachineInstr, treating possible (predicated) defs as actually happening ones (conservatively).\n*\n* @param MI The MachineInstr to parse.\n* @param Defs A vector of unsigned integers representing the defs.\n* @param Uses A vector of unsigned integers representing the uses.\n*/\nvoid parseOperands(const MachineInstr &MI, SmallVector<unsigned, 4> &Defs, SmallVector<unsigned, 8> &Uses) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool allocaWouldBeStaticInEntry(const AllocaInst *AI ) {\r\n  return isa<Constant>(AI->getArraySize()) && !AI->isUsedWithInAlloca();\r\n}\r\n",
        "answer": "/** @brief Determines if an alloca would be static in the entry block.\n*\n*  This function checks if an alloca instruction, AI, would be static if it were moved to the entry block. Allocas used in inalloca calls and allocas of dynamic array size cannot be static.\n*\n* @param AI The alloca instruction to check.\n* @return True if the alloca would be static in the entry block, false otherwise.\n*/\nstatic bool allocaWouldBeStaticInEntry(const AllocaInst *AI) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool pointsToConstantGlobal(Value *V) {\r\n  if (GlobalVariable *GV = dyn_cast<GlobalVariable>(V))\r\n    return GV->isConstant();\r\n\r\n  if (ConstantExpr *CE = dyn_cast<ConstantExpr>(V)) {\r\n    if (CE->getOpcode() == Instruction::BitCast ||\r\n        CE->getOpcode() == Instruction::AddrSpaceCast ||\r\n        CE->getOpcode() == Instruction::GetElementPtr)\r\n      return pointsToConstantGlobal(CE->getOperand(0));\r\n  }\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Determines if a value points to some part of a constant global variable.\n*\n*  This function checks whether the given value V (possibly indirectly) points to some part of a constant global variable. It intentionally only accepts constant expressions because we can't rewrite arbitrary instructions.\n*\n* @param V The value to check.\n* @return True if V (possibly indirectly) points to some part of a constant global variable, false otherwise.\n*/\nstatic bool pointsToConstantGlobal(Value *V) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMBool LLVM_STDCALL LLVMParseIRInContext(LLVMContextRef ContextRef,\r\n                              LLVMMemoryBufferRef MemBuf, LLVMModuleRef *OutM,\r\n                              char **OutMessage) {\r\n  SMDiagnostic Diag;\r\n\r\n  std::unique_ptr<MemoryBuffer> MB(unwrap(MemBuf));\r\n  *OutM =\r\n      wrap(parseIR(MB->getMemBufferRef(), Diag, *unwrap(ContextRef)).release());\r\n\r\n  if(!*OutM) {\r\n    if (OutMessage) {\r\n      std::string buf;\r\n      raw_string_ostream os(buf);\r\n\r\n      Diag.print(nullptr, os, false);\r\n      os.flush();\r\n\r\n      *OutMessage = strdup(buf.c_str());\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n",
        "answer": "*OutM =\n*OutMessage = strdup(buf.c_str());\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool CanMergeValues(Value *First, Value *Second) {\r\n  return First == Second || isa<UndefValue>(First) || isa<UndefValue>(Second);\r\n}\r\n",
        "answer": "/** @brief Determines if two values can be merged.\n*\n* This function returns true if we can choose one of these values to use in place of the other. Note that we will always choose the non-undef value to keep.\n*\n* @param First The first value to compare.\n* @param Second The second value to compare.\n* @return True if the values can be merged, false otherwise.\n*/\nstatic bool CanMergeValues(Value *First, Value *Second) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void lto_module_dispose(lto_module_t mod) { delete unwrap(mod); }\r\n",
        "answer": "/** @brief Frees all memory internally allocated by the module. Upon return the lto_module_t is no longer valid.\n*\n*  This function frees all memory internally allocated by the module, including any data structures or buffers that were created during the lifetime of the module. Upon return, the lto_module_t is no longer valid and should not be used.\n*\n* @param mod The lto_module_t to dispose.\n*/\nvoid lto_module_dispose(lto_module_t mod) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool lto_codegen_compile_to_file(lto_code_gen_t cg, const char **name) {\r\n  maybeParseOptions(cg);\r\n  return !unwrap(cg)->compile_to_file(\r\n      name, DisableVerify, DisableInline, DisableGVNLoadPRE,\r\n      DisableLTOVectorization);\r\n}\r\n",
        "answer": "/** @brief Generates code for all added modules into one native object file.\n*\n* This function calls lto_codegen_optimize then lto_codegen_compile_optimized (instead of returning a generated mach-o/ELF buffer, it writes to a file). The name of the file is written to name. Returns true on error.\n*\n* @param cg The LTO code generation object.\n* @param name The name of the output file.\n* @return True if there was an error, false otherwise.\n*/\nbool lto_codegen_compile_to_file(lto_code_gen_t cg, const char **name) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void thinlto_codegen_add_must_preserve_symbol(thinlto_code_gen_t cg,\r\n                                              const char *Name, int Length) {\r\n  unwrap(cg)->preserveSymbol(StringRef(Name, Length));\r\n}\r\n",
        "answer": "/** @brief Adds a symbol to the list of global symbols that must exist in the final generated code.\n*\n*  This function adds a symbol to the list of global symbols that must exist in the final generated code. If a function is not listed there, it might be inlined into every usage and optimized away. For every single module, the functions referenced from code outside of the ThinLTO modules need to be added here.\n*\n* @param cg The thinlto_code_gen_t object that represents the code generation context.\n* @param Name The name of the symbol to add.\n* @param Length The length of the symbol name.\n*/\nvoid thinlto_codegen_add_must_preserve_symbol(thinlto_code_gen_t cg, const char *Name, int Length) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,\r\n                       unsigned &InitVal, unsigned &LoopVal) {\r\n  assert(Phi.isPHI() && \"Expecting a Phi.\");\r\n\r\n  InitVal = 0;\r\n  LoopVal = 0;\r\n  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)\r\n    if (Phi.getOperand(i + 1).getMBB() != Loop)\r\n      InitVal = Phi.getOperand(i).getReg();\r\n    else\r\n      LoopVal = Phi.getOperand(i).getReg();\r\n\r\n  assert(InitVal != 0 && LoopVal != 0 && \"Unexpected Phi structure.\");\r\n}\r\n",
        "answer": "/**\n* @brief Get the register values for the operands of a Phi instruction.\n*\n* This function assumes that the instruction is a Phi and returns the register\n* values for its operands.\n*\n* @param Phi The Phi instruction to get the operand registers for.\n* @param Loop The loop basic block associated with the Phi instruction.\n* @param InitVal The initial value of the Phi instruction's first operand.\n* @param LoopVal The loop value of the Phi instruction's second operand.\n*/\nstatic void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool checkResourceLimit(unsigned LFactor, unsigned Count,\r\n                               unsigned Latency) {\r\n  return (int)(Count - (Latency * LFactor)) > (int)LFactor;\r\n}\r\n",
        "answer": "/** @brief Checks if a SchedBoundary becomes resource limited based on the given Count of resource usage and Latency value.\n*\n*  Given a Count of resource usage and a Latency value, return true if a SchedBoundary becomes resource limited.\n*\n* @param[in] LFactor The factor used to calculate the resource limit.\n* @param[in] Count The count of resource usage.\n* @param[in] Latency The latency value.\n* @return True if a SchedBoundary becomes resource limited, false otherwise.\n*/\nstatic bool checkResourceLimit(unsigned LFactor, unsigned Count,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned getMatchingLoType(const ELFRelocationEntry &Reloc) {\r\n  unsigned Type = Reloc.Type;\r\n  if (Type == ELF::R_MIPS_HI16)\r\n    return ELF::R_MIPS_LO16;\r\n  if (Type == ELF::R_MICROMIPS_HI16)\r\n    return ELF::R_MICROMIPS_LO16;\r\n  if (Type == ELF::R_MIPS16_HI16)\r\n    return ELF::R_MIPS16_LO16;\r\n\r\n  if (Reloc.OriginalSymbol->getBinding() != ELF::STB_LOCAL)\r\n    return ELF::R_MIPS_NONE;\r\n\r\n  if (Type == ELF::R_MIPS_GOT16)\r\n    return ELF::R_MIPS_LO16;\r\n  if (Type == ELF::R_MICROMIPS_GOT16)\r\n    return ELF::R_MICROMIPS_LO16;\r\n  if (Type == ELF::R_MIPS16_GOT16)\r\n    return ELF::R_MIPS16_LO16;\r\n\r\n  return ELF::R_MIPS_NONE;\r\n}\r\n",
        "answer": "/**\n* @brief Determine the low relocation that matches the given relocation.\n*\n* This function determines the low relocation that matches the given relocation,\n* based on the type of the relocation and the binding of the symbol it refers to.\n* If the relocation does not need a low part, the return value is ELF::R_MIPS_NONE.\n* The relocations that need a matching low part are R_(MIPS|MICROMIPS|MIPS16)_HI16\n* for all symbols and R_(MIPS|MICROMIPS|MIPS16)_GOT16 for local symbols only.\n*\n* @param Reloc The relocation to match.\n* @return The matching low relocation, or ELF::R_MIPS_NONE if no low part is needed.\n*/\nstatic unsigned getMatchingLoType(const ELFRelocationEntry &Reloc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LLVM_STDCALL LLVMOrcDisposeSharedModuleRef(LLVMSharedModuleRef SharedMod) {\r\n  delete unwrap(SharedMod);\r\n}\r\n",
        "answer": "/** @brief Dispose of a shared module. The module should not be accessed after this call. The module will be deleted once all clients (including the JIT itself) have released their shared pointers.\n*/\nvoid LLVM_STDCALL LLVMOrcDisposeSharedModuleRef(LLVMSharedModuleRef SharedMod);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool symbolOpensScope(SymbolKind Kind) {\r\n  switch (Kind) {\r\n  case SymbolKind::S_GPROC32:\r\n  case SymbolKind::S_LPROC32:\r\n  case SymbolKind::S_LPROC32_ID:\r\n  case SymbolKind::S_GPROC32_ID:\r\n  case SymbolKind::S_BLOCK32:\r\n  case SymbolKind::S_SEPCODE:\r\n  case SymbolKind::S_THUNK32:\r\n  case SymbolKind::S_INLINESITE:\r\n  case SymbolKind::S_INLINESITE2:\r\n    return true;\r\n  default:\r\n    break;\r\n  }\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Determines if a symbol opens a scope.\n*\n* This function returns true if the given SymbolKind is one that opens a scope, and false otherwise.\n* A symbol that opens a scope has \"parent\" and \"end\" fields, which contain the offset of the S_END or S_INLINESITE_END record.\n*\n* @param Kind The SymbolKind to check.\n* @return True if the given SymbolKind opens a scope, false otherwise.\n*/\nstatic bool symbolOpensScope(SymbolKind Kind) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isConstantOrUndef(int Op, int Val) {\r\n  return Op < 0 || Op == Val;\r\n}\r\n",
        "answer": "/** @brief Check if the given value is either an undef node or a constant SD node.\n*\n* This function checks if the given value, Op, is either an undef node or a constant SD node. If it is, it returns true.\n*\n* @param Op The value to check.\n* @param Val The value to compare against.\n*\n* @return True if Op is undef or matches Val, false otherwise.\n*/\nstatic bool isConstantOrUndef(int Op, int Val) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isSplitEdge(const MachineBasicBlock *MBB) {\r\n  if (MBB->pred_size() != 1 || MBB->succ_size() != 1)\r\n    return false;\r\n\r\n  for (const auto &MI : *MBB) {\r\n    if (!MI.isCopyLike() && !MI.isUnconditionalBranch())\r\n      return false;\r\n  }\r\n  return true;\r\n}\r\n",
        "answer": "/** @brief Determines whether a machine basic block should be vacated by the coalescer to eliminate branches.\n*\n* This function checks if the given machine basic block is a split edge that contains only copies and unconditional branches. If it is, then it returns true, indicating that the block should be vacated. Otherwise, it returns false.\n*\n* @param MBB The machine basic block to check.\n* @return True if the block should be vacated by the coalescer, or false otherwise.\n*/\nstatic bool isSplitEdge(const MachineBasicBlock *MBB) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline bool isGlobalMemoryObject(AliasAnalysis *AA, MachineInstr *MI) {\r\n  return MI->isCall() || MI->hasUnmodeledSideEffects() ||\r\n         (MI->hasOrderedMemoryRef() && !MI->isDereferenceableInvariantLoad(AA));\r\n}\r\n",
        "answer": "/** @brief Check if a machine instruction is an instruction we are unable to reason about.\n*\n*  This function checks if the given machine instruction (MI) is an instruction that we are unable to reason about, such as a call or an instruction with unmodeled side effects.\n*\n* @param AA The alias analysis object used to determine if the memory reference is dereferenceable.\n* @param MI The machine instruction to check.\n* @return True if the given machine instruction is an instruction we are unable to reason about, false otherwise.\n*/\nstatic inline bool isGlobalMemoryObject(AliasAnalysis *AA, MachineInstr *MI) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SDValue GetSignificand(SelectionDAG &DAG, SDValue Op, const SDLoc &dl) {\r\n  SDValue t1 = DAG.getNode(ISD::AND, dl, MVT::i32, Op,\r\n                           DAG.getConstant(0x007fffff, dl, MVT::i32));\r\n  SDValue t2 = DAG.getNode(ISD::OR, dl, MVT::i32, t1,\r\n                           DAG.getConstant(0x3f800000, dl, MVT::i32));\r\n  return DAG.getNode(ISD::BITCAST, dl, MVT::f32, t2);\r\n}\r\n",
        "answer": "/** @brief Get the significand and build it into a floating-point number with exponent of 1.\n*\n* This function extracts the significand from the input floating-point value and builds a new floating-point number with an exponent of 1.\n* The operation is performed as follows: Op = (Op & 0x007fffff) | 0x3f800000; where Op is the hexadecimal representation of the floating point value.\n*\n* @param DAG The SelectionDAG object representing the current selection context.\n* @param Op The input floating-point value to be processed.\n* @param dl The debug location for the operation.\n* @return The resulting floating-point value with an exponent of 1.\n*/\nstatic SDValue GetSignificand(SelectionDAG &DAG, SDValue Op, const SDLoc &dl) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned ComputeSpeculationCost(const User *I,\r\n                                       const TargetTransformInfo &TTI) {\r\n  assert(isSafeToSpeculativelyExecute(I) &&\r\n         \"Instruction is not safe to speculatively execute!\");\r\n  return TTI.getUserCost(I);\r\n}\r\n",
        "answer": "/**\n* @brief Computes the speculation cost of an instruction.\n*\n* This function computes the abstract \"cost\" of speculating the given\n* instruction, which is assumed to be safe to speculate. The cost can be one of\n* three values: TCC_Free, TCC_Basic, or TCC_Expensive.\n*\n* @param I The instruction to compute the speculation cost for.\n* @param TTI The TargetTransformInfo object containing information about the\n*        target architecture.\n* @return The speculation cost of the instruction.\n*/\nstatic unsigned ComputeSpeculationCost(const User *I, const TargetTransformInfo &TTI) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool tryAddingSymbolicOperand(int64_t Value, bool isBranch,\r\n                                     uint64_t Address, uint64_t Offset,\r\n                                     uint64_t Width, MCInst &MI,\r\n                                     const void *Decoder) {\r\n  const MCDisassembler *Dis = static_cast<const MCDisassembler*>(Decoder);\r\n  return Dis->tryAddingSymbolicOperand(MI, Value, Address, isBranch,\r\n                                       Offset, Width);\r\n}\r\n",
        "answer": "/** @brief tryAddingSymbolicOperand - trys to add a symbolic operand in place of the immediate Value in the MCInst.\n*\n*  This function tries to add a symbolic operand in place of the immediate value in the MCInst.\n*\n* @param[in] Value The immediate value to be replaced with a symbolic operand.\n* @param[in] isBranch Whether the instruction is a branch instruction or not.\n* @param[in] Address The address of the instruction.\n* @param[in] Offset The offset of the immediate value in the instruction.\n* @param[in] Width The width of the immediate value in bits.\n* @param[out] MI The MCInst object to add the symbolic operand to.\n* @param[in] Decoder The decoder object used to disassemble the instruction.\n*\n* @return Whether the symbolic operand was successfully added or not.\n*/\nstatic bool tryAddingSymbolicOperand(int64_t Value, bool isBranch, uint64_t Address, uint64_t Offset, uint64_t Width, MCInst &MI, const void *Decoder) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "char* LLVM_STDCALL LLVMGetTargetMachineTriple(LLVMTargetMachineRef T) {\r\n  std::string StringRep = unwrap(T)->getTargetTriple().str();\r\n  return strdup(StringRep.c_str());\r\n}\r\n",
        "answer": "/** @brief Returns the triple used creating this target machine. See llvm::TargetMachine::getTriple. The result needs to be disposed with LLVMDisposeMessage.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param T The target machine reference.\n* @return The triple used creating this target machine.\n*/\nchar* LLVM_STDCALL LLVMGetTargetMachineTriple(LLVMTargetMachineRef T) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static IdentifyingPassPtr applyDisable(IdentifyingPassPtr PassID,\r\n                                       bool Override) {\r\n  if (Override)\r\n    return IdentifyingPassPtr();\r\n  return PassID;\r\n}\r\n",
        "answer": "/** @brief Apply disable command line option to a pass.\n*\n* This function allows standard passes to be disabled by command line options.\n* It supports simple binary flags that either suppress the pass or do nothing.\n* i.e. -disable-mypass=false has no effect. These should be converted to boolOrDefault\n* in order to use applyOverride.\n*\n* @param PassID The pass identifier.\n* @param Override Whether to override the pass with a null pointer if disabled.\n* @return The pass pointer, or a null pointer if disabled and overridden.\n*/\nstatic IdentifyingPassPtr applyDisable(IdentifyingPassPtr PassID, bool Override) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned convertToNonSPOpcode(unsigned Opcode) {\r\n  switch (Opcode) {\r\n  case ARM::tLDRspi:\r\n    return ARM::tLDRi;\r\n\r\n  case ARM::tSTRspi:\r\n    return ARM::tSTRi;\r\n  }\r\n\r\n  return Opcode;\r\n}\r\n",
        "answer": "/** @brief Convert the opcode to the non-SP version, because we're replacing the frame index with a non-SP register.\n*\n*  This function changes the opcode to the non-SP version, which is necessary when we're replacing the frame index with a non-SP register.\n*\n* @param Opcode The original opcode.\n* @return The converted opcode.\n*/\nstatic unsigned convertToNonSPOpcode(unsigned Opcode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool rangeMetadataExcludesValue(const MDNode* Ranges, const APInt& Value) {\r\n  const unsigned NumRanges = Ranges->getNumOperands() / 2;\r\n  assert(NumRanges >= 1);\r\n  for (unsigned i = 0; i < NumRanges; ++i) {\r\n    ConstantInt *Lower =\r\n        mdconst::extract<ConstantInt>(Ranges->getOperand(2 * i + 0));\r\n    ConstantInt *Upper =\r\n        mdconst::extract<ConstantInt>(Ranges->getOperand(2 * i + 1));\r\n    ConstantRange Range(Lower->getValue(), Upper->getValue());\r\n    if (Range.contains(Value))\r\n      return false;\r\n  }\r\n  return true;\r\n}\r\n",
        "answer": "/** @brief Checks whether the 'Range' metadata excludes a given value.\n*\n* This function checks if the 'Range' metadata, which must be a valid MD_range operand list,\n* ensures that the value it's attached to is never equal to Value. The RangeType parameter\n* specifies the type of the value described by the range.\n*\n* @param Ranges The 'Range' metadata to check.\n* @param Value The value to check for exclusion.\n* @param RangeType The type of the value described by the range.\n* @return True if the value is excluded, false otherwise.\n*/\nstatic bool rangeMetadataExcludesValue(const MDNode* Ranges, const APInt& Value, const Type* RangeType) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uint8_t byteFromBitsInit(BitsInit &init) {\r\n  int width = init.getNumBits();\r\n\r\n  assert(width <= 8 && \"Field is too large for uint8_t!\");\r\n\r\n  int     index;\r\n  uint8_t mask = 0x01;\r\n\r\n  uint8_t ret = 0;\r\n\r\n  for (index = 0; index < width; index++) {\r\n    if (static_cast<BitInit*>(init.getBit(index))->getValue())\r\n      ret |= mask;\r\n\r\n    mask <<= 1;\r\n  }\r\n\r\n  return ret;\r\n}\r\n",
        "answer": "/** @brief Extracts a value at most 8 bits in width from a BitsInit. Useful for switch statements and the like.\n*\n* This function extracts a value of at most 8 bits in width from a BitsInit, which is useful for switch statements and the like. It first checks that the field is not too large for a uint8_t, asserting if it is. It then initializes an index variable to 0 and a mask variable to 0x01. It also initializes a ret variable to 0.\n*\n* The function then enters a loop where it checks each bit in the BitsInit using the getBit() method, casting the result to a BitInit pointer. If the value of this bit is true, the function sets the corresponding bit in the ret variable to 1 using the |= operator. It then shifts the mask variable left by one bit and increments the index variable.\n*\n* The function returns the ret variable as its result.\n*\n* @param init A reference to a BitsInit object from which to extract the value.\n* @return The extracted value, at most 8 bits in width.\n*/\nstatic uint8_t byteFromBitsInit(BitsInit &init) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int sdl_thread_functor(void *instance)\n{\n  reinterpret_cast<T *>(instance)->operator()();\n  return 0;\n}\n",
        "answer": "/** @brief Wrap a function object of type T as an SDL thread function, suitable for a call to SDL_CreateThread. Define function object as a class with T::operator()(void).\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nint sdl_thread_functor(void *instance)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void processObject(JNIEnv* jenv, JNIContext* jniContext, KernelArg* arg, int& argPos, int argIdx) {\n    if(arg->isArray()) {\n       processArray(jenv, jniContext, arg, argPos, argIdx);\n    } else if(arg->isAparapiBuffer()) {\n       processBuffer(jenv, jniContext, arg, argPos, argIdx);\n    }\n}\n",
        "answer": "/** @brief Processes an object in the kernel.\n*\n*  This function processes an object in the kernel by checking if it is an array or a Aparapi buffer, and calling the appropriate function to handle it.\n*\n* @param jenv The JNI environment.\n* @param jniContext The JNI context.\n* @param arg The kernel argument.\n* @param argPos The position of the argument in the kernel.\n* @param argIdx The index of the argument in the kernel.\n*/\nvoid processObject(JNIEnv* jenv, JNIContext* jniContext, KernelArg* arg, int& argPos, int argIdx) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool sameSignNoZero(float a, float b)\n    {\n        return a*b > 0.0f;\n    }\n",
        "answer": "/** @brief Checks if two floats have the same sign but are not equal to zero.\n*\n* This function takes in two float values and checks if they have the same sign, but are not equal to zero.\n* It returns a boolean value indicating whether this condition is true or false.\n*\n* @param[in] a The first float value.\n* @param[in] b The second float value.\n* @return True if both values have the same sign and are not equal to zero, False otherwise.\n*/\nbool sameSignNoZero(float a, float b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void initialize() {\r\n  motors::slew::init();\r\n  drive::init();\r\n  sensors::init();\r\n  pid::init();\r\n}\r\n",
        "answer": "/** @brief Initializes the robot.\n*\n*  This function initializes the robot by running user initialization code. It is started in its own task with the default priority and stack size once when the robot is starting up. It initializes most sensors (gyro, encoders, ultrasonics), LCDs, global variables, and IMEs. This function must exit relatively promptly, or the operatorControl() and autonomous() tasks will not start. An autonomous mode selection menu like the pre_auton() in other environments can be implemented in this task if desired.\n*\n* @return Should not return\n*/\nvoid initialize() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void onDone()\n    {\n        if(!g_ShowOnlyErrors)\n        {\n            fprintf(stdout,\n                    \"    Sequence is done.\\n\");\n        }\n        g_bSeqFinished = true;\n    };\n",
        "answer": "/** @brief Sequence finished callback.\n*\n* This gets called when the sequence thread is stopped - either by naturally ending or by a call to stopSequence. Use this function to return any outputs to safe states.\n*\n* @return Should not return\n*/\nvoid onDone()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MT_DrawArrow(const MT_R3& center, float length, float orientation, const MT_Color& color, float fixed_width)\n{\n  \n    MT_GLTranslatefv(center);\n    glColor3fv(color);\n    glRotatef(MT_RAD2DEG*orientation, 0, 0, 1);\n  \n    MT_DrawArrow(length, fixed_width);\n  \n    glRotatef(-MT_RAD2DEG*orientation, 0, 0, 1);\n    MT_GLTranslatefv(center*(-1.0));\n  \n}\n",
        "answer": "/** @brief Draws an arrow at a given location with a given orientation, length, color, and (potentially) width.\n*\n*  If fixed_width < 0, a width is chosen automatically.\n*\n* @param center The center of the arrow.\n* @param length The length of the arrow.\n* @param orientation The orientation of the arrow.\n* @param color The color of the arrow.\n* @param fixed_width The fixed width of the arrow, or -1 if a width should be chosen automatically.\n*/\nvoid MT_DrawArrow(const MT_R3& center, float length, float orientation, const MT_Color& color, float fixed_width)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MT_UKFSetState(MT_UKF_struct* pUKF, CvMat* x_set)\n{\n    if(!x_set || (x_set->rows != (int) pUKF->n) || (x_set->cols != 1))\n    {\n        fprintf(stderr,\n                \"MT_UKFSetState Error:  x_set is the wrong \"\n                \"size or not initialized\\n\");\n        return;\n    }\n\n    cvCopy(x_set, pUKF->x);\n}\n",
        "answer": "/** @brief Force setting the state of the UKF. For example, initial conditions. Checks to make sure the size of the state is correct.\n*\n* @param pUKF A pointer to an MT_UKF_struct object that represents the UKF.\n* @param x_set A CvMat object that contains the new state values.\n* @return None.\n*/\nvoid MT_UKFSetState(MT_UKF_struct* pUKF, CvMat* x_set)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "wxString MT_wxStringFromTextFile(wxString filename)\n{\n    FILE* fp = fopen((const char*) filename.mb_str(),\"r\");\n    if(!fp)\n    {\n        return wxT(\"Error opening or reading from \") + filename + wxT(\"\\n\");\n    }\n  \n    wxString result = wxT(\"\");\n  \n    char t;\n    while(!feof(fp))\n    {\n        fscanf(fp, \"%c\", &t);\n        result = result + (wxChar) t;\n    }\n  \n    return result;\n  \n}\n",
        "answer": "/** @brief Reads a text file into a wxString.\n*\n*  This function reads the contents of a text file and returns it as a wxString.\n*  If there is an error reading from the file, an error message will be returned in the string.\n*\n* @param filename The name of the text file to read.\n* @return A wxString containing the contents of the text file, or an error message if there was an error reading from the file.\n*/\nwxString MT_wxStringFromTextFile(wxString filename)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t carla_read_control(\n      CarlaServerPtr self,\n      carla_control &values,\n      const uint32_t timeout) {\n  CARLA_PROFILE_SCOPE(C_API, ReadControl);\n  auto agent = Cast(self)->GetAgentServer();\n  if (agent == nullptr) {\n    log_debug(\"trying to read control but agent server is missing\");\n    return CARLA_SERVER_OPERATION_ABORTED;\n  }\n  return agent->ReadControl(values, timeout_t::milliseconds(timeout)).value();\n}\n",
        "answer": "/** @brief Reads control values from the CARLA server.\n*\n* This function reads control values from the CARLA server using a given timeout.\n* If no value is received within the specified time, it returns CARLA_SERVER_TRY_AGAIN.\n* If an agent server is missing, it returns CARLA_SERVER_OPERATION_ABORTED.\n* Otherwise, it returns CARLA_SERVER_SUCCESS and sets the values parameter to the read control values.\n*\n* @param self The CarlaServerPtr object.\n* @param values A reference to a carla_control object where the read control values will be stored.\n* @param timeout The maximum time in milliseconds to wait for a response from the server.\n* @return CARLA_SERVER_SUCCESS if a value was read, CARLA_SERVER_TRY_AGAIN if no value was received within the specified time, or CARLA_SERVER_OPERATION_ABORTED if an agent server is missing.\n*/\nint32_t carla_read_control(CarlaServerPtr self, carla_control &values, const uint32_t timeout) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ArrayRemoveObjectAtIndex(Array *arr, std::size_t index, bool releaseObj/* = true*/)\n{\n    if ((arr && arr->num > 0 && index >= 0 && index < arr->num) == false) {\n        ofLogError(\"ofxActionManager\") << __FUNCTION__ << \": Invalid index. Out of bounds\";\n        return;\n    }\n\n    if (releaseObj) {\n        SAFE_RELEASE(arr->arr[index]);\n    }\n\n    arr->num--;\n\n    std::size_t remaining = arr->num - index;\n    if (remaining > 0) {\n        memmove((void *)&arr->arr[index], (void *)&arr->arr[index + 1], remaining * sizeof(Action *));\n    }\n}\n",
        "answer": "/** @brief Removes object at specified index and pushes back all subsequent objects. Behavior undefined if index outside [0, num-1].\n*\n*  This function removes an object from an array at a given index and pushes back all subsequent objects to fill the gap. The behavior is undefined if the index is outside the range [0, num-1], where num is the number of elements in the array.\n*\n* @param arr The array containing the object to be removed.\n* @param index The index of the object to be removed.\n* @param releaseObj Whether or not to release the object before removing it from the array. Defaults to true.\n* @return void\n*/\nvoid ArrayRemoveObjectAtIndex(Array *arr, std::size_t index, bool releaseObj/* = true*/)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CArrayRemoveValueAtIndex(ccCArray *arr, std::size_t index)\n{\n    for (std::size_t last = --arr->num; index < last; index++) {\n        arr->arr[index] = arr->arr[index + 1];\n    }\n}\n",
        "answer": "/** @brief Removes value at specified index and pushes back all subsequent values.\n*\n*  This function removes the value at the specified index in a CArray and pushes back all subsequent values to fill the gap.\n*  The behavior is undefined if the index is outside [0, num-1].\n*\n* @param arr The CArray from which to remove the value.\n* @param index The index of the value to be removed.\n* @return void\n*/\nvoid CArrayRemoveValueAtIndex(ccCArray *arr, std::size_t index)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "srs_bool srs_aac_is_adts(char* aac_raw_data, int ac_raw_size)\n{\n    SrsStream stream;\n    if (stream.initialize(aac_raw_data, ac_raw_size) != ERROR_SUCCESS) {\n        return false;\n    }\n    \n    return srs_aac_startswith_adts(&stream);\n}\n",
        "answer": "/** @brief Checks whether AAC raw data is in ADTS format.\n*\n*  This function checks whether the provided AAC raw data is in ADTS (Audio Data Transport Stream) format, which bytes sequence matches '1111 1111 1111'B, that is 0xFFF.\n*\n* @param aac_raw_data Pointer to the AAC raw data.\n* @param ac_raw_size Size of the AAC raw data.\n* @return True if the AAC raw data is in ADTS format, false otherwise.\n*/\nsrs_bool srs_aac_is_adts(char* aac_raw_data, int ac_raw_size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    int N = 0;\n    long M = 0;\n    int K = 0;\n    cin >> N >> M >> K;\n\n    Graph g(N, M);\n    int s, e;\n    for (long i = 0; i < M; ++i)\n    {\n        cin >> s >> e;\n        g.addEdge(s, e);\n    }\n\n    int v = 0;\n    for (int i = 0; i < K; ++i)\n    {\n        cin >> v;\n        g.setAllFalse();\n        g.setTrue(v);\n        int d = g.cntConnectedParts(v);\n        cout << d - 1 << endl;\n    }\n\n    return 0;\n}\n",
        "answer": "/**\n* @brief Kernel entrypoint.\n* This is the entrypoint for your kernel.\n* You will use this to test and debug your\n* drivers and it will eventually hold the\n* code for your game.  Right now, it is\n* A tight while loop.\n* @return Should not return\n*/\nvoid kernel_entrypoint()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    int r, g, b;\n    cin >> r >> g >> b;\n    string red = toRadix13(r);\n    string green = toRadix13(g);\n    string blue = toRadix13(b);\n    cout << \"#\" << red << green << blue << endl;\n    return 0;\n}\n",
        "answer": "/** @brief Solves the DP problem of finding the maximum time when the ith picture is done by the jth painter.\n*\n*  This function uses a dynamic programming approach to solve the problem. It initializes the dp table with the values for the base cases, and then iterates through the rest of the table, filling in the values for each cell based on the maximum of the previous two cells.\n*\n* @param n The number of pictures.\n* @param m The number of painters.\n* @return The maximum time when all pictures are done by the painters.\n*/\nint dp(int n, int m)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    Hog a, b, c;\n    scanf(\"%ld.%d.%d\", &a.galleon_, &a.sickle_, &a.knut_);\n    scanf(\"%ld.%d.%d\", &b.galleon_, &b.sickle_, &b.knut_);\n\n    c.knut_ = a.knut_ + b.knut_;\n    c.sickle_ = a.sickle_ + b.sickle_;\n    c.galleon_ = a.galleon_ + b.galleon_;\n\n    if (c.knut_ >= 29)\n    {\n        c.sickle_ += c.knut_ / 29;\n        c.knut_ %= 29;\n    }\n\n    if (c.sickle_ >= 17)\n    {\n        c.galleon_ += c.sickle_ / 17;\n        c.sickle_ %= 17;\n    }\n\n    printf(\"%ld.%d.%d\\n\", c.galleon_, c.sickle_, c.knut_);\n    return 0;\n}\n",
        "answer": "/** @brief Hogwarts Currency Converter\n*\n* This function converts the currency of Hogwarts from Galleons, Sickles, and Knuts to a single unit.\n* The conversion is done by adding the values of Galleons, Sickles, and Knuts and then applying the following rules:\n* If the total value is greater than or equal to 29, the excess value is added to the number of Sickles.\n* If the total value is greater than or equal to 17, the excess value is added to the number of Galleons.\n* The function then prints the converted currency in the format \"Galleons.Sickles.Knuts\".\n*\n* @param a Hog object representing the first currency\n* @param b Hog object representing the second currency\n* @return void\n*/\nvoid main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tvector<vector<int> > ans = generate(5);\n\tfor (size_t i = 0; i < ans.size(); ++i) {\n\t\tfor (size_t j = 0; j < ans[i].size(); ++j) {\n\t\t\tcout << \" \" << ans[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Generate a matrix of size n x n with the given constraints.\n*\n* This function generates a matrix of size n x n, where each element is either 0 or 1, and satisfies the following constraints:\n* - The first row and column are all zeros.\n* - Each row and column contains at most one non-zero element.\n* - No two non-zero elements are in the same row or column.\n*\n* @param n The size of the matrix to generate.\n* @return A vector of vectors representing the generated matrix.\n*/\nvector<vector<int> > generate(int n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tunordered_set<string> dict;\n\tdict.insert(\"a\");\n\tdict.insert(\"b\");\n\tdict.insert(\"c\");\n\tstring s = \"a\";\n\tstring e = \"c\";\n\tcout << ladderLength(s, e, dict) << endl;\n\treturn 0;\n}",
        "answer": "/** @brief Solves the DP problem of finding the minimum time required to complete a set of tasks with dependencies.\n*\n* This function uses a dynamic programming approach to find the minimum time required to complete a set of tasks with dependencies. The tasks are represented as a directed acyclic graph, where each node represents a task and each edge represents a dependency between two tasks. The function returns the minimum time required to complete all tasks in the graph.\n*\n* @param dp A 2D vector representing the dynamic programming table. Each element of the vector is a pair of integers representing the minimum time required to complete the corresponding task and the number of tasks that can be completed simultaneously.\n* @param i The index of the current task in the graph.\n* @param j The index of the previous task in the graph.\n* @param t The time required to complete the current task.\n* @return The minimum time required to complete all tasks in the graph.\n*/\nint dp(vector<pair<int, int>> &dp, int i, int j, int t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    int a[] = {1, 2, 3, 1};\n    vector<int> v(a, a + 4);\n    cout << findPeakElement(v) << endl;\n    return 0;\n}\n",
        "answer": "/** @brief Finds the peak element in a vector.\n*\n*  This function finds the peak element in a vector, which is the largest element in the vector.\n*  The function uses a greedy algorithm to find the peak element by iterating through the vector and comparing each element with its neighbors.\n*  If an element is larger than both of its neighbors, it is considered a peak element and the function returns its index.\n*  Otherwise, the function continues to iterate until the end of the vector is reached.\n*\n* @param v A vector of integers.\n* @return The index of the peak element in the vector. If no peak element is found, the function returns -1.\n*/\nint findPeakElement(vector<int> v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    string ans = make24(a, b, c, d);\n    cout << ans << endl;\n    return 0;\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n*  This is the main entrypoint for the program.\n*  It reads four integers from standard input,\n*  and then calls the `make24` function to\n*  generate a string representing the solution\n*  to the 24 game using those numbers. The\n*  resulting string is then printed to standard\n*  output.\n*\n* @param argc Number of command-line arguments.\n* @param argv Array of command-line argument strings.\n* @return Exit status code.\n*/\nint main(int argc, char** argv)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint m, n;\n\twhile (scanf(\"%d %d\", &m, &n) != EOF)\n\t{\n\t\tint has = 0;\n\t\tfor (int i = m; i <= n; ++i)\n\t\t{\n\t\t\tif (IsFlower(i))\n\t\t\t{\n\t\t\t\tif (has == 0) \n\t\t\t\t{\n\t\t\t\t\thas = 1;\n\t\t\t\t\tprintf(\"%d\", i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\" %d\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has == 0) printf(\"no\\n\");\n\t\telse printf(\"\\n\");\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief The main function.\n*\n* This is the entrypoint for your program.\n* You will use this to test and debug your\n* code. Right now, it is a tight while loop.\n*\n* @return Should not return\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint a[] = {1, 3, 1};\n\tvector<int> v(a, a+3);\n\tcout << rob(v) << endl;\n\treturn 0;\n}",
        "answer": "/** @brief Solves the dp problem.\n*\n* This function solves the dp problem by finding the maximum time when the ith picture is done by the jth painter.\n* The initial conditions are dp[0][j] = {0} and dp[i][0] = {0}.\n* The solution uses a greedy algorithm, where you can always invite friends with shy level 0, since if you can invite other people with shy level k (k > 0) to make sure all people stand out, then you can replace these people with shy level 0, the solution will also succeed.\n*\n* @param v A vector of integers representing the time taken by each painter to paint a picture.\n* @return The maximum time when the ith picture is done by the jth painter.\n*/\nint solve_dp(vector<int> v)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tTreeNode* p = NULL;\n\tTreeNode* q = NULL;\n\tTreeNode* root = new TreeNode(6);\n\tp = root->left = new TreeNode(2);\n\troot->left->left = new TreeNode(0);\n\tq = root->left->right = new TreeNode(4);\n\troot->left->right->left = new TreeNode(3);\n\troot->left->right->right = new TreeNode(5);\n\troot->right = new TreeNode(8);\n\troot->right->left = new TreeNode(7);\n\troot->right->right = new TreeNode(9);\n\n\tTreeNode* ans = lowestCommonAncestor(root, p, q);\n\tcout << ans->val << endl;\n\n\treturn 0;\n\n}\n",
        "answer": "/** @brief Lowest Common Ancestor of a Binary Tree.\n*\n* This function finds the lowest common ancestor of two nodes in a binary tree.\n* The algorithm uses a recursive approach to find the LCA.\n*\n* @param root The root node of the binary tree.\n* @param p The first node to be compared.\n* @param q The second node to be compared.\n* @return The lowest common ancestor of nodes p and q.\n*/\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tvector<int> v1(2, 1);\n\tvector<int> v2(2, 1); v2[1] = 0;\n\tvector<vector<int>> A;\n\tA.push_back(v1);\n\tA.push_back(v2);\n\tgameOfLife(A);\n\treturn 0;\n}",
        "answer": "/** @brief Game of Life implementation.\n*\n* This function implements the Game of Life algorithm, which is a well-known\n* cellular automaton that simulates the evolution of a population of living cells.\n* The function takes a 2D vector as input, where each element represents a cell\n* in the grid. The function then iterates through the grid and applies the rules\n* of the Game of Life to each cell, updating its state based on the states of its\n* neighbors. The function returns the updated grid after all iterations are complete.\n*\n* @param A 2D vector representing the grid of cells.\n* @return The updated grid after all iterations are complete.\n*/\nvoid gameOfLife(vector<vector<int>>& A) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tstring s = \"barfoofoobarthefoobarman\";\n\tvector<string> words;\n\twords.push_back(\"foo\");\n\twords.push_back(\"bar\");\n\twords.push_back(\"the\");\n\tvector<int> res = findSubstring(s, words);\n\tfor (size_t i = 0; i < res.size(); ++i) {\n\t\tcout << \" \" << res[i] << endl;\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Finds the indices of all occurrences of a set of words in a given string.\n*\n* This function takes a string and a vector of strings as input, and returns a vector of integers representing the indices where each word is found in the original string. If a word is not found, its index will be -1.\n*\n* @param s The input string to search for words.\n* @param words A vector of strings representing the words to search for.\n* @return A vector of integers representing the indices where each word is found in the original string.\n*/\nvector<int> findSubstring(string s, vector<string> words) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main() {\n\tint a[] = {1, 2, 2, 33};\n\tvector<int> A(a, a + 3);\n\n\tint n = 5;\n\tcout << minPatches(A, n) << endl;\n\t\n\treturn 0;\n}\n",
        "answer": "/** @brief Solves the DP problem of finding the minimum number of patches needed to complete a set of pictures.\n*\n*  This function uses a greedy algorithm to solve the problem. It first sorts the array of picture sizes in non-decreasing order, and then iterates through the array, keeping track of the current size of the patch and the number of patches used so far. At each step, it checks if the current picture size is less than or equal to the current patch size, and if so, it adds the picture to the current patch. If the picture size is greater than the current patch size, it creates a new patch with the remaining size and increments the number of patches used. The function returns the final number of patches used.\n*\n* @param A Vector of picture sizes.\n* @param n Number of pictures.\n* @return Minimum number of patches needed to complete the set of pictures.\n*/\nint minPatches(vector<int> &A, int n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    priority_queue<int, vector<int>, greater<int> > q;\n    int n;\n    scanf(\"%d\", &n);\n\n    int x;\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\", &x);\n        q.push(x);\n    }\n\n    int cost = 0;\n    int x1, x2;\n    while (q.size() >= 2)\n    {\n        x1 = q.top();\n        q.pop();\n        x2 = q.top();\n        q.pop();\n        cost += x1 + x2;\n        q.push(x1 + x2);\n    }\n\n    cout << cost << endl;\n    return 0;\n}\n",
        "answer": "/**\n* @brief Kernel entrypoint.\n*\n* This is the entrypoint for your kernel.\n* You will use this to test and debug your\n* drivers and it will eventually hold the\n* code for your game.  Right now, it is\n* A tight while loop.\n*\n* @return Should not return\n*/\nvoid kernel_entrypoint() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint n = 5;\n\tvector<string> board(2);\n\tcin >> board[0];\n\tcin >> board[1];\n\tint ans = calc(board);\n\tcout << ans << endl;\n}\n",
        "answer": "/** @brief Calculates the number of moves required to reach the goal state.\n*\n*  This function takes a vector of strings representing the current state of the board and returns the minimum number of moves required to reach the goal state, where all the tiles are in their correct positions.\n*\n* @param board A vector of strings representing the current state of the board.\n* @return The minimum number of moves required to reach the goal state.\n*/\nint calc(vector<string> board)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    string s = \"AAABC\";\n    string t = \"ABC\";\n    cout << minWindow(s, t) << endl;\n    return 0;\n}\n",
        "answer": "/** @brief Minimum window substring.\n*\n* This function finds the minimum window substring of a string that contains all the characters of another string.\n* The algorithm used is based on dynamic programming, where dp[i][j] represents the time when the ith picture done by the jth painter.\n* The initial conditions are dp[0][j] = {0} and dp[i][0] = {0}.\n* The solution is a greedy algorithm that always invites friends with shy level 0, since if you can invite other people with shy level k (k > 0) to make sure all people stand out, then you can replace these people with shy level 0, the solution will also succeed.\n*\n* @param s The string that contains the characters of interest.\n* @param t The string that contains the characters to be found in s.\n* @return The minimum window substring of s that contains all the characters of t.\n*/\nstring minWindow(string s, string t) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    int a[] = {1, 2, 2};\n    vector<int> v(a, a + 3);\n    vector<vector<int> > result = subsetsWithDup(v);\n    cout << result.size() << endl;\n    for (size_t i = 0; i < result.size(); ++i){\n        PrintVec(result[i]);\n    }\n    return 0;\n}\n",
        "answer": "/** @brief Solves the DP problem of finding the time when the ith picture is done by the jth painter.\n*\n* The problem can be solved using a greedy algorithm, where you always invite friends with shy level 0, since if you can invite other people with shy level k (k > 0) to make sure all people stand out, then you can replace these people with shy level 0, the solution will also succeed.\n*\n* @param v A vector of integers representing the shy levels of the painters.\n* @return A vector of vectors representing the times when each picture is done by each painter.\n*/\nvector<vector<int> > subsetsWithDup(vector<int> &v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tlong n;\n\tcin >> n;\n\tlong a, b;\n\tfor (a = 4; a <= n; ++a)\n\t{\n\t\tb = n - a;\n\t\tif (!isPrime(a) && !isPrime(b)) break;\n\t}\n\n\tcout << a << \" \" << b << endl;\n\treturn 0;\n}\n",
        "answer": "/** @brief Finds the two prime numbers that sum to a given number.\n*\n* This function takes in an integer n and finds two prime numbers a and b such that a + b = n.\n* It does this by iterating from 4 to n, and for each value of a, it checks if a is prime and if the complementary value b is also prime. If both conditions are met, the function breaks out of the loop and prints the values of a and b.\n*\n* @param n The input number that the two prime numbers should sum to.\n* @return The pair of prime numbers that sum to n.\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n, 0);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> v[i];\n\t}\n\n\tint cnt = 0;\n\tint cur = 0;\n\tint next = 0;\n\twhile (v[cur] != 1 && cur < n) cur++;\n\n\tif (cur >= n)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcnt += 1;\n\tnext = cur + 1;\n\t\n\twhile (cur < n)\n\t{\n\t\twhile (next < n && v[next] != 1) next++;\n\n\t\tif (next < n)\n\t\t{\n\t\t\tif (next - cur == 1)\n\t\t\t{\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t\telse if (next - cur >= 2)\n\t\t\t{\n\t\t\t\tcnt += 2;\n\t\t\t}\n\t\t\tcur = next;\n\t\t\tnext = cur + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << cnt << endl;\n\treturn 0;\n}\n",
        "answer": "/** @brief Counts the number of islands in a given grid.\n*\n*  This function takes in a vector of integers representing a grid, where 0 represents water and 1 represents land. It then counts the number of islands in the grid by iterating through each element and checking if it is connected to any other elements that are part of the same island. If an element is not connected to any other elements that are part of the same island, it is considered a new island.\n*\n* @param grid A vector of integers representing a grid, where 0 represents water and 1 represents land.\n* @return The number of islands in the grid.\n*/\nint countIslands(vector<int> &grid) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n    root->right->left = new TreeNode(6);\n    root->right->right = new TreeNode(7);\n\n    vector<vector<int> > ans = levelOrderBottom(root);\n    for (size_t i = 0; i < ans.size(); ++i)\n    {\n        cout << \"level : \";\n        for (size_t j = 0; j < ans[i].size(); ++j)\n        {\n            cout << \" \" << ans[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
        "answer": "/** @brief Level order traversal of a binary tree from bottom to top.\n*\n*  This function performs level order traversal of a binary tree, starting from the bottom level and moving upwards. The traversal is done using a queue data structure.\n*\n* @param root A pointer to the root node of the binary tree.\n* @return A vector of vectors, where each inner vector represents a level in the tree and contains the values of the nodes at that level.\n*/\nvector<vector<int> > levelOrderBottom(TreeNode* root)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint a[] = {9, 3, 6, 7, 1, 5, 2};\n\tint n = sizeof(a) / sizeof(a[0]);\n\n\tprintf(\"Before Sort:\\n\");\n\tprintArray(a, n);\n\n\tbuddleSort(a, n);\n\n\tprintf(\"After Sort:\\n\");\n\tprintArray(a, n);\n\n\n\treturn 0;\n}\n",
        "answer": "/** @brief Buddle sort algorithm.\n*\n* This is the implementation of the buddle sort algorithm.\n* The function takes an array and its size as input, sorts the array using the buddle sort algorithm, and returns the sorted array.\n*\n* @param a[] The input array to be sorted.\n* @param n The size of the input array.\n* @return The sorted array.\n*/\nvoid buddleSort(int a[], int n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    unsigned long n;\n    cin >> n;\n    cout << CountAllBitSetFrom1ToN(n) << endl;\n    return 0;\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n* This is the main entrypoint for your program.\n* You will use this to test and debug your\n* code and it will eventually hold the\n* code for your game.  Right now, it is\n* A tight while loop.\n*\n* @param n The number of pictures to be painted.\n* @return The total time taken to paint all pictures.\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\t/*\n\t *   0\n\t * |   \\\n\t * |    \\\n\t * 1-----2\n\t */\n\n\tGraph g(3, 3);\n\tg.addEdge(0,1);\n\tg.addEdge(0,2);\n\tg.addEdge(1,2);\n\t\n\t/*\n\tGraph g(3, 2);\n\tg.addEdge(0, 1);\n\tg.addEdge(0, 2);\n\t*/\n\n\tbool ans = g.isCyclic();\n\tif (ans) cout << \"Graph has cycles\" << endl;\n\telse cout << \"Graph doesn't have cycles\" << endl;\n\n\treturn 0;\n}\n",
        "answer": "/**\n* @brief Function to check if a graph has cycles or not.\n*\n* @param g The input graph\n* @return true If the graph has cycles\n* @return false If the graph doesn't have cycles\n*/\n/**\n* @brief Function to perform a DFS from a given node.\n*\n* @param g The input graph\n* @param node The current node being visited\n* @param parent The parent of the current node (or -1 if it has no parent)\n* @param visited A vector to keep track of visited nodes\n* @return true If a cycle was found in the DFS\n* @return false If no cycles were found in the DFS\n*/\nbool dfs(Graph& g, int node, int parent, vector<bool>& visited) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tGraph g(9);\n\tg.addEdge(0, 1, 4);\n\tg.addEdge(0, 7, 8);\n\tg.addEdge(1, 2, 8);\n\tg.addEdge(1, 7, 11);\n\tg.addEdge(2, 3, 7);\n\tg.addEdge(2, 8, 2);\n\tg.addEdge(2, 5, 4);\n\tg.addEdge(3, 4, 9);\n\tg.addEdge(3, 5, 14);\n\tg.addEdge(4, 5, 10);\n\tg.addEdge(5, 6, 2);\n\tg.addEdge(6, 7, 1);\n\tg.addEdge(6, 8, 6);\n\tg.addEdge(7, 8, 7);\n\n\tg.Dijkstra(0);\n\n\treturn 0;\n}\n",
        "answer": "/** @brief Dijkstra's algorithm for finding the shortest path in a graph.\n*\n* This function uses Dijkstra's algorithm to find the shortest path from a given source node to all other nodes in a graph.\n* The algorithm works by maintaining a priority queue of nodes, where the priority of each node is its distance from the source node.\n* Initially, the priority queue contains only the source node with a distance of 0.\n* As the algorithm progresses, the priority queue is updated with the neighbors of the current node, and their distances are calculated based on the distance of the current node and the weight of the edge between them.\n* The algorithm continues until the destination node is reached or the priority queue is empty.\n*\n* @param g The graph to search for the shortest path in.\n* @param src The source node to start the search from.\n* @return A vector of nodes representing the shortest path from the source node to the destination node, or an empty vector if no such path exists.\n*/\n/** @brief Gets the shortest path from a node to the destination node.\n*\n* This function is used to get the shortest path from a node to the destination node after Dijkstra's algorithm has been run.\n* It works by tracing back through the nodes that were visited during the search and constructing a vector of nodes representing the shortest path.\n*\n* @param u The node to start the path from.\n* @return A vector of nodes representing the shortest path from the source node to the destination node, or an empty vector if no such path exists.\n*/\nvector<Node> getPath(Node u) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    string s;\n    cin >> s;\n    cout << simulate(s) << endl;\n\n    return 0;\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n*  This is the main entrypoint for the program. It reads a string from standard input, simulates the painting process using the `simulate` function, and prints the result to standard output.\n*\n* @param s The string representing the painting instructions.\n* @return 0 on success, non-zero on failure.\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tvector<vector<int> > A(3, vector<int>(3, 0));\n\tA[0][0] = 1; A[0][1] = 2; A[0][2] = 3;\n\tA[1][0] = 4; A[1][1] = 5; A[1][2] = 6;\n\tA[2][0] = 7; A[2][1] = 8; A[2][2] = 9;\n\n\tPrintMatrix(FastMatrixExponentiation(A, 3));\n\treturn 0;\n}\n",
        "answer": "/** @brief Fast Matrix Exponentiation.\n*\n* This function performs fast matrix exponentiation using the divide and conquer approach.\n* It takes two arguments: a square matrix A, and an integer n representing the power to which A should be raised.\n* The function returns the result of raising A to the power of n.\n*\n* @param A A square matrix represented as a 2D vector of integers.\n* @param n An integer representing the power to which A should be raised.\n* @return The result of raising A to the power of n, also represented as a 2D vector of integers.\n*/\n/** @brief Matrix Multiplication.\n*\n* This function performs matrix multiplication on two square matrices represented as 2D vectors of integers.\n* It takes two arguments: two square matrices A and B, both represented as 2D vectors of integers.\n* The function returns the result of multiplying A and B, also represented as a 2D vector of integers.\n*\n* @param A A square matrix represented as a 2D vector of integers.\n* @param B A square matrix represented as a 2D vector of integers.\n* @return The result of multiplying A and B, also represented as a 2D vector of integers.\n*/\n/** @brief Print Matrix.\n*\n* This function prints a square matrix represented as a 2D vector of integers to the console.\n* It takes one argument: a square matrix A, represented as a 2D vector of integers.\n* The function does not return anything.\n*\n* @param A A square matrix represented as a 2D vector of integers.\n*/\n/** @brief Main Function.\n*\n* This is the main function of the program, which tests and debugs the FastMatrixExponentiation function.\n* It takes no arguments.\n* The function does not return anything.\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint n = 4;\n\tvector<vector<int> > graph(n, vector<int>(n, INF));\n\tfor (int i = 0; i < n; ++i) graph[i][i] = 0;\n\tgraph[0][1] = 5;\n\tgraph[0][3] = 10;\n\tgraph[1][2] = 3;\n\tgraph[2][3] = 1;\n\n\tvector<vector<int> > dist = FloydWarshall(graph);\n\n\tprintf(\"Dist Matrix:\\n\");\n\tprintMatrix(dist);\n\n\treturn 0;\n}\n",
        "answer": "/** @brief Floyd-Warshall algorithm for finding the shortest path between all pairs of vertices in a weighted graph.\n*\n*  This function implements the Floyd-Warshall algorithm, which is an efficient method for finding the shortest path between all pairs of vertices in a weighted graph. The algorithm works by iteratively computing the shortest path between each pair of vertices using a dynamic programming approach.\n*\n* @param[in] graph A vector of vectors representing the weighted graph. The outer vector represents the rows of the matrix, and the inner vector represents the columns. Each element in the matrix is the weight of the edge between two vertices. If there is no edge between two vertices, then the element is set to INF (a large value).\n* @return A vector of vectors representing the shortest path between all pairs of vertices. The outer vector represents the rows of the matrix, and the inner vector represents the columns. Each element in the matrix is the distance between two vertices. If there is no path between two vertices, then the element is set to INF (a large value).\n*/\nvector<vector<int> > FloydWarshall(const vector<vector<int> >& graph)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    char ch[] = {'a', 'b', 'c', 'd'};\n    int freq[] = {1, 2, 4, 5};\n    int n = sizeof(ch) / sizeof(ch[0]);\n\n    Node* root = CreateHuffmanTree(ch, freq, n);\n    PrintHuffmanTree(root, \"\");\n    return 0;\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n*  This is the main entrypoint for the program.\n*  It creates a Huffman tree from an array of characters and their frequencies,\n*  and then prints the tree using the PrintHuffmanTree function.\n*\n* @param ch An array of characters.\n* @param freq An array of frequencies corresponding to each character in ch.\n* @param n The number of elements in ch and freq.\n* @return Should not return.\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tGraph g(4, 5);\n\tg.addEdge(0, 1, 10);\n\tg.addEdge(0, 2, 6);\n\tg.addEdge(0, 3, 5);\n\tg.addEdge(1, 3, 15);\n\tg.addEdge(2, 3, 4);\n\n\tvector<Edge> ans = g.KruskalMST();\n\n\tcout << \"The minimum spanning tree edges are:\" << endl;\n\tfor (size_t i = 0; i < ans.size(); ++i)\n\t{\n\t\tcout << ans[i].src << \"---\" << ans[i].dest << endl;\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n",
        "answer": "/** @brief Kruskal's algorithm for finding the minimum spanning tree of a graph.\n*\n* This function uses Kruskal's algorithm to find the minimum spanning tree of a graph. It works by sorting the edges of the graph by weight, and then selecting the minimum-weight edge that connects two disjoint sets in the graph. The process is repeated until all vertices are part of the same set.\n*\n* @param g The input graph.\n* @return A vector containing the edges of the minimum spanning tree.\n*/\nvector<Edge> KruskalMST(Graph& g)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint a1[] = {1, 11, 2, 10, 4, 5, 2, 1};\n\tint a2[] = {12, 11, 40, 5, 3, 1};\n\tint a3[] = {80, 60, 30, 40, 20, 10};\n\n\tint ans1 = LongestBitonicSubsequence(a1, 8);\n\tint ans2 = LongestBitonicSubsequence(a2, 6);\n\tint ans3 = LongestBitonicSubsequence(a3, 6);\n\t\n\tcout << \"test 1 ans : \" << ans1 << endl;\n\tcout << \"test 2 ans : \" << ans2 << endl;\n\tcout << \"test 3 ans : \" << ans3 << endl;\n\n}\n",
        "answer": "/** @brief Longest Bitonic Subsequence\n*\n* This function finds the longest bitonic subsequence in a given array.\n* A bitonic sequence is a sequence of numbers that starts with a number,\n* increases to a maximum value, and then decreases back to the starting value.\n* The longest bitonic subsequence problem is to find the longest such sequence\n* in an array.\n*\n* @param arr The input array\n* @param n The size of the input array\n* @return The length of the longest bitonic subsequence\n*/\nint LongestBitonicSubsequence(int arr[], int n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint m = 6;\n\tint n = 6;\n\tvector<vector<int> > bpGraph(m, vector<int>(n, 0));\n\tbpGraph[0][1] = 1; bpGraph[0][2] = 1;\n\tbpGraph[1][0] = 1; bpGraph[1][3] = 1;\n\tbpGraph[2][2] = 1;\n\tbpGraph[3][2] = 1; bpGraph[3][3] = 1;\n\tbpGraph[5][5] = 1;\n\tint result = maxBPM(bpGraph);\n\tcout << \"The maximum biparite matching:\" << result << endl;\n\treturn 0;\n}\n",
        "answer": "/** @brief Maximum Bipartite Matching Algorithm.\n*\n*  This function finds the maximum bipartite matching in a given graph using the augmenting path algorithm.\n*\n* @param[in] bpGraph A vector of vectors representing the graph, where each element is either 0 or 1, indicating whether there is an edge between two nodes or not.\n* @return The maximum bipartite matching found in the graph.\n*/\nint maxBPM(vector<vector<int> > &bpGraph)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tvector<vector<int> > graph(NODE_NUM, vector<int>(NODE_NUM, 0));\n\tgraph[0][1] = 1; graph[0][2] = 1; graph[0][3] = 1;\n\tgraph[1][0] = 1; graph[1][2] = 1;\n\tgraph[2][0] = 1; graph[2][1] = 1; graph[2][3] = 1;\n\tgraph[3][0] = 1; graph[3][2] = 1;\n\n\tvector<int> colors(NODE_NUM, 0);\n\n\tbool ok = mColor(graph, 0, colors);\n\tif (ok)\n\t{\n\t\tcout << \"Find Solution\" << endl;\n\t\tcopy(colors.begin(), colors.end(), ostream_iterator<int>(cout, \" \"));\n\t\tcout << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Solution does not exist\" << endl;\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Solves the graph coloring problem using a greedy algorithm.\n*\n* This function takes in a graph represented as an adjacency matrix, and a starting node. It then uses a greedy algorithm to assign colors to each node in the graph such that adjacent nodes have different colors. The function returns true if a valid coloring exists, and false otherwise.\n*\n* @param graph An adjacency matrix representing the graph.\n* @param startNode The starting node for the greedy algorithm.\n* @param colors A vector of integers representing the colors assigned to each node in the graph.\n* @return True if a valid coloring exists, and false otherwise.\n*/\nbool mColor(vector<vector<int> >& graph, int startNode, vector<int>& colors)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    MinStack ms;\n    ms.push(2);\n    ms.push(0);\n    ms.push(3);\n    ms.push(0);\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    return 0;\n}\n",
        "answer": "/** @brief MinStack class.\n*\n*  This class implements a stack that can return the minimum element in the stack.\n*\n*/\n/** @brief Push an element onto the stack.\n*\n*  @param x The element to push onto the stack.\n*/\n/** @brief Pop an element from the stack.\n*\n*  @return The element that was popped from the stack.\n*/\n/** @brief Get the minimum element in the stack.\n*\n*  @return The minimum element in the stack.\n*/\n/** @brief Main function.\n*\n*  This is the entrypoint for your program.\n*\n*  @param argc The number of command-line arguments.\n*  @param argv An array of pointers to the command-line arguments.\n*  @return The exit code for the program.\n*/\nint main(int argc, char **argv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    TreeNode* root = new TreeNode(5);\n    root->left = new TreeNode(4);\n    root->right = new TreeNode(8);\n    root->left->left = new TreeNode(11);\n    root->left->left->left = new TreeNode(7);\n    root->left->left->right = new TreeNode(2);\n    root->right->left = new TreeNode(13);\n    root->right->right = new TreeNode(4);\n    root->right->right->left = new TreeNode(5);\n    root->right->right->right = new TreeNode(1);\n    vector<vector<int> > ans = pathSum(root, 22);\n    for (size_t i = 0; i < ans.size(); ++i)\n    {\n        for (size_t j = 0; j < ans[i].size(); ++j)\n        {\n            cout << \" \" << ans[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
        "answer": "/** @brief Solves the DP problem.\n*\n*  This function solves the DP problem described in the problem statement.\n*  It uses a greedy algorithm to find the optimal solution.\n*\n* @param dp The 2D array representing the DP table.\n* @param i The current picture being painted.\n* @param j The current painter.\n* @return The time when the ith picture is done by the jth painter.\n*/\nint solveDP(vector<vector<int> >& dp, int i, int j)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tunsigned int n;\n\tcin >> n;\n\tcout << reverseBits(n) << endl;\n\treturn 0;\n}",
        "answer": "/** @brief Reverses the bits of an unsigned integer.\n*\n* This function takes an unsigned integer as input and returns its bit-reversed representation.\n* The algorithm works by iterating through each bit of the input number, starting from the least significant bit (LSB),\n* and swapping it with the corresponding bit in the output number, starting from the MSB.\n* The function uses a temporary variable to store the current bit being processed, and a loop to iterate over all bits.\n*\n* @param n The unsigned integer to be reversed.\n* @return The bit-reversed representation of the input number.\n*/\nint reverseBits(unsigned int n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tstring s;\n\tcin >> s;\n\tcout << romanToInt(s) << endl;\n\treturn 0;\n}",
        "answer": "/** @brief Converts a Roman numeral to an integer.\n*\n*  This function takes in a string representing a Roman numeral and returns the corresponding integer value.\n*  The function uses a greedy algorithm, always choosing the largest possible number that can be represented by the remaining digits.\n*\n* @param s A string representing a Roman numeral.\n* @return The integer value of the Roman numeral.\n*/\nint romanToInt(string s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tint A[5] = {0, 1, 2, 0, 1};\n\tfor (int i = 0; i < 5; ++i) printf(\" %d\", A[i]);\n\tprintf(\"\\n\");\n\tsortColors(A, 5);\n\tfor (int i = 0; i < 5; ++i) printf(\" %d\", A[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n",
        "answer": "/** @brief Sorts the colors in an array of integers.\n*\n* This function sorts the colors in an array of integers using the Dutch National Flag problem.\n* The algorithm is based on the idea of partitioning the array into three parts: red, white and blue.\n* The red part contains all elements less than the pivot, the white part contains all elements equal to the pivot,\n* and the blue part contains all elements greater than the pivot.\n* The algorithm then recursively sorts the red and blue parts until they are in ascending order.\n*\n* @param A An array of integers representing the colors.\n* @param n The length of the array.\n*/\nvoid sortColors(int A[], int n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tfreopen(\"sudoku.in\", \"r\", stdin);\t\n\tvector<vector<int> > grid(GRID_SIZE, vector<int>(GRID_SIZE, 0));\n\tfor (int i = 0; i < GRID_SIZE; ++i)\n\t{\n\t\tfor (int j = 0; j < GRID_SIZE; ++j)\n\t\t{\n\t\t\tcin >> grid[i][j];\n\t\t}\n\t}\n\n\tif (Sudoku(grid))\n\t{\n\t\tcout << \"Find Solution \" << endl;\n\t\tPrintSolution(grid);\n\t\tcout << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Solution does not exist\" << endl;\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Solve the Sudoku puzzle using a backtracking algorithm.\n*\n*  This function takes a vector of vectors representing the Sudoku grid as input, and uses a backtracking algorithm to find a solution. If a solution is found, it prints the solution to the console.\n*\n* @param grid A vector of vectors representing the Sudoku grid.\n* @return Returns true if a solution was found, false otherwise.\n*/\nbool Sudoku(vector<vector<int> > &grid)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n    cout << \"Hello world!\" << endl;\n    string s;\n    while (cin >> s)\n    {\n        cout << isInteresting(s) << endl; \n    }\n    return 0;\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n*  This is the main entrypoint for the program. It outputs \"Hello world!\" to the console and then reads input from the user until EOF. For each line of input, it calls the `isInteresting` function and prints the result to the console.\n*\n* @return 0 on success, non-zero on failure\n*/\nint main()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main()\n{\n\tNode* root = new Node(1);\n\troot->left = new Node(2);\n\troot->right = new Node(3);\n\troot->left->left = new Node(4);\n\troot->left->right = new Node(5);\n\n\tint ans = treeSize(root);\n\n\tcout << \"tree size:\" << ans << endl;\n\treturn 0;\n}\n",
        "answer": "/** @brief Function to calculate the size of a binary tree.\n*\n* This function calculates the size of a binary tree by recursively traversing it and counting the number of nodes.\n*\n* @param root The root node of the binary tree.\n* @return The size of the binary tree.\n*/\nint treeSize(Node* root)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void addPoint2D(const Point& point)\n    {\n        points.push_back(INT2MM(point.X));\n        points.push_back(INT2MM(point.Y));\n        last_point = point;\n    }\n",
        "answer": "/**\n* @brief Adds a 2D point to the data.\n*\n* This function adds a 2D point to the data, represented as two consecutive floats. All members adding a 2D point to the data should use this function.\n*\n* @param[in] point The point to add.\n*/\nvoid addPoint2D(const Point& point);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void astra_mex_log_debug(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])\n{\n\tif (nrhs < 4) {\n\t\tmexErrMsgTxt(\"Not enough arguments.  See the help document for a detailed argument list. \\n\");\n\t\treturn;\n\t}\n\tstring filename = mexToString(prhs[1]);\n\tint linenumber = (int)mxGetScalar(prhs[2]);\n\tstring message = mexToString(prhs[3]);\n\tastra::CLogger::debug(filename.c_str(),linenumber,\"%s\",message.c_str());\n}\n",
        "answer": "/** @brief Log a debug message.\n*\n*  This function logs a debug message with the specified file, line number, and message.\n*\n* @param[in] nlhs Number of left-hand side arguments\n* @param[out] plhs Array of left-hand side arguments\n* @param[in] nrhs Number of right-hand side arguments\n* @param[in] prhs Array of right-hand side arguments\n* @return None\n*/\nvoid astra_mex_log_debug(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void astra_mex_log_disable(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])\n{\n\tif (nrhs < 2) {\n\t\tmexErrMsgTxt(\"Not enough arguments.  See the help document for a detailed argument list. \\n\");\n\t\treturn;\n\t}\n\tstring sType = mexToString(prhs[1]);\n\tif(sType == \"all\"){\n\t\tastra::CLogger::disable();\n\t}else if(sType == \"file\"){\n\t\tastra::CLogger::disableFile();\n\t}else if(sType == \"screen\"){\n\t\tastra::CLogger::disableScreen();\n\t} else {\n\t\tmexErrMsgTxt(\"Specify which output to disable ('all', 'file', or 'screen')\");\n\t}\n}\n",
        "answer": "/** @brief Disable logging.\n*\n*  This function disables the specified type of logging.\n*\n* @param[in] nlhs Number of left-hand side arguments.\n* @param[out] plhs Array of left-hand side arguments.\n* @param[in] nrhs Number of right-hand side arguments.\n* @param[in] prhs Array of right-hand side arguments.\n* @return void\n*/\nvoid astra_mex_log_disable(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual Script invoice(const std::string& name, bool change = false) {\n        throw std::runtime_error(\"account with given name (\" + name + \") does not exist\");\n    }\n",
        "answer": "/** @brief Create a new invoice - i.e. a new payment descriptor. Generate a script assigned to either the NULL account, the acct_id account or the account with name acct_name.\n*\n* This function creates a new invoice and assigns it to an account based on the input parameters. If the account is not found, it throws a runtime error.\n*\n* @param name The name of the account to assign the invoice to.\n* @param change Whether or not to create a new invoice for the account. Default value is false.\n* @return A script object representing the invoice.\n*/\nvirtual Script invoice(const std::string& name, bool change = false) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CBSDKAPI    cbSdkResult cbSdkAnalogToDigital(uint32_t nInstance, uint16_t channel, const char * szVoltsUnitString, int32_t * digital)\r\n{\r\n    if (channel == 0 || channel > cbMAXCHANS)\r\n        return CBSDKRESULT_INVALIDCHANNEL;\r\n    if (nInstance >= cbMAXOPEN)\r\n        return CBSDKRESULT_INVALIDPARAM;\r\n    if (g_app[nInstance] == NULL)\r\n        return CBSDKRESULT_CLOSED;\r\n    if (szVoltsUnitString == NULL || digital == NULL)\r\n        return CBSDKRESULT_NULLPTR;\r\n\r\n    return g_app[nInstance]->SdkAnalogToDigital(channel, szVoltsUnitString, digital);\r\n}\r\n",
        "answer": "/**\n* @brief Converts a voltage string to its raw digital value equivalent for a given channel.\n*\n* This function takes a voltage string (e.g. '5V', '-65mV', ...) and converts it to its raw digital value equivalent for the specified channel.\n*\n* @param nInstance The instance of the application that owns the channel.\n* @param channel The channel number to convert.\n* @param szVoltsUnitString The voltage string to convert.\n* @param digital A pointer to an integer where the converted value will be stored.\n*\n* @return CBSDKRESULT_SUCCESS if successful, or an error code otherwise.\n*/\nCBSDKAPI cbSdkResult cbSdkAnalogToDigital(uint32_t nInstance, uint16_t channel, const char * szVoltsUnitString, int32_t * digital);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VDStringW VDFileGetCanonicalPath(const wchar_t *path) {\n\treturn VDParsedPath(path).ToString();\n}\n",
        "answer": "/** @brief Returns the canonical form of a valid path.\n*\n*  This function takes a valid path as input and returns the same path in canonical form. The canonical form collapses redundant backslashes, removes any trailing backslashes, and evaluates any ..\\ and . sections. It is useful for comparing paths.\n*\n* @param[in] path A valid path to be converted to canonical form.\n* @return The same path in canonical form.\n*/\nVDStringW VDFileGetCanonicalPath(const wchar_t *path) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void alSourceStop(ALuint sourceId)\n{\n\talSourceStopv(1, &sourceId);\n}\n",
        "answer": "/** @brief Stops playback from the given audio source for the current audio context.\n*\n*  This function stops playback from the given audio source for the current audio context, placing it in the AL_STOPPED state. Stopping an audio source will cause it to reset back to the beginning of the audio track. The alGetError() function will return AL_INVALID_NAME if the given audio source ID does not exist or was deleted from the system.\n*\n* @param sourceId The ID of the audio source to stop playback for.\n*\n* @return Should not return\n*/\nvoid alSourceStop(ALuint sourceId)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void alSourcePausev(ALsizei numberOfSources, const ALuint *sourceIdArray)\n{\n\tPauseAudioSourceOperation operation;\n\tExecuteOperationOnSources(numberOfSources, sourceIdArray, operation);\n}\n",
        "answer": "/** @brief Pauses the audio sources specified in the given array.\n*\n*  This function will pause the audio sources specified in the given array. If the given array contains at least one ID that does not exist or was deleted from the system, AL_INVALID_NAME will be returned and none of the audio sources will be paused, even if the rest of the audio source IDs are valid. If the given array argument is null, AL_INVALID_VALUE will be returned.\n*\n* @param numberOfSources The number of audio sources to pause.\n* @param sourceIdArray A pointer to an array of ALuint values that specify the audio sources to pause.\n*/\nvoid alSourcePausev(ALsizei numberOfSources, const ALuint *sourceIdArray)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void alGetBufferf(ALuint bufferId, ALenum parameter, ALfloat *valuePointer)\n{\n\talGetBufferfv(bufferId, parameter, valuePointer);\n}\n",
        "answer": "/** @brief Gets the specified buffer's float value.\n*\n*  This function retrieves the float value of a given buffer ID and parameter.\n*\n* @param bufferId The ID of the buffer to retrieve the value from.\n* @param parameter The parameter to retrieve the value for.\n* @param valuePointer A pointer to the float value to be returned.\n*\n* @return AL_INVALID_NAME if the given buffer ID does not exist in the system.\n* @return AL_INVALID_ENUM if the given parameter is not supported.\n* @return AL_INVALID_VALUE if the given value argument is null.\n*/\nvoid alGetBufferf(ALuint bufferId, ALenum parameter, ALfloat *valuePointer)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class BadVector : public ::testing::TestWithParam< ::testing::tuple<std::string, READER_INPUT_TYPE> > {\npublic:\n    virtual ~BadVector() {\n        ION_TEST_VECTOR_CLEANUP();\n    }\n\n    virtual void SetUp() {\n        filename = ::testing::get<0>(GetParam());\n        input_type = ::testing::get<1>(GetParam());\n        test_name = getTestName(filename, NULL, input_type);\n        ION_TEST_VECTOR_INIT();\n    }\n\n    virtual void TearDown() {\n        ION_TEST_VECTOR_CLEANUP();\n    }\n\n    std::string test_name;\nprotected:\n    std::string filename;\n    READER_INPUT_TYPE input_type;\n    IonEventStream *initial_stream;\n    IonEventStream *roundtrip_stream;\n    ION_CATALOG *catalog;\n};\n",
        "answer": "/**\n* @brief Represents a test instance for any vector under the bad/ subdirectory. Each instantiation of this class results in its own test.\n*\n* This class provides a way to run tests on vectors that are located in the bad/ subdirectory. It uses the Google Test framework to define and run the tests.\n*\n* @param filename The name of the vector file to be tested.\n* @param input_type The type of input data for the vector (e.g., binary, text).\n*/\nclass BadVector : public ::testing::TestWithParam< ::testing::tuple<std::string, READER_INPUT_TYPE> > "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "XMLTag getRootTag()\n{\n  static NoPListener listener;\n  return XMLTag(listener, \"configuration\", XMLTag::OCCUR_ONCE);\n}\n",
        "answer": "/** @brief Returns an empty root tag with name \"configuration\".\n*\n* This function returns an empty root tag with the specified name.\n*\n* @param name The name of the root tag to be returned.\n* @return An empty XMLTag object with the specified name.\n*/\nXMLTag getRootTag(const std::string& name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void precicef_has_to_evaluate_surrogate_model_(\n    int* hasToEvaluate)\n{\n  CHECK(impl != nullptr,errormsg);\n  if (impl->hasToEvaluateSurrogateModel()){\n    *hasToEvaluate = 1;\n  }\n  else {\n    *hasToEvaluate = 0;\n  }\n}\n",
        "answer": "/** @brief precicef_has_to_evaluate_surrogate_model\n*\n*  This function checks if the surrogate model needs to be evaluated.\n*\n* @param hasToEvaluate (1:true, 0:false)\n* @return void\n*/\nvoid precicef_has_to_evaluate_surrogate_model_(int* hasToEvaluate);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void precicef_set_quad_(\n  const int* meshID,\n  const int* firstEdgeID,\n  const int* secondEdgeID,\n  const int* thirdEdgeID,\n  const int* fourthEdgeID)\n{\n  CHECK(impl != nullptr,errormsg);\n  impl->setMeshQuad(*meshID, *firstEdgeID, *secondEdgeID, *thirdEdgeID, *fourthEdgeID);\n}\n",
        "answer": "/** @brief Sets a quad on a mesh.\n*\n*  This function sets a quad on a mesh using the specified edge IDs.\n*\n* @param[in] meshID The ID of the mesh to set the quad on.\n* @param[in] firstEdgeID The ID of the first edge of the quad.\n* @param[in] secondEdgeID The ID of the second edge of the quad.\n* @param[in] thirdEdgeID The ID of the third edge of the quad.\n* @param[in] fourthEdgeID The ID of the fourth edge of the quad.\n*\n* @return void\n*/\nvoid precicef_set_quad_(const int* meshID, const int* firstEdgeID, const int* secondEdgeID, const int* thirdEdgeID, const int* fourthEdgeID) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid get_info(file_info & p_info,abort_callback & p_abort) {\n\t\tSPDLOG_DEBUG(log, \"Get info\");\n\n\t\tp_info.set_length((double)m_frames*amr_audio_frame_size/amr_sample_rate);\n\t\tp_info.info_set_bitrate((amr_bits_per_sample * amr_channels * amr_sample_rate + 500 /* rounding for bps to kbps*/ ) / 1000 /* bps to kbps */);\n\t\tp_info.info_set_int(\"samplerate\",amr_sample_rate);\n\t\tp_info.info_set_int(\"channels\",amr_channels);\n\t\tp_info.info_set_int(\"bitspersample\",amr_bits_per_sample);\n\t\tp_info.info_set(\"encoding\",\"Adaptive Multirate\");\t\t\n\t}\n",
        "answer": "/** @brief Get information of properties dialog.\n*\n*  This function is called by foobar to get the information of the properties dialog. It sets the length, bitrate, samplerate, channels, and encoding of the audio file.\n*\n* @param p_info The file information object that will be filled with the information.\n* @param p_abort The abort callback object that can be used to cancel the operation.\n*\n* @return void\n*/\nvoid get_info(file_info & p_info,abort_callback & p_abort) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void toBothSat(const std::vector<double>& sw,\n                   std::vector<double>& sboth)\n    {\n        int num = sw.size();\n        sboth.resize(2*num);\n        for (int i = 0; i < num; ++i) {\n            sboth[2*i] = sw[i];\n            sboth[2*i + 1] = 1.0 - sw[i];\n        }\n    }\n",
        "answer": "/**\n* @brief Creates a vector of interleaved water and oil saturations from a vector of water saturations.\n*\n* This function takes a vector of water saturations as input and creates a new vector of interleaved\n* water and oil saturations, where each element in the output vector is either a water or oil saturation\n* value, alternating between the two. The length of the output vector is twice that of the input vector.\n*\n* @param sw A vector of water saturations.\n* @param sboth An empty vector that will be filled with the interleaved water and oil saturations.\n*/\nvoid toBothSat(const std::vector<double>& sw, std::vector<double>& sboth) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "arm_compute::TensorInfo BuildArmComputeTensorInfo(const armnn::TensorInfo& tensorInfo)\n{\n    const arm_compute::TensorShape aclTensorShape = BuildArmComputeTensorShape(tensorInfo.GetShape());\n    const arm_compute::DataType aclDataType = GetArmComputeDataType(tensorInfo.GetDataType());\n    const arm_compute::QuantizationInfo aclQuantizationInfo(tensorInfo.GetQuantizationScale(),\n                                                            tensorInfo.GetQuantizationOffset());\n\n    return arm_compute::TensorInfo(aclTensorShape, 1, aclDataType, aclQuantizationInfo);\n}\n",
        "answer": "/** @brief Builds an arm_compute::TensorInfo object based on the given armnn::TensorInfo.\n*\n*  This utility function creates an arm_compute::TensorInfo object whose dimensions are based on the given armnn::TensorInfo.\n*\n* @param tensorInfo The armnn::TensorInfo to use as a basis for the new arm_compute::TensorInfo object.\n*\n* @return An arm_compute::TensorInfo object with the same dimensions as the input armnn::TensorInfo.\n*/\narm_compute::TensorInfo BuildArmComputeTensorInfo(const armnn::TensorInfo& tensorInfo)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tstatic CFStringRef getRunLoopMode(HIDType type)\n\t{\n\t\tstatic CFStringRef KeyboardMode = CFSTR(\"BSKeyboard\");\n\t\tstatic CFStringRef MouseMode = CFSTR(\"BSMouse\");\n\t\tstatic CFStringRef GamepadMode = CFSTR(\"BSGamepad\");\n\n\t\tswitch(type)\n\t\t{\n\t\tcase HIDType::Keyboard:\n\t\t\treturn KeyboardMode;\n\t\tcase HIDType::Mouse:\n\t\t\treturn MouseMode;\n\t\tcase HIDType::Gamepad:\n\t\t\treturn GamepadMode;\n\t\t}\n\n\t\treturn nullptr;\n\t}\n",
        "answer": "/** @brief Returns the name of the run loop used for processing events for the specified category of input devices.\n*\n*  This function returns the name of the run loop used for processing events for the specified category of input devices. The possible categories are keyboard, mouse, and gamepad.\n*\n* @param type The type of input device to get the run loop mode for.\n*\n* @return The name of the run loop mode for the specified input device category.\n*/\nstatic CFStringRef getRunLoopMode(HIDType type)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void swapVals(QPFWPVector &vect,int pos1,int pos2){\r\n     QPointFWithParent temp=vect[pos2];\r\n     vect[pos2]=vect[pos1];\r\n     vect[pos1]=temp;\r\n    }\r\n",
        "answer": "/** @brief This function swaps the values of two positions in a QPFWPVector.\n*\n*  The function takes three parameters: a reference to a QPFWPVector, and two integers representing the positions to be swapped. It first stores the value at position 2 in a temporary variable, then assigns the value at position 1 to position 2, and finally assigns the value stored in the temporary variable to position 1.\n*\n* @param vect A reference to a QPFWPVector.\n* @param pos1 The first position to be swapped.\n* @param pos2 The second position to be swapped.\n* @return void\n*/\nvoid swapVals(QPFWPVector &vect,int pos1,int pos2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int fio_kv_get(const fio_kv_pool_t *pool, const fio_kv_key_t *key,\n\t\tconst fio_kv_value_t *value)\n{\n\tassert(pool != NULL);\n\tassert(pool->store != NULL);\n\tassert(pool->store->kv > 0);\n\tassert(pool->id >= 0 && pool->id < NVM_KV_MAX_POOLS);\n\tassert(key != NULL);\n\tassert(key->length >= 1 && key->length <= NVM_KV_MAX_KEY_SIZE);\n\tassert(key->bytes != NULL);\n\tassert(value != NULL);\n\tassert(value->data != NULL);\n\tassert(value->info != NULL);\n\tassert(value->info->value_len <= NVM_KV_MAX_VALUE_SIZE);\n\n\treturn nvm_kv_get(pool->store->kv, pool->id,\n\t\t\tkey->bytes, key->length,\n\t\t\tvalue->data, value->info->value_len, false,\n\t\t\tvalue->info);\n}\n",
        "answer": "/**\n* @brief Retrieve the value associated with a given key in a key/value pool.\n*\n* This function retrieves the value associated with a given key in a key/value pool. The key and value must be sector-aligned, and the memory for the value must be obtained by calling `fio_kv_alloc()`.\n*\n* @param pool The key/value pool to retrieve the value from.\n* @param key The key to retrieve the value for.\n* @param value The value associated with the given key.\n*\n* @return 0 on success, -1 on failure.\n*/\nint fio_kv_get(const fio_kv_pool_t *pool, const fio_kv_key_t *key, const fio_kv_value_t *value);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: dogecoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\" << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/**\n* @brief Performs an HTTP POST request with a JSON message and custom headers.\n*\n* This function creates an HTTP POST request with a JSON message and custom headers, as specified in the input parameters.\n* The request is sent to the server at the specified URL, and the response is returned as a string.\n*\n* @param strMsg The JSON message to be sent in the POST request.\n* @param mapRequestHeaders A map of custom headers to be included in the POST request.\n* @return The response from the server as a string.\n*/\nstring HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    const std::string md5 (\n        const std::string& input\n    )\n    {\n        unsigned char output[16];\n        md5 ( \n            reinterpret_cast<const unsigned char*>(input.data()),\n            static_cast<unsigned long>(input.size()),\n            output\n            );\n\n        \n        std::stringstream temp;\n        for (int i = 0; i < 16; ++i)\n        {\n            temp.fill('0');\n            temp.width(2);\n            temp << std::hex << static_cast<unsigned int>(output[i]);\n        }\n        \n        return temp.str();\n    }\n",
        "answer": "/** @brief Calculates the MD5 hash of a given input string.\n*\n*  This function calculates the MD5 hash of a given input string using the RSA Data Security, Inc. MD5 Message-Digest Algorithm as described in rfc1321. The resulting array contains the 16 bytes of the digest and are in the correct order. i.e. output[0], output[1], output[2], ... !\n*\n* @param input The input string to be hashed.\n* @return A string containing the MD5 hash of the input string.\n*/\nconst std::string md5 ("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    if( MinThread<1 ) {\n        REPORT(\"number of threads must be positive\\n\");\n        exit(1);\n    }\n    for( int p=MinThread; p<=MaxThread; ++p ) {\n       test_concurrency(p);\n   }\n\n#if TBB_PREVIEW_FLOW_GRAPH_FEATURES\n    test_extract<tbb::flow::rejecting>();\n    test_extract<tbb::flow::queueing>();\n#endif\n   return Harness::Done;\n}\n",
        "answer": "/** @brief The main entry point for the test application.\n*\n*  This function is called by the test harness to run the test. It checks that the minimum and maximum thread numbers are valid, then runs the test for two sizes of the thread pool (MinThread and MaxThread) to test high and low contention modes while keeping the test reasonably fast.\n*\n* @return Harness::Done if the test completes successfully, or an error code otherwise.\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int TestMain() {\n    tbb::tick_count start = tbb::tick_count::now(), stop;\n    for (int p = 2; p <= 4; ++p) {\n        tbb::task_scheduler_init init(p);\n        test_serial<int>();\n        test_serial<check_type<int> >();\n        test_parallel<int>(p);\n        test_parallel<check_type<int> >(p);\n    }\n    stop = tbb::tick_count::now();\n    REMARK(\"Queue_Node Time=%6.6f\\n\", (stop-start).seconds());\n    REMARK(\"Testing resets\\n\");\n    test_resets<int, tbb::flow::queue_node<int> >();\n    test_resets<float, tbb::flow::queue_node<float> >();\n#if TBB_PREVIEW_FLOW_GRAPH_FEATURES\n    test_buffer_extract<tbb::flow::queue_node<int> >().run_tests();\n#endif\n    return Harness::Done;\n}\n",
        "answer": "/** @brief Test entrypoint.\n*\n*  This is the entrypoint for your test application.\n*  It will run a series of tests to verify the functionality\n*  of the queue node in the TBB flow graph library.\n*\n* @return Should return Harness::Done if all tests pass, or an error code otherwise.\n*/\nint TestMain() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AL_API void AL_APIENTRY alSourceStop(ALuint sid) { }\n",
        "answer": "/** @brief Stops a source, temporarily removing it from the mixer list and resetting its internal state to pre-Play.\n*\n*  To remove a Source completely, it has to be deleted following Stop, or before Play.\n*\n* @param sid The ID of the source to stop.\n*\n* @return void\n*/\nAL_API void AL_APIENTRY alSourceStop(ALuint sid) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool SelectParamsFromCommandLine()\n{\n    bool fRegTest = GetBoolArg(\"-regtest\", false);\n    bool fTestNet = GetBoolArg(\"-testnet\", false);\n\n    if (fTestNet && fRegTest)\n    {\n        return false;\n    };\n\n    if (fRegTest)\n    {\n        SelectParams(CChainParams::REGTEST);\n    } else\n    if (fTestNet)\n    {\n        SelectParams(CChainParams::TESTNET);\n    } else\n    {\n        SelectParams(CChainParams::MAIN);\n    };\n    \n    return true;\n}\n",
        "answer": "/** @brief Selects the appropriate network parameters from the command line.\n*\n*  This function looks for -regtest or -testnet and calls SelectParams as appropriate.\n*  It returns false if an invalid combination is given.\n*\n* @param fRegTest A boolean indicating whether the regtest parameter was passed.\n* @param fTestNet A boolean indicating whether the testnet parameter was passed.\n*\n* @return true if the network parameters were selected successfully, false otherwise.\n*/\nbool SelectParamsFromCommandLine(bool fRegTest, bool fTestNet)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void start_ulp_program()\n{\n    /* Start the program */\n    esp_err_t err = ulp_run((&ulp_entry - RTC_SLOW_MEM) / sizeof(uint32_t));\n    ESP_ERROR_CHECK(err);\n}\n",
        "answer": "/**\n* @brief Starts the ULP program and resets measurement counter.\n*\n* This function starts the ULP program and resets the measurement counter. It should be called every time before going into deep sleep.\n*\n* @return Should not return.\n*/\n/* Start the program */\nesp_err_t err = ulp_run((&ulp_entry - RTC_SLOW_MEM) / sizeof(uint32_t));"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "IPv4Address resolve_domain(const std::string &to_resolve) {\n    addrinfo *result = ::resolve_domain(to_resolve, AF_INET);\n    IPv4Address addr(((sockaddr_in*)result->ai_addr)->sin_addr.s_addr);\n    freeaddrinfo(result);\n    return addr;\n}\n",
        "answer": "/** @brief Resolves a domain name to an IPv4 address.\n*\n*  If an IPv4 address is given, its integer representation is returned. Otherwise, the domain name is resolved and its IPv4 address is returned.\n*\n* @param[in] to_resolve The domain name or IPv4 address to resolve.\n* @return The resolved IPv4 address.\n*/\nIPv4Address resolve_domain(const std::string &to_resolve) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool appendFile(const QString &fileName, const QByteArray &data)\n{\n    if (fileName.isEmpty())\n        return false;\n    QFile f(fileName);\n    if (!touch(fileName) || !f.open(QFile::WriteOnly | QFile::Append))\n        return false;\n    bool b = (f.write(data) == data.size());\n    f.close();\n    return b;\n}\n",
        "answer": "/** @brief Appends data to a file.\n*\n*  This function appends the given data to the end of the specified file. If the file does not exist, it will be created automatically.\n*\n* @param fileName The name of the file to append to.\n* @param data The data to append to the file.\n* @return True on success, false if any error occurs.\n*/\nbool appendFile(const QString &fileName, const QByteArray &data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString localeBasedDirName(const QString &path, const QString &subpath, const QLocale &loc)\n{\n    if (path.isEmpty())\n        return \"\";\n    QString lname = loc.name().left(5);\n    QDir d(path + \"/\" + subpath + lname);\n    if (!d.exists())\n        d.setPath(path + \"/\" + subpath + lname.left(2));\n    if (!d.exists())\n        d.setPath(path + \"/\" + subpath + \"en\");\n    if (!d.exists())\n        d.setPath(path);\n    if (!d.exists())\n        return \"\";\n    return d.path();\n}\n",
        "answer": "/** @brief Returns the locale-based directory name for a given path and subpath, using the provided QLocale object.\n*\n* This function constructs a directory name based on the provided QLocale object, and checks if it exists in the file system. If it does not exist, it tries to construct a new directory name using the first two letters of the locale name, and then \"en\" as a fallback. If none of these directories exist, an empty QString is returned.\n*\n* @param path The base path for the directory.\n* @param subpath The subpath for the directory.\n* @param loc The QLocale object to use for constructing the directory name.\n* @return The locale-based directory name, or an empty QString if none of the constructed directories exist.\n*/\nQString localeBasedDirName(const QString &path, const QString &subpath, const QLocale &loc)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool writePropertiesFile(const QString &fileName, const BProperties &p, QTextCodec *codec)\n{\n    return writeTextFile(fileName, BeQt::propertiesToString(p), codec);\n}\n",
        "answer": "/** @brief Write properties file.\n*\n* This function writes a properties file to disk. It takes the name of the file, the properties object, and an optional text codec as input. The file is created automatically if it does not exist.\n*\n* @param fileName The name of the file to write.\n* @param p The properties object to write.\n* @param codec An optional text codec to use for encoding the file. If null, the default codec will be used.\n*\n* @return True on success, false if any error occurs.\n*/\nbool writePropertiesFile(const QString &fileName, const BProperties &p, QTextCodec *codec)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString macVersion()\n{\n    return macVersionToString(QSysInfo::macVersion());\n}\n",
        "answer": "/** @brief Returns a string containing the version of the Mac OS X, on which the application is running. Information is retrieved from the QSysInfo class.\n*\n*  This function returns a string containing the version of the Mac OS X, on which the application is running. The information is retrieved from the QSysInfo class.\n*\n* @return A string containing the version of the Mac OS X.\n*/\nQString macVersion()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void waitNonBlocking(const QObject *sender, const char *signal, int msecs)\n{\n    waitNonBlocking(QList<Until>() << until(sender, signal), msecs);\n}\n",
        "answer": "/** @brief Wait for a non-blocking event.\n*\n*  This function blocks execution of the current function, but does not block the Qt's signal and slot system. The GUI is not blocked either.\n*\n* @param sender The object that will emit the signal.\n* @param signal The name of the signal to wait for.\n* @param msecs The maximum time to wait in milliseconds.\n*\n* @return Should not return\n*/\nvoid waitNonBlocking(const QObject *sender, const char *signal, int msecs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString guessFileCodecName(const QString &fileName, qint64 bytes, const QLocale locale)\n{\n    if (fileName.isEmpty())\n        return \"\";\n    bool ok = false;\n    QByteArray data = BDirTools::readFile(fileName, bytes, &ok);\n    return ok ? guessTextCodecName(data, locale) : QString();\n}\n",
        "answer": "/** @brief Guesses the name of the corresponding QTextCodec for a given file.\n*\n*  This function takes in the name of a file and its size in bytes, as well as a locale object. It then reads the first few bytes of the file using the BDirTools::readFile() function, and passes them to the guessTextCodecName() function to determine the name of the corresponding QTextCodec. If it is not possible to determine the codec, an empty QString is returned.\n*\n* @param fileName The name of the file to be analyzed.\n* @param bytes The size of the file in bytes.\n* @param locale A locale object used for determining the codec.\n* @return The name of the corresponding QTextCodec, or an empty string if it cannot be determined.\n*/\nQString guessFileCodecName(const QString &fileName, qint64 bytes, const QLocale locale)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tk3d::uint_t gl_layer()\n\t{\n\t\treturn 2048;\n\t}\n",
        "answer": "/** @brief Returns the layer on which this renderable should be drawn. Lower-numbered layers are rendered earlier than higher-numbered layers. The (arbitrary) default layer for most 3D objects is 1024. Layer zero is reserved for the viewport background.\n*\n* @return The layer on which this renderable should be drawn.\n*/\nk3d::uint_t gl_layer()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid initialize(document_state& DocumentState, k3d::iproperty& Property)\n\t{\n\t\tentry::control* const control = new entry::control(new knot_vector_model(Property), &DocumentState.document().state_recorder());\n\t\tpack_start(*Gtk::manage(control), Gtk::PACK_EXPAND_WIDGET);\n\t}\n",
        "answer": "/** @brief Initializes the control for the given document state and property.\n*\n*  This function is called once at startup to initialize the control (this is necessary because plugins can't take constructor arguments).\n*\n* @param DocumentState The current document state.\n* @param Property The property to use for initialization.\n*/\nvoid initialize(document_state& DocumentState, k3d::iproperty& Property)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void on_update_mesh_topology(k3d::mesh& Output)\n    {\n        k3d::log() << info << \"Create Topology\" << std::endl;\n    \tOutput = k3d::mesh();\n    }\n",
        "answer": "/**\n* @brief Create a doxygen comment for the following C++ Function.\n*\n* This is the description of the functionality of the function.\n* Implement this in derived classes to setup the topology of the output mesh. Note that the output mesh is empty the first time this method is called, but will retain its state thereafter, so implementations must be written to ensure that they don't simply append to the existing state.\n*\n* @param Output The output mesh to be updated.\n*/\nvoid on_update_mesh_topology(k3d::mesh& Output)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tconst k3d::uint_t change_count()\n\t{\n\t\tif(!inotify)\n\t\t\treturn 0;\n\t\t\n\t\tinotify->SetNonBlock(true);\n\t\tinotify->WaitForEvents();\n\t\treturn inotify->GetEventCount();\n\t}\n",
        "answer": "/** @brief Returns the number of file changes that are pending and ready to be signalled. This method never blocks.\n*\n*  This function returns the number of file changes that are pending and ready to be signalled. It does not block, but instead returns immediately with the current count.\n*\n* @return The number of file changes that are pending and ready to be signalled.\n*/\nconst k3d::uint_t change_count()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tconst bool save_unsaved_changes()\n\t{\n\t\treturn on_file_save();\n\t}\n",
        "answer": "/** @brief Save the underlying document, returning true if it was saved successfully.\n*\n*  Implementations may need to prompt the user for a filename, and should return false if the user cancels file selection.\n*\n* @return True if the document was saved successfully, false otherwise.\n*/\nconst bool save_unsaved_changes()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid on_update_mesh_topology(k3d::mesh& Output)\n\t{\n\t\tOutput = k3d::mesh();\n\n\t\tk3d::iscript_engine::context context;\n\t\tcontext[\"document\"] = &document();\n\t\tcontext[\"node\"] = static_cast<k3d::inode*>(this);\n\t\tcontext[\"output\"] = &Output;\n\n\t\texecute_script(context);\n\t}\n",
        "answer": "/** @brief Updates the topology of the output mesh.\n*\n*  This function is called to setup the topology of the output mesh. Note that the output mesh is empty the first time this method is called, but will retain its state thereafter, so implementations must be written to ensure that they don't simply append to the existing state.\n*\n* @param Output The output mesh to update.\n*/\nvoid on_update_mesh_topology(k3d::mesh& Output)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tk3d::bool_t identify_mime_type(const k3d::filesystem::path& File, k3d::string_t& FileType)\n\t{\n\t\tbool uncertain = false;\n\t\tGlib::ustring mime_type = Gio::content_type_guess(File.native_filesystem_string(), std::string(), uncertain);\n\n\t\tif(uncertain)\n\t\t\treturn false;\n\n\t\tFileType = mime_type;\n\n\t\tk3d::log() << info << \"Identified \" << File.native_console_string() << \" as \" << FileType << \" using \" << get_factory().name() << std::endl;\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Identify the MIME Type of a file.\n*\n*  This function is called to identify the MIME Type of a file. It returns true iff the MIME Type was successfully identified.\n*\n* @param File The path to the file whose MIME Type is to be identified.\n* @param FileType A reference to a string that will hold the identified MIME Type.\n* @return True if the MIME Type was successfully identified, false otherwise.\n*/\nk3d::bool_t identify_mime_type(const k3d::filesystem::path& File, k3d::string_t& FileType)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid register_properties(const properties_t&)\n\t{\n\t}\n",
        "answer": "/** @brief Registers a set of properties with the collection.\n*\n*  This function registers a set of properties with the collection. The collection will assume responsibility for the lifetime of user properties only.\n*\n* @param[in] properties A reference to the properties_t object containing the properties to be registered.\n*/\nvoid register_properties(const properties_t& properties)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tconst k3d::string_t panel_type()\n\t{\n\t\treturn get_factory().name();\n\t}\n",
        "answer": "/** @brief Returns a unique string identifying the panel type.\n*\n*  This function is used to coordinate layout serialization for panel frames.\n*\n* @return A unique string identifying the panel type.\n*/\nconst k3d::string_t panel_type()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid initialize(document_state& DocumentState)\n\t{\n\t\tm_implementation = new detail::implementation(DocumentState);\n\n\t\tm_implementation->m_undo_button->signal_focus_in_event().connect(sigc::bind_return(sigc::hide(m_implementation->m_panel_grab_signal.make_slot()), false), false);\n\t\tm_implementation->m_redo_button->signal_focus_in_event().connect(sigc::bind_return(sigc::hide(m_implementation->m_panel_grab_signal.make_slot()), false), false);\n\t\tm_implementation->m_view.signal_focus_in_event().connect(sigc::bind_return(sigc::hide(m_implementation->m_panel_grab_signal.make_slot()), false), false);\n\t\t\n\t\tpack_start(*m_implementation, Gtk::PACK_EXPAND_WIDGET);\n\t\tshow_all();\n\t}\n",
        "answer": "/** @brief Initialize the document and parent command node for this panel.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param DocumentState The document state to initialize with.\n* @return Should not return\n*/\nvoid initialize(document_state& DocumentState)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid on_update_mesh_topology(k3d::mesh& Output)\n\t{\n\t\tOutput = k3d::mesh();\n\t\tboost::scoped_ptr<k3d::polyhedron::primitive> polyhedron(k3d::polyhedron::create(Output));\n\t\tpolyhedron->shell_types.push_back(k3d::polyhedron::POLYGONS);\n\t\tk3d::polyhedron::add_grid(Output, *polyhedron, 0, m_rows.pipeline_value(), m_columns.pipeline_value(), m_material.pipeline_value());\n\t}\n",
        "answer": "/** @brief Updates the topology of the output mesh.\n*\n*  This method is called to setup the topology of the output mesh. Note that the output mesh is empty the first time this method is called, but will retain its state thereafter, so implementations must be written to ensure that they don't simply append to the existing state.\n*\n* @param Output The output mesh to update.\n*/\nvoid on_update_mesh_topology(k3d::mesh& Output)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tk3d::uint_t gl_layer()\n\t{\n\t\treturn 4096;\n\t}\n",
        "answer": "/** @brief Get the layer on which this renderable should be drawn.\n*\n* This function returns the layer on which this renderable should be drawn. Lower-numbered layers are rendered earlier than higher-numbered layers. The (arbitrary) default layer for most 3D objects is 1024. Layer zero is reserved for the viewport background.\n*\n* @return The layer on which this renderable should be drawn.\n*/\nk3d::uint_t gl_layer()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid start_recording(std::unique_ptr<state_change_set> ChangeSet, const char* const Context)\n\t{\n\t\tif(!ChangeSet.get())\n\t\t{\n\t\t\tlog() << error << \"start_recording() attempt with NULL changeset.  Context: \" << Context << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(m_current_recording.get())\n\t\t{\n\t\t\tlog() << warning << \"Forcing termination of unfinished changeset.  Context: \" << m_current_context << std::endl;\n\t\t\tstd::unique_ptr<state_change_set> changeset = stop_recording(Context);\n\t\t\tcommit_change_set(std::move(changeset), \"Unfinished changeset\", Context);\n\t\t}\n\n\t\tm_current_recording = std::move(ChangeSet);\n\t\tm_current_context = Context;\n\t}\n",
        "answer": "/** @brief Starts recording state changes.\n*\n*  Called by clients to register a change set for recording subsequent state changes (the recorder assumes responsibility for the lifetime of the changeset)\n*\n* @param ChangeSet The change set to record.\n* @param Context The context in which the changes are being recorded.\n*/\nvoid start_recording(std::unique_ptr<state_change_set> ChangeSet, const char* const Context)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid on_deform_mesh(const k3d::mesh::points_t& InputPoints, const k3d::mesh::selection_t& PointSelection, k3d::mesh::points_t& OutputPoints)\n\t{\n\t\tconst k3d::matrix4 transformation = k3d::translate3(m_x.pipeline_value(), m_y.pipeline_value(), m_z.pipeline_value());\n\n\t\tk3d::parallel::parallel_for(\n\t\t\tk3d::parallel::blocked_range<k3d::uint_t>(0, OutputPoints.size(), k3d::parallel::grain_size()),\n\t\t\tlinear_transformation_worker(InputPoints, PointSelection, OutputPoints, transformation));\n\t}\n",
        "answer": "/** @brief Deforms the output mesh using input points and selection.\n*\n*  This method is used to deform the output mesh by applying a linear transformation to the input points based on the point selection.\n*\n* @param InputPoints The input points that will be transformed.\n* @param PointSelection The selection of points that will be transformed.\n* @param OutputPoints The output points that will be modified.\n*/\nvoid on_deform_mesh(const k3d::mesh::points_t& InputPoints, const k3d::mesh::selection_t& PointSelection, k3d::mesh::points_t& OutputPoints)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tk3d::uint_t watch_path(const k3d::filesystem::path& Path, const sigc::slot<void>& Slot)\n\t{\t\n\t\treturn 0;\n\t}\n",
        "answer": "/** @brief Call a slot whenever given filesystem path is modified.\n*\n* This function watches the specified file system path for modifications and calls the provided slot when a modification occurs.\n* The slot will be called when a file is created / modified / renamed / deleted at that location.\n* Returns a nonzero watch identifier that is used to cancel the watch later-on, or 0 if there is an error or the implementation does not support path-watching.\n* Note that we are watching the path, not an inode, so it isn't an error to specify a path for a nonexistent file.\n*\n* @param Path The file system path to watch for modifications.\n* @param Slot The slot to call when a modification occurs.\n* @return A nonzero watch identifier if the watch is successful, or 0 if there is an error or the implementation does not support path-watching.\n*/\nk3d::uint_t watch_path(const k3d::filesystem::path& Path, const sigc::slot<void>& Slot)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void require_metadata(const mesh::primitive& Primitive, const array& Array, const string_t& ArrayName, const string_t& MetadataName, const string_t& MetadataValue)\n{\n\tif(Array.get_metadata_value(MetadataName) != MetadataValue)\n\t{\n\t\tstd::ostringstream buffer;\n\t\tbuffer << \"[\" << Primitive.type << \"] primitive [\" << ArrayName << \"] array missing [\" << MetadataName << \"] metadata value [\" << MetadataValue << \"]\";\n\t\tthrow std::runtime_error(buffer.str());\n\t}\n}\n",
        "answer": "/** @brief Requires metadata for a mesh primitive array.\n*\n*  This function tests an array to verify that it has metadata with the given name and value, throws an exception otherwise.\n*\n* @param Primitive The mesh primitive object.\n* @param Array The array to be tested.\n* @param ArrayName The name of the array.\n* @param MetadataName The name of the metadata to be tested.\n* @param MetadataValue The value of the metadata to be tested.\n* @return Void.\n*/\nvoid require_metadata(const mesh::primitive& Primitive, const array& Array, const string_t& ArrayName, const string_t& MetadataName, const string_t& MetadataValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const string_t demangle(const std::type_info& Type)\n{\n\treturn detail::demangle(Type.name());\n}\n",
        "answer": "/** @brief Returns an informal, human-readable string representation for the given type. On platforms that support it, the returned string will be the fully-qualified type-name, including namespaces. Otherwise, the result will be the mangled symbol name or some other unique string representation. Note: this function is only for use in error-messages and for troubleshooting, you cannot make any assumptions about the return values.\n*  @param Type The type to demangle.\n*  @return A string representing the demangled type.\n*/\nconst string_t demangle(const std::type_info& Type)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const string_t domain()\n{\n\treturn \"k3d:domain\";\n}\n",
        "answer": "/** @brief Returns the metadata key for defining the domain over which a value / collection of values is defined.\n*\n*  This function returns the metadata key \"k3d:domain\", which is commonly used with geometric primitives to specify that one array contains indices into another.\n*\n* @return A string representing the metadata key for defining the domain.\n*/\nconst string_t domain()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const string_t nurbs_knot_vector_role()\n{\n\treturn \"k3d:nurbs-knot-vector\";\n}\n",
        "answer": "/** @brief Returns the metadata value for use with \"k3d:role\" that specifies that an array of floating-point values is a NURBS knot vector.\n*\n*  This function returns the string \"k3d:nurbs-knot-vector\", which is used to specify that an array of floating-point values is a NURBS knot vector.\n*\n* @return A string representing the metadata value for use with \"k3d:role\" that specifies that an array of floating-point values is a NURBS knot vector.\n*/\nconst string_t nurbs_knot_vector_role()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int run(Gtk::Window& Parent, const std::string& Title)\n{\n\tGtk::MessageDialog dialog(Parent, \"\", false, Gtk::MESSAGE_WARNING, Gtk::BUTTONS_NONE);\n\n\tdialog.set_message(string_cast(boost::format(_(\"Save the changes to document \\\"%1%\\\" before closing?\")) % Title));\n\tdialog.set_secondary_text( _(\"If you don't save, changes will be permanently lost (no undo).\"));\n\n\tGtk::Button* const close_button = new Gtk::Button(_(\"Cl_ose without Saving\"), true);\n\tclose_button->show();\n\n\tdialog.add_action_widget(*Gtk::manage(close_button), Gtk::RESPONSE_CLOSE);\n\tdialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);\n\tdialog.add_button(Gtk::Stock::SAVE, Gtk::RESPONSE_OK);\n\n\tdialog.set_default_response(Gtk::RESPONSE_OK);\n\n\tconst int result = dialog.run();\n\n\treturn result;\n}\n",
        "answer": "/** @brief Prompts the user with a modal dialog and returns Gtk::RESPONSE_NONE (cancel closing), Gtk::RESPONSE_CLOSE (close without saving), Gtk::RESPONSE_CANCEL (cancel closing), or Gtk::RESPONSE_OK (save before closing)\n*\n* @param Parent The parent window of the dialog.\n* @param Title The title of the document to be saved.\n* @return An integer representing the user's response to the dialog, as defined by the Gtk::RESPONSE constants.\n*/\nint run(Gtk::Window& Parent, const std::string& Title)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void add_face(mesh& Mesh, primitive& Polyhedron, const uint_t Shell, const mesh::points_t& Vertices, imaterial* const Material)\n{\n\tadd_face(Mesh, Polyhedron, Shell, Vertices, std::vector<mesh::points_t>(), Material);\n}\n",
        "answer": "/** @brief Adds a face to an existing polyhedron shell.\n*\n*  This function adds a face to an existing polyhedron shell. Preconditions: the polyhedron must already contain at least one shell.\n*\n* @param Mesh The mesh containing the polyhedron.\n* @param Polyhedron The polyhedron to which the face will be added.\n* @param Shell The index of the shell to which the face will be added.\n* @param Vertices The vertices of the face.\n* @param Material The material of the face.\n* @return void\n*/\nvoid add_face(mesh& Mesh, primitive& Polyhedron, const uint_t Shell, const mesh::points_t& Vertices, imaterial* const Material)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "k3d::bool_t do_named_action(atk_object_wrapper& Self, const k3d::string_t& ActionName)\n{\n\tAtkObject* atk_object = Self.wrapped_ptr();\n\treturn_val_if_fail(ATK_IS_ACTION(atk_object), false);\n\tAtkAction* action = ATK_ACTION(atk_object);\n\tk3d::int32_t action_idx = action_index(action, ActionName);\n\treturn_val_if_fail(action_idx > -1, false);\n\tk3d::bool_t result = atk_action_do_action(action, action_idx);\n\tk3d::user_interface().synchronize();\n\treturn result;\n}\n",
        "answer": "/**\n* @brief Performs the action with the given name. Requires Self to be an AtkAction and the action must exist (caller needs to check this)\n*\n* @param Self The object that contains the action\n* @param ActionName The name of the action to perform\n* @return true if the action was performed successfully, false otherwise\n*/\nk3d::bool_t do_named_action(atk_object_wrapper& Self, const k3d::string_t& ActionName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const filesystem::path find_executable(const string_t& Executable)\n{\n\tconst string_t executable_name = k3d::system::executable_name(Executable);\n\n\tfilesystem::path result;\n\n\tconst filesystem::path_list paths = filesystem::split_native_paths(ustring::from_utf8(system::getenv(\"PATH\")));\n\tfor(filesystem::path_list::const_iterator path = paths.begin(); path != paths.end(); ++path)\n\t{\n\t\tconst filesystem::path test_path = (*path) / filesystem::generic_path(ustring::from_utf8(executable_name));\n\t\tif(filesystem::exists(test_path))\n\t\t{\n\t\t\tresult = test_path;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n",
        "answer": "/** @brief Finds the path to a binary executable by searching the contents of the PATH environment variable, or an empty path.\n*\n*  This function searches for the specified executable in the directories listed in the PATH environment variable. If it is found, the full path to the executable is returned. Otherwise, an empty path is returned.\n*\n* @param Executable The name of the executable to search for.\n* @return The path to the executable, or an empty path if not found.\n*/\nconst filesystem::path find_executable(const string_t& Executable)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const k3d::uint_t get_index_in_role(AtkObject* Object)\n{\n\tconst k3d::uint_t index_in_parent = atk_object_get_index_in_parent(Object);\n\tconst AtkRole role = atk_object_get_role(Object);\n\tAtkObject* parent = atk_object_get_parent(Object);\n\treturn_val_if_fail(parent, 0);\n\tk3d::uint_t result = 0;\n\tfor(k3d::uint_t i = 0; i != index_in_parent; ++i)\n\t{\n\t\tif(atk_object_get_role(atk_object_ref_accessible_child(parent, i)) == role)\n\t\t\t++result;\n\t}\n\treturn result;\n}\n",
        "answer": "/** @brief Returns the index in a \"per role\" array of children, for the given child number of the parent Object.\n*\n*  This function returns the index in a \"per role\" array of children, for the given child number of the parent Object.\n*\n* @param[in] Object The AtkObject whose role is to be determined.\n*\n* @return The index in a \"per role\" array of children, for the given child number of the parent Object.\n*/\nconst k3d::uint_t get_index_in_role(AtkObject* Object)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mha_fft_wave2spec(mha_fft_t h,const mha_wave_t* in, mha_spec_t* out, \n                       bool swap)\n{\n    ((MHASignal::fft_t*)h)->wave2spec(in,out,swap);\n}\n",
        "answer": "/** @brief Converts a waveform to a spectrogram using the MHA FFT library.\n*\n*  This function converts a waveform to a spectrogram using the MHA FFT library. It takes an MHA FFT handle, a pointer to the input waveform, and a pointer to the output spectrogram as arguments. If the swaps parameter is true, it will swap the wave buffer halves before transforming.\n*\n* @param h The MHA FFT handle.\n* @param in A pointer to the input waveform.\n* @param out A pointer to the output spectrogram.\n* @param swap A boolean indicating whether to swap the wave buffer halves before transforming.\n*/\nvoid mha_fft_wave2spec(mha_fft_t h,const mha_wave_t* in, mha_spec_t* out,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mha_fft_spec2wave_scale(mha_fft_t h,const mha_spec_t* in, mha_wave_t* out)\n{\n    ((MHASignal::fft_t*)h)->spec2wave_scale(in,out);\n}\n",
        "answer": "/** @brief Performs a scaled FFT on an audio signal.\n*\n*  This function takes in an audio signal represented as a complex spectrum and performs a scaled FFT on it, producing a waveform output. The scaling is done using standard DFT scaling: there is no scaling in the forward transformation, and 1/N scaling for the backward.\n*\n* @param h A handle to the MHA_FFT object.\n* @param in Pointer to the input complex spectrum.\n* @param out Pointer to the output waveform.\n*/\nvoid mha_fft_spec2wave_scale(mha_fft_t h, const mha_spec_t* in, mha_wave_t* out)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ssize_t qemu_iovec_compare(QEMUIOVector *a, QEMUIOVector *b)\n{\n    int i;\n    ssize_t offset = 0;\n\n    assert(a->niov == b->niov);\n    for (i = 0; i < a->niov; i++) {\n        size_t len = 0;\n        uint8_t *p = (uint8_t *)a->iov[i].iov_base;\n        uint8_t *q = (uint8_t *)b->iov[i].iov_base;\n\n        assert(a->iov[i].iov_len == b->iov[i].iov_len);\n        while (len < a->iov[i].iov_len && *p++ == *q++) {\n            len++;\n        }\n\n        offset += len;\n\n        if (len != a->iov[i].iov_len) {\n            return offset;\n        }\n    }\n    return -1;\n}\n",
        "answer": "/**\n* @brief Compares two QEMUIOVector objects.\n*\n* This function compares two QEMUIOVector objects and returns a value indicating whether they are identical or not. The comparison is done by checking that the IO vectors have the same structure (same length of all parts) and that each part of the vector contains the same data. A typical usage is to compare vectors created with qemu_iovec_clone().\n*\n* @param a The first QEMUIOVector object to compare.\n* @param b The second QEMUIOVector object to compare.\n* @return 0 if the IO vectors are identical, -1 otherwise.\n*/\nssize_t qemu_iovec_compare(QEMUIOVector *a, QEMUIOVector *b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "sshsNode sshsNodeGetChild(sshsNode node, const char *childName) {\n\tstd::shared_lock<std::shared_timed_mutex> lock(node->traversal_lock);\n\n\tif (node->children.count(childName)) {\n\t\treturn (node->children[childName]);\n\t}\n\telse {\n\t\treturn (nullptr);\n\t}\n}\n",
        "answer": "/** @brief Returns a reference to the child node with the given name, or nullptr if no such child exists.\n*\n* This function returns a reference to the child node with the given name, or nullptr if no such child exists.\n* The returned reference must be carefully managed with any calls to sshsNodeRemoveNode(), as it may become invalidated.\n*\n* @param node The parent node.\n* @param childName The name of the child node to retrieve.\n* @return A reference to the child node, or nullptr if no such child exists.\n*/\nsshsNode sshsNodeGetChild(sshsNode node, const char *childName) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void opcontrol() {\n\tpros::Controller master(pros::E_CONTROLLER_MASTER);\n\tpros::Motor left_mtr(1);\n\tpros::Motor right_mtr(2);\n\twhile (true) {\n\t\tpros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0);\n\t\tint left = master.get_analog(ANALOG_LEFT_Y);\n\t\tint right = master.get_analog(ANALOG_RIGHT_Y);\n\n\t\tleft_mtr = left;\n\t\tright_mtr = right;\n\t\tpros::delay(20);\n\t}\n}\n",
        "answer": "/** @brief Runs the operator control code.\n*\n*  This function will be started in its own task with the default priority and stack size whenever the robot is enabled via the Field Management System or the VEX Competition Switch in the operator control mode. If no competition control is connected, this function will run immediately following initialize(). If the robot is disabled or communications is lost, the operator control task will be stopped. Re-enabling the robot will restart the task, not resume it from where it left off.\n*\n* @param master The controller object for the master controller.\n* @param left_mtr The motor object for the left motor.\n* @param right_mtr The motor object for the right motor.\n* @return Should not return\n*/\nvoid opcontrol(pros::Controller master, pros::Motor left_mtr, pros::Motor right_mtr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void childBoundsChanged (Component* child)\n    {\n        const int cw = child->getWidth();\n        const int ch = child->getHeight();\n\n        setSize (cw, ch);\n\n        if (uiResize != nullptr)\n            uiResize->ui_resize (uiResize->handle, cw, ch);\n    }\n",
        "answer": "/** @brief Called when one of this component's children is moved or resized. If the parent wants to know about changes to its immediate children (not to children of its children), this is the method to override.\n*\n*  This function is called whenever a child component of this component is moved or resized. It is used to update the size of the component and call the ui_resize() function on the uiResize object, if it exists.\n*\n* @param child The child component that was moved or resized.\n*/\nvoid childBoundsChanged (Component* child)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool HandlesEnumWindows(std::vector<WINDOW_INFO> & windowsList)\r\n{\r\n    std::vector<WINDOW_INFO> childWindowsList;\r\n    EnumWindows(getWindowInfoCallback, (LPARAM)&windowsList);\r\n    auto i = windowsList.begin();\r\n    for(auto i = windowsList.cbegin(); i != windowsList.cend(); ++i)\r\n    {\r\n        EnumChildWindows((HWND)i->handle, getWindowInfoCallback, (LPARAM)&childWindowsList);\r\n    }\r\n    for(auto i = childWindowsList.cbegin(); i != childWindowsList.cend(); ++i)\r\n    {\r\n        windowsList.push_back(*i);\r\n    }\r\n    return true;\r\n}\r\n",
        "answer": "/** @brief Enumerates the window and returns a list of all the windows owned by the debuggee (currently only top level windows).\n*\n*  This function enumerates the windows and returns a list of all the windows owned by the debuggee, currently only top-level windows.\n*\n* @param[in] windowsList A reference to a vector of WINDOW_INFO objects that will be filled with the window information.\n* @return true if the function succeeds, false otherwise.\n*/\nbool HandlesEnumWindows(std::vector<WINDOW_INFO> &windowsList)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void read_head(const std::string &fn, int rank, unsigned *fields) {\n  FILE *f = nullptr;\n  if (rank == 0) {\n    if (!(f = fopen(fn.c_str(), \"rb\"))) {\n      fprintf(stderr, \"MPI-IO: Could not open %s.head.\\n\", fn.c_str());\n      errexit();\n    }\n    if (fread((void *)fields, sizeof(unsigned), 1, f) != 1) {\n      fprintf(stderr, \"MPI-IO: Read on %s.head failed.\\n\", fn.c_str());\n      errexit();\n    }\n    MPI_Bcast(fields, 1, MPI_UNSIGNED, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Bcast(fields, 1, MPI_UNSIGNED, 0, MPI_COMM_WORLD);\n  }\n  free(f);\n}\n",
        "answer": "/** @brief Reads the header of a file and stores the information in the pointer \"fields\". This function should be called by all processes.\n*\n*  @param fn The name of the file to read.\n*  @param rank The rank of the process calling this function.\n*  @param fields A pointer to an array of unsigned integers where the header information will be stored.\n*\n*  @return Should not return.\n*/\nvoid read_head(const std::string &fn, int rank, unsigned *fields) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mpi_bcast_ia_params(int i, int j) {\n  mpi_call(mpi_bcast_ia_params_slave, i, j);\n\n  if (j >= 0) {\n    /* non-bonded interaction parameters */\n    boost::mpi::broadcast(comm_cart, *get_ia_param(i, j), 0);\n\n    *get_ia_param(j, i) = *get_ia_param(i, j);\n  } else {\n    /* bonded interaction parameters */\n    MPI_Bcast(&(bonded_ia_params[i]), sizeof(Bonded_ia_parameters), MPI_BYTE, 0,\n              comm_cart);\n#ifdef TABULATED\n    /* For tabulated potentials we have to send the tables extra */\n    if (bonded_ia_params[i].type == BONDED_IA_TABULATED) {\n      boost::mpi::broadcast(comm_cart, *bonded_ia_params[i].p.tab.pot, 0);\n    }\n#endif\n  }\n\n  on_short_range_ia_change();\n}\n",
        "answer": "/**\n* @brief Broadcasts interaction parameters to all processes in the communicator.\n*\n* This function broadcasts the interaction parameters for a given pair of atoms (i, j) to all processes in the communicator.\n* If j is negative, it means that the interaction is non-bonded and the parameters are broadcasted using Boost MPI's `broadcast` function.\n* Otherwise, if j is positive, it means that the interaction is bonded and the parameters are broadcasted using MPI's `MPI_Bcast` function.\n* In both cases, the `on_short_range_ia_change` function is called after the broadcast to update any necessary data structures.\n*\n* @param i The index of the first atom in the interaction.\n* @param j The index of the second atom in the interaction. If negative, the interaction is non-bonded. Otherwise, it is bonded.\n*/\nvoid mpi_bcast_ia_params(int i, int j) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void lattice_boltzmann_update() {\n  auto factor = (int)round(lbpar.tau / time_step);\n\n  fluidstep += 1;\n  if (fluidstep >= factor) {\n    fluidstep = 0;\n\n    lb_collide_stream();\n  }\n}\n",
        "answer": "/** @brief Update the lattice Boltzmann fluid.\n*\n* This function is called from the integrator and updates the lattice Boltzmann fluid. Since the time step for the lattice dynamics can be coarser than the MD time step, we monitor the time since the last lattice update.\n*\n* @param lbpar The Lattice Boltzmann parameters.\n* @param time_step The time step of the simulation.\n* @return void\n*/\nvoid lattice_boltzmann_update(lbpar, time_step) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void realloc_ia_params(int nsize) {\n  if (nsize <= max_seen_particle_type)\n    return;\n\n  auto new_params = std::vector<IA_parameters>(nsize * nsize);\n\n  /* if there is an old field, move entries */\n  for (int i = 0; i < max_seen_particle_type; i++)\n    for (int j = 0; j < max_seen_particle_type; j++) {\n      new_params[i * nsize + j] =\n          std::move(ia_params[i * max_seen_particle_type + j]);\n    }\n\n  max_seen_particle_type = nsize;\n  std::swap(ia_params, new_params);\n}\n",
        "answer": "/** @brief Reallocates the ia_params field for non-bonded interactions to the given size.\n*\n* This function increases the LOCAL ia_params field for non-bonded interactions to the given size. This function is not exported since it does not do this on all nodes. Use make_particle_type_exist for that.\n*\n* @param nsize The new size of the ia_params field.\n*/\n/* if there is an old field, move entries */\nfor (int i = 0; i < max_seen_particle_type; i++)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dp3m_dipole_assign(void) {\n  /* magnetic particle counter, dipole fraction counter */\n  int cp_cnt = 0;\n\n  /* prepare local FFT mesh */\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < dp3m.local_mesh.size; j++)\n      dp3m.rs_mesh_dip[i][j] = 0.0;\n\n  for (auto const &p : local_cells.particles()) {\n    if (p.p.dipm != 0.0) {\n      dp3m_assign_dipole(p.r.p.data(), p.p.dipm, p.calc_dip().data(), cp_cnt);\n      cp_cnt++;\n    }\n  }\n\n  dp3m_shrink_wrap_dipole_grid(cp_cnt);\n}\n",
        "answer": "/** @brief Assigns dipoles using the tabulated assignment function. If Dstore_ca_frac is true, then the charge fractions are buffered in Dcur_ca_fmp and Dcur_ca_frac.\n*\n*  This function assigns dipoles using the tabulated assignment function. If Dstore_ca_frac is true, then the charge fractions are buffered in Dcur_ca_fmp and Dcur_ca_frac.\n*\n* @param void\n* @return void\n*/\n/* magnetic particle counter, dipole fraction counter */\n/* prepare local FFT mesh */\nfor (int i = 0; i < 3; i++)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void p3m_calc_differential_operator() {\n  int i, j;\n\n  for (i = 0; i < 3; i++) {\n    p3m.d_op[i] =\n        Utils::realloc(p3m.d_op[i], p3m.params.mesh[i] * sizeof(double));\n    p3m.d_op[i][0] = 0;\n    p3m.d_op[i][p3m.params.mesh[i] / 2] = 0.0;\n\n    for (j = 1; j < p3m.params.mesh[i] / 2; j++) {\n      p3m.d_op[i][j] = j;\n      p3m.d_op[i][p3m.params.mesh[i] - j] = -j;\n    }\n  }\n}\n",
        "answer": "/** @brief Calculate the Fourier transformed differential operator. Remark: This is done on the level of n-vectors and not k-vectors, i.e. the prefactor i*2*PI/L is missing!\n*\n* @param p3m The P3M structure containing the parameters and mesh information.\n* @return void\n*/\nvoid p3m_calc_differential_operator() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void rotate_system(double phi, double theta, double alpha) {\n  mpi_rotate_system(phi, theta, alpha);\n}\n",
        "answer": "/** @brief Rotate all particle coordinates around an axis given by phi,theta through the center of mass by an angle alpha.\n*\n* This function rotates all particle coordinates around an axis given by phi,theta through the center of mass by an angle alpha.\n*\n* @param phi The angle of rotation around the x-axis.\n* @param theta The angle of rotation around the y-axis.\n* @param alpha The angle of rotation around the z-axis.\n*/\nvoid rotate_system(double phi, double theta, double alpha) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void thermo_heat_up() {\n  if (thermo_switch & THERMO_LANGEVIN) {\n    langevin_heat_up();\n  }\n#ifdef DPD\n  if (thermo_switch & THERMO_DPD) {\n    dpd_heat_up();\n  }\n#endif\n  if (n_thermalized_bonds) {\n    thermalized_bond_heat_up();\n  }\n}\n",
        "answer": "/** @brief Thermostat heat up function.\n*\n*  This function is used to heat up the thermostat. It checks if the Langevin or DPD thermostats are enabled and calls the appropriate functions. If there are any thermalized bonds, it also calls the thermalized bond heat up function.\n*\n* @return Should not return\n*/\nvoid thermo_heat_up() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void closeSha384Context(void* ctx, unsigned char* digest)\n{\n    gcry_md_hd_t hd = (gcry_md_hd_t)ctx;\n\n    if (digest != NULL) {\n        uint8_t* p = gcry_md_read (hd, GCRY_MD_SHA384);\n        memcpy(digest, p, SHA384_DIGEST_LENGTH);\n    }\n    gcry_md_close (hd);\n}\n",
        "answer": "/** @brief Close the SHA384 digest context.\n*\n*  This function computes the SHA384 digest and closes the SHA384 context.\n*\n* @param ctx The SHA384 context to close.\n* @param digest A pointer to a buffer where the computed digest will be stored. If NULL, the digest is not returned.\n*/\nvoid closeSha384Context(void* ctx, unsigned char* digest)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void zrtp_processZrtpMessage(ZrtpContext* zrtpContext, uint8_t *extHeader, uint32_t peerSSRC) {\n    if (initialized)\n        zrtpContext->zrtpEngine->processZrtpMessage(extHeader, peerSSRC);\n}\n",
        "answer": "/** @brief Process RTP extension header.\n*\n* This method expects to get a pointer to the message part of a ZRTP packet.\n*\n* @param zrtpContext Pointer to the ZRTP context.\n* @param extHeader Pointer to the extension header.\n* @param peerSSRC The SSRC of the peer.\n*/\nvoid zrtp_processZrtpMessage(ZrtpContext* zrtpContext, uint8_t *extHeader, uint32_t peerSSRC) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t zrtp_isMultiStreamAvailable(ZrtpContext* zrtpContext) {\n    if (initialized)\n        return zrtpContext->zrtpEngine->isMultiStreamAvailable() ? 1 : 0;\n\n    return 0;\n}\n",
        "answer": "/** @brief Check if the other ZRTP client supports Multi-stream.\n*\n* This method checks if the other ZRTP client supports Multi-stream mode.\n*\n* @param zrtpContext The ZRTP context to check.\n* @return 1 if the other ZRTP client supports Multi-stream, 0 otherwise.\n*/\nint32_t zrtp_isMultiStreamAvailable(ZrtpContext* zrtpContext) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t zrtp_getSignatureLength(ZrtpContext* zrtpContext) {\n    if (initialized)\n        return zrtpContext->zrtpEngine->getSignatureLength();\n\n    return 0;\n}\n",
        "answer": "/** @brief Get length of signature data.\n*\n* This function returns the length of signature data that was received during ZRTP processing. Refer to chapters 5.7 and 7.2.\n*\n* @param zrtpContext The ZRTP context.\n* @return The length of the signature data, or 0 if not initialized.\n*/\nint32_t zrtp_getSignatureLength(ZrtpContext* zrtpContext) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "MStatus uninstallCallback()\n{\n\tMStatus status = MMessage::removeCallbacks(CallbackNode::callbacks);\n\tMGlobal::displayInfo(\"Removed feature!\");\n\treturn status;\n}\n",
        "answer": "/** @brief Uninstalls the callback for the example feature.\n*\n*  This function will handle cleanup of all callbacks that were installed for the example feature to work.\n*\n* @return Should not return\n*/\nMStatus uninstallCallback()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool MetaDirDiff(std::string dir1, std::string dir2,\n                 uint64_t* num_checked_ret) {\n  return MetaDirDiffRun(dir1, dir2)(num_checked_ret);\n}\n",
        "answer": "/** @brief Compares two metadata server directories to check whether the size, uid, gid, permissions etc, link target and xattr of its inodes are identical.\n*\n*  This function compares two metadata server directories to check whether the size, uid, gid, permissions etc, link target and xattr of its inodes are identical.\n*\n* @param dir1 The first directory to compare.\n* @param dir2 The second directory to compare.\n* @param num_checked_ret The number of inodes checked during the comparison.\n* @return Whether the directories are identical or not.\n*/\nbool MetaDirDiff(std::string dir1, std::string dir2, uint64_t* num_checked_ret) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "byte server_delete_log ( char *p )\n{\n\n    if ( !findKeyVal ( p, tmp_buffer, TMP_BUFFER_SIZE, PSTR ( \"day\" ), true ) )\n        return HTML_DATA_MISSING;\n\n    delete_log ( tmp_buffer );\n\n    return HTML_SUCCESS;\n}\n",
        "answer": "/** @brief Server delete log function.\n*\n*  This function is used to delete log files from the server.\n*  It takes a single argument, p, which is a pointer to a character array containing the password and day (epoch time / 86400) or \"all\" if all log files should be deleted.\n*  The function first checks if the key-value pair for \"day\" exists in the input string using findKeyVal(). If it does not exist, it returns HTML_DATA_MISSING.\n*  Otherwise, it calls delete_log() with the value of \"day\" as an argument to delete the log files.\n*  Finally, it returns HTML_SUCCESS to indicate that the operation was successful.\n*\n* @param p Pointer to a character array containing the password and day (epoch time / 86400) or \"all\".\n* @return HTML_DATA_MISSING if the key-value pair for \"day\" does not exist, otherwise returns HTML_SUCCESS.\n*/\nbyte server_delete_log(char *p) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double HostClockTime() {\n    return SDL_GetTicks()*0.001;\n}\n",
        "answer": "/** @brief Returns the host clock time in seconds.\n*\n*  This function returns the current time in seconds, using the SDL_GetTicks() function to get the number of milliseconds since the system was started. The result is then converted to seconds by multiplying it by 0.001.\n*\n* @return The host clock time in seconds.\n*/\ndouble HostClockTime() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CBaseChainParams::Network NetworkIdFromCommandLine()\r\n{\r\n    bool fRegTest = GetBoolArg(\"-regtest\", false);\r\n    bool fTestNet = GetBoolArg(\"-testnet\", false);\r\n\r\n    if (fTestNet && fRegTest)\r\n        return CBaseChainParams::MAX_NETWORK_TYPES;\r\n    if (fRegTest)\r\n        return CBaseChainParams::REGTEST;\r\n    if (fTestNet)\r\n        return CBaseChainParams::TESTNET;\r\n    return CBaseChainParams::MAIN;\r\n}\r\n",
        "answer": "/** @brief Returns the appropriate Network ID based on command line arguments.\n*\n*  This function looks for -regtest or -testnet and returns the appropriate Network ID.\n*  If an invalid combination is given, it returns CBaseChainParams::MAX_NETWORK_TYPES.\n*\n* @param fRegTest A boolean indicating whether the -regtest argument was provided.\n* @param fTestNet A boolean indicating whether the -testnet argument was provided.\n* @return The appropriate Network ID based on the command line arguments.\n*/\nCBaseChainParams::Network NetworkIdFromCommandLine(bool fRegTest, bool fTestNet)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void DecryptAES(uint256 encryptedIn, uint256 decryptionKey, uint256& output)\n{\n    AES_KEY key;\n    AES_set_decrypt_key(decryptionKey.begin(), 256, &key);\n    AES_decrypt(encryptedIn.begin(), output.begin(), &key);\n}\n",
        "answer": "/** @brief Decrypts an AES-256 encrypted input using a given decryption key and stores the result in the output parameter.\n*\n*  This function takes an AES-256 encrypted input, a decryption key, and an output parameter. It uses the OpenSSL library to perform the decryption and stores the result in the output parameter.\n*\n* @param[in] encryptedIn The AES-256 encrypted input to be decrypted.\n* @param[in] decryptionKey The decryption key used to decrypt the input.\n* @param[out] output The decrypted output.\n*\n* @return None.\n*/\nvoid DecryptAES(uint256 encryptedIn, uint256 decryptionKey, uint256& output)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SetRPCWarmupStatus(const std::string& newStatus)\n{\n    LOCK(cs_rpcWarmup);\n    rpcWarmupStatus = newStatus;\n}\n",
        "answer": "/** @brief Set the RPC warmup status.\n*\n*  This function sets the RPC warmup status to a given string. When this is done, all RPC calls will error out immediately with RPC_IN_WARMUP.\n*\n* @param newStatus The new status to set for the RPC warmup.\n*/\nvoid SetRPCWarmupStatus(const std::string& newStatus)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void drawSolidPoly(const Vec2 *poli, unsigned int numberOfPoints, Color4F color)\n{\n    lazy_init();\n\n    s_shader->use();\n    s_shader->setUniformsForBuiltins();\n    s_shader->setUniformLocationWith4fv(s_colorLocation, (GLfloat*) &color.r, 1);\n\n    GL::enableVertexAttribs( GL::VERTEX_ATTRIB_FLAG_POSITION );\n\n    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, 0, poli);\n    glDrawArrays(GL_TRIANGLE_FAN, 0, (GLsizei) numberOfPoints);\n\n    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1, numberOfPoints);\n}\n",
        "answer": "/**\n* @brief Draws a solid polygon given a pointer to CGPoint coordinates, the number of vertices measured in points, and a color.\n*\n* This function draws a solid polygon on the screen using the specified color and vertex coordinates. The number of vertices is measured in points, and the polygon is drawn using the GL_TRIANGLE_FAN mode.\n*\n* @param poli A pointer to an array of CGPoint structures that define the vertex coordinates of the polygon.\n* @param numberOfPoints The number of vertices in the polygon, measured in points.\n* @param color The color of the polygon, represented as a Color4F structure.\n*/\nvoid drawSolidPoly(const Vec2 *poli, unsigned int numberOfPoints, Color4F color)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ccArrayRemoveArray(ccArray *arr, ccArray *minusArr)\n{\n\tfor (ssize_t i = 0; i < minusArr->num; i++)\n    {\n\t\tccArrayRemoveObject(arr, minusArr->arr[i]);\n    }\n}\n",
        "answer": "/** @brief Removes from arr all objects in minusArr. For each object in minusArr, the first matching instance in arr will be removed.\n*\n*  This function removes all objects in minusArr from arr. It iterates through minusArr and for each object, it finds the first matching instance in arr and removes it.\n*\n* @param arr The array to remove objects from.\n* @param minusArr The array of objects to be removed from arr.\n* @return void\n*/\nvoid ccArrayRemoveArray(ccArray *arr, ccArray *minusArr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void recordMatch( bool results[NumTestFiles], OsPath& matched )\n    {\n       int file;\n       bool found;\n\n       TRACE_TEST((\"\\n ####### found '%s'\", matched.data()));\n       for ( file = 0, found = false; file < NumTestFiles && ! found; file++ )\n       {\n          if ( matched == TestFiles[file] )\n          {\n             CPPUNIT_ASSERT_MESSAGE( \"Found the same file twice.\", results );\n             results[file] = true;\n             found = true;\n          }\n       }\n       CPPUNIT_ASSERT_MESSAGE( \"Found a file not in the test set.\", found );\n    }\n",
        "answer": "/**\n* @brief Records the match of a file in the test set.\n*\n* This function finds the element in TestFiles that was matched, and records that fact in the results array. We do it this way because the order in which the matches will occur is undefined.\n*\n* @param results An array of booleans indicating whether each file in the test set has been matched.\n* @param matched The path to the file that was matched.\n*/\nvoid recordMatch(bool results[NumTestFiles], OsPath& matched) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void testCompareTo()\n    {\n        utlTestCompareOrEquals(TEST_COMPARE) ; \n    }\n",
        "answer": "/** @brief Test the compareTo method.\n*\n* This function tests the compareTo method with different values that are equal to, greater than, and less than itself.\n*\n* @return None\n*/\nvoid testCompareTo()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void testAppend_charstar_specifyAllCharacters_toExistingString()\n    {\n        utlTestAppend_Charstar_to_ExistingString(true, TEST_APPEND) ;\n        utlTestAppend_MaxCapacity(TYPE_CHARSTAR, true) ;\n    }\n",
        "answer": "/** @brief Tests the append_charstar_specifyAllCharacters_toExistingString function.\n*\n*  This test case tests the functionality of the append_charstar_specifyAllCharacters_toExistingString function, which appends a character string to an existing string. The test data for this test case are all cases of the testAppend_char_toExistingString() test case.\n*\n* @param[in] true - indicates that the test case should use all characters in the test data\n* @param[in] TEST_APPEND - a constant that represents the append operation\n* @return None\n*/\nvoid testAppend_charstar_specifyAllCharacters_toExistingString()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void testAppend_charstar_specifiedSize_toExistingString()\n    {\n        utlTestAppend_specifiedSize_toExistingString(TYPE_CHARSTAR) ;\n    }\n",
        "answer": "/** @brief Tests the append method with a specified size for a char* to an existing string.\n*\n* This test case tests the functionality of the append method when passed a char* and a specified size, where the string already contains some data. The test verifies that only the specified number of bytes are copied from the char* to the string.\n*\n* @param[in] TYPE_CHARSTAR - The type of input parameter for the function being tested.\n* @return None\n*/\nvoid testAppend_charstar_specifiedSize_toExistingString() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void testStrip_Default()\n    {\n        KNOWN_EFENCE_BUG(\"Segmentation fault, EF_PROTECT_BELOW=1\", \"XPL-8\");\n        utlTestStripSpaces(UtlString::trailing, false, false) ; \n    }\n",
        "answer": "/** @brief Test the strip() function to remove trailing spaces.\n*\n* This test case checks if the strip() function correctly removes\n* trailing spaces from a given string. The different types of strings\n* used for testing this case are:\n* 1. An empty string.\n* 2. A regular string with trailing spaces.\n* 3. A regular string with leading spaces.\n* 4. A regular string without spaces.\n* 5. An alphanumeric string with trailing spaces.\n* 6. An alphanumeric string without trailing spaces.\n* 7. An alphanumeric string with both spaces.\n* 8. Space only string.\n*\n* @return Should not return\n*/\nvoid testStrip_Default()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SIPXTAPI_API SIPX_RESULT sipxConfigUnsubscribe(const SIPX_SUB hSub) \n{ \n    return sipxCallUnsubscribe(hSub); \n} \n",
        "answer": "/** @brief Unsubscribe from previously subscribed NOTIFY events.\n*\n* This method will send another subscription request with an expires time of 0 (zero) to end your subscription.\n*\n* @param hSub The handle to the subscription that you want to unsubscribe from.\n* @return SIPX_RESULT indicating success or failure.\n*/\nSIPXTAPI_API SIPX_RESULT sipxConfigUnsubscribe(const SIPX_SUB hSub)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SIPXTAPI_API SIPX_RESULT sipxConfigEnableIce(const SIPX_INST hInst)\n{\n    OsStackTraceLogger stackLogger(FAC_SIPXTAPI, PRI_DEBUG, \"sipxConfigEnableIce\");\n    OsSysLog::add(FAC_SIPXTAPI, PRI_INFO,\n        \"sipxConfigEnableICE hInst=%p\", hInst);\n\n    SIPX_RESULT rc = SIPX_RESULT_INVALID_ARGS;\n\n    SIPX_INSTANCE_DATA* pInst = (SIPX_INSTANCE_DATA*) hInst;\n    assert(pInst);\n    if (pInst)\n    {      \n        pInst->pCallManager->enableIce(true) ;\n        rc = SIPX_RESULT_SUCCESS ;\n    }\n\n    return rc ;    \n}\n",
        "answer": "/** @brief Enables ICE-like mechanism for determining connectivity of remote parties dynamically.\n*\n*  This function enables the ICE-like mechanism for determining connectivity of remote parties dynamically. By default, ICE is disabled. The current sipXtapi implementation is a bastardization of draft-ietf-mmusic-ice-04. In subsequent releases, this will conform to draft-ietf-mmusic-ice-05 or the latest draft.\n*\n* @param hInst A handle to the SIPX instance data structure.\n* @return Should return SIPX_RESULT_SUCCESS on success, and SIPX_RESULT_INVALID_ARGS if the function is called with an invalid argument.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SIPXTAPI_API SIPX_RESULT sipxConfigUpdatePreviewWindow(const SIPX_INST hInst, const SIPX_WINDOW_HANDLE hWnd)\n{\n#ifdef VIDEO\n    OsStackTraceLogger stackLogger(FAC_SIPXTAPI, PRI_DEBUG, \"sipxConfigUpdatePreviewWindow\");\n\n    OsSysLog::add(FAC_SIPXTAPI, PRI_INFO,\n        \"sipxConfigUpdatePreviewWindow hInst=%p, hWnd=%p\",\n        hInst, hWnd);\n        \n#if defined(_WIN32) && defined(HAVE_GIPS)\n    #include <windows.h>\n\tPAINTSTRUCT ps;\n\tHDC hdc = BeginPaint((HWND)hWnd, &ps);\n\tGipsVideoEngineWindows* pVideoEngine = sipxConfigGetVideoEnginePtr(hInst);\n\tpVideoEngine->GIPSVideo_OnPaint(hdc);\n\tEndPaint((HWND)hWnd, &ps);\n#endif\n    return SIPX_RESULT_SUCCESS;\n#else\n    return SIPX_RESULT_NOT_SUPPORTED ;\n#endif\n\n}\n",
        "answer": "/**\n* @brief Updates the Preview window with a new frame buffer. Should be called when the window receives a PAINT message.\n*\n* This function updates the preview window with a new frame buffer. It should be called when the window receives a PAINT message.\n*\n* @param hInst The handle to the instance of the SIPX API.\n* @param hWnd The handle to the preview window.\n*\n* @return Should not return.\n*/\nvoid sipxConfigUpdatePreviewWindow(const SIPX_INST hInst, const SIPX_WINDOW_HANDLE hWnd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long CE_RegOpenKeyExA (\t HKEY hKey,\n\t\t\t\t\t\t LPCSTR lpSubKey,\n\t\t\t\t\t\t DWORD ulOptions,\n\t\t\t\t\t\t REGSAM samDesired,\n\t\t\t\t\t\t PHKEY phkResult\n\t\t\t\t\t\t)\n{\n\tprintf( \"CE_RegOpenKeyExA( ) NOT IMPLEMENTED\\n\" );\n\treturn NULL;\n}\n",
        "answer": "/** @brief Redefines RegOpenKeyExA for the CE library.\n*\n*  This function redefines the RegOpenKeyExA function from the Windows API to work with the CE library.\n*  It is used to test and debug drivers, and will eventually hold the code for a game.\n*\n* @param hKey A handle to an open key.\n* @param lpSubKey The name of a subkey to be opened.\n* @param ulOptions Specifies the option to apply when opening the key.\n* @param samDesired A mask that specifies the desired access rights to the key.\n* @param phkResult A pointer to a variable that receives a handle to the opened key.\n*\n* @return If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h.\n*/\nlong CE_RegOpenKeyExA (\t HKEY hKey,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline btScalar\tcalculateCombinedFriction(const btCollisionObject* body0,const btCollisionObject* body1)\n{\n\tbtScalar friction = body0->getFriction() * body1->getFriction();\n\n\tconst btScalar MAX_FRICTION  = btScalar(10.);\n\tif (friction < -MAX_FRICTION)\n\t\tfriction = -MAX_FRICTION;\n\tif (friction > MAX_FRICTION)\n\t\tfriction = MAX_FRICTION;\n\treturn friction;\n\n}\n",
        "answer": "/** @brief Calculates the combined friction between two collision objects.\n*\n*  This function calculates the combined friction between two collision objects based on their individual frictions. The resulting friction is clamped to a maximum value of 10.\n*\n* @param body0 The first collision object.\n* @param body1 The second collision object.\n* @return The combined friction between the two collision objects.\n*/\ninline btScalar calculateCombinedFriction(const btCollisionObject* body0, const btCollisionObject* body1)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)\n{\n    arith_uint256 r;\n    int sign = 1;\n    if (to.nChainWork > from.nChainWork) {\n        r = to.nChainWork - from.nChainWork;\n    } else {\n        r = from.nChainWork - to.nChainWork;\n        sign = -1;\n    }\n    r = r * arith_uint256(params.nPowTargetSpacing) / GetBlockProof(tip);\n    if (r.bits() > 63) {\n        return sign * std::numeric_limits<int64_t>::max();\n    }\n    return sign * r.GetLow64();\n}\n",
        "answer": "/** @brief Calculates the time it would take to redo the work difference between two blocks, assuming the current hashrate corresponds to the difficulty at a third block, in seconds.\n*\n*  This function takes three CBlockIndex objects as input: \"to\", \"from\" and \"tip\". It returns an int64_t value representing the time it would take to redo the work difference between \"to\" and \"from\", assuming the current hashrate corresponds to the difficulty at \"tip\".\n*\n* @param to The CBlockIndex object representing the block with the higher chainwork.\n* @param from The CBlockIndex object representing the block with the lower chainwork.\n* @param tip The CBlockIndex object representing the block with the current difficulty.\n* @param params The Consensus::Params object containing the network parameters.\n* @return An int64_t value representing the time it would take to redo the work difference between \"to\" and \"from\", assuming the current hashrate corresponds to the difficulty at \"tip\".\n*/\nint64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void UpdateUncommittedBlockStructures(CBlock &block, const CBlockIndex *pindexPrev,\n                                      const Consensus::Params &consensusParams) {\n    int commitpos = GetWitnessCommitmentIndex(block);\n    static const std::vector<unsigned char> nonce(32, 0x00);\n    if (commitpos != -1 && IsWitnessEnabled(pindexPrev, consensusParams) && block.vtx[0].wit.IsEmpty()) {\n        block.vtx[0].wit.vtxinwit.resize(1);\n        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.resize(1);\n        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0] = nonce;\n    }\n}\n",
        "answer": "/** @brief Update uncommitted block structures (currently: only the witness nonce). This is safe for submitted blocks.\n*\n*  This function updates the uncommitted block structures, currently only the witness nonce, for a given block and its previous index. It also checks if the witness is enabled for the previous block and if the block's first transaction has an empty witness. If these conditions are met, it resizes the witness stack to 1 and sets the nonce to a vector of 32 zeroes.\n*\n* @param[in] block The block to be updated.\n* @param[in] pindexPrev The previous index of the block.\n* @param[in] consensusParams The consensus parameters for the blockchain.\n*/\nvoid UpdateUncommittedBlockStructures(CBlock &block, const CBlockIndex *pindexPrev,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QByteArray generateInfo(const MediaFileInfo &file, Diagnostics &diag, Diagnostics &diagReparsing)\n{\n    Generator gen(file, diag, diagReparsing);\n    gen.mkDoc();\n#ifdef QT_DEBUG\n    QFile test(QStringLiteral(\"/tmp/test.xhtml\"));\n    test.open(QFile::WriteOnly | QFile::Truncate);\n    test.write(gen.res());\n#endif\n    return gen.res();\n}\n",
        "answer": "/**\n* @brief Generates information about a media file.\n*\n* This function generates an XML document containing information about a media file, such as its format, duration, and bitrate.\n* The generated document can be used to display information about the media file in a user interface or to store it for later use.\n*\n* @param file The media file to generate information about.\n* @param diag A diagnostics object that will be used to report any errors or warnings that occur during generation.\n* @param diagReparsing A diagnostics object that will be used to report any errors or warnings that occur during reparsing.\n*\n* @return The generated XML document as a QByteArray.\n*/\nQByteArray generateInfo(const MediaFileInfo &file, Diagnostics &diag, Diagnostics &diagReparsing)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getSizeInUnits()    { return (endPos - startPos) + 32; }\r\n",
        "answer": "/** @brief Get the size of this object in units.\n*\n* This function returns the size of this object in units, which are arbitrary and don't have to be accurate. The default value returned here is 10.\n*\n* @return The size of this object in units.\n*/\nint getSizeInUnits() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void addMenuItems (PopupMenu& menu, int columnIdClicked)\r\n    {\r\n        if (owner.isAutoSizeMenuOptionShown())\r\n        {\r\n            menu.addItem (autoSizeColumnId, TRANS(\"Auto-size this column\"), columnIdClicked != 0);\r\n            menu.addItem (autoSizeAllId, TRANS(\"Auto-size all columns\"), owner.getHeader().getNumColumns (true) > 0);\r\n            menu.addSeparator();\r\n        }\r\n\r\n        TableHeaderComponent::addMenuItems (menu, columnIdClicked);\r\n    }\r\n",
        "answer": "/**\n* @brief Adds menu items to the popup menu.\n*\n* This method adds custom items to the popup menu, and also calls the superclass's\n* method to add its column show/hide items if desired.\n*\n* @param menu The popup menu to which items will be added.\n* @param columnIdClicked The ID of the column that was clicked.\n*/\nvoid addMenuItems(PopupMenu& menu, int columnIdClicked);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void resized()\r\n    {\r\n        slider.setBounds (getLocalBounds().removeFromTop (25));\r\n    }\r\n",
        "answer": "/** @brief Called when this component's size has been changed.\n*\n*  This method is called synchronously as a result of the setBounds or setSize methods, so repeatedly changing a components size will repeatedly call its resized method (unlike things like repainting, where multiple calls to repaint are coalesced together). If the component is a top-level window on the desktop, its size could also be changed by operating-system factors beyond the application's control.\n*\n* @param bounds The new bounds of this component.\n*/\nvoid resized (const Rectangle<int>& bounds)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int64 getTotalLength()\r\n    {\r\n        return (int64) zipEntryHolder.compressedSize;\r\n    }\r\n",
        "answer": "/** @brief Returns the total number of bytes available for reading in this stream.\n*\n* This function returns the total number of bytes available for reading in this stream, from the start of the stream. If the size of the stream isn't actually known, this will return -1.\n*\n* @return The total number of bytes available for reading in this stream, or -1 if the size is not known.\n*/\nint64 getTotalLength()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void test_only_hack_update_fbb_reference(MyGame::Example::MonsterBuilder &monsterBuilder,\n                                         flatbuffers::grpc::MessageBuilder &mb) {\n  *reinterpret_cast<flatbuffers::FlatBufferBuilder **>(&monsterBuilder) = &mb;\n}\n",
        "answer": "/** @brief Updates the FlatBufferBuilder reference in a MonsterBuilder object.\n*\n*  This function is a hack to update the FlatBufferBuilder reference (fbb_) in the MonsterBuilder object. This function will break if fbb_ is not the first member in MonsterBuilder. In that case, some offset must be added. This function is used exclusively for testing correctness of move operations between FlatBufferBuilders. If MonsterBuilder had a fbb_ pointer, this hack would be unnecessary. That involves a code-generator change though.\n*\n* @param monsterBuilder The MonsterBuilder object to update.\n* @param mb The new FlatBufferBuilder reference to use.\n*/\n*reinterpret_cast<flatbuffers::FlatBufferBuilder **>(&monsterBuilder) = &mb;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   DLL_HEADER void Ng_SaveMesh(Ng_Mesh * mesh, const char* filename)\r\n   {\r\n      ((Mesh*)mesh)->Save(filename);\r\n   }\r\n",
        "answer": "/** @brief Saves a generated mesh structure to disk in the Netgen VOL file format.\n*\n*  This function allows a generated mesh structure to be saved to disk using the Netgen VOL file format.\n*\n*  @param[in] mesh A pointer to the mesh structure to be saved.\n*  @param[in] filename The name of the file to save the mesh to.\n*\n*  @return void\n*/\nvoid Ng_SaveMesh(Ng_Mesh* mesh, const char* filename) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   DLL_HEADER void Ng_AddVolumeElement (Ng_Mesh * mesh, Ng_Volume_Element_Type et,\r\n                                        int * pi)\r\n   {\r\n      Mesh * m = (Mesh*)mesh;\r\n      Element el (4);\r\n      el.SetIndex (1);\r\n      el.PNum(1) = pi[0];\r\n      el.PNum(2) = pi[1];\r\n      el.PNum(3) = pi[2];\r\n      el.PNum(4) = pi[3];\r\n      m->AddVolumeElement (el);\r\n   }\r\n",
        "answer": "/** @brief Adds a volume element to the mesh structure by providing the type of element and the indices of the points which constitute the element.\n*\n*  This function allows the top-level code to directly add individual Volume Elements to a Netgen Mesh Structure by providing the type of element to be added and the indices of the points which constitute the element.\n*\n* @param mesh The mesh structure to which the volume element will be added.\n* @param et The type of volume element to be added.\n* @param pi An array of integers containing the indices of the points which constitute the volume element.\n*/\nDLL_HEADER void Ng_AddVolumeElement (Ng_Mesh * mesh, Ng_Volume_Element_Type et, int * pi)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Ng_GetMultiElementTransformation (int ei, int n,\n                                       const double * xi, size_t sxi,\n                                       double * x, size_t sx,\n                                       double * dxdxi, size_t sdxdxi)\n{\n  if (mesh->GetDimension() == 2)\n    mesh->GetCurvedElements().CalcMultiPointSurfaceTransformation<2> (ei-1, n, xi, sxi, x, sx, dxdxi, sdxdxi);\n  else\n    mesh->GetCurvedElements().CalcMultiPointElementTransformation (ei-1, n, xi, sxi, x, sx, dxdxi, sdxdxi);\n}\n",
        "answer": "/** @brief Calculates the transformation for multiple elements.\n*\n*  This function calculates the transformation for multiple elements based on the local coordinates and step sizes provided.\n*\n* @param ei The element index.\n* @param n The number of points to transform.\n* @param xi Local coordinates sxi..step xi x ..global coordinates dxdxi...D x D Jacobian matrix (row major storage)\n* @param sxi The size of the local coordinates array.\n* @param x Global coordinates.\n* @param sx The size of the global coordinates array.\n* @param dxdxi The D x D Jacobian matrix (row major storage).\n* @param sdxdxi The size of the D x D Jacobian matrix.\n*/\nvoid Ng_GetMultiElementTransformation(int ei, int n, const double *xi, size_t sxi, double *x, size_t sx, double *dxdxi, size_t sdxdxi) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void uasserted(int msgid, const char *msg) {\n        assertionCount.condrollover( ++assertionCount.user );\n        LOG(1) << \"User Assertion: \" << msgid << \":\" << msg << endl;\n        raiseError(msgid,msg);\n        throw UserException(msgid, msg);\n    }\n",
        "answer": "/** @brief uasserted function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param msgid The message ID of the assertion.\n* @param msg The message associated with the assertion.\n* @return Should not return\n*/\nvoid uasserted(int msgid, const char *msg) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setColor(boolean value, boolean highlighted) {\n  if (value && highlighted) {\n    EsploraTFT.stroke(0, 204, 0);\n    EsploraTFT.fill(0, 204, 0);\n  } else if (value && !highlighted) {\n    EsploraTFT.stroke(0, 0, 0);\n    EsploraTFT.fill(0, 0, 0);\n  } else if (highlighted) {\n    EsploraTFT.stroke(255, 153, 51);\n    EsploraTFT.fill(255, 153, 51);\n  } else {\n    EsploraTFT.stroke(255, 255, 255);\n    EsploraTFT.fill(255, 255, 255);\n  }\n}\n",
        "answer": "/**\n* @brief Sets the color of a cell based on its state and whether it is highlighted.\n*\n* This function sets the color of a cell based on its state (alive or dead) and whether it is highlighted. If the cell is alive and highlighted, the color is green. If the cell is alive but not highlighted, the color is black. If the cell is dead and highlighted, the color is orange. If the cell is dead and not highlighted, the color is white.\n*\n* @param value The state of the cell (alive or dead).\n* @param highlighted Whether the cell is highlighted.\n*/\nvoid setColor(boolean value, boolean highlighted) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int strCompareNoCase(const char* s1, const char* s2, size_t size) \r\n{\r\n    const char *us1 = (const char*) s1,*us2 = (const char*) s2;\r\n\r\n    while (size && *us1 && (lookup[*us1 + 128] == lookup[*us2 + 128])) \r\n    {\r\n        us1++;\r\n        us2++;\r\n        size--;\r\n    }\r\n\r\n    if (size) \r\n    {\r\n        return (unsigned char) lookup[*us1 + 128] - \r\n            (unsigned char) lookup[*us2 + 128];\r\n    }\r\n    else \r\n    {\r\n        return 0;\r\n    }\r\n}\r\n",
        "answer": "/** @brief strCompareNoCase.\n*\n* This function is a case-insensitive version of strncasecmp. It returns an integer less than, equal to or greater than 0 if the first size characters of s1 are less than, equal to or greater than the first size characters of s2, ignoring case. If a letter gets compared with []\\^_` the letter will be evaluated to more than these characters (equivalent to conversion to lowercase)\n*\n* @param s1 The first string to compare.\n* @param s2 The second string to compare.\n* @param size The number of characters to compare.\n* @return An integer less than, equal to or greater than 0 if the first size characters of s1 are less than, equal to or greater than the first size characters of s2, ignoring case.\n*/\nint strCompareNoCase(const char* s1, const char* s2, size_t size) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CAmount GetRequiredFee(unsigned int nTxBytes)\n{\n    return std::max(CWallet::minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes));\n}\n",
        "answer": "/** @brief Get the minimum required fee for a transaction.\n*\n*  This function returns the minimum required fee for a transaction, taking into account both the floating relay fee and the user-set minimum transaction fee.\n*\n* @param nTxBytes The size of the transaction in bytes.\n* @return The minimum required fee for the transaction.\n*/\nCAmount GetRequiredFee(unsigned int nTxBytes)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void RPCTypeCheck(const UniValue& params,\n                  const std::list<UniValue::VType>& typesExpected,\n                  bool fAllowNull)\n{\n    unsigned int i = 0;\n    for (UniValue::VType t : typesExpected)\n    {\n        if (params.size() <= i)\n            break;\n\n        const UniValue& v = params[i];\n        if (!(fAllowNull && v.isNull())) {\n            RPCTypeCheckArgument(v, t);\n        }\n        i++;\n    }\n}\n",
        "answer": "/** @brief Type-check arguments; throws JSONRPCError if wrong type given. Does not check that the right number of arguments are passed, just that any passed are the correct type.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param params The parameters passed to the function.\n* @param typesExpected The expected types of the parameters.\n* @param fAllowNull Whether null values are allowed.\n* @return Should not return\n*/\nvoid RPCTypeCheck(const UniValue& params,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n{\n    int commitpos = GetWitnessCommitmentIndex(block);\n    static const std::vector<unsigned char> nonce(32, 0x00);\n    if (commitpos != -1 && IsWitnessEnabled(pindexPrev, consensusParams) && !block.vtx[0]->HasWitness()) {\n        CMutableTransaction tx(*block.vtx[0]);\n        tx.vin[0].scriptWitness.stack.resize(1);\n        tx.vin[0].scriptWitness.stack[0] = nonce;\n        block.vtx[0] = MakeTransactionRef(std::move(tx));\n    }\n}\n",
        "answer": "/** @brief Update uncommitted block structures (currently: only the witness reserved value). This is safe for submitted blocks.\n*\n*  This function updates the uncommitted block structures, currently only the witness reserved value. It is safe for submitted blocks.\n*\n* @param[in] block The block to update.\n* @param[in] pindexPrev The previous block index.\n* @param[in] consensusParams The consensus parameters.\n*/\nvoid UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline int IsFoldingContainer(WordList &keywordslist, char * keyword) {\n    if(\n        strlen(keyword) > 3 &&\n        keyword[0] == 'e' && keyword[1] == 'n' && keyword[2] == 'd') {\n        if (keywordslist.InList(keyword + 3)) {\n            return -1;\n        }\n\n    } else {\n        if(keywordslist.InList(keyword)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
        "answer": "/** @brief Detects keywords that can have a body.\n*\n*  This function detects keywords which are able to have a body. Note that it uses the Fold Containers word description, not the containers description. It only works when the style at that particular position is set on Containers or Flow (number 3 or 4).\n*\n* @param keywordslist The list of keywords to check.\n* @param keyword The keyword to check for.\n* @return -1 if the keyword is a folding container, 1 if it is a regular keyword, and 0 otherwise.\n*/\nstatic inline int IsFoldingContainer(WordList &keywordslist, char *keyword) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    FLAC__bool FLAC__format_sample_rate_is_subset(unsigned sample_rate) {\n        static FLAC__bool (*func)(unsigned) = NULL;\n        if(func == NULL) {\n            func = flac_bindings::libFlac->getSymbolAddress<FLAC__bool (*)(unsigned)>(\"FLAC__format_sample_rate_is_subset\");\n            if(func == NULL) printf(\"%s\\n\", flac_bindings::libFlac->getLastError().c_str());\n        }\n        if(func != NULL) return func(sample_rate);\n        return false;\n    }\n",
        "answer": "/**\n* @brief Tests whether a sample rate is valid for the FLAC subset.\n*\n* The subset rules for valid sample rates are slightly more complex since the rate has to be expressible completely in the frame header.\n*\n* @param sample_rate The sample rate to test.\n* @return True if the sample rate is valid for the FLAC subset, false otherwise.\n*/\nFLAC__bool FLAC__format_sample_rate_is_subset(unsigned sample_rate) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    FLAC__bool FLAC__format_picture_is_legal(const FLAC__StreamMetadata_Picture *picture, const char **violation) {\n        static FLAC__bool (*func)(const FLAC__StreamMetadata_Picture*, const char**) = NULL;\n        if(func == NULL) {\n            func = flac_bindings::libFlac->getSymbolAddress<FLAC__bool (*)(const FLAC__StreamMetadata_Picture*, const char**)>(\"FLAC__format_picture_is_legal\");\n            if(func == NULL) printf(\"%s\\n\", flac_bindings::libFlac->getLastError().c_str());\n        }\n        if(func != NULL) return func(picture, violation);\n        return false;\n    }\n",
        "answer": "/**\n* @brief Checks whether the picture data conforms to the FLAC specification.\n*\n* This function checks the picture data to see if it adheres to the FLAC format specification. It returns a boolean value indicating whether the data is legal or not, and also sets the violation parameter to point to the specific part of the data that caused the failure.\n*\n* @param picture The picture data to be checked.\n* @param violation A pointer to a string that will be set to the location in the data where the violation occurred.\n*\n* @return True if the data is legal, false otherwise.\n*/\nFLAC__bool FLAC__format_picture_is_legal(const FLAC__StreamMetadata_Picture *picture, const char **violation) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid OnErrorChangeIncomingData(int errcode, int libsrtperrorcode) \n\t{\n\t\tprintf(\"SSRC %x JRTPLIB Error: %s\\n\", GetLocalSSRC(), RTPGetErrorString(errcode).c_str());\n\t\tif (libsrtperrorcode != err_status_ok)\n\t\t\tprintf(\"libsrtp error: %d\\n\", libsrtperrorcode);\n\t\tprintf(\"\\n\");\n\t}\n",
        "answer": "/** @brief Callback for error in incoming data.\n*\n*  This member function will be called when an error is encountered while reimplementing OnChangeIncomingData (which may take place in a background thread). Implement this function in a derived class to receive notification of the error.\n*\n* @param errcode Error code\n* @param libsrtperrorcode libSRTP error code\n*/\nvoid OnErrorChangeIncomingData(int errcode, int libsrtperrorcode)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool LoadScript(char const *fileName)\r\n{\r\n    bool read = false;\r\n    std::ifstream inFile(fileName);\r\n    if (inFile.is_open())\r\n    {\r\n        while (inFile.peek() != EOF)\r\n        {\r\n            std::string currLine;\r\n            getline(inFile, currLine);\r\n            ParseInput(currLine);\r\n        }\r\n        inFile.close();\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n",
        "answer": "/** @brief Loads a script from the passed file name.\n*\n*  Attempts to open a stream to the passed fileName. If the file stream was opened, each line in the file is read and passed to the ParseInput function.\n*\n* @param[in] fileName The name of the file to load the script from.\n* @return True if the script was loaded successfully, false otherwise.\n*/\nbool LoadScript(char const *fileName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mc_pfwl_set_core_callbacks(\n    mc_pfwl_state_t *state, mc_pfwl_packet_reading_callback *reading_callback,\n    mc_pfwl_processing_result_callback *processing_callback, void *user_data) {\n  state->reading_callback = reading_callback;\n  state->processing_callback = processing_callback;\n  state->read_process_callbacks_user_data = user_data;\n}\n",
        "answer": "/** @brief Sets the reading and processing callbacks.\n*\n* This function sets the reading and processing callbacks for a given state. It can be done only after that the state has been initialized and before calling run().\n*\n* @param[in] state The state to set the callbacks for.\n* @param[in] reading_callback The reading callback to use.\n* @param[in] processing_callback The processing result callback to use.\n* @param[in] user_data User data to pass to the callbacks.\n*/\nvoid mc_pfwl_set_core_callbacks(mc_pfwl_state_t *state, mc_pfwl_packet_reading_callback *reading_callback, mc_pfwl_processing_result_callback *processing_callback, void *user_data) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class PixelIterator\n{\n  unsigned src_increment, src_counter;\n  unsigned dest_increment, dest_counter;\n\npublic:\n  PixelIterator(unsigned src_size, unsigned dest_size)\n    :src_increment(dest_size), src_counter(0),\n     dest_increment(src_size), dest_counter(0) {}\n\n  /**\n   * @return the number of source pixels to skip\n   */\n  unsigned Next() {\n    if (dest_counter < src_counter) {\n      dest_counter += dest_increment;\n      return 0;\n    }\n\n    dest_counter += dest_increment;\n\n    unsigned n = 0;\n\n    /* this loop is inefficient with large dest_increment values */\n    while (src_counter + src_increment <= dest_counter) {\n      src_counter += src_increment;\n      ++n;\n    }\n\n    return n;\n  }\n};\n",
        "answer": "/**\n* @brief A class that implements an algorithm to traverse pixels quickly with only integer addition, no multiplication and division.\n*\n* This class provides a way to iterate over pixels in a source image and map them to pixels in a destination image. It uses a fast algorithm that only requires integer addition, making it efficient for large images.\n*/\n/**\n* @brief Constructs a new `PixelIterator` object with the given source and destination sizes.\n*\n* @param src_size The size of the source image in pixels.\n* @param dest_size The size of the destination image in pixels.\n*/\n/**\n* @brief Returns the number of source pixels to skip.\n*\n* This method returns the number of source pixels that should be skipped in order to map the next destination pixel to a source pixel. It uses a fast algorithm that only requires integer addition, making it efficient for large images.\n*\n* @return The number of source pixels to skip.\n*/\n/* this loop is inefficient with large dest_increment values */\nwhile (src_counter + src_increment <= dest_counter) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool get_item( void*& item, size_t k ) {\n        if( k==my_queue.my_rep->tail_counter ) {\n            item = NULL;\n            return true;\n        } else {\n            concurrent_queue_base::page* p = array[concurrent_queue_rep::index(k)];\n            __TBB_ASSERT(p,NULL);\n            size_t i = k/concurrent_queue_rep::n_queue & (my_queue.items_per_page-1);\n            item = static_cast<unsigned char*>(static_cast<void*>(p+1)) + my_queue.item_size*i;\n            return (p->mask & uintptr(1)<<i)!=0;\n        }\n    }\n",
        "answer": "/**\n* @brief Get item from queue.\n*\n* This function sets the item pointer to point to the kth element in the queue,\n* and returns true if at end of queue or item is marked valid; false otherwise.\n*\n* @param[in] item The item to be retrieved from the queue.\n* @param[in] k The index of the item to be retrieved.\n* @return True if at end of queue or item is marked valid; false otherwise.\n*/\nbool get_item(void*& item, size_t k) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    /*override*/ void independent_thread_number_changed( int ) {__TBB_ASSERT(false,NULL);}\n",
        "answer": "/**\n* @brief Independent thread number changed.\n*\n* This function is called when the number of independent threads has changed.\n* The delta is the change in the number of non-RML threads that are running. For example, a value of 1 means the client has started running another thread, and a value of -1 indicates that the client has blocked or terminated one of its threads.\n*\n* @param delta The change in the number of independent threads.\n*/\nvoid independent_thread_number_changed(int delta) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool sendIcmpResponse(PcapLiveDevice* dev,\r\n\t\tMacAddress srcMacAddr, MacAddress dstMacAddr,\r\n\t\tIPv4Address srcIPAddr, IPv4Address dstIPAddr,\r\n\t\tsize_t icmpMsgId,\r\n\t\tuint64_t msgType,\r\n\t\tuint8_t* data, size_t dataLen)\r\n{\r\n\treturn sendIcmpMessage(dev, srcMacAddr, dstMacAddr, srcIPAddr, dstIPAddr, icmpMsgId, msgType, data, dataLen, false);\r\n}\r\n",
        "answer": "/** @brief Send an ICMP reply from source to dest with certain ICMP ID, msgType will be written in the timestamp field of the request, and data will be written in the data section of the request.\n*\n* This function sends an ICMP reply message from a source device to a destination device with a specific ICMP ID, message type, and data. The message type is written in the timestamp field of the request, and the data is written in the data section of the request.\n* @param dev A pointer to the PcapLiveDevice object representing the network device that will send the message.\n* @param srcMacAddr The MAC address of the source device.\n* @param dstMacAddr The MAC address of the destination device.\n* @param srcIPAddr The IPv4 address of the source device.\n* @param dstIPAddr The IPv4 address of the destination device.\n* @param icmpMsgId The ICMP message ID.\n* @param msgType The message type to be written in the timestamp field of the request.\n* @param data A pointer to the data to be written in the data section of the request.\n* @param dataLen The length of the data to be written in the data section of the request.\n* @return Returns true if the message was sent successfully, false otherwise.\n*/\nbool sendIcmpResponse(PcapLiveDevice* dev,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void dpotrf_ (const char *uplo, const unsigned long *_n, double *a,\n\t\t\t\t\t\t const unsigned long *_lda, long *info)\n{\n\tunsigned long n = *_n, lda = *_lda;\n\tdouble sum;\n\tunsigned long i, j;\n\tint k;\n\n\tfor( i=0; i<n; ++i )\n\t{\n\t\t/* j == i */\n\t\tsum = a[i + lda*i];\n\n\t\tfor( k=(i-1); k>=0; --k )\n\t\t\tsum -= a[k+lda*i] * a[k+lda*i];\n\n\t\tif ( sum > 0.0 )\n\t\t\ta[i+lda*i] = sqrt( sum );\n\t\telse\n\t\t{\n\t\t\tif (info != 0)\n\t\t\t\t*info = i+1;\n\t\t\treturn;\n\t\t}\n\n\t\tfor( j=(i+1); j<n; ++j )\n\t\t{\n\t\t\tsum = a[j*lda + i];\n\n\t\t\tfor( k=(i-1); k>=0; --k )\n\t\t\t\tsum -= a[k+lda*i] * a[k+lda*j];\n\n\t\t\ta[i+lda*j] = sum / a[i+lda*i];\n\t\t}\n\t}\n\tif (info != 0)\n\t\t*info = 0;\n}\n",
        "answer": "/** @brief Calculates the Cholesky factorization of a real symmetric positive definite matrix in double precision.\n*\n* This function calculates the Cholesky factorization of a real symmetric positive definite matrix using a double precision floating point representation. The input matrix is represented as a one-dimensional array, and the output matrix is also represented as a one-dimensional array.\n*\n* @param uplo A character string indicating whether the upper or lower triangular part of the matrix should be used for the factorization. If uplo is 'U', the upper triangular part is used, and if uplo is 'L', the lower triangular part is used.\n* @param n The number of rows/columns in the input matrix.\n* @param a A one-dimensional array representing the input matrix. The matrix should be symmetric positive definite.\n* @param lda The leading dimension of the input matrix. This should be at least n.\n* @param info An integer output parameter that indicates the success or failure of the factorization. If info is 0, the factorization was successful. If info is nonzero, an error occurred and the factorization could not be completed.\n*/\n/* j == i */\n*info = i+1;\n*info = 0;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void ObjectRegistered(void) {\n        LOGD(\"\\n Object registered \\n\");\n    }\n",
        "answer": "/** @brief Called by the message bus when the object has been successfully registered. The object can perform any initialization such as adding match rules at this time.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid ObjectRegistered(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void SessionJoined(SessionPort sessionPort, SessionId id, const char* joiner)\n    {\n        LOGD(\"SessionJoined with %s (id=%u)\\n\", joiner, id);\n        _id = id;\n    }\n",
        "answer": "/** @brief Called by the bus when a session has been successfully joined. The session is now fully up. This callback is only used by session creators. Therefore it is only called on listeners passed to BusAttachment::BindSessionPort.\n*\n*  @param[in] sessionPort The port of the session that was joined.\n*  @param[in] id The ID of the session that was joined.\n*  @param[in] joiner The name of the peer that joined the session.\n*/\nvoid SessionJoined(SessionPort sessionPort, SessionId id, const char* joiner)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool cmpTagLt(TiffComponent const* lhs, TiffComponent const* rhs)\n    {\n        assert(lhs != 0);\n        assert(rhs != 0);\n        if (lhs->tag() != rhs->tag()) return lhs->tag() < rhs->tag();\n        return lhs->idx() < rhs->idx();\n    }\n",
        "answer": "/**\n* @brief Compare two TIFF component pointers by tag.\n*\n* This function compares two TIFF component pointers by their tags. If the tag of the first component is less than that of the second component, it returns true. Otherwise, it returns false.\n*\n* @param lhs A pointer to a TiffComponent object.\n* @param rhs A pointer to another TiffComponent object.\n* @return True if the tag of the first component is less than that of the second component, false otherwise.\n*/\nbool cmpTagLt(TiffComponent const* lhs, TiffComponent const* rhs) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)\r\n{\r\n  m_aci_event_check();\r\n\r\n  if (aci_queue_peek(&aci_rx_q, p_aci_data))\r\n  {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Peeks an event from the ACI event queue.\n*\n* This function is called by lib_aci_event_peek to peek an event from the ACI event queue.\n* It first calls m_aci_event_check() to check if there are any events in the queue, and then\n* uses aci_queue_peek() to retrieve the next event from the queue. If there is no event in the queue, it returns false.\n*\n* @param[in] p_aci_data Pointer to an ACI data structure that will be filled with the peeked event.\n*\n* @return Returns true if there was an event in the queue and it was successfully peeked, or false otherwise.\n*/\nbool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvoid sleep(int duration)\n\t\t{\n\t\t\tif (duration >= 0)\n\t\t\t\tpriv::sleepImpl(duration);\n\t\t}\n",
        "answer": "/** @brief Sleeps the program or one of its threads for a specified duration.\n*\n*  This function is the best way to block a program or one of its threads, as it doesn't consume any CPU power.\n*\n* @param duration The duration in milliseconds that the program or thread should be blocked for. If negative, the function will return immediately without blocking.\n*/\nvoid sleep(int duration)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QRectF qwtBoundingRect( \r\n    const QwtSeriesData<QwtPointPolar> &series, int from, int to )\r\n{\r\n    return qwtBoundingRectT<QwtPointPolar>( series, from, to );\r\n}\r\n",
        "answer": "/** @brief Calculates the bounding rectangle of a polar coordinate series.\n*\n*  This function iterates over the series and calculates the minimum and maximum values for both the azimuth and radius coordinates, which are then used to construct the bounding rectangle.\n*\n* @param series The polar coordinate series to calculate the bounding rectangle for.\n* @param from The index of the first point in the series to include in the calculation.\n* @param to The index of the last point in the series to include in the calculation.\n* @return The bounding rectangle of the polar coordinate series.\n*/\nQRectF qwtBoundingRect( const QwtSeriesData<QwtPointPolar> &series, int from, int to )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void GetEigenConfigCUDAHost(float* data, const Sophus::SE3f& v)\n{\n    getEigenConfiguration(data,v);\n}\n",
        "answer": "/** @brief Get the Eigen configuration for a CUDA host.\n*\n*  This function gets the Eigen configuration for a CUDA host. It is used to test and debug the drivers and will eventually hold the code for the game. Right now, it is a tight while loop.\n*\n* @param data The data to get the Eigen configuration for.\n* @param v The Sophus::SE3f object to use for the Eigen configuration.\n*\n* @return Should not return.\n*/\nvoid GetEigenConfigCUDAHost(float* data, const Sophus::SE3f& v)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n    {\n        return DecodeBase58Check(str.c_str(), vchRet);\n    }\n",
        "answer": "/** @brief Decode a base58-encoded string (str) that includes a checksum into a byte vector (vchRet), return true if decoding is successful\n*\n* This function takes in a base58-encoded string and a reference to an empty byte vector. It then decodes the base58 string, verifies the checksum, and stores the decoded bytes in the vector. If the decoding is successful, it returns true, otherwise it returns false.\n*\n* @param str The base58-encoded string to be decoded\n* @param vchRet A reference to an empty byte vector where the decoded bytes will be stored\n* @return True if decoding is successful, false otherwise\n*/\nbool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual bool iterate() {\n\n            if (this->failed.compareAndSet(true, false)) {\n                IOException ex(__FILE__, __LINE__,\n                    (std::string(\"Channel was inactive for too long: \") + remote).c_str());\n                this->parent->onException(ex);\n            }\n\n            return this->failed.get();\n        }\n",
        "answer": "/** @brief Perform one iteration of work, returns true if the task needs to run again to complete or false to indicate that the task is now complete.\n*\n*  This function performs one iteration of work and returns a boolean value indicating whether the task needs to run again to complete or if it is now complete.\n*\n* @return A boolean value indicating whether the task needs to run again to complete or if it is now complete.\n*/\nvirtual bool iterate() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void unlinkCancelledWaiters() {\n\n            Node* t = head;\n            Node* trail = NULL;\n            while (t != NULL) {\n                Node* next = t->nextWaiter;\n                if (t->waitStatus != Node::CONDITION) {\n                    t->nextWaiter = NULL;\n\n                    if (trail == NULL) {\n                        head = next;\n                    } else {\n                        trail->nextWaiter = next;\n                    }\n\n                    if (next == NULL) {\n                        tail = trail;\n                    }\n\n                    impl->nodePool.returnNode(t);\n\n                } else {\n                    trail = t;\n                }\n                t = next;\n            }\n        }\n",
        "answer": "/**\n* @brief Unlinks canceled waiter nodes from condition queue.\n*\n* This method is called when cancellation occurs during a condition wait, and upon insertion of a new waiter when the tail is seen to have been canceled. It traverses all nodes rather than stopping at a particular target to unlink all pointers to garbage nodes without requiring many re-traversals during cancellation storms.\n*\n* @param head The head of the condition queue.\n* @param trail The trailing node in the condition queue.\n* @param t The current node being processed.\n* @param next The next node in the condition queue.\n* @param impl The implementation object for the condition variable.\n*/\nvoid unlinkCancelledWaiters(Node* head, Node* trail, Node* t, Node* next, Impl& impl) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void signalAll() {\n            if (!impl->isHeldExclusively()) {\n                throw IllegalMonitorStateException();\n            }\n            Node* first = head;\n            if (first != NULL) {\n                doSignalAll(first);\n            }\n        }\n",
        "answer": "/** @brief Wakes up all waiting threads.\n*\n*  If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from await.\n*\n* @return Should not return\n*/\nvirtual void signalAll() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void onCommand(const Pointer<Command> command AMQCPP_UNUSED) {\n        numMessages++;\n    }\n",
        "answer": "/** @brief Event handler for the receipt of a command.\n*\n*  This function is called when the transport receives a command. The transport passes off all received commands to its listeners, the listener then owns the Object. If there is no registered listener the Transport deletes the command upon receipt.\n*\n* @param[in] command A pointer to the Command object that was received.\n* @return None.\n*/\nvirtual void onCommand(const Pointer<Command> command AMQCPP_UNUSED) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void wait( long long millisecs, int nanos ) {\n\n        mutex->wait( millisecs, nanos );\n    }\n",
        "answer": "/** @brief Waits on a signal from this object, which is generated by a call to Notify. Must have this object locked before calling. This wait will timeout after the specified time interval. This method is similar to the one argument wait function except that it add a finer grained control over the amount of time that it waits by adding in the additional nanosecond argument. NOTE: The ability to wait accurately at a nanosecond scale depends on the platform and OS that the Decaf API is running on, some systems do not provide an accurate enough clock to provide this level of granularity.\n* @param millisecs The number of milliseconds to wait for the signal.\n* @param nanos The number of nanoseconds to wait for the signal.\n*/\nvirtual void wait( long long millisecs, int nanos ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void onCommand( const Pointer<commands::Command> command ){\n        const MyCommand* cmd = dynamic_cast<const MyCommand*>(command.get());\n        str += cmd->c;\n        latch.countDown();\n    }\n",
        "answer": "/** @brief Event handler for the receipt of a command.\n*\n*  The transport passes off all received commands to its listeners, the listener then owns the Object. If there is no registered listener the Transport deletes the command upon receipt.\n*\n* @param[in] command A pointer to the received command object.\n*/\nvoid onCommand(const Pointer<commands::Command> command) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void onMessage(const cms::Message* message) {\n\n            synchronized( &threadIds ) {\n                count++;\n                threadIds.add(Thread::currentThread()->getId());\n            }\n\n            Thread::sleep(20);\n        }\n",
        "answer": "/**\n* @brief Called asynchronously when a new message is received.\n*\n* This method is called asynchronously when a new message is received, and it is\n* responsible for handling that message. The message reference can be to any of the\n* Message types, and a dynamic cast is used to find out what type of message this is.\n* The lifetime of this object is only guaranteed to be for life of the onMessage function\n* after this call-back returns the message may no longer exists. Users should copy the data or\n* clone the message if they wish to retain information that was contained in this Message.\n* It is considered a programming error for this method to throw an exception. The method has\n* been tagged with the 'throw()' qualifier, this implies that you application will segfault\n* if you throw an error from an implementation of this method.\n*\n* @param message A pointer to the received message.\n*/\nvoid onMessage(const cms::Message* message) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void example_3( void ) {\n    cout << endl << \"Example 3...\" << endl;\n\tclock_t startTime, endTime;\n\n\tLBP lbp( 16, LBP_MAPPING_U2 );\n\tcout << lbp.toString() << endl;\n\tstartTime = clock();\n\tlbp.saveMapping( \"mapping.txt\" );\n\tendTime = clock();\n\tcout << \"save took \" << double( endTime - startTime ) / double( CLOCKS_PER_SEC ) << \"s\" << endl;\n\n\tLBP lbp2;\n\tstartTime = clock();\n\tlbp2.loadMapping( \"mapping.txt\" );\n\tendTime = clock();\n\tcout << lbp2.toString() << endl;\n\tcout << \"load took \" << double( endTime - startTime ) / double( CLOCKS_PER_SEC ) << \"s\" << endl;\n\n}\n",
        "answer": "/** @brief Calculate a mapping and save it to a file.\n*\n*  This function calculates a mapping using the LBP algorithm with the given size and type,\n*  saves it to a file, and prints the contents of the mapping.\n*\n* @param size The size of the mapping to calculate.\n* @param filename The name of the file to save the mapping to.\n* @return void\n*/\n/** @brief Calculate a mapping and save it to a file.\n*\n*  This function calculates a mapping using the LBP algorithm with the given size and type,\n*  saves it to a file, and prints the contents of the mapping.\n*\n* @param size The size of the mapping to calculate.\n* @param filename The name of the file to save the mapping to.\n* @return void\n*/\n/** @brief Load a mapping from a file.\n*\n*  This function loads a mapping from the given file and prints its contents.\n*\n* @param filename The name of the file to load the mapping from.\n* @return void\n*/\n/** @brief Print the contents of a mapping.\n*\n*  This function prints the contents of the given mapping.\n*\n* @param lbp The LBP object containing the mapping to print.\n* @return void\n*/\nvoid printMapping(LBP lbp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int ofc_proc_sgml(LibofxContext * libofx_context, int argc, char *argv[])\n{\n  message_out(DEBUG, \"Begin ofx_proc_sgml()\");\n  message_out(DEBUG, argv[0]);\n  message_out(DEBUG, argv[1]);\n  message_out(DEBUG, argv[2]);\n\n  ParserEventGeneratorKit parserKit;\n  parserKit.setOption (ParserEventGeneratorKit::showOpenEntities);\n  EventGenerator *egp =\tparserKit.makeEventGenerator (argc, argv);\n  egp->inhibitMessages (true);\t/* Error output is handled by libofx not OpenSP */\n  OFCApplication *app = new OFCApplication(libofx_context);\n  unsigned nErrors = egp->run (*app); /* Begin parsing */\n  delete egp;\n  return nErrors > 0;\n}\n",
        "answer": "/** @brief Processes SGML files using LibofxContext and command line arguments.\n*\n* This function takes a LibofxContext object and a list of files in command line format as input, where the first file must be the DTD and then any number of OFX files. It uses the ParserEventGeneratorKit to generate events from the SGML files and passes them to an OFCApplication object for processing. The function returns the number of errors encountered during parsing.\n*\n* @param libofx_context A LibofxContext object used for processing the SGML files.\n* @param argc The number of command line arguments.\n* @param argv[] An array of command line arguments, where the first argument must be the DTD and then any number of OFX files.\n* @return The number of errors encountered during parsing.\n*/\nint ofc_proc_sgml(LibofxContext * libofx_context, int argc, char *argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void touch(std::string const& path) {\n  throw std::exception(\"Not yet implemented\");\n}\n",
        "answer": "/** @brief Update file access and modification times.\n*\n*  This is a simplified version of touch(1) that changes both access and modification time to \"now\".\n*\n* @param path The path of the file to update.\n* @return Should not return\n*/\nvoid touch(std::string const& path) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "torch::Tensor unsquash(torch::Tensor x, int i, at::IntList sizes) {\n  auto inputSize = x.sizes();\n  std::vector<int64_t> outputSize;\n  outputSize.insert(outputSize.end(), inputSize.begin(), inputSize.begin() + i);\n  outputSize.insert(outputSize.end(), sizes.begin(), sizes.end());\n  outputSize.insert(\n      outputSize.end(), inputSize.begin() + i + 1, inputSize.end());\n\n  return x.view(outputSize);\n}\n",
        "answer": "/**\n* @brief Unsquash a dimension of a tensor into several dimensions.\n*\n* Replace the i-th dimension of x by sizes (this augments the number of dimensions of x). The product of the elements of sizes should be x.size(i) (sizes can also contain a -1). If x is of size s_1 x ... x s_d, the returned tensor will be a view of x of size s_1 x ... x s_i-1 x sizes x s_i+1 x ... s_d.\n*\n* @param x The input tensor.\n* @param i The dimension to unsquash.\n* @param sizes The list of sizes for the new dimensions.\n* @return A view of x with the specified dimensions.\n*/\ntorch::Tensor unsquash(torch::Tensor x, int i, at::IntList sizes);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "torch::Tensor takeNd(torch::Tensor x, torch::Tensor index) {\n  auto index1D = indexTo1D(x, index);\n  return x.view({-1}).take(index1D);\n}\n",
        "answer": "/**\n* @brief Take elements from a tensor at specified indices.\n*\n* This function takes elements from a tensor at specified indices and returns a new tensor with the same shape as the input tensor.\n* The input tensor must have shape X1 x .. x Xd, where d is the number of dimensions.\n* The index tensor must have shape N x d, where N is the number of indices to take.\n* For 2D tensors, this is equivalent to: y[i] = x[index[i][0], index[i][1]];\n*\n* @param x The input tensor.\n* @param index The index tensor.\n* @return A new tensor with the same shape as the input tensor and the elements taken from the input tensor at the specified indices.\n*/\ntorch::Tensor takeNd(torch::Tensor x, torch::Tensor index);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool responseBodyMustBeEmpty(unsigned status) {\n  return (status == 304 || status == 204 || (100 <= status && status < 200));\n}\n",
        "answer": "/** @brief Determines if a response body must be empty based on the status code.\n*\n* This function takes in an unsigned integer representing the HTTP status code and returns a boolean indicating whether a response body must not be included.\n* The function checks if the status code is equal to 304, 204, or falls within the range of 100 to 200 (inclusive). If any of these conditions are met, the function returns true, indicating that a response body must not be included. Otherwise, it returns false.\n*\n* @param status The HTTP status code as an unsigned integer.\n* @return A boolean indicating whether a response body must not be included based on the status code.\n*/\nbool responseBodyMustBeEmpty(unsigned status) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void utf8_to_utf16(const uint8_t* u8str, size_t u8len, char16_t* u16str) {\n    char16_t* end = utf8_to_utf16_no_null_terminator(u8str, u8len, u16str);\n    *end = 0;\n}\n",
        "answer": "/** @brief Convert UTF-8 to UTF-16 including surrogate pairs.\n*\n* This function converts a UTF-8 string to a UTF-16 string, including surrogate pairs. The destination buffer must be large enough to hold the result as measured by utf8_to_utf16_length plus an added NULL terminator.\n*\n* @param u8str The source UTF-8 string.\n* @param u8len The length of the source UTF-8 string in bytes.\n* @param u16str The destination UTF-16 string.\n*/\n*end = 0;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool range_is_default(_InputIterator first, _InputIterator last)\n{\n\ttypedef typename std::iterator_traits<_InputIterator>::value_type vt;\n\tvt v0 = vt();\n\twhile (first != last)\n\t{\n\t\tif (*first != v0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++first;\n\t\t}\n\t}\n\treturn true;\n}\n",
        "answer": "/** @brief Check if a range is all default. Scan a range, return true if all the elements are the same as their 'default' values (e.g. 0 for integers)\n*\n* @param first The beginning of the range to check\n* @param last The end of the range to check\n* @return True if the range is all default, false otherwise\n*/\nbool range_is_default(_InputIterator first, _InputIterator last)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int deequip(uint32_t c, uint32_t ptr)\n{\n\tint a, b = 0;\n\n\tif (ptr >= NUM_EQUIPMENT)\n\t{\n\t\treturn 0;\n\t}\n\n\ta = party[pidx[c]].eqp[ptr];\n\tif (a > 0)\n\t{\n\t\tb = check_inventory(a, 1);\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n\tif (b == 0)\n\t{\n\t\treturn 0;\n\t}\n\tparty[pidx[c]].eqp[ptr] = 0;\n\treturn 1;\n}\n",
        "answer": "/**\n* @brief De-equips an item from a character.\n*\n* This function de-equips an item from a character's equipment slot, if possible.\n* It checks if the item can be de-equipped and if there is enough inventory space to store it.\n* If the item cannot be de-equipped or there is not enough inventory space, the function returns 0.\n* Otherwise, it sets the character's equipment slot to 0 and returns 1.\n*\n* @param c The character index.\n* @param ptr The equipment slot index.\n* @return 1 if the item was de-equipped successfully, 0 otherwise.\n*/\nstatic int deequip(uint32_t c, uint32_t ptr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int KQ_set_ent_target(lua_State *L)\n{\n\tint a = real_entity_num(L, 1);\n\n\tg_ent[a].target_x = (int)lua_tonumber(L, 2);\n\tg_ent[a].target_y = (int)lua_tonumber(L, 3);\n\tg_ent[a].movemode = MM_TARGET;\n\treturn 0;\n}\n",
        "answer": "/** @brief Set the target position for an entity.\n*\n* This function sets the target position for an entity, and enters it into move mode.\n* The entity will attempt to move to the specified point, but the caller must still call wait_entity()\n* to ensure that the movement is completed.\n*\n* @param L A pointer to the Lua state.\n* @return 0 on success, -1 on failure.\n*/\nstatic int KQ_set_ent_target(lua_State *L)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void do_zone(int zn_num)\n{\n\tint oldtop = lua_gettop(theL);\n\n#ifdef DEBUGMODE\n\tlua_pushcfunction(theL, KQ_traceback);\n\tlua_getglobal(theL, \"zone_handler\");\n\tlua_pushnumber(theL, zn_num);\n\tlua_pcall(theL, 1, 0, oldtop + 1);\n#else\n\tlua_getglobal(theL, \"zone_handler\");\n\tlua_pushnumber(theL, zn_num);\n\tlua_call(theL, 1, 0);\n#endif\n\tlua_settop(theL, oldtop);\n\tKQ_check_map_change();\n}\n",
        "answer": "/** @brief Calls the zone handler function in Lua.\n*\n*  This function is called when the hero steps on a new zone, and it calls the \"zone_handler\" function in Lua with the zone number as an argument. The function also checks for errors and prints them to the console if necessary.\n*\n* @param zn_num The zone number that the hero has stepped on.\n* @return void\n*/\nvoid do_zone(int zn_num)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void init_music() {\n  atexit(&dumb_exit);\n  dumb_register_stdfiles();\n  dumb_resampling_quality = 2;\n\n  /* initialize all music players */\n  current_music_player = MAX_MUSIC_PLAYERS;\n  while (current_music_player--) {\n    mod_song[current_music_player] = NULL;\n    mod_player[current_music_player] = NULL;\n  }\n  current_music_player = 0;\n}\n",
        "answer": "/**\n* @brief Initializes the music players. Must be called before any other music function. Needs to be shutdown when finished.\n*\n* This function initializes all music players and sets up the necessary resources for playing music. It must be called before any other music function is used, and it should be shut down when finished using the `dumb_exit` function.\n*\n* @return None\n*/\n/* initialize all music players */\ncurrent_music_player = MAX_MUSIC_PLAYERS;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int getakey(void)\n{\n\tint a;\n\n\tclear_keybuf();\n\tDraw.menubox(double_buffer, 108 + xofs, 108 + yofs, 11, 1, DARKBLUE);\n\tDraw.print_font(double_buffer, 116 + xofs, 116 + yofs, _(\"Press a key\"), FNORMAL);\n\tDraw.blit2screen(xofs, yofs);\n\n\twhile (1)\n\t{\n\t\tMusic.poll_music();\n\t\tfor (a = 0; a < KEY_MAX; a++)\n\t\t{\n\t\t\tif (key[a] != 0)\n\t\t\t{\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Get a key from the user.\n*\n* This function grabs whatever key is being pressed and returns it to the caller.\n*\n* @return The key that was pressed.\n*/\nstatic int getakey(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool OnDownloadComplete(DownloadCompleteStruct *dcs)\n\t{\n\t\treturn onFileCallback->OnDownloadComplete(dcs);\n\t}\n",
        "answer": "/** @brief Called when a download is complete.\n*\n*  This function is called by the FileListTransfer plugin when a download is complete. It will pass a pointer to a DownloadCompleteStruct, which contains information about the completed download.\n*\n* @param dcs A pointer to a DownloadCompleteStruct containing information about the completed download.\n* @return true if the class should continue to be maintained by the FileListTransfer plugin, false otherwise.\n*/\nvirtual bool OnDownloadComplete(DownloadCompleteStruct *dcs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_equip_item(lua_State *s)\n{\n    Entity *ch = checkCharacter(s, 1);\n    ItemClass *it = checkItemClass(s, 2);\n\n    Inventory inv(ch);\n\n    int inventorySlot = inv.getFirstSlot(it->getDatabaseID());\n    bool success = false;\n\n    if (inventorySlot > -1)\n        success = inv.equip(inventorySlot);\n\n    lua_pushboolean(s, success);\n    return 1;\n}\n",
        "answer": "/** @brief Equips an item to a character entity if it exists in the player's inventory.\n*\n*  This function is used to equip an item to a character entity if it exists in the player's inventory. It takes two arguments, the first being the entity ID of the character and the second being the item ID or name of the item to be equipped. If the item exists in the player's inventory, the function will return true, otherwise it will return false.\n*\n* @param s The Lua state.\n* @return A boolean indicating whether the item was successfully equipped (true) or not (false).\n*/\nstatic int entity_equip_item(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_set_global_ability_cooldown(lua_State *s)\n{\n    Entity *c = checkCharacter(s, 1);\n    const int ticks = luaL_checkint(s, 2);\n    c->getComponent<AbilityComponent>()->setGlobalCooldown(ticks);\n    return 0;\n}\n",
        "answer": "/** @brief Sets the global ability cooldown for a character entity.\n*\n* This function sets the amount of ticks before any other ability can be used again for a character entity.\n*\n* @param s The Lua state.\n* @return 0 if successful, -1 otherwise.\n*/\nstatic int entity_set_global_ability_cooldown(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_get_action(lua_State *s)\n{\n    Entity *being = checkBeing(s, 1);\n    lua_pushinteger(s, being->getComponent<BeingComponent>()->getAction());\n    return 1;\n}\n",
        "answer": "/** @brief Get the action of a being entity.\n*\n* This function returns the current action of a being entity.\n* The possible actions are:\n* - ACTION_STAND (0)\n* - ACTION_WALK (1)\n* - ACTION_SIT (2)\n* - ACTION_DEAD (3)\n* - ACTION_HURT (4)\n*\n* @param s The Lua state.\n* @return The current action of the being entity.\n*/\nstatic int entity_get_action(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_set_base_attribute(lua_State *s)\n{\n    Entity *being = checkBeing(s, 1);\n    auto *attribute = checkAttribute(s, 2);\n    double value = luaL_checknumber(s, 3);\n\n    being->getComponent<BeingComponent>()->setAttribute(*being, attribute, value);\n    return 0;\n}\n",
        "answer": "/** @brief Sets the base attribute of an entity.\n*\n* This function sets the base attribute of an entity to a new value. It is only valid for being entities.\n*\n* @param[in] s The Lua state.\n* @return 0 if successful, -1 otherwise.\n*/\nstatic int entity_set_base_attribute(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_set_correction_points(lua_State *s)\n{\n    Entity *being = checkCharacter(s, 1);\n    int points = luaL_checkint(s, 2);\n    auto *characterComponent = being->getComponent<CharacterComponent>();\n    characterComponent->setCorrectionPoints(points);\n    return 0;\n}\n",
        "answer": "/** @brief Sets the amount of correction points for a character entity.\n*\n* This function is used to set the amount of correction points for a character entity.\n* It takes two arguments: an entity and an integer representing the number of correction points.\n* The function first checks if the entity is a character using the checkCharacter() function,\n* and then retrieves the CharacterComponent from the entity using getComponent().\n* Finally, it sets the correction points for the character using setCorrectionPoints().\n*\n* @param s Lua state variable.\n* @return 0 if successful, -1 otherwise.\n*/\nstatic int entity_set_correction_points(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_set_hair_style(lua_State *s)\n{\n    Entity *c = checkCharacter(s, 1);\n    const int style = luaL_checkint(s, 2);\n    luaL_argcheck(s, style >= 0, 2, \"invalid style id\");\n\n    c->getComponent<CharacterComponent>()->setHairStyle(style);\n    c->getComponent<ActorComponent>()->raiseUpdateFlags(\n            UPDATEFLAG_LOOKSCHANGE);\n    return 0;\n}\n",
        "answer": "/** @brief Set the hair style of an entity.\n*\n* This function sets the hair style of a character entity.\n*\n* @param s The Lua state.\n* @return 0 if successful, -1 otherwise.\n*/\nstatic int entity_set_hair_style(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_register(lua_State *s)\n{\n    Entity *entity = LuaEntity::check(s, 1);\n    Script *script = getScript(s);\n\n    entity->signal_removed.connect(sigc::mem_fun(script, &Script::processRemoveEvent));\n\n    if (BeingComponent *bc = entity->findComponent<BeingComponent>())\n        bc->signal_died.connect(sigc::mem_fun(script, &Script::processDeathEvent));\n\n    return 0;\n}\n",
        "answer": "/** @brief Registers an entity with the scripting system.\n*\n*  This function is called when a new entity is created in the game world, and it registers the entity with the scripting system. It also sets up callbacks for when the entity is removed from the map or dies.\n*\n* @param s The Lua state.\n* @return Returns 0 on success, -1 on failure.\n*/\nstatic int entity_register(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_take_ability(lua_State *s)\n{\n    Entity *b = checkBeing(s, 1);\n    const int ability = luaL_checkint(s, 2);\n\n    auto *abilityComponent = b->getComponent<AbilityComponent>();\n    lua_pushboolean(s, abilityComponent->hasAbility(ability));\n    abilityComponent->takeAbility(ability);\n    return 1;\n}\n",
        "answer": "/** @brief Take an ability from a being.\n*\n* This function removes an ability from a being, if the being has that ability.\n* It is valid only for character and monster entities.\n*\n* @param s The Lua state.\n* @return 1 if the ability was taken, 0 otherwise.\n*/\nstatic int entity_take_ability(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int set_questlog_description(lua_State *s)\n{\n    const Entity *character = checkCharacter(s, 1);\n    const int questId = luaL_checkinteger(s, 2);\n    const char *questDescription = luaL_checkstring(s, 3);\n    const bool questNotification = checkOptionalBool(s, 4, true);\n\n    auto *characterComponent = character->getComponent<CharacterComponent>();\n    characterComponent->setQuestlogDescription(questId, questDescription, questNotification);\n    return 0;\n}\n",
        "answer": "/** @brief Sets the questlog description for a character entity.\n*\n*  This function sets the questlog description for a character entity. It takes an integer ID, a string description, and an optional boolean notify parameter. If the notify parameter is not provided, it defaults to true.\n*\n* @param[in] s The Lua state.\n* @return 0 if successful, -1 otherwise.\n*/\nstatic int set_questlog_description(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int entity_set_status_time(lua_State *s)\n{\n    Entity *being = checkBeing(s, 1);\n    const int id = luaL_checkint(s, 2);\n    const int time = luaL_checkint(s, 3);\n\n    being->getComponent<BeingComponent>()->setStatusEffectTime(id, time);\n    return 0;\n}\n",
        "answer": "/** @brief Sets the time on a status effect for an entity.\n*\n*  This function is used to set the time on a status effect for an entity. It takes three arguments: the Lua state, the entity ID, and the status effect ID. It returns 0 if successful, or -1 if there was an error.\n*\n* @param s The Lua state.\n* @param id The entity ID.\n* @param time The status effect ID.\n* @return 0 if successful, or -1 if there was an error.\n*/\nstatic int entity_set_status_time(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int setvar_map(lua_State *s)\n{\n    const char *name = luaL_checkstring(s, 1);\n    const char *value = luaL_checkstring(s, 2);\n    luaL_argcheck(s, name[0] != 0, 1, \"empty variable name\");\n\n    MapComposite *map = checkCurrentMap(s);\n    map->setVariable(name, value);\n\n    return 0;\n}\n",
        "answer": "/** @brief Sets the value of a persistent map variable.\n*\n* This function sets the value of a persistent map variable. It takes two arguments:\n* - variablename: The name of the variable to set.\n* - value: The new value for the variable.\n*\n* @param s The Lua state.\n* @return 0 if successful, non-zero otherwise.\n*/\nstatic int setvar_map(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int abilityinfo_get_name(lua_State *s)\n{\n    auto *info = LuaAbilityInfo::check(s, 1);\n    push(s, info->name);\n    return 1;\n}\n",
        "answer": "/** @brief Get the name of an abilityinfo object.\n*\n* This function returns the name of an abilityinfo object.\n*\n* @param s The Lua state.\n* @return The name of the abilityinfo object.\n*/\nstatic int abilityinfo_get_name(lua_State *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CVector3f cross(const CVector3f &u, const CVector3f &v)\n{\n\treturn CVector3f(\n\t\t  (u[1] * v[2]) - (u[2] * v[1]),\n\t\t-((u[0] * v[2]) - (u[2] * v[0])),\n\t\t  (u[0] * v[1]) - (u[1] * v[0]));\n}\n",
        "answer": "/**\n* @brief Calculates the cross product of two 3D vectors.\n*\n* The resulting vector is perpendicular to both input vectors, and points in a direction according to the right-hand rule.\n*\n* @param u The first input vector.\n* @param v The second input vector.\n* @return The cross product of the two input vectors.\n*/\nCVector3f cross(const CVector3f &u, const CVector3f &v)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long\t\t\tdkcGetFrame()\n{\n\treturn CDkc::frame;\n}\n",
        "answer": "/** @brief Get the number of update cycles since the start of the program.\n*\n*  This function returns the number of cycles of the update (update) or since the last call to dkcJumpToFrame(), if any.\n*\n* @return The number of update cycles since the start of the program or since the last call to dkcJumpToFrame().\n*/\nlong\t\t\tdkcGetFrame()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void NameValue(Value *V, tree t) {\n  if (!V->hasName()) {\n    const std::string &Name = getDescriptiveName(t);\n    if (!Name.empty())\n      V->setName(Name);\n  }\n}\n",
        "answer": "/** @brief Name a value after the given GCC tree node.\n*\n*  This function tries to name a value after the given GCC tree node. If the GCC tree node has no sensible name, it does nothing. If the value already has a name, it is not changed.\n*\n* @param V The value to be named.\n* @param t The GCC tree node that provides the name.\n*/\nvoid NameValue(Value *V, tree t) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int get_decl_index(tree t) {\n  int Idx;\n  if (getCachedInteger(t, Idx))\n    return Idx;\n  return -1;\n}\n",
        "answer": "/** @brief Get the non-negative number associated with the given GCC field decl. Returns a negative value if no such association has been made.\n*\n* This function returns the non-negative number associated with the given GCC field decl, or a negative value if no such association has been made.\n*\n* @param t The tree to get the decl index for.\n* @return The decl index, or a negative value if no association exists.\n*/\nstatic int get_decl_index(tree t) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void register_lua_functions()\n{\n\tlua_standard_libs(L);\n\tload_vector3_lib(L);\n\tload_unitinfo_lib(L);\n\tload_random_lib(L);\n\n\tLUA_REG(add_interval);\n\tLUA_REG(add_timer);\n\tLUA_REG(remove_timer);\n\tLUA_REG(visible_units);\n\tLUA_REG(get_info);\n\tLUA_REG(move);\n\tLUA_REG(melee);\n\tLUA_REG(begin_firing);\n\tLUA_REG(end_firing);\n\tLUA_REG(fire);\n\tLUA_REG(stop);\n}\n",
        "answer": "/** @brief Register all of the Lua functions listed above.\n*\n*  This function registers all of the Lua functions that are used in the game.\n*\n*/\nvoid register_lua_functions()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uint32_t eventHandler()\n{\n#ifdef YOTTA_CFG_MBED_OS\n    minar::Scheduler::postCallback(intern_softdevice_events_execute);\n#else\n    intern_softdevice_events_execute();\n#endif\n\n    return NRF_SUCCESS;\n}\n",
        "answer": "/**\n* @brief Handles events from the SoftDevice.\n*\n* This function is called by the SoftDevice to handle events. It posts a callback to the scheduler in mbed OS, or executes the event processing logic directly in interrupt context for mbed-classic.\n*\n* @return NRF_SUCCESS if the event was handled successfully, or an error code otherwise.\n*/\nstatic uint32_t eventHandler() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void app_start(int, char*[]) {\n    MBED_HOSTTEST_TIMEOUT(20);\n    MBED_HOSTTEST_SELECT(default_auto);\n    MBED_HOSTTEST_DESCRIPTION(Blinky);\n    MBED_HOSTTEST_START(\"MBED_BLINKY\");\n    minar::Scheduler::postCallback(&blink).period(minar::milliseconds(200));\n}\n",
        "answer": "/** @brief Application start.\n*\n*  This function is used to set up the user's application. It should not block. Use this function to schedule the first code that your app will execute, and perform non-blocking initialisation.\n*\n* @param argc The number of command line arguments passed to the program.\n* @param argv An array of pointers to null-terminated strings representing the command line arguments passed to the program.\n* @return Should not return.\n*/\nvoid app_start(int argc, char* argv[]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void app_start(int, char*[])\n{\n    MBED_HOSTTEST_TIMEOUT(15);\n    MBED_HOSTTEST_SELECT(wait_us_auto);\n    MBED_HOSTTEST_DESCRIPTION(Ticker Two callbacks);\n    MBED_HOSTTEST_START(\"MBED_34\");\n\n    ticker.attach(ticker_callback_1, 1.0);\n}\n",
        "answer": "/** @brief Application entrypoint.\n*\n* This is the entrypoint for your application. It should not block. Use this function to schedule the first code that your app will execute, and perform non-blocking initialisation.\n*\n* @param argc The number of command line arguments passed to the program.\n* @param argv An array of pointers to null-terminated strings representing the command line arguments passed to the program.\n* @return Should not return\n*/\nvoid app_start(int argc, char* argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline bool isStatic(MovementGenerator* mv)\n{\n    return (mv == &si_idleMovement);\n}\n",
        "answer": "/** @brief Checks if the movement generator is static.\n*\n*  This function checks if the movement generator is static or not.\n*\n* @param mv The movement generator to check.\n* @return True if the movement generator is static, false otherwise.\n*/\ninline bool isStatic(MovementGenerator* mv)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double rand_chance(void)\n{\n    return RNG::instance()->rand_d(0.0, 100.0);\n}\n",
        "answer": "/** @brief Generates a random chance between 0.0 and 100.0.\n*\n* This function generates a random chance between 0.0 and 100.0 using the RNG::instance()->rand_d() method.\n*\n* @return A double representing the random chance between 0.0 and 100.0.\n*/\ndouble rand_chance(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void drawBitmapFlash(bitmap bmp, int16_t x, int16_t y) {\n  drawBitmapFlash(bmp, x, y, WHITE);\n}\n",
        "answer": "/** @brief Draw a bitmap from flash memory to the screen.\n*\n* This function draws a bitmap from flash memory to the screen at the specified coordinates. The bitmap must point to valid bitmap on flash storage, and it is simple, 1 = WHITE, 0 = BLACK.\n*\n* @param bmp A pointer to the bitmap struct that points to the valid bitmap on flash storage.\n* @param x The x-coordinate of the top-left corner of the bitmap.\n* @param y The y-coordinate of the top-left corner of the bitmap.\n* @return None\n*/\nvoid drawBitmapFlash(bitmap bmp, int16_t x, int16_t y) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void modifySetting(uint8_t address, byte b, bool commit) {\n  flash.readBytes(SETTINGS_ADDRESS, temp, SETTINGS_SIZE);\n\n  temp[address] = b;\n\n  if (commit) {\n    flash.erase4k(0x0);\n    flash.writeBytes(SETTINGS_ADDRESS, temp, SETTINGS_SIZE);\n  }\n}\n",
        "answer": "/** @brief Modify a one byte setting in cache.\n*\n* This function modifies a one byte setting in the cache. It reads the current settings from flash, updates the specified address with the new value, and then writes the updated settings back to flash if commit is true. If commit is false, it batches the changes and saves power by not writing to flash until later.\n*\n* @param address The address of the setting to modify.\n* @param b The new value for the setting.\n* @param commit Whether or not to immediately write the updated settings to NAND. If true, the function will erase the first 4k block of NAND and then write the updated settings. If false, it will batch the changes and save power by not writing to flash until later.\n*/\nvoid modifySetting(uint8_t address, byte b, bool commit) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint8_t mcp4728_eepromWrite() {\n  Wire.beginTransmission(DAC_DEV_ADDRESS);\n  Wire.write(SEQWRITE);\n  LOOP_XYZE(i) {\n    Wire.write(DAC_STEPPER_VREF << 7 | DAC_STEPPER_GAIN << 4 | highByte(mcp4728_values[i]));\n    Wire.write(lowByte(mcp4728_values[i]));\n  }\n  return Wire.endTransmission();\n}\n",
        "answer": "/**\n* @brief Write all input resistor values to EEPROM using SequencialWrite method. This will update both input register and EEPROM value. This will also write current Vref, PowerDown, Gain settings to EEPROM.\n*\n* @return Should not return\n*/\nuint8_t mcp4728_eepromWrite() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void set_current_from_steppers_for_axis(const AxisEnum axis) {\n  get_cartesian_from_steppers();\n  #if PLANNER_LEVELING\n    planner.unapply_leveling(cartes);\n  #endif\n  if (axis == ALL_AXES)\n    COPY(current_position, cartes);\n  else\n    current_position[axis] = cartes[axis];\n}\n",
        "answer": "/** @brief Set the current position for an axis based on the stepper positions, removing any leveling that may have been applied.\n*\n*  This function sets the current position for a given axis based on the stepper positions, while also removing any leveling that may have been applied.\n*\n* @param[in] axis The axis for which to set the current position.\n*\n* @return None\n*/\nvoid set_current_from_steppers_for_axis(const AxisEnum axis) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  bool select_coordinate_system(const int8_t _new) {\n    if (active_coordinate_system == _new) return false;\n    float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };\n    if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))\n      COPY(old_offset, coordinate_system[active_coordinate_system]);\n    if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))\n      COPY(new_offset, coordinate_system[_new]);\n    active_coordinate_system = _new;\n    LOOP_XYZ(i) {\n      const float diff = new_offset[i] - old_offset[i];\n      if (diff) {\n        position_shift[i] += diff;\n        update_software_endstops((AxisEnum)i);\n      }\n    }\n    return true;\n  }\n",
        "answer": "/**\n* @brief Select a coordinate system and update the workspace offset. System index -1 is used to specify machine-native.\n*\n* This function selects a new coordinate system and updates the workspace offset accordingly. If the selected coordinate\n* system is not valid, the function returns false and does not make any changes to the current coordinate system or workspace\n* offset. Otherwise, it sets the active coordinate system to the specified index and updates the workspace offset by the difference\n* between the old and new offsets. The function also updates the software endstops for each axis if the corresponding offset\n* has changed.\n*\n* @param _new The index of the new coordinate system to select. A value of -1 specifies the machine-native coordinate system.\n* @return True if the coordinate system was successfully selected and updated, false otherwise.\n*/\nbool select_coordinate_system(const int8_t _new) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void gcode_M42() {\n  if (!parser.seenval('S')) return;\n  const byte pin_status = parser.value_byte();\n\n  const pin_t pin_number = parser.byteval('P', LED_PIN);\n  if (pin_number < 0) return;\n\n  if (!parser.boolval('I') && pin_is_protected(pin_number)) return protected_pin_err();\n\n  pinMode(pin_number, OUTPUT);\n  digitalWrite(pin_number, pin_status);\n  analogWrite(pin_number, pin_status);\n\n  #if FAN_COUNT > 0\n    switch (pin_number) {\n      #if HAS_FAN0\n        case FAN_PIN: fanSpeeds[0] = pin_status; break;\n      #endif\n      #if HAS_FAN1\n        case FAN1_PIN: fanSpeeds[1] = pin_status; break;\n      #endif\n      #if HAS_FAN2\n        case FAN2_PIN: fanSpeeds[2] = pin_status; break;\n      #endif\n    }\n  #endif\n}\n",
        "answer": "/** @brief Change pin status via GCode P<pin> Pin number (LED if omitted) S<byte> Pin status from 0 - 255 I Flag to ignore Marlin's pin protection.\n*\n* This function changes the status of a pin based on the input parameters. The pin number can be specified using the 'P' parameter, and the pin status can be set using the 'S' parameter. If the 'I' flag is set, Marlin's pin protection will be ignored.\n*\n* @param parser A reference to the GCode parser.\n* @return void\n*/\ninline void gcode_M42() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M150() {\n    leds.set_color(MakeLEDColor(\n      parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,\n      parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,\n      parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,\n      parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,\n      parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()\n    ));\n  }\n",
        "answer": "/**\n* @brief Set Status LED Color - Use R-U-B-W for R-G-B-W and Brightness - Use P (for NEOPIXEL only) Always sets all 3 or 4 components. If a component is left out, set to 0. If brightness is left out, no value changed\n*\n* Examples:\n* M150 R255 ; Turn LED red\n* M150 R255 U127 ; Turn LED orange (PWM only)\n* M150 ; Turn LED off\n* M150 R U B ; Turn LED white\n* M150 W ; Turn LED white using a white LED\n* M150 P127 ; Set LED 50% brightness\n* M150 P ; Set LED full brightness\n*/\ninline void gcode_M150() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void gcode_M303() {\n  #if HAS_PID_HEATING\n    const int e = parser.intval('E'), c = parser.intval('C', 5);\n    const bool u = parser.boolval('U');\n\n    int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);\n\n    if (WITHIN(e, 0, HOTENDS - 1))\n      target_extruder = e;\n\n    #if DISABLED(BUSY_WHILE_HEATING)\n      KEEPALIVE_STATE(NOT_BUSY);\n    #endif\n\n    thermalManager.PID_autotune(temp, e, c, u);\n\n    #if DISABLED(BUSY_WHILE_HEATING)\n      KEEPALIVE_STATE(IN_HANDLER);\n    #endif\n  #else\n    SERIAL_ERROR_START();\n    SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);\n  #endif\n}\n",
        "answer": "/** @brief Autotune the PID values for a hotend or the heated bed.\n*\n* This function uses the PID autotuning algorithm to find the optimal\n* values for the PID parameters (Kp, Ki, and Kd) for a given hotend or\n* heated bed. The process involves heating the hotend or bed to a\n* specific temperature and measuring the actual temperature using a\n* thermistor. The difference between the target temperature and the\n* measured temperature is then used to calculate the PID values.\n*\n* @param temp The target temperature for the autotuning process (in Celsius).\n* @param e The hotend index (0 for the first hotend, 1 for the second, etc.). If -1, autotune the heated bed.\n* @param c The number of cycles to use for the autotuning process.\n* @param u If true, apply the result to current settings.\n*/\nvoid gcode_M303(float temp, int8_t e, uint8_t c, bool u) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    inline void gcode_M165() { gcode_get_mix(); }\n",
        "answer": "/** @brief Set multiple mix factors for a mixing extruder.\n*\n*  This function sets multiple mix factors for a mixing extruder. The factors are specified using the letters A, B, C, D, H, and I. The factors must add up to 1.0. If a factor is not specified, it will be set to 0.\n*\n* @param[in] factor A mix factor for extruder stepper 1.\n* @param[in] factor B mix factor for extruder stepper 2.\n* @param[in] factor C mix factor for extruder stepper 3.\n* @param[in] factor D mix factor for extruder stepper 4.\n* @param[in] factor H mix factor for extruder stepper 5.\n* @param[in] factor I mix factor for extruder stepper 6.\n*\n* @return None.\n*/\ninline void gcode_M165() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    inline void set_current_from_destination() { COPY(current_position, destination); }\n",
        "answer": "/** @brief Sets the current position from the destination.\n*\n*  This function sets the current position of the robot to the destination position.\n*\n* @param[in] destination The destination position.\n*/\ninline void set_current_from_destination(const Point& destination) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool button(cv::Mat& theWhere, int theX, int theY, int theWidth, int theHeight, const cv::String& theLabel) {\n        gScreen.where = theWhere;\n        return internal::button(gScreen, theX, theY, theWidth, theHeight, theLabel, true);\n    }\n",
        "answer": "/** @brief Display a button.\n*\n*  This function displays a button on the screen. The size of the button will be defined by the width and height parameters, no matter the content of the label.\n*\n* @param[in] theWhere The Mat object where the button will be displayed.\n* @param[in] theX The x-coordinate of the top-left corner of the button.\n* @param[in] theY The y-coordinate of the top-left corner of the button.\n* @param[in] theWidth The width of the button.\n* @param[in] theHeight The height of the button.\n* @param[in] theLabel The label to be displayed on the button.\n*\n* @return True if the button was successfully displayed, false otherwise.\n*/\nbool button(cv::Mat& theWhere, int theX, int theY, int theWidth, int theHeight, const cv::String& theLabel) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void printf(char *theFmt, ...) {\n        cvui_block_t& aBlock = internal::topBlock();\n        va_list aArgs;\n\n        va_start(aArgs, theFmt);\n        vsprintf(gBuffer, theFmt, aArgs);\n        va_end(aArgs);\n\n        internal::text(aBlock, aBlock.anchor.x, aBlock.anchor.y, gBuffer, 0.4, 0xCECECE, true);\n    }\n",
        "answer": "/** @brief A function that prints text to the screen using cvui.\n*\n* This function takes a format string and a variable number of arguments, similar to the standard C library function printf(). It uses the cvui library to print the text on the screen. The text will be displayed at the current anchor point of the top block in the cvui hierarchy. The color of the text will be 0xCECECE (a light gray) and it will be anti-aliased.\n*\n* @param theFmt A format string, similar to the standard C library function printf().\n* @param ... A variable number of arguments to be used with the format string.\n*\n* @return None.\n*/\nvoid printf(char *theFmt, ...) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline bool compareBeaconCostByCount(BeaconCost const &lhs, BeaconCost const &rhs) {\n  return std::tie(lhs.count, lhs.totalCost, lhs.id) > std::tie(rhs.count, rhs.totalCost, rhs.id);\n}\n",
        "answer": "/** @brief Compares two BeaconCost objects based on their count, total cost, and ID.\n*\n*  This function compares two BeaconCost objects based on their count, total cost, and ID.\n*  It returns true if the left-hand side (lhs) is greater than the right-hand side (rhs),\n*  and false otherwise. The comparison is done in that order of precedence.\n*\n* @param lhs The first BeaconCost object to compare.\n* @param rhs The second BeaconCost object to compare.\n* @return True if lhs is greater than rhs, false otherwise.\n*/\ninline bool compareBeaconCostByCount(BeaconCost const &lhs, BeaconCost const &rhs) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void enableBlurBehind(WId window, bool enable, const QRegion &region)\n{\n    KWindowSystemPluginWrapper::self().effects()->enableBlurBehind(window, enable, region);\n}\n",
        "answer": "/** @brief Enables or disables blur behind effect for a window.\n*\n*  Instructs the window manager to blur the background in the specified region behind the given window. The given region will overwrite any previous blur-behind region. Passing a null region will enable the blur effect for the whole window. The region is relative to the top-left corner of the client area. Note that you will usually want to set the region to the shape of the window, excluding any shadow or halo.\n*\n* @param window The ID of the window for which the blur behind effect should be enabled or disabled.\n* @param enable Whether to enable (true) or disable (false) the blur behind effect.\n* @param region The region of the window that should be blurred, relative to the top-left corner of the client area. If null, the entire window will be blurred.\n*/\nvoid enableBlurBehind(WId window, bool enable, const QRegion &region)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "JNICALL void setConsoleColorProcessInformation()\r\n{\r\n    HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);\r\n    SetConsoleTextAttribute(hCon,ProccessInfoColor);\r\n}\r\n",
        "answer": "/** @brief Sets the color of the console for displaying Process information.\n*\n*  This function sets the color of the console for displaying Process information.\n*\n* @param[in] hCon The handle to the standard output device.\n* @param[in] ProccessInfoColor The color to set the console text attribute to.\n* @return Should not return\n*/\nJNICALL void setConsoleColorProcessInformation(HANDLE hCon, int ProccessInfoColor)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n                          const CScript& scriptSig1, const CScript& scriptSig2)\n{\n    txnouttype txType;\n    vector<vector<unsigned char> > vSolutions;\n    Solver(scriptPubKey, txType, vSolutions);\n\n    vector<valtype> stack1;\n    EvalScript(stack1, scriptSig1, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker());\n    vector<valtype> stack2;\n    EvalScript(stack2, scriptSig2, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker());\n\n    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, stack1, stack2);\n}\n",
        "answer": "/** @brief Combines two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders.\n*\n*  This function combines two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders.\n*  It takes in the scriptPubKey, BaseSignatureChecker, CScript, and vector of vectors of unsigned chars as parameters.\n*  It returns a CScript.\n*\n* @param[in] scriptPubKey The script public key.\n* @param[in] checker The base signature checker.\n* @param[in] scriptSig1 The first script signature.\n* @param[in] scriptSig2 The second script signature.\n* @return A CScript that is the combination of the two input scripts.\n*/\nCScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool DisconnectBlocks(int blocks)\n{\n    LOCK(cs_main);\n\n    CValidationState state;\n    const CChainParams& chainparams = Params();\n\n    LogPrintf(\"DisconnectBlocks -- Got command to replay %d blocks\\n\", blocks);\n    for(int i = 0; i < blocks; i++) {\n        if(!DisconnectTip(state, chainparams.GetConsensus()) || !state.IsValid()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
        "answer": "/** @brief Disconnects a specified number of blocks from the chain.\n*\n*  This function is used to reprocess a number of blocks and try to get back on the correct chain. It disconnects the given number of blocks from the current tip of the chain, validates each block using the CValidationState object, and then updates the block tree accordingly. If any of the blocks fail validation or if the function is unable to update the block tree, it returns false.\n*\n* @param blocks The number of blocks to disconnect.\n* @return True if the operation was successful, false otherwise.\n*/\nbool DisconnectBlocks(int blocks)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void send_response(session &sess, const std::string &app_name, const std::string &data)\n{\n\tkey key_id = app_name;\n\tkey_id.transform(sess);\n\tdnet_id id = key_id.id();\n\n\tELLIPTICS_REQUIRE(exec_result, sess.exec(&id, app_name + \"@response\", data));\n\n\tsync_exec_result result = exec_result;\n\tBOOST_REQUIRE_EQUAL(result.size(), 1);\n\tBOOST_REQUIRE_EQUAL(result[0].context().data().to_string(), data);\n}\n",
        "answer": "/** @brief Sends a response to a session.\n*\n*  This function sends a response to a session using the given application name and data. It first transforms the key ID using the session, then executes the response command with the transformed ID and data. Finally, it synchronously waits for the result of the execution and checks that it is successful and has the expected data.\n*\n* @param sess The session to send the response to.\n* @param app_name The name of the application to use for the response.\n* @param data The data to include in the response.\n*/\nvoid send_response(session &sess, const std::string &app_name, const std::string &data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" bool obs_module_load(void)\n{\n#if ENABLE_WINMF\n\tMFStartup(MF_VERSION, MFSTARTUP_FULL);\n\n\tRegisterMFAACEncoder();\n\tRegisterMFH264Encoders();\n#endif\n\n\treturn true;\n}\n",
        "answer": "/** @brief Module load function.\n*\n*  This function is called when the module is loaded. It is used to load all the sources, encoders, outputs, and services for your module, or anything else that may need loading.\n*\n* @return Returns true if the module was successfully loaded, false otherwise.\n*/\nextern \"C\" bool obs_module_load(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool get_bbox_from_end(FILE *ps_file,\n                       int &lower_left_x, int &lower_left_y, \n                       int &upper_right_x, int &upper_right_y)\n{\n  char buf[102400];\n  while (fgets(buf, sizeof(buf), ps_file)) {\n    if (!strncasecmp(buf, \"%%BoundingBox:\", 14)) {\n      if (sscanf(buf + 14, \"%d %d %d %d\",\n                 &lower_left_x, &lower_left_y, &upper_right_x, &upper_right_y) == 4) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
        "answer": "/** @brief Get the bounding box from the end of a file.\n*\n* This function searches for a bounding box at the end of a file, but in a really dumb way. It returns true if a bbox was found.\n*\n* @param ps_file The file to search for the bounding box.\n* @param lower_left_x The x coordinate of the lower left corner of the bounding box.\n* @param lower_left_y The y coordinate of the lower left corner of the bounding box.\n* @param upper_right_x The x coordinate of the upper right corner of the bounding box.\n* @param upper_right_y The y coordinate of the upper right corner of the bounding box.\n* @return True if a bbox was found, false otherwise.\n*/\nbool get_bbox_from_end(FILE *ps_file, int &lower_left_x, int &lower_left_y, int &upper_right_x, int &upper_right_y) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BH_ERRNO BH_PluginReset ()\n{\n\tif (!is_init())\n\t\treturn BPE_NOT_INIT;\n\n\treturn reset();\n}\n",
        "answer": "/** @brief Reset command for VM.\n*\n*  This function sends a reset command to the VM, which closes all sessions and unloads all packages. It will be blocked until the VM replies with a response. If anything goes wrong, please call BH_PluginDeinit() to clean up.\n*\n* @return Should not return\n*/\nBH_ERRNO BH_PluginReset ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void primesieve_free(void* primes)\n{\n  free(primes);\n}\n",
        "answer": "/** @brief Deallocate a primes array created using the primesieve_generate_primes() or primesieve_generate_n_primes() functions.\n*\n* This function deallocates a primes array that was created using the primesieve_generate_primes() or primesieve_generate_n_primes() functions.\n* It is important to use this function to free the memory allocated for the primes array, as it will prevent memory leaks and ensure that the memory is properly released.\n*\n* @param[in] primes A pointer to the primes array that was created using the primesieve_generate_primes() or primesieve_generate_n_primes() functions.\n*\n* @return None.\n*/\nvoid primesieve_free(void* primes)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint64_t primesieve_count_quintuplets(uint64_t start, uint64_t stop)\n{\n  try\n  {\n    return count_quintuplets(start, stop);\n  }\n  catch (exception&)\n  {\n    errno = EDOM;\n    return PRIMESIEVE_ERROR;\n  }\n}\n",
        "answer": "/** @brief Count the prime quintuplets within the interval [start, stop].\n*\n* This function counts the number of prime quintuplets (i.e., five prime numbers in arithmetic progression) within the given interval [start, stop]. By default, all CPU cores are used to perform the calculation. Use primesieve_set_num_threads(int threads) to change the number of threads.\n*\n* @param start The starting number of the interval (inclusive).\n* @param stop The ending number of the interval (exclusive).\n* @return The number of prime quintuplets within the given interval.\n*/\nuint64_t primesieve_count_quintuplets(uint64_t start, uint64_t stop)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class CtrlUpdate : public CallbackMessage {\r\n    Ctrl *ctrl;\r\n    float value;\r\npublic:\r\n    CtrlUpdate(Ctrl *ctrl, float value) {\r\n        this->ctrl = ctrl;\r\n        this->value = value;\r\n    }\r\n    void messageCallback() {\r\n        ctrl->publishValue(value);\r\n    }\r\n};\r\n",
        "answer": "/** @brief CtrlUpdate class.\n*\n*  This class is used to update the value of a control.\n*  It contains a pointer to the control and the new value.\n*\n* @param ctrl The control to be updated.\n* @param value The new value for the control.\n*/\n/** @brief Constructor.\n*\n*  Initializes the class with a pointer to the control and the new value.\n*\n* @param ctrl The control to be updated.\n* @param value The new value for the control.\n*/\n/** @brief Message callback function.\n*\n*  This function is called when a message is received.\n*  It updates the value of the control with the new value.\n*/\nvoid messageCallback() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void getCurrentProgramStateInformation (MemoryBlock& destData)\r\n    {\r\n        getStateInformation (destData);\r\n    }\r\n",
        "answer": "/** @brief Get current program state information.\n*\n*  This method returns the current program's state information.\n*\n* @param destData A reference to a MemoryBlock object where the state information will be stored.\n*/\nvoid getCurrentProgramStateInformation (MemoryBlock& destData)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isSameExcept(const ResTable_config& a, const ResTable_config& b, int axisMask) {\n    return a.diff(b) == axisMask;\n}\n",
        "answer": "/** @brief Checks if two configurations are the same except for a specific axis.\n*\n*  This function compares two ResTable_config objects and returns true if they only differ by the specified axis. The axis mask is a bitmask of CONFIG_* constants.\n*\n* @param[in] a The first configuration to compare.\n* @param[in] b The second configuration to compare.\n* @param[in] axisMask A bitmask of CONFIG_* constants representing the allowed difference between the two configurations.\n* @return True if the two configurations only differ by the specified axis, false otherwise.\n*/\nbool isSameExcept(const ResTable_config& a, const ResTable_config& b, int axisMask) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void daemon_exit ( void )\n{\n    daemon_files_fini ();\n    daemon_dump_info  ();\n    exit (0);\n}\n",
        "answer": "/** @brief Daemon exit function.\n*\n* This is the description of the functionality of the function.\n* Called by signal handler on daemon exit Performs cleanup by closing open files and freeing used memory\n*\n* @return Should not return\n*/\nvoid daemon_exit ( void )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int daemon_configure ( void )\n{\n    int rc = PASS ;\n\n    /* read config out of /etc/mtc/lmond.conf */\n    if (ini_parse( CONFIG_FILE, lmon_config_handler, &lmon_config) < 0)\n    {\n        elog(\"Can't load '%s'\\n\", CONFIG_FILE );\n        rc = FAIL_INI_CONFIG ;\n    }\n    else\n    {\n        get_debug_options ( CONFIG_FILE, &lmon_config );\n    }\n    return (rc);\n}\n",
        "answer": "/** @brief Reads and processes the mtc.ini file settings into the daemon configuration.\n*\n*  This function reads and processes the mtc.ini file settings into the daemon configuration. It first reads the config out of /etc/mtc/lmond.conf using ini_parse(). If the parsing is successful, it then gets the debug options from the CONFIG_FILE using get_debug_options().\n*\n* @param void\n* @return int rc - PASS if successful, FAIL_INI_CONFIG otherwise.\n*/\n/* read config out of /etc/mtc/lmond.conf */\nif (ini_parse( CONFIG_FILE, lmon_config_handler, &lmon_config) < 0)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "aiTextureType ParseTextureTypeFromString(std::string &inputString, aiTextureType defaultType) {\n\tif (_stricmp(inputString.c_str(), \"diffuse\") == 0) {\n\t\treturn aiTextureType_DIFFUSE;\n\t} else if (_stricmp(inputString.c_str(), \"normal\") == 0) {\n\t\treturn aiTextureType_NORMALS;\n\t} else if (_stricmp(inputString.c_str(), \"height\") == 0) {\n\t\treturn aiTextureType_HEIGHT;\n\t} else if (_stricmp(inputString.c_str(), \"displacement\") == 0) {\n\t\treturn aiTextureType_DISPLACEMENT;\n\t} else if (_stricmp(inputString.c_str(), \"alpha\") == 0) {\n\t\treturn aiTextureType_OPACITY;\n\t} else if (_stricmp(inputString.c_str(), \"specColor\") == 0) {\n\t\treturn aiTextureType_SPECULAR;\n\t} else if (_stricmp(inputString.c_str(), \"specPower\") == 0) {\n\t\treturn aiTextureType_SHININESS;\n\t} else {\n\t\treturn defaultType;\n\t}\n}\n",
        "answer": "/** @brief Parse a string into an aiTextureType.\n*\n* This function tries to parse a string into an aiTextureType. If the parse fails, the default return is 'defaultType'.\n*\n* @param inputString The input string to be parsed.\n* @param defaultType The default return value if the parse fails.\n* @return The parsed aiTextureType or the defaultType if the parse fails.\n*/\naiTextureType ParseTextureTypeFromString(std::string &inputString, aiTextureType defaultType) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool SelectParamsFromCommandLine() {\n    bool fRegTest = GetBoolArg(\"-regtest\", false);\n    bool fTestNet = GetBoolArg(\"-testnet\", false);\n\n    if (fTestNet && fRegTest) {\n        return false;\n    }\n\n    if (fRegTest) {\n        SelectParams(CChainParams::REGTEST);\n    } else if (fTestNet) {\n        SelectParams(CChainParams::TESTNET);\n    } else {\n        SelectParams(CChainParams::MAIN);\n    }\n    return true;\n}",
        "answer": "/** @brief Selects parameters from the command line.\n*\n*  This function looks for -regtest or -testnet and then calls SelectParams as appropriate. Returns false if an invalid combination is given.\n*\n* @param fRegTest A boolean indicating whether the regtest parameter was passed.\n* @param fTestNet A boolean indicating whether the testnet parameter was passed.\n* @return true if the parameters were selected successfully, false otherwise.\n*/\nbool SelectParamsFromCommandLine(bool fRegTest, bool fTestNet) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "FSW_STATUS fsw_set_directory_only(const FSW_HANDLE handle,\n                                  const bool directory_only)\n{\n  FSW_SESSION *session = get_session(handle);\n  session->directory_only = directory_only;\n\n  return fsw_set_last_error(FSW_OK);\n}\n",
        "answer": "/** @brief Sets the directory only flag for a file system watcher.\n*\n* This function determines whether the monitor only watches a directory when performing a recursive scan. By default, a monitor accepts all kinds of files.\n*\n* @param handle The handle to the file system watcher.\n* @param directory_only A boolean value indicating whether the monitor should only watch directories.\n*\n* @return FSW_STATUS indicating the result of the operation.\n*/\nFSW_STATUS fsw_set_directory_only(const FSW_HANDLE handle, const bool directory_only)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string real_strprintf(const std::string &format, int dummy, ...)\r\n{\r\n    va_list arg_ptr;\r\n    va_start(arg_ptr, dummy);\r\n    string str = vstrprintf(format.c_str(), arg_ptr);\r\n    va_end(arg_ptr);\r\n    return str;\r\n}\r\n",
        "answer": "/** @brief Overload strprintf for std::string, to be able to use it with _ (translation). This will not support GCC format type warnings (-Wformat) so be careful.\n*\n* @param[in] format The format string.\n* @param[in] dummy A dummy argument to hold the place of ... in the variadic function.\n* @param[in] ... The variadic arguments for the format string.\n* @return The formatted string.\n*/\nstring real_strprintf(const std::string &format, int dummy, ...)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "flann_index_t flann_build_index(float* dataset, int rows, int cols, float* speedup, FLANNParameters* flann_params)\n{\n    return _flann_build_index<float>(dataset, rows, cols, speedup, flann_params);\n}\n",
        "answer": "/**\n* @brief Builds and returns an index.\n*\n* This function builds and returns an index using autotuning if the target_precision field of index_params is between 0 and 1, or the parameters specified if it's -1.\n*\n* @param dataset A pointer to a data set stored in row major order.\n* @param rows The number of rows (features) in the dataset.\n* @param cols The number of columns in the dataset (feature dimensionality).\n* @param speedup A pointer to a float that will be filled with the estimated speedup over linear search, if using autotuning.\n* @param flann_params A pointer to an FLANNParameters struct that contains index-related parameters.\n*\n* @return The newly created index or a number <0 for error.\n*/\nflann_index_t flann_build_index(float* dataset, int rows, int cols, float* speedup, FLANNParameters* flann_params);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int flann_free_index(flann_index_t index_ptr, FLANNParameters* flann_params)\n{\n    return _flann_free_index<float>(index_ptr, flann_params);\n}\n",
        "answer": "/** @brief Deletes an index and releases the memory used by it.\n*\n*  This function deletes an index and releases the memory used by it.\n*\n* @param[in] index_id The index to be deleted (constructed previously using flann_build_index).\n* @param[in] flann_params Generic flann parameters.\n* @return Zero or a number <0 for error.\n*/\nint flann_free_index(flann_index_t index_ptr, FLANNParameters* flann_params)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CHAR_DESC ExtractBlobFeatures(const FEATURE_DEFS_STRUCT &FeatureDefs,\n                              const DENORM& bl_denorm, const DENORM& cn_denorm,\n                              const INT_FX_RESULT_STRUCT& fx_info,\n                              TBLOB *Blob) {\n  return ExtractFlexFeatures(FeatureDefs, Blob, bl_denorm, cn_denorm, fx_info);\n}                                /* ExtractBlobFeatures */\n",
        "answer": "/** @brief Extract features from a blob.\n*\n*  This routine extracts features from a blob by calling the feature extractor which is currently being used. It provides a high level interface to feature extraction, allowing the caller to extract any type of features from a blob without understanding any lower level details.\n*\n* @param FeatureDefs The feature definitions structure containing information about the features to be extracted.\n* @param bl_denorm The blob's left normalization factor.\n* @param cn_denorm The blob's center normalization factor.\n* @param fx_info The fixed-point result structure containing information about the blob's features.\n* @param Blob The blob from which to extract features.\n*\n* @return A character description of the extracted features.\n*/\nCHAR_DESC ExtractBlobFeatures(const FEATURE_DEFS_STRUCT &FeatureDefs,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": " l_int32 numaGetXParameters(NUMA       *na,\n                    l_float32  *pstartx,\n                    l_float32  *pdelx)\n {\n     PROCNAME(\"numaGetXParameters\");\n\n     if (!na)\n         return ERROR_INT(\"na not defined\", procName, 1);\n\n     if (pstartx) *pstartx = na->startx;\n     if (pdelx) *pdelx = na->delx;\n     return 0;\n }\n",
        "answer": "/** @brief Get X parameters.\n*\n*  This function gets the start and end x values of a Numa object.\n*\n* @param na The Numa object to get the parameters from.\n* @param pstartx (<optional return>=\"\"> startx) The starting x value.\n* @param pdelx (<optional return>=\"\"> delx) The ending x value.\n* @return 0 if OK, 1 on error.\n*/\nl_int32 numaGetXParameters(NUMA *na, l_float32 *pstartx, l_float32 *pdelx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int tfscanf(FILE* stream, const char *format, ...) {\n  va_list ap;\n  int rv;\n\n  va_start(ap, format);\n  rv = tvfscanf(stream, format, ap);\n  va_end(ap);\n\n  return rv;\n}\n",
        "answer": "/** @brief tfscanf variant to ensure correct reading regardless of locale.\n*\n* This function is a fscanf variant that ensures correct reading regardless of the current locale. It parses a file stream according to the given format, and it attempts to mimic the behavior of the fscanf manpage.\n*\n* @param stream The file stream to parse.\n* @param format The format string used for parsing.\n* @return The number of items assigned.\n*/\nint tfscanf(FILE* stream, const char *format, ...) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sync_plan_position() {\n  #if ENABLED(DEBUG_LEVELING_FEATURE)\n    if (DEBUGGING(LEVELING)) DEBUG_POS(\"sync_plan_position\", current_position);\n  #endif\n  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\n}\n",
        "answer": "/**\n* @brief Synchronize planner and stepper positions directly from current position without kinematic translation.\n*\n* This function sets the planner and stepper positions to the current position without performing any kinematic translation. It is used for homing axes and cartesian/core syncing.\n*\n* @param current_position The current position of the machine.\n*/\nvoid sync_plan_position(const float (&current_position)[XYZE]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void print_signed_float(const char * const prefix, const float &f) {\n      SERIAL_PROTOCOLPGM(\"  \");\n      serialprintPGM(prefix);\n      SERIAL_PROTOCOLCHAR(':');\n      if (f >= 0) SERIAL_CHAR('+');\n      SERIAL_PROTOCOL_F(f, 2);\n    }\n",
        "answer": "/** @brief Delta '1-4-7-point' Auto-Calibration Calibrate height, endstops, delta radius, and tower angles. Parameters: Pn Number of probe points: P1 Probe center and set height only. P2 Probe center and towers. Set height, endstops, and delta radius. P3 Probe all positions: center, towers and opposite towers. Set all. P4-P7 Probe all positions at different locations and average them. T0 Don't calibrate tower angle corrections Cn.nn Calibration precision; when omitted calibrates to maximum precision Fn Force to run at least n iterations and takes the best result Vn Verbose level: V0 Dry-run mode. Report settings and probe results. No calibration. V1 Report settings V2 Report settings and probe results E Engage the probe for each point\n*\n* @param prefix The prefix to print before the float value.\n* @param f The float value to print.\n*/\nvoid print_signed_float(const char * const prefix, const float &f) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M208() {\n    if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);\n    if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));\n    #if EXTRUDERS > 1\n      if (parser.seen('W')) retract_recover_length_swap = parser.value_axis_units(E_AXIS);\n    #endif\n  }\n",
        "answer": "/**\n* @brief Set firmware un-retraction values.\n*\n* This function sets the firmware un-retraction values for the specified axis.\n* It takes three parameters: S, F, and W. S specifies the length of the retraction,\n* F specifies the feedrate of the retraction, and W specifies the length of the\n* retraction swap (only used if EXTRUDERS > 1).\n*\n* @param parser The parser object containing the parameters for this function.\n* @return Void.\n*/\ninline void gcode_M208() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M163() {\n    const int mix_index = parser.intval('S');\n    if (mix_index < MIXING_STEPPERS) {\n      float mix_value = parser.floatval('P');\n      NOLESS(mix_value, 0.0);\n      mixing_factor[mix_index] = RECIPROCAL(mix_value);\n    }\n  }\n",
        "answer": "/**\n* @brief Set a single mix factor for a mixing extruder.\n*\n* This function sets the mix factor for a specific channel of a mixing extruder. The mix factor is\n* specified as a float value between 0 and 1, where 0 represents no mixing and 1 represents full mixing.\n*\n* @param index The channel index to set.\n* @param float The mix value.\n*/\ninline void gcode_M163() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Point unit_vector(Point const &a)\n{\n    Point ret(a);\n    ret.normalize();\n    return ret;\n}\n",
        "answer": "/** @brief Returns the unit vector of a given point.\n*\n*  This function takes a point as input and returns its unit vector.\n*  The unit vector is calculated by normalizing the input point.\n*\n* @param[in] a The input point.\n* @return The unit vector of the input point.\n*/\nPoint unit_vector(Point const &a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "wxString GetDedicatedProductCommandArguments(const wxString& arguments)\n{\n\n    wxLogNull log;\n    wxRegKey regKey(wxT(\"HKEY_CURRENT_USER\\\\Software\\\\Spark Engine\"));\n\n    wxString gameDirectory;\n\n    if (regKey.Exists())\n    {\n        regKey.QueryValue(wxT(\"Game Asset Directory\"), gameDirectory);\n    }\n\n    wxString result;\n\n    if (!gameDirectory.IsEmpty())\n    {\n        result = wxT(\"-game \\\"\") + gameDirectory + wxT(\"\\\"\");\n    }\n    \n    if (!arguments.IsEmpty())\n    {\n        result += wxT(\" \") + arguments;\n    }\n\n    return result;\n\n}\n",
        "answer": "/** @brief Returns the command line arguments that will be used to launch the dedicated application.\n*\n*  This function returns the command line arguments that will be used to launch the dedicated application, which are the arguments specified by the user. In general, these should be added to whatever special arguments the dedicated product requires.\n*\n* @param arguments The arguments specified by the user.\n* @return The command line arguments that will be used to launch the dedicated application.\n*/\nwxString GetDedicatedProductCommandArguments(const wxString& arguments)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    const char* ADR_CALL getTagType(int i)  { return m_source->getTagType(i);  }\n",
        "answer": "/** @brief Returns the type of the i'th tag in the source. The type is where the tag comes from, i.e. \"ID3v1\", \"ID3v2\", or \"vorbis\".\n*\n*  This function returns the type of the i'th tag in the source. The type is where the tag comes from, i.e. \"ID3v1\", \"ID3v2\", or \"vorbis\".\n*\n* @param i The index of the tag to get the type for.\n* @return The type of the i'th tag in the source.\n*/\nconst char* ADR_CALL getTagType(int i)  "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void co_delete(co_thread_t *t) {\r\n    assert(t);\r\n    if (t != t->main_ && t->stack_)\r\n        co_free(t->alloc_, t->stack_);\r\n    co_free(t->alloc_, t);\r\n}\r\n",
        "answer": "/** @brief Deletes a coroutine thread.\n*\n*  This function deletes a coroutine thread and frees its memory.\n*\n* @param[in] t The coroutine thread to delete.\n*/\nvoid co_delete(co_thread_t *t) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int aes_crypt_ctr( aes_context *ctx,\n                       size_t length,\n                       size_t *nc_off,\n                       unsigned char nonce_counter[16],\n                       unsigned char stream_block[16],\n                       const unsigned char *input,\n                       unsigned char *output )\n{\n    int c, i;\n    size_t n = *nc_off;\n\n    while( length-- )\n    {\n        if( n == 0 ) {\n            aes_crypt_ecb( ctx, AES_ENCRYPT, nonce_counter, stream_block );\n\n            for( i = 16; i > 0; i-- )\n                if( ++nonce_counter[i - 1] != 0 )\n                    break;\n        }\n        c = *input++;\n        *output++ = (unsigned char)( c ^ stream_block[n] );\n\n        n = (n + 1) & 0x0F;\n    }\n\n    *nc_off = n;\n\n    return( 0 );\n}\n",
        "answer": "/** @brief AES Crypt Counter.\n*\n* This function performs the AES encryption or decryption of a buffer using the CTR mode.\n*\n* @param ctx The AES context to use for encryption or decryption.\n* @param length The length of the input data in bytes.\n* @param nc_off The offset in the current stream block, for resuming within current cipher stream.\n* @param nonce_counter The 128-bit nonce and counter.\n* @param stream_block The saved stream-block for resuming. Is overwritten by the function.\n* @param input The buffer holding the input data.\n* @param output The buffer holding the output data.\n*\n* @return 0 if successful, or AES_ERR_INVALID_INPUT_LENGTH if the input length is not valid.\n*/\n*output++ = (unsigned char)(c ^ stream_block[n]);\n*nc_off = n;\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual bool onKeyPressed( int key, int flags )\n    {\n        _wm->postEvent( new CRGUIKeyDownEvent(key, flags) );\n        _wm->closeWindow( this );\n        return true;\n    }\n",
        "answer": "/** @brief Handles key press events.\n*\n*  This function processes key press events and returns true if the key is processed.\n*  By default, it translates the key to a command using an accelerator table.\n*\n* @param key The key that was pressed.\n* @param flags Additional information about the key press event.\n* @return True if the key was processed, false otherwise.\n*/\nvirtual bool onKeyPressed( int key, int flags )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LVStreamRef LVCreateBlockWriteStream( LVStreamRef baseStream, int blockSize, int blockCount )\n{\n    if ( baseStream.isNull() || baseStream->GetMode()==LVOM_READ )\n        return baseStream;\n    return LVStreamRef( new LVBlockWriteStream(baseStream, blockSize, blockCount) );\n}\n",
        "answer": "/** @brief Creates cache buffers for stream to write data by big blocks to optimize Flash drives writing performance.\n*\n*  This function creates cache buffers for a given stream to write data in big blocks, which optimizes the performance of Flash drives.\n*\n* @param baseStream The stream to create the cache buffers for.\n* @param blockSize The size of each block in bytes.\n* @param blockCount The number of blocks to use.\n* @return A reference to the created stream, or a null reference if an error occurred.\n*/\nLVStreamRef LVCreateBlockWriteStream( LVStreamRef baseStream, int blockSize, int blockCount )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeInOutCubic(kn_double t)\r\n{\r\n    t*=2.0;\r\n    if(t < 1) {\r\n        return 0.5*t*t*t;\r\n    } else {\r\n        t -= kn_double(2.0);\r\n        return 0.5*(t*t*t + 2);\r\n    }\r\n}\r\n",
        "answer": "/** @brief Easing equation function for a cubic (t^3) easing in/out: acceleration until halfway, then deceleration.\n*\n* This is the description of the functionality of the function.\n*\n* @param t The input value to be used in the easeInOutCubic function.\n* @return The output value after applying the easeInOutCubic function on the input value.\n*/\nstatic kn_double easeInOutCubic(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutInQuint(kn_double t)\r\n{\r\n    if (t < 0.5) return easeOutQuint (2*t)/2;\r\n    return easeInQuint(2*t - 1)/2 + 0.5;\r\n}\r\n",
        "answer": "/** @brief Easing equation function for a quintic (t^5) easing out/in: deceleration until halfway, then acceleration.\n*\n* This function implements the easing equation for a quintic (t^5) easing out/in. The function\n* decelerates until halfway and then accelerates.\n*\n* @param t The input parameter of the function, representing the current time or position.\n* @return The output value of the function, representing the new time or position.\n*/\nstatic kn_double easeOutInQuint(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeInOutCirc(kn_double t)\r\n{\r\n    t*=kn_double(2.0);\r\n    if (t < 1) {\r\n        return -0.5 * (sqrt(1 - t*t) - 1);\r\n    } else {\r\n        t -= kn_double(2.0);\r\n        return 0.5 * (sqrt(1 - t*t) + 1);\r\n    }\r\n}\r\n",
        "answer": "/** @brief Easing equation function for a circular (sqrt(1-t^2)) easing in/out: acceleration until halfway, then deceleration.\n*\n*  This function implements the easing equation for a circular (sqrt(1-t^2)) easing in/out: acceleration until halfway, then deceleration.\n*\n* @param t The input parameter for the easing function.\n* @return The output value of the easing function.\n*/\nstatic kn_double easeInOutCirc(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutInElastic(kn_double t, kn_double a, kn_double p)\r\n{\r\n    if (t < 0.5) return easeOutElastic_helper(t*2, 0, 0.5, 1.0, a, p);\r\n    return easeInElastic_helper(2*t - 1.0, 0.5, 0.5, 1.0, a, p);\r\n}\r\n",
        "answer": "/** @brief Easing equation function for an elastic (exponentially decaying sine wave) easing out/in: deceleration until halfway, then acceleration.\n*\n*  This function implements the easing equation for an elastic (exponentially decaying sine wave) easing out/in. It takes four parameters: t, a, p, and b. The function first checks if t is less than 0.5, and if so, it returns the result of calling easeOutElastic_helper with the appropriate arguments. Otherwise, it returns the result of calling easeInElastic_helper with the appropriate arguments.\n*\n* @param t The current time (or position) of the animation.\n* @param a The amplitude of the sine wave.\n* @param p The period of the sine wave.\n* @return The value of the easing equation at the given time.\n*/\nstatic kn_double easeOutInElastic(kn_double t, kn_double a, kn_double p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutBounce(kn_double t, kn_double a)\r\n{\r\n    return easeOutBounce_helper(t, 1, a);\r\n}\r\n",
        "answer": "/** @brief Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out: decelerating from zero velocity.\n*\n* This is the description of the functionality of the function.\n*\n* @param t The time elapsed since the beginning of the animation.\n* @param a The amplitude of the bounce.\n* @return The value of the easeOutBounce function at the given time and amplitude.\n*/\nstatic kn_double easeOutBounce(kn_double t, kn_double a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutCurve(kn_double t)\r\n{\r\n    const kn_double progress = sinProgress(t);\r\n    const kn_double mix = smoothBeginEndMixFactor(1 - t);\r\n    return progress * mix + t * (1 - mix);\r\n}\r\n",
        "answer": "/** @brief Easing function that starts growing steadily, then ends slowly. The speed will be constant at the beginning of the curve.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nstatic kn_double easeOutCurve(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool CanUseHttpImages()\n    {\n        return IsRunningAsUwp();\n    }\n",
        "answer": "/** @brief Gets a boolean representing whether HTTP images can be used within toasts. This is true if running under Desktop Bridge.\n*\n*  @return A boolean indicating whether HTTP images can be used within toasts.\n*/\nbool CanUseHttpImages()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\n\r\nANONYMOUS_NAMESPACE_BEGIN\r\nstatic inline ECP::Point ToMontgomery(const ModularArithmetic &mr, const ECP::Point &P)\r\n{\r\n\treturn P.identity ? P : ECP::Point(mr.ConvertIn(P.x), mr.ConvertIn(P.y));\r\n}\r\n",
        "answer": "/** @brief Converts an ECP::Point to Montgomery form using ModularArithmetic.\n*\n*  This function takes a ModularArithmetic object and an ECP::Point as input, and returns the corresponding point in Montgomery form. If the point is already in Montgomery form, it is returned unchanged.\n*\n* @param mr The ModularArithmetic object to use for the conversion.\n* @param P The ECP::Point to convert.\n* @return The converted ECP::Point in Montgomery form.\n*/\nvoid kernel_entrypoint()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void onTransferFinish(MegaApi* api, MegaTransfer *transfer, MegaError* error)\n\t{\n\t\tif (error->getErrorCode())\n\t\t{\n\t\t\tcout << \"***** Transfer finished with error: \" << error->getErrorString() << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"***** Transfer finished OK\" << endl;\n\t\t}\n\n\t\tfinished = true;\n\t}\n",
        "answer": "/** @brief Callback for when a transfer finishes.\n*\n*  This function is called by the SDK when a transfer finishes. It provides the result of the transfer, including any errors that may have occurred.\n*\n* @param api The MegaApi object that started the transfer.\n* @param transfer The MegaTransfer object that represents the transfer.\n* @param error The MegaError object that contains information about any errors that may have occurred during the transfer.\n*/\nvirtual void onTransferFinish(MegaApi* api, MegaTransfer *transfer, MegaError* error)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool onTransferData(MegaApi *api, MegaTransfer *transfer, char *buffer, size_t s)\n\t{\n\t\tdata.append(buffer, s);\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Callback for transfer data.\n*\n*  This callback is called when there is new data available for a transfer. The buffer provided by this function contains the new data, and the size of the buffer is specified by the s parameter. The SDK retains the ownership of the transfer and buffer parameters. Don't use them after this functions returns. This callback is mainly provided for compatibility with other programming languages.\n*\n* @param api MegaApi object that started the transfer.\n* @param transfer MegaTransfer object containing information about the transfer.\n* @param buffer Pointer to a buffer containing the new data.\n* @param s Size of the buffer in bytes.\n* @return Should return true if the data was processed successfully, false otherwise.\n*/\nbool onTransferData(MegaApi *api, MegaTransfer *transfer, char *buffer, size_t s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int fuse_loop_mt(struct fuse *f) { return do_fuse_loop(f, true); }\n",
        "answer": "/** @brief FUSE event loop with multiple threads.\n*\n*  Requests from the kernel are processed, and the appropriate operations are called. Requests are processed in parallel by distributing them between multiple threads. Calling this function requires the pthreads library to be linked to the application.\n*\n* @param f A pointer to a struct fuse object.\n* @return Should not return.\n*/\nint fuse_loop_mt(struct fuse *f) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double markov(double sigma,\n              double bcor,\n              double time,\n              double intstep,\n              double &value_saved) {\n    double value = 0;\n\n    value = gauss(0., sigma);\n    if (time == 0.) {\n        value_saved = value;\n    } else {\n        if (bcor != 0.) {\n            double dum = exp(-bcor * intstep);\n            double dumsqrd = dum * dum;\n            value = value * sqrt(1. - dumsqrd) + value_saved * dum;\n            value_saved = value;\n        }\n    }\n    return value;\n}\n",
        "answer": "/** @brief Markov function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param sigma = standard deviation of Gaussian distribution - unit of variable\n* @param bcor = beta time correlation coefficient - 1/s (Hz) time = simulation time - s intstep = integration step size - s return output: value = value of variable - unit of variable\n* @return Should not return\n*/\nvoid kernel_entrypoint()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ALvoid alGenBuffers( ALsizei n, ALuint* buffers )\n{\n\twhile (n--)\n\t{\n\t\tQALState::BufferInfo* info = new QALState::BufferInfo;\n\n\t\tinfo->m_Valid = false;\n\n\t\ts_pState->m_Buffers[s_pState->m_NextBuffer] = info;\n\t\tbuffers[n] = s_pState->m_NextBuffer++;\n\t}\n}\n",
        "answer": "/** @brief Generates one or more buffers.\n*\n*  This function generates one or more buffers, which are storage spaces for sample data. Buffers are referred to by Sources. There can be more than one Source using the same Buffer data. If Buffers have to be duplicated on a per-Source basis, the driver has to take care of allocation, copying, and deallocation as well as propagating buffer data changes.\n*\n* @param[in] n The number of buffers to generate.\n* @param[out] buffers A pointer to an array where the generated buffers will be stored.\n*\n* @return void\n*/\nvoid alGenBuffers(ALsizei n, ALuint* buffers)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool system_io_flash_read(uint8_t* buffer, uint32_t bufferLength)\n{\n   std::string pathStr = MDFN_MakeFName(MDFNMKF_SAV, 0, \"flash\");\n   RFILE     *flash_fp = filestream_open(pathStr.c_str(),\n         RETRO_VFS_FILE_ACCESS_READ, RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n   if (!flash_fp)\n      return 0;\n\n   filestream_read(flash_fp, buffer, bufferLength);\n   filestream_close(flash_fp);\n\n   return 1;\n}\n",
        "answer": "/** @brief Reads the \"appropriate\" (system specific) flash data into the given preallocated buffer. The emulation core doesn't care where from.\n*\n*  This function reads the \"appropriate\" (system specific) flash data into the given preallocated buffer. The emulation core doesn't care where from.\n*\n* @param[in] buffer A pointer to a pre-allocated buffer where the flash data will be stored.\n* @param[in] bufferLength The length of the buffer in bytes.\n*\n* @return True if the flash data was read successfully, false otherwise.\n*/\nbool system_io_flash_read(uint8_t* buffer, uint32_t bufferLength)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "XN_C_API void xnDumpClose(XnDump* pDump)\r\n{\r\n\tif (pDump->hFile != XN_INVALID_FILE_HANDLE)\r\n\t{\r\n\t\txnOSCloseFile(&pDump->hFile);\r\n\t\t*pDump = XN_DUMP_CLOSED;\r\n\t}\r\n}\r\n",
        "answer": "/** @brief Closes a dump file.\n*\n* This function closes a dump file (use it once file is no longer needed). You can later use xnDumpWriteString and xnDumpWriteBuffer to write to this file.\n*\n* @param pDump A pointer to the XnDump object representing the file to be closed.\n*/\n*pDump = XN_DUMP_CLOSED;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "XN_C_API XnStatus xnNodeQueryAddSupportedCapability(XnNodeQuery* pQuery, const XnChar* strNeededCapability)\r\n{\r\n\tXN_VALIDATE_INPUT_PTR(pQuery);\r\n\tXN_VALIDATE_INPUT_PTR(strNeededCapability);\r\n\tpQuery->astrSupportedCapabilities[pQuery->nSupportedCapabilities++] = strNeededCapability;\r\n\treturn (XN_STATUS_OK);\r\n}\r\n",
        "answer": "/** @brief Adds a capability that the node must support. Note that for checking if a capability is supported, the node must be created (if it's not an existing one). This operation might take a bit longer...\n*\n*  @param pQuery A pointer to the XnNodeQuery object.\n*  @param strNeededCapability The name of the capability that the node must support.\n*\n*  @return Should not return\n*/\nXN_C_API XnStatus xnNodeQueryAddSupportedCapability(XnNodeQuery* pQuery, const XnChar* strNeededCapability)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "subgroup_shard_layout_t one_subgroup_entire_view_raw(const std::type_index& subgroup_type,\n                                                     const std::unique_ptr<View>& prev_view, View& curr_view) {\n    subgroup_shard_layout_t subgroup_vector(1);\n    subgroup_vector[0].emplace_back(curr_view.make_subview(curr_view.members, Mode::UNORDERED));\n    curr_view.next_unassigned_rank = curr_view.members.size();\n    return subgroup_vector;\n}\n",
        "answer": "/** @brief A simple implementation of shard_view_generator_t that returns a single, un-sharded subgroup in Unordered (Raw) mode containing all the members of curr_view, regardless of what subgroup type is supplied. This is best used when there is only one subgroup type.\n*\n* @param subgroup_type The type of the subgroup to be generated.\n* @param prev_view The previous view.\n* @param curr_view The current view.\n* @return A vector containing a single subgroup, which contains all members of the current view in unordered mode.\n*/\nsubgroup_shard_layout_t one_subgroup_entire_view_raw(const std::type_index& subgroup_type, const std::unique_ptr<View>& prev_view, View& curr_view) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OSVR_ReturnCode osvrClientFreeDisplay(OSVR_DisplayConfig disp) {\n    OSVR_VALIDATE_DISPLAY_CONFIG;\n    OSVR_ClientContext ctx = disp->ctx;\n    BOOST_ASSERT_MSG(\n        ctx != nullptr,\n        \"Should never get a display config object with a null context in it.\");\n    if (nullptr == ctx) {\n        return OSVR_RETURN_FAILURE;\n    }\n    auto freed = ctx->releaseObject(disp);\n    return freed ? OSVR_RETURN_SUCCESS : OSVR_RETURN_FAILURE;\n}\n",
        "answer": "/** @brief Frees a display configuration object.\n*\n*  This function is used to free a display configuration object that was created by osvrClientGetDisplayConfig.\n*  It should be called when the application no longer needs the display configuration information.\n*\n* @param[in] disp The display configuration object to free.\n* @return OSVR_RETURN_SUCCESS if the object was freed successfully, or OSVR_RETURN_FAILURE if there was an error.\n*/\nOSVR_ReturnCode osvrClientFreeDisplay(OSVR_DisplayConfig disp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvoid initPlugin() {\n\t\t\tif (reporterThread) return;\n\n\t\t\tobservedActivities = 0;\n\t\t\tdroppedActivities = 0;\n\t\t\tobservedAsyncActivities = 0;\n\n\t\t\tmultiplexer->registerCatchall( this, static_cast<ActivityMultiplexer::Callback>( &ActivityMonitor::Notify ), false );\n\t\t\tmultiplexer->registerCatchall( this, static_cast<ActivityMultiplexer::Callback>( &ActivityMonitor::NotifyAsync ), true );\n\t\t}\n",
        "answer": "/** @brief Initializes the plugin.\n*\n*  This function is called at the end of the plugin initialization procedure. It initializes the plugin by registering catchall callbacks for both synchronous and asynchronous activities.\n*\n* @param reporterThread The thread that reports on the plugin's activity. If this parameter is not null, the function returns immediately without performing any action.\n* @param observedActivities The number of observed activities.\n* @param droppedActivities The number of dropped activities.\n* @param observedAsyncActivities The number of observed asynchronous activities.\n* @param multiplexer The activity multiplexer that registers the catchall callbacks.\n* @return void\n*/\nvoid initPlugin(reporterThread, observedActivities, droppedActivities, observedAsyncActivities, multiplexer) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid siox_activity_set_attribute( siox_activity * activity, siox_attribute * attribute, const void * value )\n\t{\n\t\tassert( activity != nullptr );\n\t\tassert( attribute != nullptr );\n\n\t\tif( value == nullptr ) {\n\t\t\treturn;\n\t\t}\n\n\t\tFUNCTION_BEGIN\n\n\t\tActivityBuilder * ab = ActivityBuilder::getThreadInstance();\n\t\tOntologyAttribute oa = convertPtrToOntologyAttribute(attribute);\n\t\tAttribute attr( oa.aID, convert_attribute( oa, value ) );\n\n\t\tab->setActivityAttribute( activity->activity, attr );\n\n\t}\n",
        "answer": "/** @brief Sets an attribute for a given activity.\n*\n*  This function sets an attribute for a given activity. Attributes can be either parameters or other values computed from them, or metrics and statistics resulting from the call.\n*\n* @param[in] activity The activity to set the attribute for.\n* @param[in] attribute The attribute to set.\n* @param[in] value The value of the attribute.\n*/\nvoid siox_activity_set_attribute( siox_activity * activity, siox_attribute * attribute, const void * value )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void btAlignedAllocSetCustomAligned(btAlignedAllocFunc *allocFunc, btAlignedFreeFunc *freeFunc)\n{\n\tsAlignedAllocFunc = allocFunc ? allocFunc : btAlignedAllocDefault;\n\tsAlignedFreeFunc = freeFunc ? freeFunc : btAlignedFreeDefault;\n}\n",
        "answer": "/** @brief Set custom aligned allocator.\n*\n*  This function sets a custom aligned allocator for the Bullet Physics library. If no custom aligned allocator is provided, the default aligned allocator will be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator and instruments it.\n*\n* @param[in] allocFunc Pointer to a function that performs aligned allocation.\n* @param[in] freeFunc Pointer to a function that frees memory allocated by the aligned allocator.\n*/\nvoid btAlignedAllocSetCustomAligned(btAlignedAllocFunc *allocFunc, btAlignedFreeFunc *freeFunc)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BOOL checkIsSessionRecording(void) {\n\tif (g_strPluginRegKey.length() < 1) return FALSE;\n\tBOOL retVal = REG_DEFVAL_RECORDING;\n\n\tString strRegVal = getRegValue(HKEY_CURRENT_USER, g_strPluginRegKey, REG_VALNAME_RECORDING);\n\n\tif (strRegVal.length() > 0)\n\t\tretVal = strRegVal.equalsIgnoreCase(\"true\");\n\n#ifdef _DEBUG\n\tLog(eSeverityInfo, retVal ? \"checkIsSessionRecording Returning TRUE\" : \"checkIsSessionRecording Returning FALSE\", 0);\n\tLog(eSeverityInfo, (String(REG_VALNAME_RECORDING) + String(\" is \") + getRegValue(HKEY_CURRENT_USER, g_strPluginRegKey, REG_VALNAME_RECORDING)).getBytes(), 0);\n#endif\n\treturn retVal;\n}\n",
        "answer": "/** @brief Checks Registry entry for \"IsSessionRecording\" and Provide activation state. If Value is not found, the default is returned (TRUE)\n*\n*  This function checks the registry entry for \"IsSessionRecording\" and provides the activation state. If the value is not found, the default is returned (TRUE).\n*\n* @param[in] void\n* @return BOOL retVal - Returns TRUE if the value is found and equals \"true\", otherwise returns FALSE.\n*/\nBOOL checkIsSessionRecording(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void fex_free_path( char* path )\n{\n\tfree( path );\n}\n",
        "answer": "/** @brief Frees converted path. OK to pass NULL. Only supported when BLARGG_UTF8_PATHS is defined and building on Windows\n*\n*  This function frees the memory allocated for the converted path. It is safe to pass a null pointer, in which case the function will do nothing. This function is only supported when BLARGG_UTF8_PATHS is defined and building on Windows.\n*\n* @param[in] path The path to be freed.\n* @return None.\n*/\nvoid fex_free_path( char* path )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BLARGG_EXPORT unsigned    fex_crc32           ( const fex_t* fe )                   { return fe->crc32(); }\n",
        "answer": "/** @brief Calculates the CRC-32 checksum of a file's contents.\n*\n*  This function calculates the CRC-32 checksum of a file's contents, or returns 0 if unavailable. It doesn't require calculation; simply gets it from the file's header. fex_stat() must have been called.\n*\n* @param fe A pointer to the fex_t structure representing the file.\n* @return The CRC-32 checksum of the file's contents, or 0 if unavailable.\n*/\nBLARGG_EXPORT unsigned    fex_crc32           ( const fex_t* fe )                   "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unrar_err_t unrar_extract_mem( unrar_t* p, void const** out )\n{\n\tassert( !unrar_done( p ) );\n\t\n\t*out = NULL;\n\t\n\tif ( !p->data_ )\n\t{\n\t\tunrar_err_t err = unrar_extract_custom( p, &extract_mem, p );\n\t\tif ( err )\n\t\t\treturn err;\n\t}\n\t\n\t*out = (p->own_data_ ? p->own_data_ : p->data_);\n\treturn unrar_ok;\n}\n",
        "answer": "/** @brief Extracts data to memory and returns pointer to it in *out. Pointer is valid until unrar_next(), unrar_rewind(), unrar_seek(), or unrar_close(). OK to call more than once for same file. Optimized to avoid allocating memory when entire file will already be kept in internal window.\n*\n* @param p A pointer to an unrar_t structure that represents the RAR archive.\n* @param out A pointer to a void const** that will hold the extracted data.\n* @return unrar_err_t An error code indicating the result of the operation.\n*/\n*out = NULL;\n*out = (p->own_data_ ? p->own_data_ : p->data_);\nreturn unrar_ok;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Vector2 ParseVector2(const std::string& in_string)\n    {\n        u32 udwSize = EnumerateItems(in_string);\n        CS_ASSERT((udwSize == 2), \"Invalid number of elements for Vector2.\");\n        \n        if (udwSize != 2)\n        {\n            return Vector2::k_zero;\n        }\n        else\n        {\n            Vector2 vRet;\n            CS_SSCANF(in_string.c_str(), \"%f %f\", &vRet.x, &vRet.y);\n            return vRet;\n        }\n    }\n",
        "answer": "/**\n* @brief Parses a string to a 2 component vector.\n*\n* The vector must be in the format \"x y\", i.e F32 values, space delimited. Failure to parse will result in a zero vector.\n*\n* @param in_string The input string to parse.\n* @return A 2 component vector parsed from the input string, or a zero vector if parsing failed.\n*/\nVector2 ParseVector2(const std::string& in_string);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Integer4 ParseInteger4(const std::string& string)\n    {\n        u32 size = EnumerateItems(string);\n        CS_ASSERT((size == 4), \"Invalid number of elements for Integer4.\");\n        \n        if (size != 4)\n        {\n            return Integer4::k_zero;\n        }\n        else\n        {\n            Integer4 ret;\n            CS_SSCANF(string.c_str(), \"%d %d %d %d\", &ret.x, &ret.y, &ret.z, &ret.w);\n            return ret;\n        }\n    }\n",
        "answer": "/**\n* @brief Parses a string to an integer vector.\n*\n* The input string must be in the format \"x y z w\", where x, y, z, and w are s32 values, space delimited.\n* If the input string cannot be parsed, this function will return a zero vector.\n*\n* @param[in] string The input string to parse.\n* @return The parsed integer vector, or a zero vector if parsing failed.\n*/\nInteger4 ParseInteger4(const std::string& string);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    ProgressBarType ParseProgressBarType(const std::string& in_stringType)\n    {\n        std::string lowerType = in_stringType;\n        StringUtils::ToLowerCase(lowerType);\n        \n        if (lowerType == k_typeFill)\n        {\n            return ProgressBarType::k_fill;\n        }\n        else if (lowerType == k_typeStretch)\n        {\n            return ProgressBarType::k_stretch;\n        }\n        \n        CS_LOG_FATAL(\"Could not parse progress bar type: \" + in_stringType);\n        return ProgressBarType::k_fill;\n    }\n",
        "answer": "/**\n* @brief Parse a progress bar type from string. This is case insensitive. If the string is not a valid type then the app is considered to be in an irrecoverable state and will terminate.\n*\n* @param in_stringType The input string representing the progress bar type.\n*\n* @return The parsed progress bar type, or k_fill if the input string is not a valid type.\n*/\nProgressBarType ParseProgressBarType(const std::string& in_stringType);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        Vector2 FitOriginal(const Vector2& in_originalSize, f32 in_preferredAspectRatio)\n        {\n            f32 originalRatio = in_originalSize.x / in_originalSize.y;\n            \n            if(in_preferredAspectRatio > originalRatio)\n            {\n                return KeepOriginalWidthAdaptHeight(in_originalSize, in_preferredAspectRatio);\n            }\n            else\n            {\n                return KeepOriginalHeightAdaptWidth(in_originalSize, in_preferredAspectRatio);\n            }\n        }\n",
        "answer": "/** @brief Fit the original size while maintaining aspect ratio.\n*\n*  This function fits the original size while maintaining the given target aspect ratio,\n*  ensuring that the resulting size does not exceed the original size.\n*\n* @param in_originalSize The original size to be fitted.\n* @param in_preferredAspectRatio The target aspect ratio to be maintained.\n* @return The fitted size while maintaining the given aspect ratio.\n*/\nVector2 FitOriginal(const Vector2& in_originalSize, f32 in_preferredAspectRatio)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\t\tstd::string CreateSTDStringFromJString(jstring in_jString)\n\t\t\t{\n\t\t\t    if (in_jString == nullptr)\n\t\t\t    {\n\t\t\t        return \"\";\n\t\t\t    }\n\n\t\t\t\tauto environment = JavaVirtualMachine::Get()->GetJNIEnvironment();\n                const char * cString = environment->GetStringUTFChars(in_jString, JNI_FALSE);\n                CS_ASSERT(cString != nullptr, \"String returned from GetStringUTFChars() cannot be null.\");\n\n                std::string output = std::string(cString);\n                environment->ReleaseStringUTFChars(in_jString, cString);\n\n                return output;\n\t\t\t}\n",
        "answer": "/** @brief Converts a Java string to a std::string.\n*\n*  This function takes a Java string and converts it to a std::string. If a null string is passed in, an empty string will be returned.\n*\n* @param [in] in_jString The Java string to convert.\n* @return The converted std::string.\n*/\nstd::string CreateSTDStringFromJString(jstring in_jString)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\t\tBOOL WindowsFindNextFile(HANDLE in_previousFile, LPWIN32_FIND_DATA in_findFileData)\n\t\t\t{\n\t\t\t\treturn FindNextFile(in_previousFile, in_findFileData);\n\t\t\t}\n",
        "answer": "/** @brief Continues a file search started using FileFirstFile. The directory can contain wildcard characters (* or ?).\n*\n*  This function continues a file search started using FileFirstFile. The directory can contain wildcard characters (* or ?).\n*\n* @param in_previousFile A handle to the previous file found by FileFirstFile.\n* @param in_findFileData A pointer to a WIN32_FIND_DATA structure that receives information about the found file.\n*\n* @return TRUE if the function succeeds, FALSE otherwise.\n*/\nBOOL WindowsFindNextFile(HANDLE in_previousFile, LPWIN32_FIND_DATA in_findFileData)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Java_com_chilliworks_chillisource_social_EmailComposerNativeInterface_OnEmailClosed(JNIEnv* inpEnv, jobject inpThis, s32 indwResultCode)\n{\n\tCSBackend::Android::EmailComposerJavaInterfaceSPtr pJavaInterface = CSBackend::Android::JavaInterfaceManager::GetSingletonPtr()->GetJavaInterface<CSBackend::Android::EmailComposerJavaInterface>();\n\tif (pJavaInterface != nullptr)\n\t{\n\t\tpJavaInterface->OnEmailClosed(indwResultCode);\n\t}\n}\n",
        "answer": "/** @brief Java_com_chilliworks_chillisource_social_EmailComposerNativeInterface_OnEmailClosed.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param inpEnv The JNI environment.\n* @param inpThis The Java object.\n* @param indwResultCode The result code.\n* @return Should not return\n*/\nvoid Java_com_chilliworks_chillisource_social_EmailComposerNativeInterface_OnEmailClosed(JNIEnv* inpEnv, jobject inpThis, s32 indwResultCode)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ITT_DoUnsafeOneTimeInitialization () {\n    if ( !ITT_InitializationDone ) {\n        ITT_Present = (__TBB_load_ittnotify()!=0);\n        ITT_InitializationDone = true;\n        ITT_SYNC_CREATE(&market::theMarketMutex, SyncType_GlobalLock, SyncObj_SchedulerInitialization);\n    }\n}\n",
        "answer": "/**\n* @brief Thread-unsafe lazy one-time initialization of tools interop. Used by both dummy handlers and general TBB one-time initialization routine.\n*\n* This function initializes the tools interop lazily, meaning that it only performs the initialization once, even if called multiple times. It is not thread-safe, meaning that it should only be called from a single thread.\n*\n* @return void\n*/\nvoid ITT_DoUnsafeOneTimeInitialization() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ErrorCode GetNextAvailRes(DocID* p_doc_id, unsigned int* p_num_res, QueryID** p_query_ids)\n{\n\tif (pool_count != 0){\n\t\tAllJobDone();\n\t\tpool_count = 0;\n\t}\n\n\t*p_doc_id=0; \n\t*p_num_res=0; \n\t*p_query_ids=0;\n\tif(docs.size()==0) \n\t\treturn EC_NO_AVAIL_RES;\n\t\n\tpthread_mutex_lock(&mut_document);\n\t*p_doc_id=docs[0].doc_id; \n\t*p_num_res=docs[0].num_res; \n\t*p_query_ids=docs[0].query_ids;\n\tdocs.erase(docs.begin());\n\tpthread_mutex_unlock(&mut_document);\n\t\n\treturn EC_SUCCESS;\n}\n",
        "answer": "/** @brief Get the next available active queries subset that matches any previously submitted document, sorted by query IDs.\n*\n*  This function returns the next available active queries subset that matches any previously submitted document, sorted by query IDs. The returned result must depend on the state of the active queries at the time of calling MatchDocument().\n*\n* @param p_doc_id A pointer to a DocID object where the doc ID will be stored.\n* @param p_num_res A pointer to an unsigned int where the number of results will be stored.\n* @param p_query_ids A pointer to a QueryID array where the query IDs will be stored.\n* @return EC_SUCCESS if successful, EC_NO_AVAIL_RES if no available results were found.\n*/\n*p_doc_id=0;\n*p_num_res=0;\n*p_query_ids=0;\n*p_doc_id=docs[0].doc_id;\n*p_num_res=docs[0].num_res;\n*p_query_ids=docs[0].query_ids;\ndocs.erase(docs.begin());"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "float roundf (float x)\n{\n  float res;\n  if (x >= 0.0F) { res = ceilf (x); if (res - x > 0.5F) res -= 1.0F; }\n  else { res = ceilf (-x); if (res + x > 0.5F) res -= 1.0F; res = -res; }\n  return res;\n}\n",
        "answer": "/** @brief Round a float to the nearest integer.\n*\n* This function rounds a float to the nearest integer.\n*\n* @param x The float value to round.\n*\n* @return The rounded integer value.\n*/\nfloat roundf (float x)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main() {\n    auto host = std::make_shared<oarp>();\n    auto phone = host\n            ->addTarget(\"192.168.1.183\")\n            ->spoofAs(\"192.168.1.1\")\n            ->disguiseAsHost()\n            ->resume();\n    auto router = host\n            ->addTarget(\"192.168.1.1\")\n            ->spoofAs(\"192.168.1.183\")\n            ->disguiseAsHost()\n            ->resume();\n\n    fprintf(stdout, \"[*] Starting...\\n\");\n\n    host->start();\n\n    sleep(5);\n\n    fprintf(stdout, \"[*] Restoring...\\n\");\n\n    phone->restore();\n    router->restore();\n\n    sleep(3);\n\n    fprintf(stdout, \"[*] Cleaning...\\n\");\n\n    host->destory();\n\n    return 0;\n}\n",
        "answer": "/**\n* @brief Main entrypoint of the program.\n*\n* This function is the main entrypoint of the program, and it is responsible for setting up and running the ARP spoofing attack.\n* It creates a shared pointer to an instance of the `oarp` class, which represents the host machine that will be performing the attack.\n* It then adds two targets to the host: \"192.168.1.183\" and \"192.168.1.1\", which are the IP addresses of the phone and router, respectively.\n* The `spoofAs` method is used to set the IP address that the host will use to communicate with each target.\n* The `disguiseAsHost` method is used to make the host appear as a legitimate host on the network.\n* Finally, the `resume` method is called to start the attack.\n* The program then sleeps for 5 seconds before restoring the targets and cleaning up the host.\n*\n* @return Should not return\n*/\nint main() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void rn_register_bridge_cb(rn_bridge_cb _cb) {\n    embedder_callback=_cb;\n}\n",
        "answer": "/** @brief Register the callback that receives messages sent from Node.\n*\n*  This function is called by the React Native plug-in to register the callback that receives the messages sent from Node.\n*\n* @param _cb The callback that receives the messages sent from Node.\n*/\nvoid rn_register_bridge_cb(rn_bridge_cb _cb) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  QString toString(char charToConvert) {\n    QString result;\n    result += QChar(charToConvert);\n    return result;\n  }\n",
        "answer": "/** @brief Convert a character to a string.\n*\n*  This function takes in a single ASCII character and returns a string with length 1 that contains only the given character.\n*\n* @param charToConvert The ASCII character to convert to a string.\n* @return A string with length 1 containing only the given character.\n*/\nQString toString(char charToConvert) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void EndLine(std::ofstream &os) {\n  os << \"</gml:coordinates>\" << \"</gml:LineString>\" << \"</ogr:geometryProperty>\" << endl;\n  os << \"  </ogr:mapLine>\" << endl;\n  os << \"</gml:featureMember>\" << endl;\n}\n",
        "answer": "/** @brief Ends a line in GML.\n*\n* This function ends a line in GML by writing the necessary closing tags to the output stream.\n* It should be called after each line has the necessary points added using AddPointToLine.\n*\n* @param os The output stream to write to.\n*/\nvoid EndLine(std::ofstream &os) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ignoreMeasure(ControlNet &cnet, ControlPoint *point,\n                   ControlMeasure *measure, QString cause) {\n  ControlMeasure::Status result = measure->SetIgnored(true);\n\n  logResult(\n      result == ControlMeasure::Success ? ignoredMeasures : editLockedMeasures,\n      point->GetId(), measure->GetCubeSerialNumber(), cause);\n\n  if (ignoreAll && measure->Parent()->GetRefMeasure() == measure) {\n    foreach (ControlMeasure *cm, measure->Parent()->getMeasures()) {\n      if (!cm->IsIgnored())\n        ignoreMeasure(cnet, measure->Parent(), cm, \"Reference ignored\");\n    }\n  }\n}\n",
        "answer": "/** @brief Ignore a control measure.\n*\n* This function ignores a control measure and adds it to the list of ignored measures if the user wished to keep a log.\n*\n* @param cnet The control net containing the point and measure to be ignored.\n* @param point The control point associated with the measure to be ignored.\n* @param measure The control measure to be ignored.\n* @param cause The reason for ignoring the measure.\n* @return void\n*/\nvoid ignoreMeasure(ControlNet &cnet, ControlPoint *point,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double et2line(double et, double lineRate, double originalStartEt) {\n  return (et - originalStartEt) / lineRate + 0.5;\n}\n",
        "answer": "/** @brief Returns the corresponding line number for the given ephemeris time. Note that this return value is not an integer line, number, it is the exact double line value associated with this time.\n*\n*  This function returns the corresponding line number for a given ephemeris time. The line number is calculated by taking the difference between the given et and originalStartEt and dividing it by the lineRate. The result is then added to 0.5 to ensure that the returned value is always rounded up to the nearest integer.\n*\n* @param et The ephemeris time for which the corresponding line number is desired.\n* @param lineRate The rate at which lines are being generated, in lines per second.\n* @param originalStartEt The starting ephemeris time from which the line count should begin.\n* @return The corresponding line number for the given ephemeris time.\n*/\ndouble et2line(double et, double lineRate, double originalStartEt) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hal_send_sysex(uint8_t port, const uint8_t* data, uint16_t length)\n{\n    VirtualLpp::getInstance()->sendSysex(port, data, length);\n}\n",
        "answer": "/** @brief Send system exclusive to USB or DIN.\n*\n*  This function sends a system exclusive message to the specified port. The message must be correctly formatted (F0 ... F7) and must not exceed 320 bytes.\n*\n* @param port The port to send the message to. Must be either USB or DIN.\n* @param data A pointer to the message data.\n* @param length The length of the message in bytes.\n*/\nvoid hal_send_sysex(uint8_t port, const uint8_t* data, uint16_t length)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int ofc_proc_sgml(LibofxContext * libofx_context, int argc, char * const* argv)\n{\n  message_out(DEBUG, \"Begin ofx_proc_sgml()\");\n  assert(argc >= 3);\n  message_out(DEBUG, argv[0]);\n  message_out(DEBUG, argv[1]);\n  message_out(DEBUG, argv[2]);\n\n  ParserEventGeneratorKit parserKit;\n  parserKit.setOption (ParserEventGeneratorKit::showOpenEntities);\n  EventGenerator *egp =\tparserKit.makeEventGenerator (argc, argv);\n  egp->inhibitMessages (true);\t/* Error output is handled by libofx not OpenSP */\n  OFCApplication *app = new OFCApplication(libofx_context);\n  unsigned nErrors = egp->run (*app); /* Begin parsing */\n  delete egp;\n  return nErrors > 0;\n}\n",
        "answer": "/** @brief Processes SGML files using LibOFX.\n*\n* This function takes a list of files in command line format, where the first file must be the DTD and then any number of OFX files. It uses the LibOFX library to parse the SGML files and generate events based on their contents. The function returns the number of errors encountered during parsing.\n*\n* @param libofx_context A pointer to a LibOFX context object, which provides access to the necessary resources for parsing the SGML files.\n* @param argc The number of files in the list.\n* @param argv An array of strings containing the file names.\n* @return The number of errors encountered during parsing.\n*/\nint ofc_proc_sgml(LibofxContext * libofx_context, int argc, char * const* argv)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void splinter_bspline_insert_knots(splinter_obj_ptr bspline_ptr, double tau, unsigned int dim, unsigned int multiplicity)\n{\n    auto bspline = get_bspline(bspline_ptr);\n    if (bspline != nullptr)\n    {\n        try\n        {\n            bspline->insertKnots(tau, dim, multiplicity);\n        }\n        catch (const Exception &e)\n        {\n            set_error_string(e.what());\n        }\n    }\n}\n",
        "answer": "/** @brief Inserts knots at tau of multiplicity 'multiplicity' to knot vector in variable 'dim'. The B-spline is geometrically unaltered by the knot insertion.\n*\n*  This function inserts knots at a specified parameter value (tau) into the knot vector of a B-spline curve or surface, while maintaining the geometric continuity and shape of the curve or surface. The multiplicity of the inserted knots is specified by the 'multiplicity' parameter.\n*\n* @param bspline_ptr A pointer to the splinter object that contains the B-spline curve or surface.\n* @param tau The parameter value at which the knots are inserted.\n* @param dim The dimension of the knot vector in which the knots are inserted.\n* @param multiplicity The multiplicity of the inserted knots.\n*/\nvoid splinter_bspline_insert_knots(splinter_obj_ptr bspline_ptr, double tau, unsigned int dim, unsigned int multiplicity)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\r\nNAMESPACE_BEGIN(CryptoPP)\r\n\r\nstatic void MulU(byte *k, unsigned int length)\r\n{\r\n\tbyte carry = 0;\r\n\r\n\tfor (int i=length-1; i>=1; i-=2)\r\n",
        "answer": "/** @brief Wake stream cipher information. Vector of 8-bit elements. Hash size in bytes. The subkey type is usually word32 or word64. F2 and F6 must use the same word type. AdvancedProcessBlocks for 2 and 6 blocks. AdvancedProcessBlocks for 2 and 6 blocks. The subkey type is usually word32 or word64. F1 and F2 must use the same word type. The subkey type is usually word32 or word64. F2 and F6 must use the same word type. AdvancedProcessBlocks for 2 and 6 blocks.\n*/\nvoid MulU(byte *k, unsigned int length)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\n\r\n#if !defined(NDEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\r\nvoid TestInstantiations_gfpcrypt()\r\n{\r\n\tGDSA<SHA>::Signer test;\r\n\tGDSA<SHA>::Verifier test1;\r\n\tDSA::Signer test5(NullRNG(), 100);\r\n\tDSA::Signer test2(test5);\r\n\tNR<SHA>::Signer test3;\r\n\tNR<SHA>::Verifier test4;\r\n\tDLIES<>::Encryptor test6;\r\n\tDLIES<>::Decryptor test7;\r\n}\r\n",
        "answer": "/** @brief Test instantiations for the gfpcrypt namespace.\n*\n*  This function tests various instantiations of classes in the gfpcrypt namespace.\n*\n* @return None\n*/\nvoid TestInstantiations_gfpcrypt()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\n\r\nstatic word64 SHARKTransform(word64 a)\r\n{\r\n\tstatic const byte iG[8][8] = {\r\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \r\n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \r\n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \r\n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \r\n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \r\n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \r\n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \r\n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \r\n\t};\r\n\r\n\tword64 result=0;\r\n\tGF256 gf256(0xf5);\r\n\tfor (unsigned int i=0; i<8; i++)\r\n\t\tfor(unsigned int j=0; j<8; j++) \r\n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\r\n\treturn result;\r\n}\r\n",
        "answer": "/** @brief SHARK transformation.\n*\n*  This function performs the SHARK transformation on a 64-bit word.\n*\n* @param[in] a The input word to transform.\n* @return The transformed output word.\n*/\nstatic word64 SHARKTransform(word64 a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void print2u(print_t* pr, uint8_t v) {\n  char c0 = '?';\n  char c1 = '?';\n  if (v < 100) {\n    c1 = v/10;\n    c0 = v - 10*c1 + '0';\n    c1 += '0';\n  }\n  pr->write(c1);\n  pr->write(c0);\n}\n",
        "answer": "/**\n* @brief Prints a two-digit unsigned integer to the specified print object.\n*\n* This function takes a pointer to a print object and an unsigned integer as input, and prints the integer in decimal format with leading zeros if necessary. The function returns nothing.\n*\n* @param pr A pointer to the print object where the output will be written.\n* @param v The unsigned integer to be printed.\n*/\nstatic void print2u(print_t* pr, uint8_t v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class BackendLibrary{\nprivate:\n    std::map<backend_families, shared_ptr<AbstractStateGenerator> > backends;\npublic:\n    void add_backend(const backend_families &bg, const shared_ptr<AbstractStateGenerator> &asg){\n        backends[bg] = asg;\n    };\n    void get_generator_iterators(const backend_families &bg,\n                                 std::map<backend_families,shared_ptr<AbstractStateGenerator> >::const_iterator &generator,\n                                 std::map<backend_families,shared_ptr<AbstractStateGenerator> >::const_iterator &end){\n        generator = backends.find(bg);\n        end = backends.end();\n    };\n    std::size_t size(){ return backends.size(); };\n};\n",
        "answer": "/** @brief BackendLibrary class.\n*\n*  This class holds pointers to generators for the backends and can be used to look up generators at runtime.\n*  It should be populated through the use of static initialized.\n*\n*/\n/** @brief Adds a backend to the library.\n*\n*  This function adds a backend to the library.\n*\n* @param bg The backend family to add.\n* @param asg A shared pointer to the abstract state generator for the backend.\n*/\n/** @brief Gets an iterator to the generators for a given backend family.\n*\n*  This function gets an iterator to the generators for a given backend family.\n*\n* @param bg The backend family to get the iterators for.\n* @param generator An output parameter that will be set to an iterator pointing to the first generator in the sequence.\n* @param end An output parameter that will be set to an iterator pointing to the end of the sequence.\n*/\n/** @brief Gets the number of backends in the library.\n*\n*  This function gets the number of backends in the library.\n*\n* @return The number of backends in the library.\n*/\nstd::size_t size()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double TwoPhaseMedium_specificHeatCapacityCp_C_impl(ExternalThermodynamicState *state,\n\t\t\t\t\t\t\t\t\t\t\t  const char *mediumName, const char *libraryName, const char *substanceName){\n\tBaseSolver *solver = SolverMap::getSolver(mediumName, libraryName, substanceName);\n    return solver->cp(state);\n}\n",
        "answer": "/** @brief Calculates the specific heat capacity at constant pressure of a two-phase medium.\n*\n*  This function calculates the specific heat capacity at constant pressure of a two-phase medium, given its external thermodynamic state and the name of the medium, library, and substance.\n*\n* @param[in] state The external thermodynamic state of the medium.\n* @param[in] mediumName The name of the medium.\n* @param[in] libraryName The name of the library that contains the medium model.\n* @param[in] substanceName The name of the substance in the medium.\n* @return The specific heat capacity at constant pressure of the two-phase medium.\n*/\ndouble TwoPhaseMedium_specificHeapCapacityCp_C_impl(ExternalThermodynamicState *state, const char *mediumName, const char *libraryName, const char *substanceName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double TwoPhaseMedium_dynamicViscosity_C_impl(ExternalThermodynamicState *state,\n\t\t\t\t\t\t\t\t\t\tconst char *mediumName, const char *libraryName, const char *substanceName){\n\tBaseSolver *solver = SolverMap::getSolver(mediumName, libraryName, substanceName);\n    return solver->eta(state);\n}\n",
        "answer": "/** @brief Calculates the dynamic viscosity of a two-phase medium.\n*\n*  This function calculates the dynamic viscosity of a two-phase medium, given an external thermodynamic state and the name of the medium, library, and substance. It uses the solver map to retrieve the appropriate solver for the medium and then calls the eta() method on the solver to calculate the dynamic viscosity.\n*\n* @param[in] state The external thermodynamic state for which the dynamic viscosity is calculated.\n* @param[in] mediumName The name of the medium for which the dynamic viscosity is calculated.\n* @param[in] libraryName The name of the library containing the solver for the medium.\n* @param[in] substanceName The name of the substance for which the dynamic viscosity is calculated.\n* @return The dynamic viscosity of the two-phase medium at the given state and with the given name, library, and substance.\n*/\ndouble TwoPhaseMedium_dynamicViscosity_C_impl(ExternalThermodynamicState *state, const char *mediumName, const char *libraryName, const char *substanceName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double TwoPhaseMedium_specificEntropy_C_impl(ExternalThermodynamicState *state,\n\t\t\t\t\t\t\t\t\t   const char *mediumName, const char *libraryName, const char *substanceName){\n\tBaseSolver *solver = SolverMap::getSolver(mediumName, libraryName, substanceName);\n    return solver->s(state);\n}\n",
        "answer": "/** @brief Calculates the specific entropy of a two-phase medium.\n*\n*  This function calculates the specific entropy of a two-phase medium, given an external thermodynamic state and the name of the medium, library, and substance. It uses a solver to perform the calculation.\n*\n* @param[in] state The external thermodynamic state for which the specific entropy is calculated.\n* @param[in] mediumName The name of the medium.\n* @param[in] libraryName The name of the library.\n* @param[in] substanceName The name of the substance.\n* @return The specific entropy of the two-phase medium at the given state.\n*/\ndouble TwoPhaseMedium_specificEntropy_C_impl(ExternalThermodynamicState *state, const char *mediumName, const char *libraryName, const char *substanceName) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double TwoPhaseMedium_dDewDensity_dPressure_C_impl(ExternalSaturationProperties *sat,\n\t\t\t\t\t\t\t\t\t\t\t const char *mediumName, const char *libraryName, const char *substanceName){\n\tBaseSolver *solver = SolverMap::getSolver(mediumName, libraryName, substanceName);\n    return solver->ddvdp(sat);\n}\n",
        "answer": "/** @brief Calculates the partial derivative of dew density with respect to pressure at constant composition.\n*\n*  This function calculates the partial derivative of dew density with respect to pressure at constant composition for a given medium, using an external solver.\n*\n* @param sat ExternalSaturationProperties object that contains the saturation properties of the medium\n* @param mediumName Name of the medium\n* @param libraryName Name of the library that contains the solver\n* @param substanceName Name of the substance\n* @return Partial derivative of dew density with respect to pressure at constant composition\n*/\ndouble TwoPhaseMedium_dDewDensity_dPressure_C_impl(ExternalSaturationProperties *sat, const char *mediumName, const char *libraryName, const char *substanceName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double TwoPhaseMedium_dewEnthalpy_C_impl(ExternalSaturationProperties *sat,\n\t\t\t\t\t\t\t\t   const char *mediumName, const char *libraryName, const char *substanceName){\n\tBaseSolver *solver = SolverMap::getSolver(mediumName, libraryName, substanceName);\n    return solver->hv(sat);\n}\n",
        "answer": "/** @brief Calculates the dew enthalpy of a two-phase medium.\n*\n*  This function calculates the dew enthalpy of a two-phase medium using an external solver. The solver is obtained from the SolverMap and the dew enthalpy is calculated by calling the hv() method on the solver.\n*\n* @param sat ExternalSaturationProperties object containing saturation properties for the medium.\n* @param mediumName Name of the medium.\n* @param libraryName Name of the library containing the solver.\n* @param substanceName Name of the substance in the medium.\n* @return The dew enthalpy of the two-phase medium.\n*/\ndouble TwoPhaseMedium_dewEnthalpy_C_impl(ExternalSaturationProperties *sat, const char *mediumName, const char *libraryName, const char *substanceName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::size_t strcmp(const std::string &s, const std::string &e){\n    return s.compare(e);\n}\n",
        "answer": "/** @brief Overload of the strcmp function for comparing two strings.\n*\n*  This is a stub overload to help with all the strcmp calls below and avoid needing to rewrite all of them.\n*\n* @param s The first string to compare.\n* @param e The second string to compare.\n* @return The result of comparing the two strings.\n*/\nstd::size_t strcmp(const std::string &s, const std::string &e)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void exceptionDispatcherError(const char *s, ...) {\n\tchar buf[STRINGBUFLEN];\n\tva_list va;\n\n\tva_start(va, s);\n\tvsnprintf(buf, STRINGBUFLEN, s, va);\n\tva_end(va);\n\n\texceptionDispatcher(\"ERROR: \", buf);\n}\n",
        "answer": "/** @brief Exception dispatcher that prints the exception as an error, and adds another reason on top. This is intended for fatal errors.\n*\n* @param s The string to print as an error message.\n* @param ... A variable number of arguments to be used with the string.\n*\n* @return Should not return.\n*/\nvoid exceptionDispatcherError(const char *s, ...) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32 convertIEEEFloat(float value) {\n\tfloatConvert conv;\n\n\tconv.dFloat = value;\n\n\treturn conv.dInt;\n}\n",
        "answer": "/** @brief Convert a native float into a uint32 holding the bit pattern of a 32-bit IEEE 754 single precision floating point value.\n*\n*  This function converts a native float into a uint32, which holds the bit pattern of a 32-bit IEEE 754 single precision floating point value.\n*  NOTE: Currently, this function assumes native floats are 32-bit IEEE 754 single precision floating point values!\n*\n* @param[in] value The float value to be converted.\n* @return A uint32 holding the bit pattern of the input float value.\n*/\nuint32 convertIEEEFloat(float value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "TEST_CLASS(TestTemplate) {\nprivate:\n    bool val = false;\npublic:\n    /**\n    * Optional. Executed before every test case\n    */\n    SET_UP() {\n        val = true;\n    }\n\n    /**\n    * Optional. Executed after every test case\n    */\n    TEAR_DOWN() {\n        val = false;\n    }\n\n    void testSimpleAssert() {\n        CPPUNIT_ASSERT(val);\n    }\npublic:\n    /**\n    * Test suit declaration and test case registration\n    */\n    CPPUNIT_TEST_SUITE(TestTemplate);\n    CPPUNIT_TEST(testSimpleAssert);\n    CPPUNIT_TEST_SUITE_END();\n};\n",
        "answer": "/**\n* @brief Kernel entrypoint.\n*\n* This is the entrypoint for your kernel.\n* You will use this to test and debug your\n* drivers and it will eventually hold the\n* code for your game.  Right now, it is\n* A tight while loop.\n*\n* @return Should not return\n*/\nvoid kernel_entrypoint() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "BooleanResult takeBoolean(const QString &parameter, VmtFile *vmt,\n\t\tUi::MainWindow *ui)\n{\n\tBooleanResult result;\n\tconst QString raw = vmt->parameters.take(parameter);\n\tif (raw.isEmpty())\n\t\treturn result;\n\n\tresult.present = true;\n\tif (raw != \"0\" && raw != \"1\") {\n\t\tERROR(parameter + \" has an invalid value: \" + raw)\n\t\treturn result;\n\t}\n\tif (raw == \"1\") {\n\t\tresult.value = true;\n\t} else {\n\t\tINFO(parameter + \" has default value: 0\")\n\t}\n\treturn result;\n}\n",
        "answer": "/**\n* @brief Takes a boolean parameter and parses it as a boolean with values 0 or 1.\n*\n* This function takes a QString parameter and parses it as a boolean value, with\n* values 0 or 1. If the parameter is not present in the VMT file, the default value\n* of false (0) is returned. If the parameter is present but has an invalid value,\n* an error message is logged and the function returns a BooleanResult object with\n* the present flag set to true and the value flag set to false.\n*\n* @param parameter The name of the parameter to take.\n* @param vmt A pointer to the VMT file containing the parameters.\n* @param ui A pointer to the UI object for logging errors.\n* @return A BooleanResult object with the parsed boolean value and a flag indicating\n* whether the parameter was present in the VMT file.\n*/\nBooleanResult takeBoolean(const QString &parameter, VmtFile *vmt, Ui::MainWindow *ui) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string csvescape(std::string value) {\n\tsize_t pos = 0;\n\twhile ((pos = value.find_first_of(\"\\\\\\n\\r,\", pos)) != value.npos) {\n\t\tvalue.insert(pos, 1, '\\\\');\n\t\tpos += 2;\n\t}\n\treturn value;\n}\n",
        "answer": "/** @brief Escape characters that are special in csv files.\n*\n*  The parameters is passed by value because it is going to be modified.\n*\n* @param[in,out] value The string to escape.\n* @return The escaped string.\n*/\nstd::string csvescape(std::string value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clear_header(FILE * file) { \n  char buff[4];\n  fread(buff,sizeof(char),4,file);\n}\n",
        "answer": "/** @brief Clears the header of a Fortran write statement.\n*\n* This function clears the 4-byte header that Fortran puts in front and back of every write statement.\n* It is used to clear the header since we know when the writes come from the excellent abinit documentation.\n*\n* @param file The file to clear the header for.\n* @return void\n*/\nvoid clear_header(FILE * file) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void set(size_t /*num_elems*/)\n    {\n        throw Poco::Exception(__PRETTY_FUNCTION__);\n    }\n",
        "answer": "/** @brief Set the buffer size by the number of elements in the hash table. Used when deserializing a hash table.\n*\n*  This function sets the buffer size for the hash table based on the number of elements in the table. It is used during deserialization to ensure that the buffer has enough space to hold all the elements in the table.\n*\n* @param num_elems The number of elements in the hash table.\n*/\nvoid set(size_t num_elems)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static constexpr UInt32 intLog(const UInt32 value, const UInt32 base, const bool carry)\n{\n    return value >= base ? 1 + intLog(value / base, base, value % base || carry) : value % base > 1 || carry;\n}\n",
        "answer": "/** @brief Calculates the integer logarithm of a given value with a specified base.\n*\n* This function calculates the smallest integer greater than or equal to the logarithm of the input value with the specified base.\n* The function takes three parameters: the value, the base, and a boolean flag indicating whether to carry the result.\n* If the carry flag is set to true, the function will return 1 plus the integer logarithm of the value divided by the base,\n* otherwise it will simply return the integer logarithm of the value divided by the base.\n*\n* @param value The input value for which the integer logarithm is calculated.\n* @param base The base used in the calculation of the integer logarithm.\n* @param carry A boolean flag indicating whether to carry the result.\n* @return The smallest integer greater than or equal to the logarithm of the input value with the specified base.\n*/\nstatic constexpr UInt32 intLog(const UInt32 value, const UInt32 base, const bool carry)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void safeDeserialize(\n    IColumn & column,\n    CheckForNull && check_for_null, DeserializeNested && deserialize_nested)\n{\n    ColumnNullable & col = static_cast<ColumnNullable &>(column);\n\n    if (check_for_null())\n    {\n        col.insertDefault();\n    }\n    else\n    {\n        deserialize_nested(col.getNestedColumn());\n\n        try\n        {\n            col.getNullMapData().push_back(0);\n        }\n        catch (...)\n        {\n            col.getNestedColumn().popBack(1);\n            throw;\n        }\n    }\n}\n",
        "answer": "/** @brief Safely deserializes a column, inserting both to nested column and null byte map, or not inserting at all.\n*\n*  This function takes an IColumn reference and two lambdas as parameters. The first lambda checks for null values, while the second lambda deserializes the nested column. If an exception is thrown during deserialization, the function ensures that neither the nested column nor the null byte map are modified.\n*\n* @param column The IColumn to be deserialized.\n* @param check_for_null A lambda that checks for null values in the column.\n* @param deserialize_nested A lambda that deserializes the nested column.\n* @return Void.\n*/\nvoid safeDeserialize(IColumn &column, CheckForNull &&check_for_null, DeserializeNested &&deserialize_nested) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void parseDateTimeBestEffort(time_t & res, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone)\n{\n    parseDateTimeBestEffortImpl<void>(res, in, local_time_zone, utc_time_zone);\n}\n",
        "answer": "/**\n* @brief Parses a date and time string using best effort.\n*\n* This function parses a date and time string in various formats, including:\n* - NNNNNNNNNN (9..10 digits is a unix timestamp)\n* - YYYYMMDDhhmmss (14 numbers is always interpreted this way)\n* - YYYY*MM*DD (8 digits in a row, with any delimiter after first 4-digit year component and after month)\n* - DD/MM/YY (or with any delimiter after day and month)\n* - DD/MM/YYYY (when '/' separator is used, these are the only possible forms)\n* - hh:mm:ss (when ':' separator is used, it is always time)\n* - hh:mm (it can be specified without seconds)\n* - YYYY (4 digits is always year)\n* - YYYYMM (6 digits is a year, month if year was not already read)\n* - hhmmss (6 digits is a time if year was already read)\n* - .nnnnnnn (any number of digits after point is fractional part of second, if it is not YYYY.MM.DD or DD.MM.YYYY)\n* - T (means that time will follow)\n* - Z (means zero UTC offset)\n* - +hhmm (+hh:mm +hh -... - time zone offset single whitespace can be used as a separator)\n* - AM/PM (AM is ignored and PM means: add 12 hours if value is less than 12)\n* - Jan/Feb/Mar/Apr/May/Jun/Jul/Aug/Sep/Oct/Nov/Dec (allowed to specify month)\n* - Mon/Tue/Wed/Thu/Fri/Sat/Sun (simply ignored).\n*\n* @param res The result of the parsing, as a time_t value.\n* @param in The input string to parse.\n* @param local_time_zone The local time zone.\n* @param utc_time_zone The UTC time zone.\n*/\nvoid parseDateTimeBestEffort(time_t & res, ReadBuffer & in, const DateLUTImpl & local_time_zone, const DateLUTImpl & utc_time_zone)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isOldPartDirectory(Poco::File & directory, time_t threshold)\n{\n    if (directory.getLastModified().epochTime() >= threshold)\n        return false;\n\n    Poco::DirectoryIterator end;\n    for (Poco::DirectoryIterator it(directory); it != end; ++it)\n        if (it->getLastModified().epochTime() >= threshold)\n            return false;\n\n    return true;\n}\n",
        "answer": "/** @brief Checks whether a part directory is old.\n*\n*  This function checks if the modification time of a given directory and all files inside it are less than a given threshold. Only files on the first level of nesting are considered.\n*\n* @param[in] directory The directory to check.\n* @param[in] threshold The threshold value for the last modified time.\n* @return True if the directory is old, false otherwise.\n*/\nstatic bool isOldPartDirectory(Poco::File & directory, time_t threshold)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void call_default_signal_handler(int sig)\n{\n    signal(sig, SIG_DFL);\n    raise(sig);\n}\n",
        "answer": "/** @brief Reset signal handler to the default and send signal to itself.\n*\n*  This function is called from user signal handler to write core dump.\n*  It resets the signal handler to the default and sends the signal to itself.\n*\n* @param sig The signal number.\n* @return Should not return.\n*/\nstatic void call_default_signal_handler(int sig)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setThreadName(const char * name)\n{\n#ifndef NDEBUG\n    if (strlen(name) > 15)\n        throw DB::Exception(\"Thread name cannot be longer than 15 bytes\", DB::ErrorCodes::PTHREAD_ERROR);\n#endif\n\n#if defined(__FreeBSD__)\n    pthread_set_name_np(pthread_self(), name);\n    return;\n\n#elif defined(__APPLE__)\n    if (0 != pthread_setname_np(name))\n#else\n    if (0 != prctl(PR_SET_NAME, name, 0, 0, 0))\n#endif\n        DB::throwFromErrno(\"Cannot set thread name with prctl(PR_SET_NAME, ...)\", DB::ErrorCodes::PTHREAD_ERROR);\n}\n",
        "answer": "/**\n* @brief Sets the thread name (maximum length is 15 bytes), which will be visible in ps, gdb, /proc, for convenience of observation and debugging.\n*\n* @param name The name to set for the current thread.\n*\n* @return Should not return.\n*/\nvoid setThreadName(const char *name) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)\n{\n    arith_uint256 r;\n    int sign = 1;\n    if (to.nChainWork > from.nChainWork) {\n        r = to.nChainWork - from.nChainWork;\n    } else {\n        r = from.nChainWork - to.nChainWork;\n        sign = -1;\n    }\n    r = r * arith_uint256(params.nTargetSpacing) / GetBlockProof(tip);\n    if (r.bits() > 63) {\n        return sign * std::numeric_limits<int64_t>::max();\n    }\n    return sign * r.GetLow64();\n}\n",
        "answer": "/** @brief Get the block proof equivalent time.\n*\n*  This function returns the time it would take to redo the work difference between two blocks, assuming the current hashrate corresponds to the difficulty at a third block, in seconds.\n*\n* @param[in] to The block index of the first block.\n* @param[in] from The block index of the second block.\n* @param[in] tip The block index of the third block.\n* @param[in] params The consensus parameters.\n* @return The time it would take to redo the work difference between the two blocks, in seconds.\n*/\nint64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "PLUGIN_EXPORT void PLUGIN_CALL ProcessTick() {\n    sampgdk::ProcessTick();\n    if (svr) {\n        svr->tick();\n    }\n}\n",
        "answer": "/** @brief Processes a server tick.\n*\n*  This function is called on every server tick, and it processes the tick by calling the sampgdk::ProcessTick() function and then checking if the server is running and if so, it calls the tick() function of the server.\n*\n* @return Should not return\n*/\nvoid PLUGIN_EXPORT void PLUGIN_CALL ProcessTick() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual void setShapeIdentifiersA(int partId0, int index0)\n\t\t{\n\t\t}\n",
        "answer": "/** @brief Sets the shape identifiers for material A.\n*\n*  This function sets the shape identifiers for material A, which is used to identify\n*  the triangles in the mesh that are associated with a particular material. The partId0\n*  parameter specifies the ID of the part that contains the triangle, and the index0\n*  parameter specifies the index of the triangle within the part.\n*\n* @param partId0 The ID of the part that contains the triangle.\n* @param index0 The index of the triangle within the part.\n*/\nvirtual void setShapeIdentifiersA(int partId0, int index0)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline btScalar\tcalculateCombinedFriction(float friction0,float friction1)\n{\n    btScalar friction = friction0 * friction1;\n\n    const btScalar MAX_FRICTION  = 10.f;\n    if (friction < -MAX_FRICTION)\n        friction = -MAX_FRICTION;\n    if (friction > MAX_FRICTION)\n        friction = MAX_FRICTION;\n    return friction;\n\n}\n",
        "answer": "/** @brief Calculates the combined friction between two objects.\n*\n*  This function takes the friction values of two objects and combines them using the following formula:\n*  friction = friction0 * friction1\n*\n*  The resulting friction value is then clamped to a maximum value of 10.f.\n*\n* @param friction0 The friction value of the first object.\n* @param friction1 The friction value of the second object.\n* @return The combined friction value between the two objects.\n*/\ninline btScalar calculateCombinedFriction(float friction0, float friction1)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void update()\n  {\n    const uint8_t *A = reinterpret_cast<const uint8_t*>(in1);\n    const uint8_t *B = reinterpret_cast<const uint8_t*>(in2);\n    uint8_t *D = reinterpret_cast<uint8_t*>(out);\n    uint32_t sizeCounter = size;\n            \n    uint32_t b;\n  \n    while (sizeCounter--)\n      {\n        for (b = 0; b < ALPHA; b++)\n          D[b] = add_lut[A[b] + ((B[b]*B[ALPHA])>>8)];\n        \n        D[ALPHA] = 255;\n        A += NBYTES;\n        B += NBYTES;\n        D += NBYTES;\n      }\n  }\n",
        "answer": "/**\n* @brief Updates the output buffer with the addition of two input buffers.\n*\n* This function takes two input buffers, A and B, and adds them together, storing the result in the output buffer D. The alpha channel of B is only added if it is not 0.\n*\n* @param[in] in1 The first input buffer.\n* @param[in] in2 The second input buffer.\n* @param[out] out The output buffer.\n* @param[in] size The number of bytes to process.\n*/\nvoid update() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void update()\n  {\n    const uint8_t *src1 = reinterpret_cast<const uint8_t*>(in1);\n    const uint8_t *src2 = reinterpret_cast<const uint8_t*>(in2);\n    uint8_t *dst = reinterpret_cast<uint8_t*>(out);\n    uint32_t sizeCounter = size;\n            \n    uint32_t b;\n    uint8_t s1, s2;\n  \n    while (sizeCounter--)\n      {\n        for (b = 0; b < ALPHA; b++)\n          {\n            s1 = src1[b];\n            s2 = src2[b];\n            dst[b] = MAX(s1,s2);\n          }\n  \n        dst[ALPHA] = MIN(src1[ALPHA], src2[ALPHA]);\n  \n        src1 += NBYTES;\n        src2 += NBYTES;\n        dst += NBYTES;\n      }\n  }\n",
        "answer": "/** @brief Update function.\n*\n*  This is the update function for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid update()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void audioProcessorParameterChangeGestureEnd (AudioProcessor*, int index)\r\n    {\r\n        ReleaseControl (index + 2);\r\n    }\r\n",
        "answer": "/** @brief Indicates that a parameter change gesture has finished. E.g. if the user is dragging a slider, this would be called when they release the mouse button.\n*\n*  @param AudioProcessor: The audio processor that triggered the event.\n*  @param index: The index of the parameter that changed.\n*/\nvoid audioProcessorParameterChangeGestureEnd(AudioProcessor*, int index)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        String getTextFromValue (double /*value*/)\r\n        {\r\n            return owner.getParameterText (index);\r\n        }\r\n",
        "answer": "/** @brief Turns the slider's current value into a text string. Subclasses can override this to customise the formatting of the text-entry box.\n*\n* This function turns the slider's current value into a text string. Subclasses can override this to customise the formatting of the text-entry box.\n* @param value The current value of the slider.\n* @return A text string representing the current value of the slider.\n*/\nString getTextFromValue (double /*value*/)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool getToolbarItemSizes (int toolbarThickness, bool /*isToolbarVertical*/,\r\n                              int& preferredSize, int& minSize, int& maxSize)\r\n    {\r\n        if (fixedSize <= 0)\r\n        {\r\n            preferredSize = toolbarThickness * 2;\r\n            minSize = 4;\r\n            maxSize = 32768;\r\n        }\r\n        else\r\n        {\r\n            maxSize = roundToInt (toolbarThickness * fixedSize);\r\n            minSize = drawBar ? maxSize : jmin (4, maxSize);\r\n            preferredSize = maxSize;\r\n\r\n            if (getEditingMode() == editableOnPalette)\r\n                preferredSize = maxSize = toolbarThickness / (drawBar ? 3 : 2);\r\n        }\r\n\r\n        return true;\r\n    }\r\n",
        "answer": "/**\n* @brief Get toolbar item sizes.\n*\n* This method must return the size criteria for this item, based on a given toolbar size and orientation. The preferredSize, minSize and maxSize values must all be set by your implementation method. If the toolbar is horizontal, these will be the width of the item; for a vertical toolbar, they refer to the item's height. The preferredSize is the size that the component would like to be, and this must be between the min and max sizes. For a fixed-size item, simply set all three variables to the same value. The isToolbarVertical parameter tells you whether the bar is oriented horizontally or vertically.\n*\n* @param toolbarThickness The thickness of the toolbar.\n* @param isToolbarVertical Whether the toolbar is vertical or not.\n* @param preferredSize The preferred size of the item.\n* @param minSize The minimum size of the item.\n* @param maxSize The maximum size of the item.\n* @return True if the sizes were set successfully, false otherwise.\n*/\nbool getToolbarItemSizes (int toolbarThickness, bool isToolbarVertical, int& preferredSize, int& minSize, int& maxSize) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ensureRegisteredTerminateHandler() {\n  static auto initializer = (gTerminateHandler = std::set_terminate(logExceptionAndAbort));\n  (void)initializer;\n}\n",
        "answer": "/** @brief Ensure that a terminate handler that logs traces is installed.\n*\n* This function ensures that a terminate handler is installed to log traces when an exception occurs.\n* It also sets the library identifier function if the stack trace should log build ids for libraries.\n*\n* @return Should not return\n*/\nvoid ensureRegisteredTerminateHandler() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HV_EXPORT void hv_setSendHook(HeavyContextInterface *c, HvSendHook_t *f) {\n  hv_assert(c != nullptr);\n  c->setSendHook(f);\n}\n",
        "answer": "/** @brief Set the send hook. The function is called whenever a message is sent to any send object. Messages returned by this function should NEVER be freed. If the message must persist, call hv_msg_copy() first.\n*\n* @param c HeavyContextInterface pointer\n* @param f HvSendHook_t pointer\n*/\nvoid hv_setSendHook(HeavyContextInterface *c, HvSendHook_t *f) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HV_EXPORT int hv_getParameterInfo(HeavyContextInterface *c, int index, HvParameterInfo *info) {\n  hv_assert(c != nullptr);\n  return c->getParameterInfo(index, info);\n}\n",
        "answer": "/** @brief Retrieves information about each parameter such as name, hash, and range. The total number of parameters is always returned.\n*\n* @param c HeavyContextInterface pointer\n* @param index Index of the parameter to retrieve information for\n* @param info Pointer to a HvParameterInfo struct where the information will be stored\n* @return Total number of parameters\n*/\nint hv_getParameterInfo(HeavyContextInterface *c, int index, HvParameterInfo *info) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HV_EXPORT void hv_setOutputMessageQueueSize(HeavyContextInterface *c, hv_uint32_t outQueueKb) {\n  hv_assert(c != nullptr);\n  c->setOutputMessageQueueSize(outQueueKb);\n}\n",
        "answer": "/** @brief Set the size of the output message queue in kilobytes.\n*\n* This function sets the size of the output message queue in kilobytes. The buffer is reset and all existing contents are lost on resize. Only the default sendhook uses the outgoing message queue. If the default sendhook is not being used, then this function is not useful.\n*\n* @param c A HeavyContextInterface pointer to the context that will have its output message queue size set.\n* @param outQueueKb The new size of the output message queue in kilobytes.\n*/\nvoid hv_setOutputMessageQueueSize(HeavyContextInterface *c, hv_uint32_t outQueueKb) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void startZED() {\n    quit = false;\n    zed_callback = std::thread(run);\n}\n",
        "answer": "/** @brief Launch ZED thread.\n*\n*  This function launches a new thread for the ZED camera, allowing for concurrent retrieval of camera motion and display in a GL window.\n*\n* @param[in] quit A boolean flag indicating whether the thread should be terminated.\n* @param[out] zed_callback The callback function to be executed by the thread.\n*\n* @return None\n*/\nvoid startZED() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void createXYZChannels( Channel* &X, Channel* &Y, Channel* &Z )\n  {\n    X = createChannel(\"X\");\n    Y = createChannel(\"Y\");\n    Z = createChannel(\"Z\");\n  }\n",
        "answer": "/** @brief Creates color channels in XYZ color space.\n*\n* This function creates color channels in XYZ color space. If such channels already exists, returns existing channels, rather than creating new ones. Note, that nothing can be assumed about the content of each channel.\n*\n* @param[in] X A pointer to a Channel object representing the X channel.\n* @param[in] Y A pointer to a Channel object representing the Y channel.\n* @param[in] Z A pointer to a Channel object representing the Z channel.\n*/\nvirtual void createXYZChannels(Channel* &X, Channel* &Y, Channel* &Z) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "scpi_result_t scpi_cmd_coreSav(scpi_t * context) {\n    int location;\n    if (!get_profile_location_param(context, location)) {\n        return SCPI_RES_ERR;\n    }\n\n    if (!profile::saveAtLocation(location)) {\n        SCPI_ErrorPush(context, SCPI_ERROR_EXTERNAL_EEPROM_SAVE_FAILED);\n        return SCPI_RES_ERR;\n    }\n\n    return SCPI_RES_OK;\n}\n",
        "answer": "/** @brief Stores the current PSU state in the specified storage location.\n*\n*  This function stores the current PSU state in the specified storage location using IEEE488.2 *SAV command.\n*\n* @param context The SCPI context.\n* @return SCPI_RES_OK if successful, SCPI_RES_ERR if an error occurred.\n*/\nscpi_result_t scpi_cmd_coreSav(scpi_t * context) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void stage(const boost::intrusive_ptr<PersistableMessage>& msg)\n    {\n        checkExpectation(STAGE);\n        BOOST_CHECK_EQUAL(expectedMsg, msg);\n        msg->setPersistenceId(++id);\n    }\n",
        "answer": "/** @brief Stages a message before it has been enqueued.\n*\n*  This function stores the headers and content of a message if it has not yet been stored, and sets a persistence id for the message.\n*\n* @param msg The message to be staged.\n*/\nvoid stage(const boost::intrusive_ptr<PersistableMessage>& msg)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void destroy(PersistableMessage&) {}\n",
        "answer": "/**\n* @brief Destroys a previously staged message.\n*\n* This function destroys a message that was previously staged, but never enqueued. Once a message is enqueued, deletion will be automatic when the message is dequeued from all queues it was enqueued onto.\n*\n* @param msg The message to destroy.\n*/\nvoid destroy(PersistableMessage& msg) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void assertClusterSafe()  {\n    if (!isClusterSafe()) {\n        QPID_LOG(critical, \"Modified cluster state outside of cluster context\");\n        ::abort();\n    }\n}\n",
        "answer": "/** @brief Assert that the current operation is safe to modify clustered state.\n*\n*  This function checks if it is being called in a context where it is safe to modify clustered state. If not, it aborts the process as this is a serious bug. This function is used to enforce correct usage of clustered state modification functions.\n*\n* @return Should not return\n*/\nvoid assertClusterSafe()  "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   void callback()\n   {\n      coral::log::status(\"async rpc callback\\n\");\n      mSem.give();\n   }\n",
        "answer": "/** @brief Callback method invoked on completion, timeout, or if any other error occurs. Derived classes can obtain call completion status via the RpcSupervisor accessors and via the accessors below.\n*\n* This is the description of the functionality of the function.\n*\n* @return Should not return\n*/\nvoid callback()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void\tcellDmaWaitTagStatusAll(int ignore)\n{\n\n}\n",
        "answer": "/** @brief Cell DMA wait tag status all.\n*\n*  This function waits for the status of all tags to be set to a specific value.\n*\n* @param ignore The value to wait for.\n* @return None.\n*/\nvoid cellDmaWaitTagStatusAll(int ignore)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CFeeRate GetRequiredFeeRate(const CWallet& wallet)\n{\n    return std::max(wallet.m_min_fee, ::minRelayTxFee);\n}\n",
        "answer": "/** @brief Get the minimum required feerate taking into account the minimum relay feerate and user set minimum transaction feerate.\n*\n*  This function returns the minimum required feerate for a transaction to be accepted by the mempool, based on the minimum relay feerate and the user-set minimum transaction feerate.\n*\n* @param wallet The wallet object containing the user's settings.\n* @return The minimum required feerate.\n*/\nCFeeRate GetRequiredFeeRate(const CWallet& wallet)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void GetDevURandom(unsigned char *ent32)\n{\n    int f = open(\"/dev/urandom\", O_RDONLY);\n    if (f == -1) {\n        RandFailure();\n    }\n    int have = 0;\n    do {\n        ssize_t n = read(f, ent32 + have, NUM_OS_RANDOM_BYTES - have);\n        if (n <= 0 || n + have > NUM_OS_RANDOM_BYTES) {\n            close(f);\n            RandFailure();\n        }\n        have += n;\n    } while (have < NUM_OS_RANDOM_BYTES);\n    close(f);\n}\n",
        "answer": "/**\n* @brief Gets 32 bytes of system entropy from /dev/urandom.\n*\n* This function gets 32 bytes of system entropy from /dev/urandom, which is a\n* cryptographically secure source of randomness on UNIX-ish platforms. If the\n* read fails or if less than 32 bytes are read, the `RandFailure` function is\n* called to handle the error.\n*\n* @param ent32 A pointer to an array of unsigned chars where the entropy will be stored.\n*/\nstatic void GetDevURandom(unsigned char *ent32)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ReleaseDirectoryLocks()\n{\n    std::lock_guard<std::mutex> ulock(cs_dir_locks);\n    dir_locks.clear();\n}\n",
        "answer": "/** @brief Release all directory locks.\n*\n*  This function is used for unit testing only, at runtime the global destructor will take care of the locks.\n*\n* @return Should not return\n*/\nvoid ReleaseDirectoryLocks()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int GetSpendHeight(const CCoinsViewCache& inputs)\n{\n    LOCK(cs_main);\n    CBlockIndex* pindexPrev = LookupBlockIndex(inputs.GetBestBlock());\n    return pindexPrev->nHeight + 1;\n}\n",
        "answer": "/** @brief Get the spend height, which is one more than the inputs.GetBestBlock(). While checking, GetBestBlock() refers to the parent block. (protected by cs_main) This is also true for mempool checks.\n*\n*  @param[in] inputs The coins view cache that contains the best block.\n*\n*  @return The spend height, which is one more than the inputs.GetBestBlock().\n*/\nint GetSpendHeight(const CCoinsViewCache& inputs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class la_i_add_vc_t : public OpcodeBase<la_i_add_vc_t> {\npublic:\n  MYFLT *lhs_;\n  MYFLT *rhs_a_;\n  MYFLT *rhs_b_;\n  la_i_vc_create_t *lhs;\n  la_i_vc_create_t *rhs_a;\n  la_i_vc_create_t *rhs_b;\n  int init(CSOUND *) {\n    toa(lhs_, lhs);\n    toa(rhs_a_, rhs_a);\n    toa(rhs_b_, rhs_b);\n    for (size_t i = 0, n = rhs_a->vc.size(); i < n; ++i) {\n      lhs->vc[i] = rhs_a->vc[i] + rhs_b->vc[i];\n    }\n    return OK;\n  }\n};\n",
        "answer": "/** @brief Elementwise addition. The array on the left-hand side can also appear on the right-hand side in order to perform a += b.\n*\n*  This function performs elementwise addition of two arrays, where the array on the left-hand side is modified in place.\n*  The arrays must have the same size, and the operation is performed using floating-point arithmetic.\n*\n* @param lhs The array on the left-hand side of the addition. This array will be modified in place.\n* @param rhs_a The first array to add.\n* @param rhs_b The second array to add.\n* @return OK if successful, or an error code otherwise.\n*/\nvoid la_i_add_vc_t::init(CSOUND *csound) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class la_i_divide_vr_t : public OpcodeBase<la_i_divide_vr_t> {\npublic:\n  MYFLT *lhs_;\n  MYFLT *rhs_a_;\n  MYFLT *rhs_b_;\n  la_i_vr_create_t *lhs;\n  la_i_vr_create_t *rhs_a;\n  la_i_vr_create_t *rhs_b;\n  int init(CSOUND *) {\n    toa(lhs_, lhs);\n    toa(rhs_a_, rhs_a);\n    toa(rhs_b_, rhs_b);\n    for (size_t i = 0, n = rhs_a->vr.size(); i < n; ++i) {\n      lhs->vr[i] = rhs_a->vr[i] / rhs_b->vr[i];\n    }\n    return OK;\n  }\n};\n",
        "answer": "/**\n* @brief Elementwise division. The array on the left-hand side can also appear on the right-hand side in order to perform a /= b.\n*\n* This function performs elementwise division between two arrays of MYFLT type. The result is stored in the lhs_ array.\n*\n* @param lhs_ The left-hand side array\n* @param rhs_a_ The right-hand side array a\n* @param rhs_b_ The right-hand side array b\n* @return OK if successful, or an error code otherwise\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class la_i_multiply_vc_t : public OpcodeBase<la_i_multiply_vc_t> {\npublic:\n  MYFLT *lhs_;\n  MYFLT *rhs_a_;\n  MYFLT *rhs_b_;\n  la_i_vc_create_t *lhs;\n  la_i_vc_create_t *rhs_a;\n  la_i_vc_create_t *rhs_b;\n  int init(CSOUND *) {\n    toa(lhs_, lhs);\n    toa(rhs_a_, rhs_a);\n    toa(rhs_b_, rhs_b);\n    for (size_t i = 0, n = rhs_a->vc.size(); i < n; ++i) {\n      lhs->vc[i] = rhs_a->vc[i] * rhs_b->vc[i];\n    }\n    return OK;\n  }\n};\n",
        "answer": "/**\n* @brief Elementwise multiplication. The array on the left-hand side can also appear on the right-hand side in order to perform a *= b.\n*\n* This is the description of the functionality of the function.\n*\n* @param lhs_ Pointer to the first input array\n* @param rhs_a_ Pointer to the second input array\n* @param rhs_b_ Pointer to the third input array\n* @return OK if successful, otherwise an error code\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class la_k_add_mc_t : public OpcodeBase<la_k_add_vc_t> {\npublic:\n  MYFLT *lhs_;\n  MYFLT *rhs_a_;\n  MYFLT *rhs_b_;\n  la_i_mc_create_t *lhs;\n  la_i_mc_create_t *rhs_a;\n  la_i_mc_create_t *rhs_b;\n  size_t rowN;\n  size_t columnN;\n  int init(CSOUND *) {\n    toa(lhs_, lhs);\n    toa(rhs_a_, rhs_a);\n    toa(rhs_b_, rhs_b);\n    rowN = gmm::mat_nrows(rhs_a->mc);\n    columnN = gmm::mat_ncols(rhs_a->mc);\n    return OK;\n  }\n  int kontrol(CSOUND *) {\n    for (size_t rowI = 0; rowI < rowN; ++rowI) {\n      for (size_t columnI = 0; columnI < columnN; ++columnI) {\n        lhs->mc(rowI, columnI) =\n            rhs_a->mc(rowI, columnI) + rhs_b->mc(rowI, columnI);\n      }\n    }\n    return OK;\n  }\n};\n",
        "answer": "/**\n* @brief Elementwise addition. The array on the left-hand side can also appear on the right-hand side in order to perform A += B.\n*\n* This function performs elementwise addition of two matrices, where the result is stored in the matrix on the left-hand side.\n* The matrices must have the same dimensions.\n*\n* @param lhs The matrix on the left-hand side of the addition operation.\n* @param rhs_a The first matrix to be added.\n* @param rhs_b The second matrix to be added.\n* @return OK if successful, or an error code otherwise.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class la_k_divide_mr_t : public OpcodeBase<la_k_divide_mr_t> {\npublic:\n  MYFLT *lhs_;\n  MYFLT *rhs_a_;\n  MYFLT *rhs_b_;\n  la_i_mr_create_t *lhs;\n  la_i_mr_create_t *rhs_a;\n  la_i_mr_create_t *rhs_b;\n  size_t rowN;\n  size_t columnN;\n  int init(CSOUND *) {\n    toa(lhs_, lhs);\n    toa(rhs_a_, rhs_a);\n    toa(rhs_b_, rhs_b);\n    rowN = gmm::mat_nrows(rhs_a->mr);\n    columnN = gmm::mat_ncols(rhs_a->mr);\n    return OK;\n  }\n  int kontrol(CSOUND *) {\n    for (size_t rowI = 0; rowI < rowN; ++rowI) {\n      for (size_t columnI = 0; columnI < columnN; ++columnI) {\n        lhs->mr(rowI, columnI) =\n            rhs_a->mr(rowI, columnI) / rhs_b->mr(rowI, columnI);\n      }\n    }\n    return OK;\n  }\n};\n",
        "answer": "/** @brief Elementwise division. The array on the left-hand side can also appear on the right-hand side in order to perform A /= B.\n*\n*  This function performs elementwise division between two matrices, where the result is stored in the matrix on the left-hand side.\n*  If the same matrix appears on both sides of the division operator, it will be modified in place.\n*\n* @param lhs The matrix on the left-hand side of the division operator.\n* @param rhs_a The first matrix operand for the division operation.\n* @param rhs_b The second matrix operand for the division operation.\n* @return A reference to the modified matrix on the left-hand side.\n*/\nvoid la_k_divide_mr_t::init(CSOUND *csound) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class la_k_multiply_mr_t : public OpcodeBase<la_k_multiply_mr_t> {\npublic:\n  MYFLT *lhs_;\n  MYFLT *rhs_a_;\n  MYFLT *rhs_b_;\n  la_i_mr_create_t *lhs;\n  la_i_mr_create_t *rhs_a;\n  la_i_mr_create_t *rhs_b;\n  size_t rowN;\n  size_t columnN;\n  int init(CSOUND *) {\n    toa(lhs_, lhs);\n    toa(rhs_a_, rhs_a);\n    toa(rhs_b_, rhs_b);\n    rowN = gmm::mat_nrows(rhs_a->mr);\n    columnN = gmm::mat_ncols(rhs_a->mr);\n    return OK;\n  }\n  int kontrol(CSOUND *) {\n    for (size_t rowI = 0; rowI < rowN; ++rowI) {\n      for (size_t columnI = 0; columnI < columnN; ++columnI) {\n        lhs->mr(rowI, columnI) =\n            rhs_a->mr(rowI, columnI) * rhs_b->mr(rowI, columnI);\n      }\n    }\n    return OK;\n  }\n};\n",
        "answer": "/**\n* @brief Elementwise multiplication. The array on the left-hand side can also appear on the right-hand side in order to perform A *= B.\n*\n* This is a C++ class that implements elementwise multiplication of two arrays. The arrays are represented as matrices, and the multiplication is performed using the `gmm::mat_nrows` and `gmm::mat_ncols` functions from the GMM library.\n*\n* @param lhs The left-hand side array.\n* @param rhs_a The right-hand side array A.\n* @param rhs_b The right-hand side array B.\n* @return The result of the elementwise multiplication.\n*/\nclass la_k_multiply_mr_t : public OpcodeBase<la_k_multiply_mr_t> "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void log(CSOUND *csound, const char *format, ...) {\n  va_list args;\n  va_start(args, format);\n  if (csound) {\n    if (csound->GetMessageLevel(csound) & WARNMSG)\n      csound->MessageV(csound, 0, format, args);\n  } else {\n    vfprintf(stdout, format, args);\n  }\n  va_end(args);\n}\n",
        "answer": "/** @brief Logging function for Csound.\n*\n* This function logs messages to the console or to the Csound message buffer, depending on the availability of a Csound instance.\n*\n* @param csound The Csound instance, or NULL if not available.\n* @param format The format string for the log message.\n* @param args The variable arguments list for the format string.\n*/\nstatic void log(CSOUND *csound, const char *format, ...) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double ina_voltage(uint8_t ic, uint8_t channel) {\n    return 0;\n}\n",
        "answer": "/** @brief Obtains the bus voltage for the given ADC and channel.\n*\n* This function obtains the bus voltage for a specific channel of an INA3221 IC.\n*\n* @param ic A number >= 0 referring to which INA3221 IC to use.\n* @param channel The channel of the given IC to measure.\n*\n* @return The bus voltage for the specified channel and IC.\n*/\ndouble ina_voltage(uint8_t ic, uint8_t channel) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t arm_uc_blockdevice_read(uint8_t *buffer,\n                                uint64_t address,\n                                uint32_t size)\n{\n    return arm_uc_blockdevice_ext->read(buffer, address, size);\n}\n",
        "answer": "/** @brief Read blocks from a block device.\n*\n*  This function reads blocks from a block device. If a failure occurs, it is not possible to determine how many bytes succeeded.\n*\n* @param buffer The buffer to read the data into.\n* @param address The address of the block to read.\n* @param size The number of bytes to read.\n* @return Returns 0 on success, negative error code on failure.\n*/\nint32_t arm_uc_blockdevice_read(uint8_t *buffer, uint64_t address, uint32_t size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void bam_get_qual_string(bam1_t *s, kstring_t *qual)\n{\n    qual->l=0;\n    uint32_t offset = 0;\n    uint8_t* q = bam_get_qual(s);\n    for (int32_t i = 0; i < bam_get_l_qseq(s); ++i)\n    {\n        kputc(q[i-offset] + 33, qual);\n    }\n};\n",
        "answer": "/** @brief Gets the base qualities from a bam record.\n*\n*  This function gets the base qualities from a bam record. When N is observed, a placeholder value of 0(!, 33 adjusted) is entered.\n*\n* @param s Pointer to a bam1_t structure representing the alignment record.\n* @param qual Pointer to a kstring_t structure where the base qualities will be stored.\n*/\nvoid bam_get_qual_string(bam1_t *s, kstring_t *qual)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool\tIterateMultivaluedStart ( int, CSphString & )\t{ return false; }\n",
        "answer": "/** @brief Iterates the values of an out-of-document multi-valued attribute.\n*\n*  This function iterates the values of an out-of-document multi-valued attribute. It will fail if the attribute is out of range, or is not multi-valued. It can also fail if configured settings are invalid (eg. SQL query can not be executed).\n*\n*  @param iAttr The index of the attribute to iterate.\n*  @param sValue The value of the current iteration.\n*  @return True on success, false on failure.\n*/\nvirtual bool\tIterateMultivaluedStart ( int iAttr, CSphString & sValue )\t"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class ExtRanker_Export_c : public ExtRanker_T<RankerState_Export_fn>\n{\npublic:\n\tExtRanker_Export_c ( const XQQuery_t & tXQ, const ISphQwordSetup & tSetup, const char * sExpr, const CSphSchema & tSchema )\n\t\t: ExtRanker_T<RankerState_Export_fn> ( tXQ, tSetup )\n\t{\n\t\tm_tState.m_sExpr = sExpr;\n\t\tm_tState.m_pSchema = &tSchema;\n\t}\n\n\tvoid SetQwordsIDF ( const ExtQwordsHash_t & hQwords )\n\t{\n\t\tExtRanker_T<RankerState_Export_fn>::SetQwordsIDF ( hQwords );\n\t\tm_tState.m_iMaxQpos = m_iMaxQpos;\n\t\tm_tState.SetQwords ( hQwords );\n\t}\n};\n",
        "answer": "/** @brief ExtRanker_Export_c class definition.\n*\n*  This class defines an export ranker that emits BM25 as the weight, but computes and exports all the factors useful for research purposes, eg. exporting the data for machine learning.\n*\n* @param tXQ The XQ query object.\n* @param tSetup The ISphQwordSetup object.\n* @param sExpr The expression string.\n* @param tSchema The CSphSchema object.\n*/\nclass ExtRanker_Export_c : public ExtRanker_T<RankerState_Export_fn>"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid SetSelect ( SqlNode_t * pStart, SqlNode_t * pEnd=NULL )\n\t{\n\t\tif ( m_pQuery )\n\t\t{\n\t\t\tif ( pStart && ( m_pQuery->m_iSQLSelectStart<0 || m_pQuery->m_iSQLSelectStart>pStart->m_iStart ) )\n\t\t\t\tm_pQuery->m_iSQLSelectStart = pStart->m_iStart;\n\t\t\tif ( !pEnd )\n\t\t\t\tpEnd = pStart;\n\t\t\tif ( pEnd && ( m_pQuery->m_iSQLSelectEnd<0 || m_pQuery->m_iSQLSelectEnd<pEnd->m_iEnd ) )\n\t\t\t\tm_pQuery->m_iSQLSelectEnd = pEnd->m_iEnd;\n\t\t}\n\t}\n",
        "answer": "/** @brief Sets the select list for a SQL query.\n*\n*  This function is called every time we capture a select list item (i think there should be a simpler way to track these though). It sets the start and end positions of the select list in the query object.\n*\n* @param pStart The starting position of the select list.\n* @param pEnd The ending position of the select list. If not provided, it is set to the same value as pStart.\n*/\nvoid SetSelect ( SqlNode_t * pStart, SqlNode_t * pEnd=NULL )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "operator delete(\n    void *                      in_pointer,\n    atoms::allocation_placement,\n    const char *                in_file,\n    int                         in_line )\n{\n    return lifecycle::allocation_center::get_singleton()\n        .deallocate( in_pointer, in_file, in_line );\n}\n",
        "answer": "/** @brief Placement delete operator.\n*\n*  This is the placement delete operator for the allocation center singleton.\n*  It merely matches the placement new operators, it is NEVER called through normal use of global ::delete X.\n*  It is only called by the class-based delete operators or via the BEACH_DELETE(T,X) macro.\n*\n* @param in_pointer The pointer to deallocate.\n* @param in_file The file from which the allocation was made.\n* @param in_line The line number of the allocation.\n* @return Should not return\n*/\nvoid operator delete("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int btDumpMemoryLeaks()\n{\n\tint totalLeak = 0;\n\t\n\tfor (int i=0;i<mynumallocs;i++)\n\t{\n\t\tprintf(\"Error: leaked memory of allocation #%d (%d bytes)\\n\", allocations_id[i], allocations_bytes[i]);\n\t\ttotalLeak+=allocations_bytes[i];\n\t}\n\tif (totalLeak)\n\t{\n\t\tprintf(\"Error: memory leaks: %d allocations were not freed and leaked together %d bytes\\n\",mynumallocs,totalLeak);\n\t}\n\treturn totalLeak;\n}\n",
        "answer": "/** @brief Dumps memory leaks.\n*\n*  This function dumps the memory leaks by iterating through the allocations and printing an error message for each leak.\n*  It also calculates the total number of bytes leaked and returns it.\n*\n* @return The total number of bytes leaked.\n*/\nint btDumpMemoryLeaks()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CBaseChainParams::Network NetworkIdFromCommandLine() {\n    bool fRegTest = GetBoolArg(\"-regtest\", false);\n    bool fTestNet = GetBoolArg(\"-testnet\", false);\n\n    if (fTestNet && fRegTest)\n        return CBaseChainParams::MAX_NETWORK_TYPES;\n    if (fRegTest)\n        return CBaseChainParams::REGTEST;\n    if (fTestNet)\n        return CBaseChainParams::TESTNET;\n    return CBaseChainParams::MAIN;\n}\n",
        "answer": "/** @brief Returns the appropriate Network ID based on command line arguments.\n*\n*  This function looks for -regtest or -testnet and returns the appropriate Network ID.\n*  If an invalid combination is given, it returns MAX_NETWORK_TYPES.\n*\n* @param fRegTest A boolean indicating whether the regtest argument was passed.\n* @param fTestNet A boolean indicating whether the testnet argument was passed.\n* @return The appropriate Network ID based on command line arguments.\n*/\nCBaseChainParams::Network NetworkIdFromCommandLine(bool fRegTest, bool fTestNet) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SetRPCWarmupStatus(const std::string& newStatus) {\n    LOCK(cs_rpcWarmup);\n    rpcWarmupStatus = newStatus;\n}\n",
        "answer": "/** @brief Sets the RPC warmup status.\n*\n*  This function sets the RPC warmup status to a given string. When this is done, all RPC calls will error out immediately with RPC_IN_WARMUP.\n*\n* @param newStatus The new RPC warmup status.\n*/\nvoid SetRPCWarmupStatus(const std::string& newStatus) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tFLMINT FTKAPI AddRef( void)\n\t{\n\t\treturn( f_atomicInc( &m_refCnt));\n\t}\n",
        "answer": "/** @brief Increment the reference count for this object.\n*\n*  The reference count is the number of pointers that are referencing this object. Return value is the incremented reference count.\n*\n* @return The incremented reference count.\n*/\nFLMINT FTKAPI AddRef( void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "FLMEXP RCODE FLMAPI FlmStorage2UINT64(\n\tFLMUINT\t\t\t\tuiValueType,\n\tFLMUINT\t\t\t\tuiValueLength,\n\tconst FLMBYTE *\tpucValue,\n\tFLMUINT64 *\t\t\tpui64Num)\n{\n\tRCODE\t\t\t\t\trc = FERR_OK;\n\tFLMBOOL\t\t\t\tbNegFlag;\n\n\tif( RC_OK(rc = flmBcd2Num64( uiValueType, uiValueLength, pucValue,\n\t\t\t\t\t\t\tpui64Num, &bNegFlag)))\n\t{\n\t\tif (bNegFlag)\n\t\t{\n\t\t\trc = RC_SET( FERR_CONV_NUM_UNDERFLOW);\n\t\t}\n\t}\n\t\n\treturn( rc);\n}\n",
        "answer": "/** @brief Converts a value from FLAIM's internal format to a FLMUINT64.\n*\n*  This function converts a value from FLAIM's internal format to a FLMUINT64. The value may be a FLM_NUMBER_TYPE, FLM_TEXT_TYPE, or FLM_CONTEXT_TYPE.\n*\n* @param uiValueType The type of the value to convert. This should be one of the following: FLM_NUMBER_TYPE, FLM_TEXT_TYPE, or FLM_CONTEXT_TYPE.\n* @param uiValueLength The length of the value in bytes.\n* @param pucValue A pointer to the value to convert.\n* @param pui64Num A pointer to a FLMUINT64 variable that will receive the converted value.\n* @return Returns FERR_OK if successful, or an error code if not.\n*/\nFLMEXP RCODE FLMAPI FlmStorage2UINT64("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\n\r\n#if CRYPTOPP_DEBUG && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\r\nvoid ElGamal_TestInstantiations()\r\n{\r\n\tElGamalEncryptor test1(1, 1, 1);\r\n\tElGamalDecryptor test2(NullRNG(), 123);\r\n\tElGamalEncryptor test3(test2);\r\n}\r\n",
        "answer": "/** @brief ElGamal_TestInstantiations.\n*\n* This is a function that tests the instantiation of ElGamalEncryptor and ElGamalDecryptor classes.\n* It creates three objects: test1, test2, and test3.\n* Test1 is an instance of ElGamalEncryptor with parameters 1, 1, and 1.\n* Test2 is an instance of ElGamalDecryptor with a NullRNG object and parameter 123.\n* Test3 is an instance of ElGamalEncryptor with test2 as its constructor argument.\n*\n* @return void\n*/\nvoid ElGamal_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string StringFromFixedZeroTerminatedBuffer(const char * buffer, size_t max_len) {\n    size_t len = 0;\n    while (len < max_len && buffer[len] != '\\0')\n        ++len;\n\n    return std::string(buffer, len);\n}\n",
        "answer": "/** @brief Creates a std::string from a fixed-size NUL-terminated char buffer. If the buffer isn't NUL-terminated then the string ends at max_len characters.\n*\n* @param buffer The fixed-size NUL-terminated char buffer to create the string from.\n* @param max_len The maximum length of the string.\n* @return A std::string created from the buffer, or an empty string if the buffer is not NUL-terminated and max_len is reached.\n*/\nstd::string StringFromFixedZeroTerminatedBuffer(const char *buffer, size_t max_len) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void join() {\n    if (!detached_ && state_ != uninitialized) {\n      void* ignore;\n      /* XXX\n         If join fails it is most likely due to the fact\n         that the last reference was the thread itself and cannot\n         join.  This results in leaked threads and will eventually\n         cause the process to run out of thread resources.\n         We're beyond the point of throwing an exception.  Not clear how\n         best to handle this. */\n      int res = pthread_join(pthread_, &ignore);\n      detached_ = (res == 0);\n      if (res != 0) {\n        GlobalOutput.printf(\"PthreadThread::join(): fail with code %d\", res);\n      }\n    } else {\n      GlobalOutput.printf(\"PthreadThread::join(): detached thread\");\n    }\n  }\n",
        "answer": "/**\n* @brief Join this thread. If this thread is joinable, the calling thread blocks until this thread completes. If the target thread is not joinable, then nothing happens.\n*\n* @return Should not return\n*/\n/* XXX\nIf join fails it is most likely due to the fact"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned get_available_numa_count()\n{ sentinel(); return s_core_topology.first ; }\n",
        "answer": "/** @brief Query the number of available NUMA regions.\n*\n*  This function returns the number of available NUMA regions, which may be less than the hardware capacity if the MPI process is pinned to a NUMA region.\n*\n* @return The number of available NUMA regions.\n*/\nunsigned get_available_numa_count()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool backslash(const mat &A, const mat &B, mat &X)\n{\n  int m = A.rows(), n = A.cols();\n  bool info;\n\n  if (m == n)\n    info = ls_solve(A, B, X);\n  else if (m > n)\n    info = ls_solve_od(A, B, X);\n  else\n    info = ls_solve_ud(A, B, X);\n\n  return info;\n}\n",
        "answer": "/** @brief Tries to emulate the backslash operator in Matlab by calling ls_solve(A,B,X), ls_solve_od(A,B,X), or ls_solve_ud(A,B,X).\n*\n*  This function is used to solve a system of linear equations using the backslash operator. It takes three arguments: A, B, and X.\n*  The matrix A represents the coefficient matrix, B represents the right-hand side vector, and X represents the solution vector.\n*  The function first checks if the number of rows in A is equal to the number of columns in A. If it is, then it calls ls_solve(A,B,X) to solve the system of linear equations.\n*  Otherwise, if the number of rows in A is greater than the number of columns in A, then it calls ls_solve_od(A,B,X) to solve the overdetermined system of linear equations.\n*  If the number of rows in A is less than the number of columns in A, then it calls ls_solve_ud(A,B,X) to solve the underdetermined system of linear equations.\n*  The function returns a boolean value indicating whether the solution was successful or not.\n*\n* @param[in] A The coefficient matrix.\n* @param[in] B The right-hand side vector.\n* @param[out] X The solution vector.\n* @return true if the solution was successful, false otherwise.\n*/\nbool backslash(const mat &A, const mat &B, mat &X)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "cmat backslash(const cmat &A, const cmat &B)\n{\n  cmat X;\n  bool info;\n  info = backslash(A, B, X);\n  it_assert_debug(info, \"backslash(): solution was not found\");\n  return X;\n}\n",
        "answer": "/**\n* @brief Tries to emulate the backslash operator in Matlab by calling ls_solve(A,B), ls_solve_od(A,B), or ls_solve_ud(A,B).\n*\n* This is the description of the functionality of the function.\n*\n* @param A The first matrix operand.\n* @param B The second matrix operand.\n* @return The solution to the system of linear equations.\n*/\ncmat backslash(const cmat &A, const cmat &B)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "vec backward_substitution(const mat &U, int q, const vec &b)\n{\n  vec x(U.rows());\n  backward_substitution(U, q, b, x);\n\n  return x;\n}\n",
        "answer": "/** @brief Solves Ux=b, where U is a upper triangular n by n matrix band-matrix with upper bandwidth q. Assumes that U is nonsingular. Requires about 2nq flops (if n >> q). Uses Alg. 4.3.3 in Golub & van Loan \"Matrix computations\", 3rd ed., p. 153.\n* @param U The upper triangular matrix\n* @param q The upper bandwidth of the matrix\n* @param b The right-hand side vector\n* @return The solution vector x\n*/\nvec backward_substitution(const mat &U, int q, const vec &b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double norm(const cmat &m, int p)\n{\n  it_assert((p == 1) || (p == 2),\n            \"norm(): Can only calculate a matrix norm of order 1 or 2\");\n\n  if (p == 1)\n    return max(sum(abs(m)));\n  else\n    return max(svd(m));\n}\n",
        "answer": "/** @brief Calculate the p-norm of a complex matrix.\n*\n* This function calculates the p-norm of a complex matrix, where p is an integer greater than or equal to 1.\n* The p-norm is defined as the maximum singular value of the matrix for p = 2, and as the sum of the absolute values of the elements for p = 1.\n* If no p is given, the default is the 2-norm.\n*\n* @param m The complex matrix to calculate the norm of.\n* @param p The order of the norm (optional).\n*\n* @return The p-norm of the matrix.\n*/\ndouble norm(const cmat &m, int p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void v_assign_double_to_string (TIXML_STRING & S_string, double d_val)\r\n{\r\n   char ca_int [80];\r\n\r\n   sprintf (ca_int, \"%f\", d_val);\r\n   while (ca_int [strlen (ca_int) - 1] == '0')\r\n      ca_int [strlen (ca_int) - 1] = 0;\r\n   if (ca_int [strlen (ca_int) - 1] == '.')\r\n      ca_int [strlen (ca_int) - 1] = 0;\r\n   S_string = ca_int;\r\n}\r\n",
        "answer": "/** @brief Assign a double to a string, cleaning any trailing zeroes and the decimal point if there's no decimal part.\n*\n*  This function assigns a double value to a string, while removing any trailing zeroes and the decimal point if there's no decimal part.\n*\n* @param S_string The string to be assigned the double value.\n* @param d_val The double value to be assigned.\n*/\nvoid v_assign_double_to_string(TIXML_STRING &S_string, double d_val)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "tresult getSpeakerChannelIndex (SpeakerArrangement arrangement, uint64 speaker, int32& channel)\r\n{\r\n\tchannel = SpeakerArr::getSpeakerIndex (speaker, arrangement);\r\n\treturn channel < 0 ? kResultFalse : kResultTrue;\r\n}\r\n",
        "answer": "/** @brief Gets the channel index of a given speaker in a arrangement.\n*\n* This function returns the channel index of a given speaker in a specific arrangement.\n* If the speaker is not part of the arrangement, it will return kResultFalse.\n*\n* @param[in] arrangement The speaker arrangement to check for the speaker.\n* @param[in] speaker The speaker to get the channel index for.\n* @param[out] channel The channel index of the speaker in the arrangement.\n*\n* @return Returns kResultTrue if the speaker is part of the arrangement, and kResultFalse otherwise.\n*/\ntresult getSpeakerChannelIndex (SpeakerArrangement arrangement, uint64 speaker, int32& channel)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int notify(int n, void *p)\n    {\n        Q_UNUSED(p);\n        if( !n || n&LH_NOTE_MEM )\n            requestRender();\n        return LH_NOTE_MEM;\n    }\n",
        "answer": "/** @brief Notify function.\n*\n*  This function is used to notify the object of changes in the source objects and target objects.\n*  It checks for changes in the source objects and updates the target objects accordingly.\n*\n* @param n The notification code.\n* @param p The notification data.\n* @return LH_NOTE_MEM if the notification was successful, 0 otherwise.\n*/\nint notify(int n, void *p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int notify(int n, void *p)\r\n    {\r\n        setValue( net_.inPermille()/10.0 );\r\n        return net_.notify(n,p);\r\n    }\r\n",
        "answer": "/** @brief Notify function for conditional formatting.\n*\n*  This function notifies the target object when the source object meets the specified rules.\n*\n* @param n The notification code.\n* @param p The pointer to the notification data.\n* @return The result of the notify call on the net object.\n*/\nint notify(int n, void *p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    double getSampleRate (int index)                { return internal.sampleRates [index]; }\r\n",
        "answer": "/** @brief Returns one of the sample-rates this device supports.\n*\n*  This function returns one of the sample-rates that this device supports. (Note that for DirectSound some rates might not work, depending on combinations of i/o channels that are being opened).\n*\n* @param index The index of the sample rate to return.\n* @return One of the supported sample rates.\n*/\ndouble getSampleRate(int index);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getOutputLatencyInSamples()         { return internal.outputLatency; }\r\n",
        "answer": "/** @brief Gets the output latency in samples.\n*\n*  This function returns the device's output latency, which is the delay in samples between a callback getting a block of data and that data actually getting played.\n*\n* @return The output latency in samples.\n*/\nint getOutputLatencyInSamples() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getInputLatencyInSamples()                      { return (minBufferSizeIn * 3) / 4; }\r\n",
        "answer": "/** @brief Returns the device's input latency.\n*\n* This function returns the delay in samples between some audio actually arriving at the soundcard, and the callback getting passed this block of data.\n*\n* @return The input latency in samples.\n*/\nint getInputLatencyInSamples() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool isPlaying()                                    { return isRunning && callback != 0; }\r\n",
        "answer": "/**\n* @brief Check if the device is still playing.\n*\n* This function checks whether the device is still calling back. The device might mysteriously stop, so this checks whether it's still playing.\n*\n* @return True if the device is still playing, false otherwise.\n*/\nbool isPlaying() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool isPlaying()                    { return isASIOOpen && (currentCallback != nullptr); }\r\n",
        "answer": "/** @brief Checks if the device is still playing.\n*\n*  This function checks whether the device is still calling back. The device might mysteriously stop, so this checks whether it's still playing.\n*\n* @return true if the device is still playing, false otherwise.\n*/\nbool isPlaying() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getInputLatencyInSamples()      { return inputLatency + currentBlockSizeSamples / 4; }\r\n",
        "answer": "/**\n* @brief Returns the device's input latency. This is the delay in samples between some audio actually arriving at the soundcard, and the callback getting passed this block of data.\n*\n* @return The input latency in samples.\n*/\nint getInputLatencyInSamples() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void componentVisibilityChanged()\r\n    {\r\n        Component* const comp = getComponent();\r\n\r\n        if (canBeAttached (*comp))\r\n        {\r\n            if (! isAttached (*comp))\r\n                attach();\r\n        }\r\n        else\r\n        {\r\n            detach();\r\n        }\r\n    }\r\n",
        "answer": "/** @brief Component visibility changed callback.\n*\n*  This callback happens when the component's visibility state changes, possibly due to one of its parents being made visible or invisible.\n*\n* @param comp The component whose visibility has changed.\n*/\nvoid componentVisibilityChanged(Component* const comp)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool mightContainSubItems()                 { return true; }\r\n",
        "answer": "/** @brief Tells the tree whether this item can potentially be opened. If your item could contain sub-items, this should return true; if it returns false then the tree will not try to open the item. This determines whether or not the item will be drawn with a 'plus' button next to it.\n*  @return bool\n*/\nbool mightContainSubItems() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseDrag (const MouseEvent& e)\r\n    {\r\n        const float sat = (e.x - edge) / (float) (getWidth() - edge * 2);\r\n        const float val = 1.0f - (e.y - edge) / (float) (getHeight() - edge * 2);\r\n\r\n        owner.setSV (sat, val);\r\n    }\r\n",
        "answer": "/** @brief Called when the mouse is moved while a button is held down.\n*\n*  This function is called each time the mouse moves when a mouse button is pressed inside a component, even if the mouse strays outside the component's bounds. It sets the saturation and value of the owner object based on the position of the mouse.\n*\n* @param e A MouseEvent object containing information about the mouse event.\n*/\nvoid mouseDrag (const MouseEvent& e)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getCurrentBufferSizeSamples()    { return internal->getBufferSize(); }\r\n",
        "answer": "/** @brief Returns the buffer size that the device is currently using. If the device isn't actually open, this value doesn't really mean much.\n*\n*  This function returns the buffer size that the device is currently using. If the device isn't actually open, this value doesn't really mean much.\n*\n* @return The current buffer size in samples.\n*/\nint getCurrentBufferSizeSamples()    "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void resized()\r\n        {\r\n            palette.setBounds (0, 0, getWidth(), getHeight() - 120);\r\n            styleBox.setBounds (10, getHeight() - 110, 200, 22);\r\n\r\n            defaultButton.changeWidthToFitText (22);\r\n            defaultButton.setTopLeftPosition (240, getHeight() - 110);\r\n\r\n            instructions.setBounds (10, getHeight() - 80, getWidth() - 20, 80);\r\n        }\r\n",
        "answer": "/**\n* @brief Called when this component's size has been changed.\n*\n* A component can implement this method to do things such as laying out its child components when its width or height changes. The method is called synchronously as a result of the setBounds or setSize methods, so repeatedly changing a component's size will repeatedly call its resized method (unlike things like repainting, where multiple calls to repaint are coalesced together). If the component is a top-level window on the desktop, its size could also be changed by operating-system factors beyond the application's control.\n*\n* @return Should not return\n*/\nvoid resized() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void componentVisibilityChanged()           { owner.visibilityChanged(); }\r\n",
        "answer": "/**\n* @brief Callback for component visibility changes.\n*\n* This callback happens when the component's visibility state changes, possibly due to one of its parents being made visible or invisible.\n*\n* @param owner The owner of this function.\n*/\nvoid componentVisibilityChanged(owner) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void itemOpennessChanged (bool isNowOpen)\r\n    {\r\n        if (isNowOpen)\r\n        {\r\n            clearSubItems();\r\n\r\n            isDirectory = file.isDirectory();\r\n\r\n            if (isDirectory)\r\n            {\r\n                if (subContentsList == nullptr)\r\n                {\r\n                    jassert (parentContentsList != nullptr);\r\n\r\n                    DirectoryContentsList* const l = new DirectoryContentsList (parentContentsList->getFilter(), thread);\r\n                    l->setDirectory (file, true, true);\r\n\r\n                    setSubContentsList (l, true);\r\n                }\r\n\r\n                changeListenerCallback (nullptr);\r\n            }\r\n        }\r\n    }\r\n",
        "answer": "/** @brief Item openness changed.\n*\n*  This function is called when an item is opened or closed. You could also use this callback as a trigger to start a background process which asynchronously creates sub-items and adds them, if that's more appropriate for the task in hand.\n*\n* @param[in] isNowOpen True if the item is now open, false otherwise.\n*/\nvoid itemOpennessChanged (bool isNowOpen)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseDrag (const MouseEvent& e)\r\n    {\r\n        owner.setHue ((e.y - edge) / (float) (getHeight() - edge * 2));\r\n    }\r\n",
        "answer": "/**\n* @brief Called when the mouse is moved while a button is held down.\n*\n* When a mouse button is pressed inside a component, that component receives\n* mouseDrag callbacks each time the mouse moves, even if the mouse strays outside\n* the component's bounds.\n*\n* @param e The MouseEvent object containing information about the mouse event.\n*/\nvoid mouseDrag (const MouseEvent& e);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void performAnyPendingRepaintsNow()\r\n    {\r\n        MSG m;\r\n        if (component->isVisible()\r\n             && (PeekMessage (&m, hwnd, WM_PAINT, WM_PAINT, PM_REMOVE) || isUsingUpdateLayeredWindow()))\r\n            handlePaintMessage();\r\n    }\r\n",
        "answer": "/** @brief Performs any pending repaints now.\n*\n* This function can be called (from the message thread) to cause the immediate redrawing of any areas of this window that need repainting. You shouldn't ever really need to use this, it's mainly for special purposes like supporting audio plugins where the host's event loop is out of our control.\n*\n* @param component The component to perform pending repaints on.\n* @return void\n*/\nvoid performAnyPendingRepaintsNow(Component* component)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getCurrentBitDepth()            { return 16; }\r\n",
        "answer": "/** @brief Get current bit depth.\n*\n* This function returns the device's current physical bit-depth. If the device isn't actually open, this value doesn't really mean much.\n*\n* @return The current bit depth of the device.\n*/\nint getCurrentBitDepth() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseDrag (const MouseEvent& e)\r\n    {\r\n        if (! (isDragging || e.mouseWasClicked()))\r\n        {\r\n            isDragging = true;\r\n            DragAndDropContainer* const dnd = DragAndDropContainer::findParentDragContainerFor (this);\r\n\r\n            if (dnd != nullptr)\r\n            {\r\n                dnd->startDragging (Toolbar::toolbarDragDescriptor, getParentComponent(), Image::null, true);\r\n\r\n                ToolbarItemComponent* const tc = getToolbarItemComponent();\r\n\r\n                if (tc != nullptr)\r\n                {\r\n                    tc->isBeingDragged = true;\r\n\r\n                    if (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)\r\n                        tc->setVisible (false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n",
        "answer": "/**\n* @brief Called when the mouse is moved while a button is held down.\n*\n* When a mouse button is pressed inside a component, that component receives\n* mouseDrag callbacks each time the mouse moves, even if the mouse strays outside\n* the component's bounds.\n*\n* @param e The MouseEvent object containing information about the mouse event.\n*/\nvoid mouseDrag (const MouseEvent& e);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool isPlaying()                        { return callback != nullptr; }\r\n",
        "answer": "/** @brief Checks if the device is still playing.\n*\n*  This function checks whether the device is still calling back. The device might mysteriously stop, so this checks whether it's still playing.\n*\n* @return True if the device is still playing, false otherwise.\n*/\nbool isPlaying() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getInputLatencyInSamples()\r\n    {\r\n        int latency = 0;\r\n\r\n        for (int i = 0; i < inputPorts.size(); i++)\r\n            latency = jmax (latency, (int) juce::jack_port_get_total_latency (client, (jack_port_t*) inputPorts [i]));\r\n\r\n        return latency;\r\n    }\r\n",
        "answer": "/** @brief Returns the device's input latency. This is the delay in samples between some audio actually arriving at the soundcard, and the callback getting passed this block of data.\n*\n*  @return The input latency in samples.\n*/\nint getInputLatencyInSamples()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void textInputRequired (const Point<int>&)\r\n    {\r\n    }\r\n",
        "answer": "/** @brief Tells the window that text input may be required at the given position.\n*\n*  This function is used to notify the window that text input may be required at a specific position.\n*  This can cause things like a virtual on-screen keyboard to appear, depending on the OS.\n*\n* @param pos The position where text input may be required.\n*/\nvoid textInputRequired (const Point<int>& pos)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void resized()\r\n    {\r\n        if (customComponent != nullptr)\r\n            customComponent->setBounds (getLocalBounds());\r\n    }\r\n",
        "answer": "/**\n* @brief Called when this component's size has been changed.\n*\n* A component can implement this method to do things such as laying out its child components when its width or height changes. The method is called synchronously as a result of the setBounds or setSize methods, so repeatedly changing a component's size will repeatedly call its resized method (unlike things like repainting, where multiple calls to repaint are coalesced together). If the component is a top-level window on the desktop, its size could also be changed by operating-system factors beyond the application's control.\n*\n* @return Should not return\n*/\nvoid resized() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void systemRequestedQuit()\r\n    {\r\n        quit();\r\n    }\r\n",
        "answer": "/** @brief System requested quit.\n*\n*  This function is called when the operating system is trying to close the application. If you want to send a quit signal to your app, this is the correct method to call, because it means that requests that come from the system get handled in the same way as those from your own application code. So e.g. you'd call this method from a \"quit\" item on a menu bar.\n*\n* @return Should not return\n*/\nvoid systemRequestedQuit()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getOutputLatencyInSamples()                     { return outputLatency; }\r\n",
        "answer": "/** @brief Returns the device's output latency. This is the delay in samples between a callback getting a block of data, and that data actually getting played.\n*\n*  @return The output latency in samples.\n*/\nint getOutputLatencyInSamples() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void componentMovedOrResized (bool /*wasMoved*/, bool /*wasResized*/)\r\n    {\r\n        Component* const topComp = owner.getTopLevelComponent();\r\n\r\n        if (topComp->getPeer() != nullptr)\r\n            setControlBounds (topComp->getLocalArea (&owner, owner.getLocalBounds()));\r\n    }\r\n",
        "answer": "/** @brief Callback for when the component is moved or resized.\n*\n*  This callback happens when the component that is being watched is moved relative to its top-level peer window, or when it is resized.\n*\n* @param wasMoved True if the component was moved, false otherwise.\n* @param wasResized True if the component was resized, false otherwise.\n*/\nvoid componentMovedOrResized(bool wasMoved, bool wasResized)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void resized()\r\n    {\r\n        int y = titleHeight;\r\n\r\n        for (int i = 0; i < propertyComps.size(); ++i)\r\n        {\r\n            PropertyComponent* const pec = propertyComps.getUnchecked (i);\r\n            pec->setBounds (1, y, getWidth() - 2, pec->getPreferredHeight());\r\n            y = pec->getBottom();\r\n        }\r\n    }\r\n",
        "answer": "/**\n* @brief Called when this component's size has been changed.\n*\n* A component can implement this method to do things such as laying out its child components when its width or height changes. The method is called synchronously as a result of the setBounds or setSize methods, so repeatedly changing a component's size will repeatedly call its resized method (unlike things like repainting, where multiple calls to repaint are coalesced together). If the component is a top-level window on the desktop, its size could also be changed by operating-system factors beyond the application's control.\n*\n* @param y The new height of the component.\n*/\nvoid resized(int y);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void setOrigin (int x, int y)                                       { stack->transform.setOrigin (x, y); }\r\n",
        "answer": "/** @brief Moves the origin to a new position.\n*\n*  The co-ords are relative to the current origin, and indicate the new position of (0, 0).\n*\n* @param x The x coordinate of the new origin.\n* @param y The y coordinate of the new origin.\n*/\nvoid setOrigin(int x, int y) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseDown (const MouseEvent&)\r\n    {\r\n        PopupMenu m;\r\n        m.addItem (1, TRANS(\"Use this swatch as the current colour\"));\r\n        m.addSeparator();\r\n        m.addItem (2, TRANS(\"Set this swatch to the current colour\"));\r\n\r\n        m.showMenuAsync (PopupMenu::Options().withTargetComponent (this),\r\n                         ModalCallbackFunction::forComponent (menuStaticCallback, this));\r\n    }\r\n",
        "answer": "/** @brief Handles mouse down event.\n*\n*  This function is called when a mouse button is pressed while it's over this component. Once a button is held down, the mouseDrag method will be called when the mouse moves, until the button is released.\n*\n* @param[in] MouseEvent& The mouse event that triggered this function call.\n* @return void\n*/\nvoid mouseDown (const MouseEvent&)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    MouseCursor getMouseCursor()\r\n    {\r\n        return owner.getMouseCursor();\r\n    }\r\n",
        "answer": "/** @brief Returns the mouse cursor shape to use when the mouse is over this component.\n*\n*  This function returns the mouse cursor shape that should be used when the mouse is over this component. The default implementation will return the cursor that was set by setCursor() but can be overridden for more specialized purposes, such as returning different cursors depending on the mouse position.\n*\n* @return The mouse cursor shape to use when the mouse is over this component.\n*/\nMouseCursor getMouseCursor()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseMove (const MouseEvent& e)    { updateButtonUnderMouse (e); }\r\n",
        "answer": "/** @brief Called when the mouse moves inside this component.\n*\n*  If the mouse button isn't pressed and the mouse moves over a component, this will be called to let the component react to this. A component will always get a mouseEnter callback before a mouseMove.\n*\n* @param e The MouseEvent object that contains information about the mouse event.\n*/\nvoid mouseMove (const MouseEvent& e)    "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void valueTreeChildAdded (ValueTree&, ValueTree&) {}\r\n",
        "answer": "/** @brief Called when a child sub-tree is added.\n*\n*  This method is called when a child sub-tree is added to the tree. Note that when you register a listener to a tree, it will receive this callback for child changes in both that tree and any of its children, (recursively, at any depth). If your tree has sub-trees but you only want to know about changes to the top level tree, just check the parentTree parameter to make sure it's the one that you're interested in.\n*\n* @param childTree The child tree that was added.\n* @param parentTree The parent tree of the child tree that was added.\n*/\nvoid valueTreeChildAdded (ValueTree& childTree, ValueTree& parentTree) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int getNumPrograms()                                { return effect != nullptr ? effect->numPrograms : 0; }\r\n",
        "answer": "/** @brief Returns the number of preset programs the filter supports.\n*\n* This function returns the number of preset programs that the filter supports. The value returned must be valid as soon as this object is created, and must not change over its lifetime. This value shouldn't be less than 1.\n*\n* @return The number of preset programs supported by the filter.\n*/\nint getNumPrograms() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseDrag (const MouseEvent& e)\r\n    {\r\n        if (pluginWindow != 0)\r\n        {\r\n            XEvent ev = { 0 };\r\n            ev.xmotion.display = display;\r\n            ev.xmotion.type = MotionNotify;\r\n            ev.xmotion.window = pluginWindow;\r\n            ev.xmotion.root = RootWindow (display, DefaultScreen (display));\r\n            ev.xmotion.time = CurrentTime;\r\n            ev.xmotion.x = e.x ;\r\n            ev.xmotion.y = e.y;\r\n            ev.xmotion.x_root = e.getScreenX();\r\n            ev.xmotion.y_root = e.getScreenY();\r\n            ev.xmotion.is_hint = NotifyNormal;\r\n\r\n            translateJuceToXMotionModifiers (e, ev);\r\n            sendEventToChild (&ev);\r\n        }\r\n    }\r\n",
        "answer": "/** @brief Handles mouse drag events.\n*\n*  This function is called when the mouse is moved while a button is held down. When a mouse button is pressed inside a component, that component receives mouseDrag callbacks each time the mouse moves, even if the mouse strays outside the component's bounds.\n*\n* @param e The MouseEvent object containing information about the mouse drag event.\n*/\nvoid mouseDrag (const MouseEvent& e)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    double getCurrentSampleRate()                       { return currentSampleRate; }\r\n",
        "answer": "/** @brief Returns the sample rate that the device is currently using. If the device isn't actually open, this value doesn't really mean much.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\ndouble getCurrentSampleRate() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool isPlaying()    { return isStarted && isOpen_ && isThreadRunning(); }\r\n",
        "answer": "/** @brief Checks whether the device is still playing.\n*\n*  This function checks whether the device is still calling back. The device might mysteriously stop, so this checks whether it's still playing.\n*\n* @return True if the device is still playing, false otherwise.\n*/\nbool isPlaying()    "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void mouseMove (const MouseEvent&)    { timerCallback(); }\r\n",
        "answer": "/** @brief Called when the mouse moves inside this component. If the mouse button isn't pressed and the mouse moves over a component, this will be called to let the component react to this. A component will always get a mouseEnter callback before a mouseMove.\n*\n*  @param[in] MouseEvent& The event that triggered this function call.\n*\n*  @return void\n*/\nvoid mouseMove (const MouseEvent&)    "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void handleCommandMessage (int commandId)\r\n    {\r\n        Component::handleCommandMessage (commandId);\r\n\r\n        if (commandId == PopupMenuSettings::dismissCommandId)\r\n            dismissMenu (nullptr);\r\n    }\r\n",
        "answer": "/** @brief Handles command message.\n*\n*  This method is called by the message thread when a command message arrives, and the component can override this method to process it in any way it needs to.\n*\n* @param commandId The ID of the command message.\n* @return Should not return.\n*/\nvoid handleCommandMessage (int commandId)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void configureLogging( const shared_ptr< Config > & config )\n{\n   if( !!config )\n   {\n      auto block = config->getGlobalBlock();\n      if( block )\n         configureLogging( block.getBlock( \"Logging\" ) );\n   }\n}\n",
        "answer": "/** @brief Configures logging based on the provided configuration.\n*\n*  This function configures the logging system based on the provided configuration. It extracts the relevant information from the configuration and sets up the log messages accordingly.\n*\n* @param[in] config The shared pointer to the configuration object.\n*/\nvoid configureLogging( const shared_ptr< Config > & config )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  int waitForTimeRelative(int64_t timeout_ms) {\n    if (timeout_ms == 0LL) {\n      return waitForever();\n    }\n\n    assert(mutex_);\n    std::timed_mutex* mutexImpl =\n      static_cast<std::timed_mutex*>(mutex_->getUnderlyingImpl());\n    assert(mutexImpl);\n\n    std::unique_lock<std::timed_mutex> lock(*mutexImpl, std::adopt_lock);\n    bool timedout = (conditionVariable_.wait_for(lock, std::chrono::milliseconds(timeout_ms)) == std::cv_status::timeout);\n    lock.release();\n    return (timedout ? THRIFT_ETIMEDOUT : 0);\n  }\n",
        "answer": "/** @brief Waits until the specified timeout in milliseconds for the condition to occur, or waits forever if timeout_ms == 0. Returns 0 if condition occurs, THRIFT_ETIMEDOUT on timeout, or an error code.\n*/\nvoid waitForTimeRelative(int64_t timeout_ms) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void gaussian1D(Array<float>& coeff, int N, float std) {\n    coeff.resize(N);\n    float sum = 0.0f;\n    for (int i = 0; i < N; ++i) {\n        float x = i - (N - 1) / 2.0f;\n        float p = -square(x / std) / 2.0f;\n        float y = exp(p);\n        coeff[i] = y;\n        sum += y;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        coeff[i] /= sum;\n    }   \n}\n",
        "answer": "/** @brief Generates a set of 1D gaussian filter coefficients of size N.\n*\n*  The coefficients are centered on element (N-1)/2 and have standard deviation given by std.\n*  The coefficients are normalized such that the sum across coeff is 1.0.\n*\n* @param[in,out] coeff An array of floats to hold the generated coefficients.\n* @param[in] N The size of the coefficient array.\n* @param[in] std The standard deviation of the gaussian filter.\n*/\nvoid gaussian1D(Array<float>& coeff, int N, float std) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int structInToJavaAddress(\r\n        JNIEnv *env, struct in_addr *address, jbyteArray java_address) {\r\n\r\n    if (java_address == NULL) {\r\n        return -1;\r\n    }\r\n\r\n    if (env->GetArrayLength(java_address) != sizeof(address->s_addr)) {\r\n        return -1;\r\n    }\r\n\r\n    jbyte *java_address_bytes;\r\n\r\n    java_address_bytes = env->GetByteArrayElements(java_address, NULL);\r\n\r\n    memcpy(java_address_bytes, &(address->s_addr), sizeof(address->s_addr));\r\n\r\n    env->ReleaseByteArrayElements(java_address, java_address_bytes, 0);\r\n\r\n    return 0;\r\n}\r\n",
        "answer": "/** @brief Converts a native address structure to a 4-byte array.\n*\n*  This function converts a native address structure to a 4-byte array. It throws a NullPointerException or an IOException in case of error. The normal return value is 0, and the return value of -1 indicates that an error has occurred.\n*\n* @param env A pointer to the JNI environment.\n* @param address A pointer to the native address structure.\n* @param java_address A pointer to the Java byte array.\n* @return Should not return, but returns 0 or -1 in case of error.\n*/\nvoid structInToJavaAddress(JNIEnv *env, struct in_addr *address, jbyteArray java_address) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void free_const(const void *p)\n{\n  std::free((void *) p);\n  p = NULL;\n}\n",
        "answer": "/** @brief Free a const pointer.\n*\n* This function frees a const pointer by casting it to a non-const pointer and then freeing it.\n*\n* @param[in] p The const pointer to be freed.\n*\n* @return Should not return\n*/\nvoid free_const(const void *p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   virtual void shutDown()\n   {\n      cout << \"Entering shutDown().\" << endl;\n      writeLogFile( );\n   }\n",
        "answer": "/** @brief Clean-up processing to be done before the program ends. This method is executed outside of a try block and should be implemeneted by the end-user.\n*\n*  This function is used for clean-up processing to be done before the program ends. It is executed outside of a try block and should be implemented by the end-user.\n*\n* @return Should not return\n*/\nvirtual void shutDown()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double RandNorm(double sigma)\n{\n#ifdef RAND_NORM_SAVE\n\tstatic short iset=0;\n\tstatic double saved;\n\tdouble r, v1, v2, fact;\n\tif(!iset) {\n\t\tdo {\n\t\t\tv1 = 2.0*Rand(1)-1.0;\n\t\t\tv2 = 2.0*Rand(1)-1.0;\n\t\t\tr = v1*v1 + v2*v2;\n\t\t} while( r >= 1.0 || r == 0.0);\n\t\tfact = sigma*sqrt(-2.*log(r)/r);\n\t\tsaved = v1*fact;\n\t\tiset = 1;\n\t\treturn v2*fact;\n\t}\n\tiset = 0;\n\treturn saved;\n#else\n\tdouble r, v1, v2, fact;\n\tdo {\n\t\tv1 = 2.0*Rand(1)-1.0;\n\t\tv2 = 2.0*Rand(1)-1.0;\n\t\tr = v1*v1 + v2*v2;\n\t} while( r >= 1.0 || r == 0.0);\n\tfact = sigma*sqrt(-2.*log(r)/r);\n\treturn v2*fact;\n#endif\n}\n",
        "answer": "/** @brief Generates normally distributed random numbers with zero mean and sqrt of variance sigma. Uses Box-Muller and Rand().\n*/\ndouble RandNorm(double sigma) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tLPVOID getMainFiber()\n\t\t{\n\t\t\treturn _ThreadMainFiber.getPointer();\n\t\t}\n",
        "answer": "/** @brief Get the main fiber for the calling thread.\n*\n*  This function returns the main fiber for the calling thread. If the thread has not been converted to a fiber, NULL is returned.\n*\n* @return The main fiber for the calling thread or NULL if the thread has not been converted to a fiber.\n*/\nLPVOID getMainFiber()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tbool\t\t\t\tonProcessModuleMessage(IModuleProxy * /* senderModuleProxy */, const CMessage &/* message */)\n\t\t{\n\t\t\treturn false;\n\t\t}\n",
        "answer": "/** @brief Called internally by basic module imp to process the message by application code. The system will call each interceptor until one return true.\n*\n*  This function is called by the basic module implementation to process a message sent by an application. The system will call each interceptor in turn, and the first one that returns true will be considered the handler for the message. If no interceptors return true, the message will be ignored.\n*\n* @param senderModuleProxy A pointer to the module proxy of the sender of the message.\n* @param message The message to be processed.\n* @return True if the message was handled by this interceptor, false otherwise.\n*/\nbool\t\t\t\tonProcessModuleMessage(IModuleProxy * /* senderModuleProxy */, const CMessage &/* message */)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvoid getCounters(uint32 &oneSlot, uint32 &treeSlots, uint32 &allSlots)\n\t\t{\n\t\t\toneSlot = _Slots[0];\n\t\t\ttreeSlots = _Slots[0]+_Slots[1]+_Slots[2];\n\t\t\tallSlots = _CounterSum;\n\t\t}\n",
        "answer": "/** @brief Returns the sum of the first slot, the tree first slot and the total of all slots.\n*  This is useful to understand the behavoir of a crashing service over the sampling period.\n*\n* @param[out] oneSlot The sum of the first slot.\n* @param[out] treeSlots The sum of the three first slots.\n* @param[out] allSlots The total of all slots.\n*/\nvoid getCounters(uint32 &oneSlot, uint32 &treeSlots, uint32 &allSlots)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static GLboolean args_match( const struct state_key *key, GLuint unit )\n{\n   GLuint i, numArgs = key->unit[unit].NumArgsRGB;\n\n   for (i = 0; i < numArgs; i++) {\n      if (key->unit[unit].OptA[i].Source != key->unit[unit].OptRGB[i].Source) \n\t return GL_FALSE;\n\n      switch (key->unit[unit].OptA[i].Operand) {\n      case OPR_SRC_ALPHA: \n\t switch (key->unit[unit].OptRGB[i].Operand) {\n\t case OPR_SRC_COLOR: \n\t case OPR_SRC_ALPHA: \n\t    break;\n\t default:\n\t    return GL_FALSE;\n\t }\n\t break;\n      case OPR_ONE_MINUS_SRC_ALPHA: \n\t switch (key->unit[unit].OptRGB[i].Operand) {\n\t case OPR_ONE_MINUS_SRC_COLOR: \n\t case OPR_ONE_MINUS_SRC_ALPHA: \n\t    break;\n\t default:\n\t    return GL_FALSE;\n\t }\n\t break;\n      default: \n\t return GL_FALSE;\t/* impossible */\n      }\n   }\n\n   return GL_TRUE;\n}\n",
        "answer": "/** @brief Check if the RGB and Alpha sources and operands match for the given texture unit's combinder state.\n*\n*  This function checks whether the RGB and Alpha sources and operands match for a given texture unit's combinder state. When the RGB and A sources and operands match, we can emit fewer instructions.\n*\n* @param key The struct state_key that contains the information about the current texture unit's combinder state.\n* @param unit The texture unit number for which to check the RGB and Alpha sources and operands.\n* @return GLboolean indicating whether the RGB and Alpha sources and operands match (GL_TRUE) or not (GL_FALSE).\n*/\nstatic GLboolean args_match(const struct state_key *key, GLuint unit)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LineParameters computeNormals(const std::vector<Point2D>& _points) {\n    return computeNormals(_points, std::vector<double>(_points.size(),1.0));\n}\n",
        "answer": "/** @brief Computes the line parameters that minimize the perpendicular errors from the points to the line.\n*\n*  This function fits a line in the weighted least squares sense to the points, in cartesian coordinates, minimizing the perpendicular errors from the points to the line.\n*\n* @param _points A vector of 2D points.\n* @param weights A vector of weights for each point.\n* @return The line parameters that minimize the perpendicular errors from the points to the line.\n*/\nLineParameters computeNormals(const std::vector<Point2D>& _points, const std::vector<double>& weights) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SCSAPI_VOID telemetry_store_dplacement(const scs_string_t name, const scs_u32_t index, const scs_value_t *const value, const scs_context_t context)\n{\n\tassert(context);\n\tscs_value_dplacement_t *const storage = static_cast<scs_value_dplacement_t *>(context);\n\n\tif (value) {\n\t\tassert(value->type == SCS_VALUE_TYPE_dplacement);\n\t\t*storage = value->value_dplacement;\n\t}\n\telse {\n\t\tstorage->position.x = 0.0;\n\t\tstorage->position.y = 0.0;\n\t\tstorage->position.z = 0.0;\n\t\tstorage->orientation.heading = 0.0f;\n\t\tstorage->orientation.pitch = 0.0f;\n\t\tstorage->orientation.roll = 0.0f;\n\t}\n}\n",
        "answer": "/**\n* @brief Stores the dplacement value in the context.\n*\n* This function stores the dplacement value in the context, which can be used to retrieve the value later. If the value is not available, it will store zeros instead.\n*\n* @param name The name of the dplacement value.\n* @param index The index of the dplacement value.\n* @param value The dplacement value to store.\n* @param context The context in which to store the value.\n*/\n*storage = value->value_dplacement;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline btScalar\tcalculateCombinedFriction(btScalar friction0,btScalar friction1)\r\n{\r\n\tbtScalar friction = friction0*friction1;\r\n\r\n\tconst btScalar MAX_FRICTION  = btScalar(10.);\r\n\r\n\tif (friction < -MAX_FRICTION)\r\n\t\tfriction = -MAX_FRICTION;\r\n\tif (friction > MAX_FRICTION)\r\n\t\tfriction = MAX_FRICTION;\r\n\treturn friction;\r\n\r\n}\r\n",
        "answer": "/** @brief Calculates the combined friction between two objects.\n*\n*  This function calculates the combined friction between two objects based on their individual frictions. The resulting friction is clamped to a maximum value of 10.\n*\n* @param friction0 The friction of the first object.\n* @param friction1 The friction of the second object.\n* @return The combined friction between the two objects.\n*/\ninline btScalar calculateCombinedFriction(btScalar friction0, btScalar friction1)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "cnmemStatus_t cnmemRelease() {\n    CNMEM_CHECK_TRUE(cnmem::Context::check(), CNMEM_STATUS_NOT_INITIALIZED);\n    return cnmem::Context::release();\n}\n",
        "answer": "/** @brief Decreases the internal reference counter of the library.\n*\n*  This function is used to give more control to the user over the lifetime of the library. It is useful with scoped memory allocation which may be destroyed in a final memory collection after the end of main(). That function is thread-safe.\n*\n* @return Should not return\n*/\ncnmemStatus_t cnmemRelease() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void getPBO(GLuint& index, GLsizei size, GLubyte*& payload) {\n  index=1;\n  payload = new GLubyte[size];\n  std::cout << \"fake getPBO: size=\"<<size<<std::endl;\n}\n",
        "answer": "/** @brief Get PBO from the GPU. There are two versions of this function: other one can be enabled in source for valgrind debugging.\n*  This is the description of the functionality of the function.\n*\n* @param index The index of the PBO to get.\n* @param size The size of the payload.\n* @param payload The payload data.\n*/\nvoid getPBO(GLuint& index, GLsizei size, GLubyte*& payload) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool GetFrameTiming(Compositor_FrameTiming *pTiming, uint32_t unFramesAgo = 0)\n\t{\n\t\treturn m_compositor->GetFrameTiming(pTiming, unFramesAgo);\n\t}\n",
        "answer": "/** @brief Get frame timing information.\n*\n* This function returns the timing data for a specific frame. If the frame is older than the stored history, it will return false and set the oldest timing info. Be sure to set pTiming->size = sizeof(Compositor_FrameTiming) on struct passed in before calling this function.\n*\n* @param[in] pTiming Pointer to a Compositor_FrameTiming struct that will be filled with the frame timing data.\n* @param[in] unFramesAgo The number of frames ago that you want to retrieve the timing data for. Default is 0, which returns the most recent frame.\n* @return True if timing data was filled in, false if the frame is older than the stored history and the oldest timing info was set instead.\n*/\nvirtual bool GetFrameTiming(Compositor_FrameTiming *pTiming, uint32_t unFramesAgo = 0)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void CompositorBringToFront()\n\t{\n\t\treturn m_compositor->CompositorBringToFront();\n\t}\n",
        "answer": "/** @brief Brings the compositor window to the front.\n*\n*  This is useful for covering any other window that may be on the HMD and is obscuring the compositor window.\n*\n* @return Should not return\n*/\nvirtual void CompositorBringToFront()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual vr::EVRCompositorError GetMirrorTextureD3D11(vr::EVREye eEye, void *pD3D11DeviceOrResource, void **ppD3D11ShaderResourceView)\n\t{\n\t\treturn m_compositor->GetMirrorTextureD3D11(eEye, pD3D11DeviceOrResource, ppD3D11ShaderResourceView);\n\t}\n",
        "answer": "/** @brief Opens a shared D3D11 texture with the undistorted composited image for each eye.\n*\n*  Use ReleaseMirrorTextureD3D11 when finished instead of calling Release on the resource itself.\n*\n* @param eEye The eye for which to get the mirror texture.\n* @param pD3D11DeviceOrResource A pointer to the D3D11 device or resource.\n* @param ppD3D11ShaderResourceView A pointer to a pointer that will be set to the shader resource view of the mirror texture.\n*\n* @return An vr::EVRCompositorError indicating the result of the operation.\n*/\nvirtual vr::EVRCompositorError GetMirrorTextureD3D11(vr::EVREye eEye, void *pD3D11DeviceOrResource, void **ppD3D11ShaderResourceView)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual HmdMatrix34_t GetEyeToHeadTransform(EVREye eEye)\n\t{\n\t\treturn m_system->GetEyeToHeadTransform(eEye);\n\t}\n",
        "answer": "/** @brief Returns the transform from eye space to the head space. Eye space is the per-eye flavor of head space that provides stereo disparity. Instead of Model * View * Projection the sequence is Model * View * Eye^-1 * Projection. Normally View and Eye^-1 will be multiplied together and treated as View in your application.\n*\n* @param eEye The eye for which to retrieve the transform.\n* @return The transform from eye space to head space.\n*/\nvirtual HmdMatrix34_t GetEyeToHeadTransform(EVREye eEye)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool IsDisplayOnDesktop()\n\t{\n\t\treturn m_system->IsDisplayOnDesktop();\n\t}\n",
        "answer": "/** @brief Determines if the headset display is part of the desktop (i.e. extended) or hidden (i.e. direct mode).\n*\n*  This function uses the m_system object to determine if the headset display is part of the desktop or hidden.\n*\n* @return True if the headset display is part of the desktop, false otherwise.\n*/\nvirtual bool IsDisplayOnDesktop()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual vr::TrackedDeviceIndex_t GetTrackedDeviceIndexForControllerRole(vr::ETrackedControllerRole unDeviceType)\n\t{\n\t\treturn m_system->GetTrackedDeviceIndexForControllerRole(unDeviceType);\n\t}\n",
        "answer": "/** @brief Get the device index for a specific controller role.\n*\n*  This function returns the device index associated with a specific controller role, such as the left hand or the right hand. This function is deprecated in favor of the new IVRInput system.\n*\n* @param unDeviceType The type of controller role to get the device index for.\n* @return The device index associated with the specified controller role.\n*/\nvirtual vr::TrackedDeviceIndex_t GetTrackedDeviceIndexForControllerRole(vr::ETrackedControllerRole unDeviceType)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual int32_t GetInt32TrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError *pError = 0L)\n\t{\n\t\treturn m_system->GetInt32TrackedDeviceProperty(unDeviceIndex, prop, pError);\n\t}\n",
        "answer": "/** @brief Get the int32 tracked device property.\n*\n*  This function returns an int32 property of a tracked device. If the device index is not valid or the property is not a int type this function will return 0.\n*\n* @param unDeviceIndex The index of the tracked device.\n* @param prop The property to retrieve.\n* @param pError A pointer to an ETrackedPropertyError that will be set to the error code if the function fails.\n* @return An int32 property of the tracked device, or 0 if the function fails.\n*/\nvirtual int32_t GetInt32TrackedDeviceProperty(vr::TrackedDeviceIndex_t unDeviceIndex, ETrackedDeviceProperty prop, ETrackedPropertyError *pError = 0L)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void TriggerHapticPulse(vr::TrackedDeviceIndex_t unControllerDeviceIndex, uint32_t unAxisId, unsigned short usDurationMicroSec)\n\t{\n\t\tm_system->TriggerHapticPulse(unControllerDeviceIndex, unAxisId, usDurationMicroSec);\n\t}\n",
        "answer": "/** @brief Trigger a single haptic pulse on a controller.\n*\n*  This function triggers a haptic pulse on the specified controller and axis. After this call, the application may not trigger another haptic pulse on this controller and axis combination for 5ms. This function is deprecated in favor of the new IVRInput system.\n*\n* @param unControllerDeviceIndex The index of the controller device to trigger the haptic pulse on.\n* @param unAxisId The ID of the axis to trigger the haptic pulse on.\n* @param usDurationMicroSec The duration of the haptic pulse in microseconds.\n*\n* @return Should not return\n*/\nvoid TriggerHapticPulse(vr::TrackedDeviceIndex_t unControllerDeviceIndex, uint32_t unAxisId, unsigned short usDurationMicroSec)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual vr::EVRFirmwareError PerformFirmwareUpdate(vr::TrackedDeviceIndex_t unDeviceIndex)\n\t{\n\t\treturn m_system->PerformFirmwareUpdate(unDeviceIndex);\n\t}\n",
        "answer": "/** @brief Performs the actual firmware update if applicable.\n*\n*  This function performs the actual firmware update if applicable. It will send the following events if VRFirmwareError_None was returned: VREvent_FirmwareUpdateStarted, VREvent_FirmwareUpdateFinished\n*  Use the properties Prop_Firmware_UpdateAvailable_Bool, Prop_Firmware_ManualUpdate_Bool, and Prop_Firmware_ManualUpdateURL_String to figure out whether a firmware update is available, and to figure out whether it's a manual update.\n*  Prop_Firmware_ManualUpdateURL_String should point to an URL describing the manual update process.\n*\n* @param unDeviceIndex The device index for which the firmware update should be performed.\n* @return VRFirmwareError_None if the operation was successful, or a relevant error code otherwise.\n*/\nvirtual vr::EVRFirmwareError PerformFirmwareUpdate(vr::TrackedDeviceIndex_t unDeviceIndex)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ControlEntryGump::ChildNotify(Gump *child, uint32 message)\n{\n\tObjId cid = child->getObjId();\n\tif (message == ButtonWidget::BUTTON_CLICK)\n\t{\n\t\tif (cid == button->getObjId())\n\t\t{\n\t\t\tModalGump* gump = new BindGump(&bindingName, parent);\n\t\t\tgump->InitGump(0);\n\t\t\tgump->setRelativePosition(CENTER);\n\t\t}\n\t}\n\telse if (message == BindGump::UPDATE)\n\t{\n\t\tparent->ChildNotify(child, message);\n\t}\n}\n",
        "answer": "/** @brief ControlEntryGump child notify.\n*\n*  This function is used by our children to notifty us of 'something' Think of it as a generic call back function\n*\n* @param[in] child The child gump that sent the notification.\n* @param[in] message The message sent by the child gump.\n*\n* @return void\n*/\nvoid ControlEntryGump::ChildNotify(Gump *child, uint32 message)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  unsigned im_search(const char* pybuf, unsigned pylen) {\n    if (NULL == matrix_search)\n      return 0;\n\n    matrix_search->search(pybuf, pylen);\n    return matrix_search->get_candidate_num();\n  }\n",
        "answer": "/** @brief Searches for a word in the dictionary using a Pinyin string.\n*\n* This function searches for a word in the dictionary using a Pinyin string. The search is performed incrementally, based on the previous search result stored in the decoder. If the caller needs to do a brand new search, they should call im_reset_search() first. Calling im_search() is equivalent to calling im_add_letter() one by one.\n*\n* @param pybuf The Pinyin string to search for.\n* @param pylen The length of the Pinyin string.\n* @return The number of candidates found.\n*/\nunsigned im_search(const char* pybuf, unsigned pylen) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void giw_cleanup(AppHandler handler)\n{\n    QApplication* app = static_cast<QApplication*>(handler);\n\n    if (app == nullptr) {\n        RAISE_PY_EXCEPTION(PyExc_RuntimeError,\n                           \"giw_terminate received null application handler\");\n        return;\n    }\n\n    QApplication::exit();\n    delete app;\n}\n",
        "answer": "/** @brief Cleanup GIW application.\n*\n*  This function should be called prior to the application shutdown, in order to release some of the resources acquired by the underlying GUI library.\n*\n* @param handler The application handler.\n* @return void.\n*/\nvoid giw_cleanup(AppHandler handler)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString formatDimensionParticipation(const QList<QPair<double, QString> >& participation, bool ratio) {\n  int maxStrSize = 0;\n  for (int i=0; i<participation.size(); i++) {\n    maxStrSize = qMax(maxStrSize, participation[i].second.size());\n  }\n\n  QString fmt = \"  %1 : %2%\";\n  if (ratio) fmt = \"  %1 : x %2\";\n\n  QStringList result;\n  for (int i=0; i<participation.size(); i++) {\n    const QPair<double, QString>& p = participation[i];\n    result << fmt\n      .arg(p.second + QString(maxStrSize-p.second.size(), ' '))\n      .arg(p.first);\n  }\n\n  return result.join(\"\\n\");\n}\n",
        "answer": "/**\n* @brief Formats the results of the dimensionParticipation function into a nicely printable string. If ratio == true, prints \"x 1.23\" instead of \"1.23%\".\n*\n* @param participation A list of pairs of doubles and strings representing the participation of each dimension in the dataset.\n* @param ratio Whether to display the ratios or not.\n* @return A string representation of the formatted data.\n*/\nQString formatDimensionParticipation(const QList<QPair<double, QString> >& participation, bool ratio) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                        bool fOverrideMempoolLimit, const CAmount nAbsurdFee, bool fDryRun)\n{\n    return AcceptToMemoryPoolWithTime(pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, fDryRun);\n}\n",
        "answer": "/** @brief Add a transaction to the memory pool.\n*\n*  This function is used to add a transaction to the memory pool. It takes in a reference to the memory pool, a validation state, and a transaction reference as parameters. It also has several optional parameters for controlling the behavior of the function.\n*\n* @param[in] pool The memory pool to which the transaction will be added.\n* @param[in] state The validation state used to validate the transaction.\n* @param[in] tx The transaction reference that will be added to the memory pool.\n* @param[in] fLimitFree Whether or not to limit the number of free transactions in the memory pool.\n* @param[out] pfMissingInputs A pointer to a boolean value that will be set to true if any inputs are missing from the transaction.\n* @param[out] plTxnReplaced A list of transaction references that were replaced from the memory pool.\n* @param[in] fOverrideMempoolLimit Whether or not to override the memory pool limit.\n* @param[in] nAbsurdFee The absurd fee threshold for the transaction.\n* @param[in] fDryRun Whether or not this is a dry run (i.e., whether or not to actually add the transaction to the memory pool).\n*\n* @return True if the transaction was successfully added to the memory pool, false otherwise.\n*/\nbool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void FreeHeapData(HEAP *Heap, void_dest destructor) {\n  HEAPENTRY Entry;\n\n  while (GetTopOfHeap (Heap, &Entry) != EMPTY)\n    destructor (Entry.Data);\n\n  FreeHeap(Heap);\n}                                /* FreeHeapData */\n",
        "answer": "/** @brief Deallocates the memory consumed by the heap and calls Deallocator for each item in the heap.\n*\n* This routine is similar to FreeHeap in that it deallocates the memory consumed by the heap. However, it also calls Deallocator for each item in the heap so that this data is also deallocated.\n*\n* @param Heap The heap to be freed.\n* @param destructor A function pointer to a function that will be called on each item in the heap before it is freed.\n*\n* @return None\n*/\nvoid FreeHeapData(HEAP *Heap, void_dest destructor) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT void __stdcall CSimStop(double* /*PInput*/,\r\n                                  double* /*POutput*/,\r\n                                  double* /*PUser*/)\r\n{\r\n  simulation.reset();\r\n}\r\n",
        "answer": "/** @brief Simulation stop function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid __stdcall CSimStop(double* /*PInput*/,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CheckErrorGL(const char* file, const int line)\n{\n    GLenum errCode;\n    const GLubyte *errString;\n\n    if ((errCode = glGetError()) != GL_NO_ERROR)\n    {\n        fprintf(stderr, \"GL Error in file '%s' in line %d :\\n\", file, line);\n        errString = gluErrorString(errCode);\n        fprintf(stderr, \"%s\\n\", errString);\n    }\n}\n",
        "answer": "/** @brief Error printing function called by CHECK_GL_ERROR_MACRO(), which is only defined when _DEBUG is defined.\n*\n* This function prints an error message to stderr if there is a GL error. It takes two arguments, file and line, which are used to print the location of the error in the code.\n*\n* @param file The name of the file where the error occurred.\n* @param line The line number where the error occurred.\n*/\nvoid CheckErrorGL(const char* file, const int line)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool matchesLdrFilename(const QString &file) {\n    QRegExp exp(\n        \".*\\\\.(jpeg|jpg|tiff|tif|crw|cr2|nef|dng|mrw|orf|kdc|dcr|arw|\"\n        \"raf|ptx|pef|\"\n        \"x3f|raw|sr2|rw2)$\",\n        Qt::CaseInsensitive);\n    return exp.exactMatch(file);\n}\n",
        "answer": "/** @brief Checks if a file name matches the pattern for LDR images.\n*\n*  This function checks if a file name matches the pattern for LDR (Low Dynamic Range) images, which are typically used in computer vision and image processing applications. The pattern is defined as files with extensions .jpeg, .jpg, .tiff, .tif, .crw, .cr2, .nef, .dng, .mrw, .orf, .kdc, .dcr, .arw, .raf, .ptx, .pef, .x3f, .raw, .sr2, and .rw2.\n*\n* @param file The file name to check.\n* @return True if the file name matches the LDR pattern, false otherwise.\n*/\nbool matchesLdrFilename(const QString &file) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t doTlsThread(unsigned, unsigned)\n{\n    size_t value;\n\n    for (size_t i = 0; i < Iterations; ++i) {\n        value = *tls;\n        *tls = value + 1;\n    }\n\n    return Iterations;\n}\n",
        "answer": "/** @brief Performs TLS thread operations.\n*\n* This function performs the TLS (Thread Local Storage) operations for a given thread.\n* It takes two unsigned integers as input, which are used to index into the TLS storage.\n* The function then iterates over the TLS storage and performs the necessary operations\n* on each element.\n*\n* @param tls The TLS storage to operate on.\n* @param Iterations The number of iterations to perform.\n*\n* @return The number of iterations performed.\n*/\n*tls = value + 1;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void rf12_setRawRecvMode(uint8_t fixed_pkt_len) {\n    rf12_fixed_pkt_len = fixed_pkt_len > RF_MAX ? RF_MAX : fixed_pkt_len;\n}\n",
        "answer": "/** @brief Set the raw receive mode.\n*\n*  This function sets the raw receive mode for the RF12 module.\n*\n* @param[in] fixed_pkt_len The length of the packet to be received.\n*/\nvoid rf12_setRawRecvMode(uint8_t fixed_pkt_len) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void executeLogic()\n        {\n        }\n",
        "answer": "/** @brief Virtual function for executing the logic of a soft sensor.\n*\n*  This function will be executed if an input attribute is updated.\n*  It should contain the logic for the soft sensor, as defined by the developer.\n*\n* @return void\n*/\nvirtual void executeLogic()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "IPCAStatus IPCA_CALL IPCADiscoverDevices(\n                                    IPCAAppHandle ipcaAppHandle,\n                                    IPCADiscoverDeviceCallback callback,\n                                    void* context,\n                                    const char* const* resourceTypeList,\n                                    int resourceTypeCount,\n                                    IPCAHandle* handle)\n{\n    App::Ptr app = FindApp(reinterpret_cast<size_t>(ipcaAppHandle));\n    if (app == nullptr)\n    {\n        return IPCA_INVALID_ARGUMENT;\n    }\n\n    return app->DiscoverDevices(callback, context, resourceTypeList, resourceTypeCount, handle);\n}\n",
        "answer": "/**\n* @brief IPCA Discover Devices\n*\n* This method allows an application to discover devices that implement resource types specified in resourceTypeList. The underlying framework triggers discovery request periodically until caller cancels the request using IPCACloseHandle().\n*\n* @param ipcaAppHandle A handle to the IPCA application\n* @param callback A pointer to a function that will be called when a device is discovered or an error occurs during discovery. The function should have the following signature: void (*IPCADiscoverDeviceCallback)(IPCAStatus status, const char* deviceId, void* context)\n* @param context A pointer to user-defined data that will be passed to the callback function.\n* @param resourceTypeList An array of strings specifying the resource types to discover.\n* @param resourceTypeCount The number of elements in resourceTypeList.\n* @param handle A pointer to an IPCAHandle object that will be set to a handle for the discovery request. This handle can be used to cancel the discovery request using IPCACloseHandle().\n* @return IPCA_OK if successful, or an error code if there was a problem with the function call.\n*/\nIPCAStatus IPCA_CALL IPCADiscoverDevices("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "IPCAStatus IPCA_CALL IPCAGetResourceInterfaces(IPCADeviceHandle deviceHandle,\n                            const char* resourcePath,\n                            char*** resourceInterfaceList,\n                            size_t* resourceInterfaceCount)\n{\n    DeviceWrapper* deviceWrapper = (DeviceWrapper*)deviceHandle;\n    return deviceWrapper->device->GetResourceInfo(resourcePath,\n                ResourceInfoType::ResourceInterface, resourceInterfaceList, resourceInterfaceCount);\n}\n",
        "answer": "/** @brief Get the list of resource interfaces implemented by a resource.\n*\n*  This function retrieves the list of resource interfaces implemented by a resource. The application must call IPCAFreeStringArray() to free memory allocated for resourceInterfaceList.\n*\n* @param[in] deviceHandle Handle to the device that contains the resource.\n* @param[in] resourcePath Path to the resource.\n* @param[out] resourceInterfaceList Pointer to a pointer that will be set to an array of strings containing the resource interfaces implemented by the resource.\n* @param[out] resourceInterfaceCount Pointer to a size_t that will be set to the number of elements in resourceInterfaceList.\n*\n* @return IPCAStatus indicating whether the operation succeeded or failed.\n*/\nIPCAStatus IPCA_CALL IPCAGetResourceInterfaces(IPCADeviceHandle deviceHandle,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "IPCAStatus IPCA_CALL IPCAPropertyBagGetResourcePath(\n                                    IPCAPropertyBagHandle propertyBagHandle,\n                                    char** resourcePath)\n{\n    if (propertyBagHandle == nullptr)\n    {\n        return IPCA_INVALID_ARGUMENT;\n    }\n\n    return AllocateAndCopyStringToFlatBuffer(\n                (reinterpret_cast<const OC::OCRepresentation*>(propertyBagHandle))->getUri(),\n                resourcePath);\n}\n",
        "answer": "/**\n* @brief Get the resource path of the property bag.\n*\n* Use IPCAPropertyBagFreeString() to free string buffer returned in resourcePath.\n*\n* @param[in]  propertyBagHandle The handle to the property bag.\n* @param[out] resourcePath      The resource path of the property bag.\n*\n* @return IPCA_OK on success, or an error code otherwise.\n*/\nIPCAStatus IPCA_CALL IPCAPropertyBagGetResourcePath("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "MPMResult pluginReconnect(MPMPluginCtx *, MPMPipeMessage *message)\n{\n    OIC_LOG(INFO, TAG,\n            \"Reconnect called! Reconnect to devices, create resources from the message/cloud/db/file.\");\n    echoResponse(message, \"ADD\");\n    return MPM_RESULT_OK;\n}\n",
        "answer": "/** @brief Plugin reconnect function.\n*\n*  This function is used to reconnect a thermostat after a system reboot. It is invoked once for each device reconnect request triggered by the client.\n*\n* @param[in] ctx The MPMPluginCtx context.\n* @param[in] message The MPMPipeMessage message.\n* @return MPM_RESULT_OK if successful, an error code otherwise.\n*/\nMPMResult pluginReconnect(MPMPluginCtx *ctx, MPMPipeMessage *message)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void communicationTestMaster()\n{\n\tHelper::delayMs(2000);\n\tuint32_t value = 0;\n\twhile (true) {\n\t\tfor (uint8_t i = 0; i < Display::cLedCount; ++i) {\n\t\t\tconst bool isBitSet = ((value&(1UL<<i)) != 0);\n\t\t\tDisplay::setLedLevel(i, (isBitSet ? Display::cMaximumLevel : 0));\n\t\t}\n\t\tDisplay::synchronizeAndShow();\n\t\tCommunication::sendData(value);\n\t\tvalue += 1;\n\t\tHelper::delayMs(2000);\n\t}\n}\n",
        "answer": "/** @brief Communication test master.\n*\n* This function is used to run a communication test. It will send a new value every two seconds and display it as a binary pattern on the snow flake.\n*\n* @return Should not return\n*/\nvoid communicationTestMaster()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void WriteMinMaxPairsToFile (char * filename, vector<TPairedExtrema> pairs)\r\n{\r\n\tofstream datafile; \r\n\tdatafile.open(filename);\r\n\t\r\n\tif (!datafile)\r\n\t{\r\n\t\tcout << \"Cannot open file \" << filename << \" for writing.\" << endl;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfor (vector<TPairedExtrema>::iterator p = pairs.begin(); p != pairs.end(); p++)\r\n\t{\r\n\t\tdatafile << to_string((long long)(*p).MinIndex) << endl;\r\n\t\tdatafile << to_string((long long)(*p).MaxIndex) << endl;\r\n\t}\r\n\r\n\tdatafile.close();\r\n}\r\n",
        "answer": "/** @brief Writes indices of extrema features to file, sorted according to their persistence. If no features were found, writes an empty file. Overwrites any existing file with the same name.\n*\n*  This function writes the indices of extrema features to a file, sorted according to their persistence. If no features were found, it writes an empty file. The function overwrites any existing file with the same name.\n*\n* @param filename The name of the file to write the data to.\n* @param pairs A vector of paired extrema indices, sorted according to their persistence.\n*/\nvoid WriteMinMaxPairsToFile (char * filename, vector<TPairedExtrema> pairs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setPriority (int priority) {\n\n  Scheduler::setRtPriority (priority);\n}\n",
        "answer": "/** @brief Set the priority of the scheduler.\n*\n*  This function sets the priority of the scheduler to the specified value. The priority must be between 1 and 99, inclusive. A value of 99 is not recommended as it can block the system...\n*\n* @param priority The new priority for the scheduler.\n*/\nvoid setPriority (int priority) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool StartHTTPServer()\n{\n    LogPrint(BCLog::HTTP, \"Starting HTTP server\\n\");\n    int rpcThreads = std::max((long)gArgs.GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n    LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n    std::packaged_task<bool(event_base*, evhttp*)> task(ThreadHTTP);\n    threadResult = task.get_future();\n    threadHTTP = std::thread(std::move(task), eventBase, eventHTTP);\n\n    for (int i = 0; i < rpcThreads; i++) {\n        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue);\n    }\n    return true;\n}\n",
        "answer": "/** @brief Start HTTP server.\n*\n*  This function starts the HTTP server, which is separate from InitHTTPServer to give users race-condition-free time to register their handlers between InitHTTPServer and StartHTTPServer.\n*\n* @return Returns true if the HTTP server was started successfully, false otherwise.\n*/\nbool StartHTTPServer() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)\n{\n    switch (type) {\n    case OUTPUT_TYPE_LEGACY: return key.GetID();\n    case OUTPUT_TYPE_P2SH_SEGWIT:\n    case OUTPUT_TYPE_BECH32: {\n        if (!key.IsCompressed()) return key.GetID();\n        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n        CScript witprog = GetScriptForDestination(witdest);\n        if (type == OUTPUT_TYPE_P2SH_SEGWIT) {\n            return CScriptID(witprog);\n        } else {\n            return witdest;\n        }\n    }\n    default: assert(false);\n    }\n}\n",
        "answer": "/** @brief Get a destination of the requested type (if possible) to the specified key.\n*\n*  This function returns a CTxDestination object for the given CPubKey and OutputType.\n*  The caller must make sure LearnRelatedScripts has been called beforehand.\n*\n* @param key The public key to get the destination for.\n* @param type The output type to use.\n*\n* @return A CTxDestination object representing the requested destination, or an empty object if the operation failed.\n*/\nCTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VGENINTERFACE_API SHORT GetvJoyVersion(void)\n{\n\treturn vJoyNS::GetvJoyVersion();\n}\n",
        "answer": "/** @brief Get the version of the vJoy interface.\n*\n*  This function returns the version number of the vJoy interface.\n*\n* @return The version number as a short integer.\n*/\nVGENINTERFACE_API SHORT GetvJoyVersion(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "u_int8_t Com_CheckAphaNum(char *string)\r\n{\r\n\tu_int8_t i, j;\r\n\r\n\tj = strlen(string);\r\n\r\n\tfor(i = 0; i < j; i++)\r\n\t{\r\n\t\tif(!((string[i] >= '0' && string[i] <= '9') || (string[i] >= 'A' && string[i] <= 'Z') || (string[i] >= 'a' && string[i] <= 'z')))\r\n\t\t\treturn 1;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n",
        "answer": "/** @brief Checks if a given string is alphanumeric.\n*\n* This function checks if the input string contains only valid characters, which are \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\". If any character in the string is not within this range, the function returns 1. Otherwise, it returns 0.\n*\n* @param string The input string to be checked for alphanumeric characters.\n* @return 0 if the string contains only valid characters, 1 otherwise.\n*/\nu_int8_t Com_CheckAphaNum(char *string)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void nvs_close(nvs_handle handle)\n{\n    Lock lock;\n    ESP_LOGD(TAG, \"%s %d\", __func__, handle);\n    auto it = find_if(begin(s_nvs_handles), end(s_nvs_handles), [=](HandleEntry& e) -> bool {\n        return e.mHandle == handle;\n    });\n    if (it == end(s_nvs_handles)) {\n        return;\n    }\n    s_nvs_handles.erase(it);\n    delete static_cast<HandleEntry*>(it);\n}\n",
        "answer": "/**\n* @brief Closes an NVS handle.\n*\n* This function should be called for each handle opened with nvs_open once the handle is not in use any more. Closing the handle may not automatically write the changes to nonvolatile storage. This has to be done explicitly using nvs_commit function. Once this function is called on a handle, the handle should no longer be used.\n*\n* @param[in] handle The NVS handle to close.\n*/\nextern \"C\" void nvs_close(nvs_handle handle);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: crave-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH (const PAIRTYPE(string, string) & item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\"\n      << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/** @brief HTTPPost function.\n*\n*  This function creates an HTTP POST request with the given message and headers.\n*\n* @param[in] strMsg The message to be sent in the POST request.\n* @param[in] mapRequestHeaders A map of request headers to be included in the POST request.\n* @return The constructed HTTP POST request as a string.\n*/\nstring HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t calculate_winlen(const size_t read_length, const double window_size)\n{\n    size_t winlen;\n    if (window_size >= 1.0) {\n        winlen = static_cast<size_t>(window_size);\n    } else {\n        winlen = static_cast<size_t>(window_size * read_length);\n    }\n\n    if (winlen == 0 || winlen > read_length) {\n        winlen = read_length;\n    }\n\n    return winlen;\n}\n",
        "answer": "/** @brief Calculates the size of the sliding window for quality trimming given a read length and a user-defined window-size (fraction or whole number).\n*\n*  This function calculates the size of the sliding window for quality trimming based on the read length and the user-defined window-size. If the window-size is greater than or equal to 1, it returns the window-size as an integer. Otherwise, it returns the product of the window-size and the read length as an integer. If the resulting value is 0 or greater than the read length, it returns the read length instead.\n*\n* @param[in] read_length The length of the read.\n* @param[in] window_size The user-defined window-size for quality trimming.\n* @return The size of the sliding window for quality trimming.\n*/\nsize_t calculate_winlen(const size_t read_length, const double window_size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int b64_encode(char *dest, const void *src, int len)\n{\n        int outsz = 0;\n\n        while (len > 0) {\n                encode_group(dest + outsz,\n                    (const unsigned char*)src,\n                    len > 3 ? 3 : len);\n                len -= 3;\n                src = (char*)src + 3 * sizeof(char);\n                outsz += 4;\n        }\n\n        return outsz;\n}\n",
        "answer": "/** @brief Encodes the given src string in Base64. It returns the encoded string size. Warning: don't use this function unless you know exactly how large the output is going to be.\n*\n*  This function encodes a given source string in Base64. It takes three arguments, dest, src, and len. Dest is the destination buffer for the encoded data, src is the source string to be encoded, and len is the length of the source string. The function returns the size of the encoded string.\n*\n* @param[out] dest The destination buffer for the encoded data.\n* @param[in] src The source string to be encoded.\n* @param[in] len The length of the source string.\n* @return The size of the encoded string.\n*/\nint b64_encode(char *dest, const void *src, int len)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "StringBuffer contextToPath(const char* cont) \n{\n    StringBuffer sb(cont);\n    sb.replaceAll(\"/\", \"\\\\\", 0);\n    return sb;\n}\n",
        "answer": "/** @brief Converts a context string to a path string on Symbian.\n*\n*  This function takes a context string as input and converts it to a path string that can be used on Symbian.\n*  The conversion involves replacing all forward slashes in the context string with backslashes, which are the directory separators on Symbian.\n*\n* @param cont A pointer to the context string to convert.\n* @return A StringBuffer object containing the converted path string.\n*/\nStringBuffer contextToPath(const char* cont)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double sigmoid2(double x, double loc, double scale) { return 1.0 / (1.0 + std::exp(-scale * x + scale * loc)); }\n",
        "answer": "/** @brief Sigmoid function with a customizable center and steepness.\n*\n*  This function implements the sigmoid function, which maps any real number to a value between 0 and 1.\n*  The center of the sigmoid is defined by the parameter loc, and the steepness is defined by the parameter scale.\n*\n* @param x The input value to the sigmoid function.\n* @param loc The center of the sigmoid function.\n* @param scale The steepness of the sigmoid function.\n* @return The output value of the sigmoid function.\n*/\ndouble sigmoid2(double x, double loc, double scale) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  size_t im_add_letter(char ch) {\n    return 0;\n  }\n",
        "answer": "/** @brief Adds a letter to the current spelling string kept by decoder.\n*\n* This function adds a Pinyin letter to the current spelling string kept by decoder. If the decoder fails in adding the letter, it will do nothing. im_get_sps_str() can be used to get the spelling string kept by decoder currently.\n*\n* @param ch The character to add to the spelling string.\n*\n* @return The size of the new spelling string.\n*/\nsize_t im_add_letter(char ch) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  Orient prev_orient(Orient orient) {\n    if(orient == Central)\n      return Central;\n    else\n      return static_cast<Orient>( ((orient-1)+(-1+4))%4+1 );\n  }\n",
        "answer": "/** @brief Returns the previous orientation.\n*\n*  This function takes an orientation as input and returns the previous orientation.\n*  The previous orientation is determined by subtracting one from the current orientation,\n*  wrapping around to the last orientation if necessary.\n*\n* @param orient The current orientation.\n* @return The previous orientation.\n*/\nOrient prev_orient(Orient orient) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool sortOnLength(const string* a, const string* b)\n{\n\treturn (*a).length() > (*b).length();\n}\n",
        "answer": "/** @brief Sort comparison function. Compares the length of the value of pointers in the vectors. The LONGEST strings will be first in the vector.\n*\n* @param a String pointer to be compared.\n* @param b String pointer to be compared.\n* @return True if the length of string pointed by a is greater than the length of string pointed by b, false otherwise.\n*/\nbool sortOnLength(const string* a, const string* b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void RunLLDBCommands(llvm::StringRef prefix,\n                     const llvm::ArrayRef<std::string> &commands,\n                     llvm::raw_ostream &strm) {\n  if (commands.empty())\n    return;\n  lldb::SBCommandInterpreter interp = g_vsc.debugger.GetCommandInterpreter();\n  if (!prefix.empty())\n    strm << prefix << \"\\n\";\n  for (const auto &command : commands) {\n    lldb::SBCommandReturnObject result;\n    strm << \"(lldb) \" << command << \"\\n\";\n    interp.HandleCommand(command.c_str(), result);\n    auto output_len = result.GetOutputSize();\n    if (output_len) {\n      const char *output = result.GetOutput();\n      strm << output;\n    }\n    auto error_len = result.GetErrorSize();\n    if (error_len) {\n      const char *error = result.GetError();\n      strm << error;\n    }\n  }\n}\n",
        "answer": "/** @brief Runs LLDB commands with a prefix and outputs the results to a stream.\n*\n* This function takes a prefix, an array of commands, and a stream as input. It runs each command through the LLDB command interpreter and outputs the result to the stream. If the prefix is not empty, it is output first. The output includes the command prompt and the command itself. If there is any output or error from the command, it is also included in the output.\n*\n* @param prefix A string that is output before running the commands.\n* @param commands An array of strings representing the LLDB commands to run.\n* @param strm The stream where the output will be written.\n*/\nvoid RunLLDBCommands(llvm::StringRef prefix, const llvm::ArrayRef<std::string> &commands, llvm::raw_ostream &strm) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void Sync_Gens_Window_CPUMenu_Debug(void)\n{\n\tSTUB();\n}\n",
        "answer": "/** @brief Synchronize the Graphics, Render submenu.\n*\n*  This function is used to synchronize the Graphics, Render submenu.\n*  It is a stub function that is currently empty and should be filled in\n*  with appropriate code to perform the necessary actions.\n*\n* @return None\n*/\nstatic void Sync_Gens_Window_CPUMenu_Debug(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void on_token_map_updated(const TokenMap::Ptr& token_map) { event_future_->set(); }\n",
        "answer": "/** @brief Callback for when the token map has changed.\n*\n*  This callback is called when the token map has been rebuilt, which can happen if keyspace metadata has changed or if a node is added/removed from a cluster.\n*\n* @param token_map A pointer to the updated token map.\n*/\nvirtual void on_token_map_updated(const TokenMap::Ptr& token_map) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void on_update_schema(SchemaType type,\n                                const ResultResponse::Ptr& result,\n                                const String& keyspace_name,\n                                const String& target_name)  { }\n",
        "answer": "/** @brief Callback for schema updates.\n*\n* This callback is called when a schema is created or updated. It will be called multiple times for each table and materialized view, once for each column and index. Columns and indexes are not updated without a preceding table or materialized view update.\n*\n* @param type The type of schema that was updated (table or materialized view).\n* @param result A pointer to the ResultResponse object containing information about the update.\n* @param keyspace_name The name of the keyspace that was updated.\n* @param target_name The name of the table or materialized view that was updated.\n*/\nvirtual void on_update_schema(SchemaType type,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void initialize() {\n    cass_cluster_set_use_beta_protocol_version(cluster, cass_false);\n    create_session();\n    test_utils::execute_query(session, str(boost::format(\n      test_utils::CREATE_KEYSPACE_SIMPLE_FORMAT)\n        % keyspace_\n        % \"3\"));\n    test_utils::execute_query(session, str(boost::format(SPEC_EX_TABLE_FORMAT)\n      % keyspace_\n      % test_name_));\n    test_utils::execute_query(session, str(boost::format(SPEC_EX_INSERT_FORMAT)\n      % keyspace_\n      % test_name_\n      % 0\n      % 1000));\n    test_utils::execute_query(session, str(boost::format(SPEC_EX_TIMEOUT_UDF_FORMAT)\n      % keyspace_));\n  }\n",
        "answer": "/** @brief Initialize the test case by creating the session and creating the necessary keyspaces, tables with data, and UDFs being utilized during query execution.\n*\n* @return Should not return\n*/\nvoid initialize() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void hdr_reset(struct hdr_histogram *h)\n{\n     h->total_count=0;\n     h->min_value = INT64_MAX;\n     h->max_value = 0;\n     memset((void *) &h->counts, 0, (sizeof(int64_t) * h->counts_len));\n     return;\n}\n",
        "answer": "/** @brief Reset a histogram to zero.\n*\n* This routine resets an existing histogram back to zero, re-initializing it for reuse.\n*\n* @param h The histogram to reset.\n*/\nvoid hdr_reset(struct hdr_histogram *h)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SgPoint PatternToPoint(int dx, int dy, const PaSpot& spot, int boardSize)\n{\n    return AXBoardToBoard(spot.m_x + dx,\n                          spot.m_y + dy,\n                          spot.m_ax,\n                          boardSize);\n}\n",
        "answer": "/** @brief Convert pattern move to point on board.\n*\n*  This function converts a pattern move to a point on the board. The pattern starting at spot: finds the point on the board corresponding to index 'n' in pattern. Returns 0 if out of board. Called e.g. to get move on Board from move index in pattern.\n*\n* @param dx The x-coordinate of the pattern move.\n* @param dy The y-coordinate of the pattern move.\n* @param spot The starting point of the pattern.\n* @param boardSize The size of the board.\n* @return The point on the board corresponding to the pattern move, or 0 if out of bounds.\n*/\nSgPoint PatternToPoint(int dx, int dy, const PaSpot& spot, int boardSize)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Expr mutate(Expr e) {\n        if (equal(e, find)) {\n            return replacement;\n        } else {\n            return IRMutator::mutate(e);\n        }\n    }\n",
        "answer": "/** @brief Mutates an expression.\n*\n*  This function is the main interface for using a mutator. Also call these in your subclass to mutate sub-expressions and sub-statements.\n*\n* @param e The expression to be mutated.\n* @return The mutated expression.\n*/\nExpr mutate(Expr e) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool can_prove(Expr e) {\n    internal_assert(e.type().is_bool())\n        << \"Argument to can_prove is not a boolean Expr: \" << e << \"\\n\";\n    return is_one(simplify(e));\n}\n",
        "answer": "/** @brief Checks if an expression can be proven.\n*\n* This function checks if a boolean Expr can be proven at compile time. It uses the simplify() function to reduce the expression and then checks if it is equal to one using the is_one() function.\n*\n* @param e The Expr to check.\n* @return True if the Expr can be proven, false otherwise.\n*/\nbool can_prove(Expr e) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int xmss_str_to_oid(uint32_t *oid, const char *s)\r\n{\r\n\tint n;\r\n\r\n\tfor ( n = 0 ; xmss_name_tab[n].name != NULL ; n++ ) {\r\n\t\tif ( !strcmp(s, xmss_name_tab[n].name) ) {\r\n\t\t\t*oid = xmss_name_tab[n].oid;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n    return -1;\r\n}\r\n",
        "answer": "/** @brief Converts a string representing an XMSS parameter set into its corresponding OID.\n*\n*  This function takes a string such as \"XMSS-SHA2_10_256\" and outputs the corresponding OID, such as 0x01000001. If the parameter set is not found, -1 is returned.\n*\n* @param oid The output OID.\n* @param s The input string representing the XMSS parameter set.\n*\n* @return 0 if the conversion was successful, -1 otherwise.\n*/\nint xmss_str_to_oid(uint32_t *oid, const char *s)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void base_w(const xmss_params *params,\r\n                   int *output, const int out_len, const unsigned char *input)\r\n{\r\n    int in = 0;\r\n    int out = 0;\r\n    unsigned char total;\r\n    int bits = 0;\r\n    int consumed;\r\n\r\n    for (consumed = 0; consumed < out_len; consumed++) {\r\n        if (bits == 0) {\r\n            total = input[in];\r\n            in++;\r\n            bits += 8;\r\n        }\r\n        bits -= params->wots_log_w;\r\n        output[out] = (total >> bits) & (params->wots_w - 1);\r\n        out++;\r\n    }\r\n}\r\n",
        "answer": "/**\n* @brief Interprets an array of bytes as integers in base w.\n*\n* This function interprets an array of bytes as integers in base w, where w is a power of 2. The function takes three arguments:\n* - `params`: A pointer to the XMSS parameters structure.\n* - `output`: An integer array that will be filled with the interpreted values.\n* - `out_len`: The length of the output array.\n* - `input`: The input byte array.\n*\n* The function returns nothing, but it modifies the contents of the `output` array.\n*\n* @param params A pointer to the XMSS parameters structure.\n* @param output An integer array that will be filled with the interpreted values.\n* @param out_len The length of the output array.\n* @param input The input byte array.\n*/\nstatic void base_w(const xmss_params *params, int *output, const int out_len, const unsigned char *input)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int xmss_core_sign_open(const xmss_params *params,\r\n                        unsigned char *m, unsigned long long *mlen,\r\n                        const unsigned char *sm, unsigned long long smlen,\r\n                        const unsigned char *pk)\r\n{\r\n    /* XMSS signatures are fundamentally an instance of XMSSMT signatures.\r\n       For d=1, as is the case with XMSS, some of the calls in the XMSSMT\r\n       routine become vacuous (i.e. the loop only iterates once, and address\r\n       management can be simplified a bit).*/\r\n    return xmssmt_core_sign_open(params, m, mlen, sm, smlen, pk);\r\n}\r\n",
        "answer": "/** @brief Verifies a given message signature pair under a given public key.\n*\n*  This function verifies a given message signature pair under a given public key.\n*  It assumes that the public key does not have an OID, i.e. [root || PUB_SEED].\n*\n* @param params The XMSS parameters.\n* @param m The message to be verified.\n* @param mlen The length of the message.\n* @param sm The signature to be verified.\n* @param smlen The length of the signature.\n* @param pk The public key used for verification.\n*\n* @return 0 if the signature is valid, -1 otherwise.\n*/\n/* XMSS signatures are fundamentally an instance of XMSSMT signatures.\nFor d=1, as is the case with XMSS, some of the calls in the XMSSMT"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static PLI_INT32 avr_get_pc_tf(char *xx) {\n    VPI_BEGIN();\n    VPI_UNPACKI(handle);\n    VPI_END();\n\n    AVR_HCHECK();\n\n    VPI_RETURN_INT(devices[handle]->cPC);\n}\n",
        "answer": "/** @brief Reads the value of the program counter in the AVR.\n*\n*  This function reads the value of the program counter in the AVR. Usage from Verilog: $avr_get_pc(handle) -> pc_value\n*\n* @param handle The handle to the device.\n* @return The value of the program counter.\n*/\nstatic PLI_INT32 avr_get_pc_tf(char *xx) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static PLI_INT32 avr_dump_start_tf(char *xx) {\n    DumpManager::Instance()->start();\n    return 0;\n}\n",
        "answer": "/** @brief Initialize all dumpers and start them. Has to be done before any clock ticks on any AVR devices, if dumping is used!\n*\n*  This function initializes all dumpers and starts them. It should be called before any clock ticks on any AVR devices, if dumping is used.\n*\n* @param xx A pointer to a character string that contains the name of the dumper to start.\n* @return Should not return\n*/\nstatic PLI_INT32 avr_dump_start_tf(char *xx) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\"  void GetDateNum (const char* const iToken[], uint32_t iTokenLen[], uint32_t iTokenNum, \n    char *const oToken, uint32_t& oTokenLen) {\n  int ts = gsql_ts_to_epoch_seconds(iToken, iTokenLen, iTokenNum) / 86400;\n  oTokenLen = sprintf(oToken, \"%d\", ts);\n}\n",
        "answer": "/** @brief Converts a token string to epoch seconds and then divides it by 86400 to get the day.\n*\n* This function takes in a token string, converts it first to epoch seconds using builtin functions,\n* and then divides it by 86400 to get the day. The resulting value is stored in the output parameter oToken.\n*\n* @param iToken A pointer to an array of characters representing the input token string.\n* @param iTokenLen An array of unsigned integers representing the length of each token.\n* @param iTokenNum The number of tokens in the input token string.\n* @param oToken A pointer to a character array where the output will be stored.\n* @param oTokenLen A reference to an unsigned integer that will be set to the length of the output token.\n*/\nvoid GetDateNum(const char* const iToken[], uint32_t iTokenLen[], uint32_t iTokenNum,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void init_closedloop() {\n  OUT_WRITE(CLOSED_LOOP_ENABLE_PIN, LOW);\n  SET_INPUT_PULLUP(CLOSED_LOOP_MOVE_COMPLETE_PIN);\n}\n",
        "answer": "/** @brief Initializes the closed-loop control system.\n*\n*  This function initializes the closed-loop control system by setting the\n*  enable pin to low and configuring the move complete pin as an input with\n*  pull-up resistor enabled.\n*\n* @return None\n*/\nvoid init_closedloop() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "float measuring_movement(const AxisEnum axis, const int dir, const bool stop_state, const bool fast) {\n  const float step  =            fast ? 0.25                      : CALIBRATION_MEASUREMENT_RESOLUTION;\n  const float mms   = MMM_TO_MMS(fast ? CALIBRATION_FEEDRATE_FAST : CALIBRATION_FEEDRATE_SLOW);\n  const float limit =            fast ? 50                        : 5;\n\n  set_destination_from_current();\n  for (float travel = 0; travel < limit; travel += step) {\n    destination[axis] += dir * step;\n    do_blocking_move_to(destination, mms);\n    planner.synchronize();\n    if (read_calibration_pin() == stop_state)\n      break;\n  }\n  return destination[axis];\n}\n",
        "answer": "/** @brief Measures the movement of a probe along an axis until it reaches a specific state.\n*\n* This function moves the probe along an axis in a specified direction until the probe value becomes a certain state, then returns the axis value.\n*\n* @param axis The axis along which the measurement will take place.\n* @param dir The direction along that axis (-1 or 1).\n* @param stop_state The desired state of the probe pin (true or false).\n* @param fast A flag indicating whether to perform a fast or precise measurement.\n*\n* @return The axis value at which the probe reached the specified state.\n*/\nfloat measuring_movement(const AxisEnum axis, const int dir, const bool stop_state, const bool fast) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void spiSendBlock(uint8_t token, const uint8_t* buf) {\n    (void)spiTransfer(token);\n    for (uint16_t i = 0; i < 512; i++)\n      (void)spiTransfer(buf[i]);\n  }\n",
        "answer": "/** @brief Write token and then write from 512 byte buffer to SPI (for SD card) SPI send block Soft SPI send block.\n*\n* This function writes a token and then writes data from a 512-byte buffer to the SPI bus (for an SD card). It sends a block of data using soft SPI.\n*\n* @param token The token to write.\n* @param buf The buffer containing the data to write.\n*/\nvoid spiSendBlock(uint8_t token, const uint8_t* buf) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) {\n  spiConfig = SPISettings(spiClock, bitOrder, dataMode);\n\n  SPI.beginTransaction(spiConfig);\n}\n",
        "answer": "/** @brief Begins an SPI transaction with the specified clock, bit order, and data mode.\n*\n* This function configures the SPI settings and begins a transaction using the configured settings.\n*\n* @param spiClock The SPI clock speed in Hz.\n* @param bitOrder The SPI bit order (either MSBFIRST or LSBFIRST).\n* @param dataMode The SPI data mode (either SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3).\n*/\nvoid spiBeginTransaction(uint32_t spiClock, uint8_t bitOrder, uint8_t dataMode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {\n    char str[12];\n    for (uint8_t i = 0; i < n; i++) {\n      SERIAL_CHAR(' ');\n      SERIAL_CHAR(axis_codes[i]);\n      SERIAL_CHAR(':');\n      SERIAL_ECHO(dtostrf(pos[i], 8, precision, str));\n    }\n    SERIAL_EOL();\n  }\n",
        "answer": "/** @brief Report the XYZE position of a point.\n*\n*  This function reports the XYZE position of a point with a specified precision.\n*\n* @param pos The position to report, as an array of floats.\n* @param n The number of axes to report (default: 4).\n* @param precision The precision to use when reporting the position (default: 3).\n*/\nvoid report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {\n    if (true\n      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)\n        && active_extruder == 0\n      #endif\n    ) {\n      zprobe_zoffset += offs;\n      SERIAL_ECHO_START();\n      SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET \": \", zprobe_zoffset);\n    }\n    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)\n      else {\n        hotend_offset[Z_AXIS][active_extruder] -= offs;\n        SERIAL_ECHO_START();\n        SERIAL_ECHOLNPAIR(MSG_IDEX_Z_OFFSET \": \", hotend_offset[Z_AXIS][active_extruder]);\n      }\n    #endif\n  }\n",
        "answer": "/**\n* @brief Modify Z probe offset.\n*\n* This function modifies the Z probe offset by the specified amount. If the BABYSTEP_HOTEND_Z_OFFSET option is enabled, it will also modify the hotend Z offset for the active extruder.\n*\n* @param offs The amount to adjust the Z probe offset by.\n*/\nFORCE_INLINE void mod_zprobe_zoffset(const float &offs) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void menu_job_recovery() {\n  ui.defer_status_screen(true);\n  START_MENU();\n  STATIC_ITEM(MSG_OUTAGE_RECOVERY);\n  MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);\n  MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);\n  END_MENU();\n}\n",
        "answer": "/** @brief Menu job recovery.\n*\n* This function displays a menu to recover from a power loss during a print job.\n* It allows the user to resume or cancel the print job.\n*\n* @return Should not return\n*/\nvoid menu_job_recovery() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void menu_tmc() {\n  START_MENU();\n  MENU_BACK(MSG_CONTROL);\n  MENU_ITEM(submenu, MSG_TMC_CURRENT, menu_tmc_current);\n  #if ENABLED(HYBRID_THRESHOLD)\n    MENU_ITEM(submenu, MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);\n  #endif\n  #if ENABLED(SENSORLESS_HOMING)\n    MENU_ITEM(submenu, MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);\n  #endif\n  #if HAS_STEALTHCHOP\n    MENU_ITEM(submenu, MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);\n  #endif\n  END_MENU();\n}\n",
        "answer": "/**\n* @brief Menu for TMC settings.\n*\n* This menu allows the user to configure various TMC settings, such as current, hybrid threshold, homing threshold, and stepping mode.\n*\n* @return Should not return\n*/\nvoid menu_tmc() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void _lcd_ubl_output_map() {\n  START_MENU();\n  MENU_BACK(MSG_UBL_LEVEL_BED);\n  MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_HOST, PSTR(\"G29 T0\"));\n  MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_CSV, PSTR(\"G29 T1\"));\n  MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_BACKUP, PSTR(\"G29 S-1\"));\n  MENU_ITEM(function, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map_lcd_cmd);\n  END_MENU();\n}\n",
        "answer": "/** @brief LCD menu for Unified Bed Leveling output map.\n*\n* This function displays a menu for the user to select an option for the Unified Bed Leveling (UBL) output map.\n* The options are:\n* - Host Output: G29 T0\n* - CSV Off Printer Backup Output: G29 T1\n* - Mesh Map: G29 S-1\n* - LCD Command: _lcd_ubl_output_map_lcd_cmd()\n*\n* @return Should not return\n*/\nvoid _lcd_ubl_output_map() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline float dist1(const float &x1, const float &y1, const float &x2, const float &y2) { return ABS(x1 - x2) + ABS(y1 - y2); }\n",
        "answer": "/** @brief Calculates the Euclidean distance between two points using the sum of coordinates offset.\n*\n*  This function approximates the Euclidean distance between two points (x1,y1) and (x2,y2) by calculating the sum of the coordinates offset.\n*\n* @param x1 The x-coordinate of the first point.\n* @param y1 The y-coordinate of the first point.\n* @param x2 The x-coordinate of the second point.\n* @param y2 The y-coordinate of the second point.\n* @return The Euclidean distance between the two points using the sum of coordinates offset.\n*/\nstatic inline float dist1(const float &x1, const float &y1, const float &x2, const float &y2) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void select_multiplexed_stepper(const uint8_t e) {\n  planner.synchronize();\n  disable_e_steppers();\n  WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);\n  WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);\n  WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);\n  safe_delay(100);\n}\n",
        "answer": "/** @brief Selects a multiplexed stepper.\n*\n*  This function selects one of the multiplexed steppers based on the value of the `e` parameter.\n*\n* @param e The index of the stepper to select (0-7).\n*/\nvoid select_multiplexed_stepper(const uint8_t e) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isDataProc(uint32_t instr) {\n  uint8_t opcode = (instr & 0x01E00000) >> 21;\n  if ((instr & 0xFC000000) != 0xE0000000) return false;\n\n  /* TST, TEQ, CMP and CMN all require S to be set */\n  bool S = !!(instr & 0x00100000);\n  if (!S && opcode >= 8 && opcode <= 11) return false;\n\n  return true;\n}\n",
        "answer": "/** @brief Checks if an instruction is a data-processing instruction.\n*\n*  This function decodes the passed instruction, checks if it is a data-processing\n*  instruction and verifies that the parameters and operation really indicate a\n*  data-processing instruction. This is needed because some parts of the instruction\n*  space under this instruction can be extended or represent other operations such as\n*  MRS, MSR.\n*\n* @param instr The instruction to check.\n* @return True if the instruction is a data-processing instruction, false otherwise.\n*/\n/* TST, TEQ, CMP and CMN all require S to be set */\nbool S = !!(instr & 0x00100000);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string perf_attr_to_string(const perf_event_attr* attr) {\n    std::string ret;\n    char* pmu = resolve_pmu(attr->type);\n    ret += std::string(pmu ? pmu : \"???\") + \"/\";\n\n#define APPEND_IF_NZ1(field) APPEND_IF_NZ2(field,field)\n#define APPEND_IF_NZ2(name, field) if (attr->field) ret += std::string(#name) + \"=0x\" + to_hex_string(attr->field) + \",\"\n\n    APPEND_IF_NZ1(config);\n    APPEND_IF_NZ1(config1);\n    APPEND_IF_NZ1(config2);\n    APPEND_IF_NZ2(period, sample_period);\n    APPEND_IF_NZ1(sample_type);\n    APPEND_IF_NZ1(read_format);\n\n\n    ret.at(ret.length() - 1) = '/';\n    return ret;\n}\n",
        "answer": "/**\n* @brief Converts a perf_event_attr object to a string representation suitable for use as an event for perf or just for display.\n*\n* Takes a perf_event_attr object and returns a string representation of the attributes in the format \"pmu/config=0x<value>,config1=0x<value>,config2=0x<value>,period=0x<value>,sample_type=0x<value>,read_format=0x<value>\".\n*\n* @param attr The perf_event_attr object to convert.\n* @return A string representation of the attributes in the format \"pmu/config=0x<value>,config1=0x<value>,config2=0x<value>,period=0x<value>,sample_type=0x<value>,read_format=0x<value>\".\n*/\nstd::string perf_attr_to_string(const perf_event_attr* attr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Normalise (real* src, real* dst, int n_elements)\n{\n\treal sum = 0.0f;\n\tint i;\n\tfor (i=0; i<n_elements; i++) {\n\t\tsum += src[i];\n\t}\n\tif (sum==0) {\n\t\tfor (i=0; i<n_elements; i++) {\n\t\t\tdst[i] = src[i];\n\t\t}\n\t\treturn;\n\t}\n\tassert(sum>0);\n\tfor (i=0; i<n_elements; i++) {\n\t\tdst[i] = src[i]/sum;\n\t}\n}\n",
        "answer": "/** @brief Normalise a vector to a destination vector (low level)\n*\n*  This function normalises a vector to a destination vector. The source vector is passed as a pointer, and the destination vector is passed as a pointer. The number of elements in the vectors is also passed as an integer. It is safe for src and dst to point at the same vector.\n*\n* @param[in] src A pointer to the source vector\n* @param[out] dst A pointer to the destination vector\n* @param[in] n_elements The number of elements in the vectors\n*\n* @return None\n*/\nvoid Normalise (real* src, real* dst, int n_elements)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void DFT(int length, float *realTimeIn, float *imagTimeIn, float *realFreqOut, float *imagFreqOut)\n  {\n    \n    int k, i;\n    float sr, si, p;\n    \n    memset(realFreqOut, 0, sizeof(float) * length);\n    memset(imagFreqOut, 0, sizeof(float) * length);\n    \n    for(k = 0; k < length; k++)\n      for(i = 0; i < length; i++)\n      {\n        p = (2.0f * PI * (float)(k * i)) / length;\n        sr = cosf(p);\n        si = -sinf(p);\n        realFreqOut[k] += (realTimeIn[i] * sr) - (imagTimeIn[i] * si);\n        imagFreqOut[k] += (realTimeIn[i] * si) + (imagTimeIn[i] * sr);\n      }\n  }\n",
        "answer": "/** @brief Discrete Fourier Transform (DFT)\n*\n* This function performs a non-FFT, brute force approach to compute the\n* discrete Fourier transform of an input signal. It is intended for wavetable\n* generation and should not be used for real-time processing.\n*\n* @param length The length of the input signal.\n* @param realTimeIn The real part of the input signal.\n* @param imagTimeIn The imaginary part of the input signal.\n* @param realFreqOut The real part of the output frequency spectrum.\n* @param imagFreqOut The imaginary part of the output frequency spectrum.\n*/\nvoid DFT(int length, float *realTimeIn, float *imagTimeIn, float *realFreqOut, float *imagFreqOut)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "calculateGroupParamLengths(uint32_t maxPLen, uint32_t securityLevel,\n                           uint32_t *pLen, uint32_t *qLen)\n{\n\t*pLen = *qLen = 0;\n\n\tif (securityLevel < 80) {\n\t\tthrow ZerocoinException(\"Security level must be at least 80 bits.\");\n\t} else if (securityLevel == 80) {\n\t\t*qLen = 256;\n\t\t*pLen = 1024;\n\t} else if (securityLevel <= 112) {\n\t\t*qLen = 256;\n\t\t*pLen = 2048;\n\t} else if (securityLevel <= 128) {\n\t\t*qLen = 320;\n\t\t*pLen = 3072;\n\t} else {\n\t\tthrow ZerocoinException(\"Security level not supported.\");\n\t}\n\n\tif (*pLen > maxPLen) {\n\t\tthrow ZerocoinException(\"Modulus size is too small for this security level.\");\n\t}\n}\n",
        "answer": "/** @brief Calculates the group parameter lengths for a given security level.\n*\n*  This function calculates the lengths of the \"p\" and \"q\" parameters for a given security level,\n*  based on the following constraints:\n*  - Security level must be at least 80 bits.\n*  - If security level is 80, then pLen = 1024 and qLen = 256.\n*  - If security level is between 80 and 112 (inclusive), then pLen = 2048 and qLen = 256.\n*  - If security level is between 112 and 128 (inclusive), then pLen = 3072 and qLen = 320.\n*  - If security level is greater than 128, then an exception is thrown.\n*\n* @param maxPLen The maximum length of the \"p\" parameter.\n* @param securityLevel The security level for which to calculate the group parameter lengths.\n* @param pLen A pointer to a uint32_t that will be set to the calculated length of the \"p\" parameter.\n* @param qLen A pointer to a uint32_t that will be set to the calculated length of the \"q\" parameter.\n*\n* @return void\n*/\n*pLen = *qLen = 0;\n*qLen = 256;\n*pLen = 1024;\n*qLen = 256;\n*pLen = 2048;\n*qLen = 320;\n*pLen = 3072;\n} else "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t version_datestamp() { return BOTAN_VERSION_DATESTAMP; }\n",
        "answer": "/** @brief Return the date this version of botan was released, in an integer of the form YYYYMMDD.\n*\n*  This function returns the date this version of botan was released, in an integer of the form YYYYMMDD. For instance a version released on May 21, 2013 would return the integer 20130521. If the currently running version is not an official release, this function will return 0 instead.\n*\n* @return Should return an integer of the form YYYYMMDD or 0 if it's not an official release.\n*/\nuint32_t version_datestamp() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    static bool edgeTargetsEdgeSource(const void *Node, EdgeIter I) {\n      return true;\n    }\n",
        "answer": "/** @brief Determines whether an outgoing edge should target another edge source.\n*\n*  This method returns true if this outgoing edge should actually target another edge source, not a node. If this method is implemented, getEdgeTarget should be implemented.\n*\n* @param Node The node that the edge originates from.\n* @param I An iterator for the edge.\n* @return True if the edge should target another edge source, false otherwise.\n*/\nstatic bool edgeTargetsEdgeSource(const void *Node, EdgeIter I) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void visitPostorderEdge(const SDep &PredDep, const SUnit *Succ) {\n    R.DFSNodeData[Succ->NodeNum].InstrCount\n      += R.DFSNodeData[PredDep.getSUnit()->NodeNum].InstrCount;\n    joinPredSubtree(PredDep, Succ);\n  }\n",
        "answer": "/** @brief Visit a postorder edge in the dominator tree.\n*\n* This function is called once for each tree edge after calling visitPostOrderNode on the predecessor. Increment the parent node's instruction count and preemptively join this subtree to its parent's if it is small enough.\n*\n* @param PredDep The predecessor dependency.\n* @param Succ The successor unit.\n*/\nvoid visitPostorderEdge(const SDep &PredDep, const SUnit *Succ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isIntImmediate(const SDNode *N, uint64_t &Imm) {\n  if (const ConstantSDNode *C = dyn_cast<const ConstantSDNode>(N)) {\n    Imm = C->getZExtValue();\n    return true;\n  }\n  return false;\n}\n",
        "answer": "/** @brief isIntImmediate - This method tests to see if the node is a constant operand. If so Imm will receive the 32-bit value.\n*\n* @param N The SDNode to test.\n* @param Imm The 32-bit value of the constant operand, if present.\n* @return True if the node is a constant operand, false otherwise.\n*/\nstatic bool isIntImmediate(const SDNode *N, uint64_t &Imm) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned getExtFactor(SDValue &V) {\n  EVT EltType = V.getValueType().getVectorElementType();\n  return EltType.getSizeInBits() / 8;\n}\n",
        "answer": "/** @brief Determine the adjustment factor for the position when generating an \"extract from vector registers\" instruction.\n*\n* This function determines the adjustment factor for the position when generating an \"extract from vector registers\" instruction.\n* It takes a single parameter, V, which is an SDValue reference.\n* The function first extracts the element type of the vector using getVectorElementType() and then calculates the size of each element in bits using getSizeInBits().\n* Finally, it divides the size of each element by 8 to determine the adjustment factor.\n*\n* @param V An SDValue reference representing the vector register from which an \"extract\" instruction is being generated.\n* @return The adjustment factor for the position when generating an \"extract from vector registers\" instruction.\n*/\nstatic unsigned getExtFactor(SDValue &V) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool findEXTRHalf(SDValue N, SDValue &Src, uint32_t &ShiftAmount,\n                         bool &FromHi) {\n  if (N.getOpcode() == ISD::SHL)\n    FromHi = false;\n  else if (N.getOpcode() == ISD::SRL)\n    FromHi = true;\n  else\n    return false;\n\n  if (!isa<ConstantSDNode>(N.getOperand(1)))\n    return false;\n\n  ShiftAmount = N->getConstantOperandVal(1);\n  Src = N->getOperand(0);\n  return true;\n}\n",
        "answer": "/** @brief Helper function to find and classify an EXTR shift.\n*\n* This function searches for and classifies the shifts in an EXTR instruction.\n* It returns a boolean value indicating whether the search was successful, as well as the source operand and shift amount.\n*\n* @param N The input node to be searched.\n* @param Src The source operand of the shift.\n* @param ShiftAmount The shift amount.\n* @param FromHi A boolean indicating whether the shift is from the high or low end.\n* @return True if the search was successful, false otherwise.\n*/\nstatic bool findEXTRHalf(SDValue N, SDValue &Src, uint32_t &ShiftAmount,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline static ARMCC::CondCodes getSwappedCondition(ARMCC::CondCodes CC) {\n  switch (CC) {\n  default: return ARMCC::AL;\n  case ARMCC::EQ: return ARMCC::EQ;\n  case ARMCC::NE: return ARMCC::NE;\n  case ARMCC::HS: return ARMCC::LS;\n  case ARMCC::LO: return ARMCC::HI;\n  case ARMCC::HI: return ARMCC::LO;\n  case ARMCC::LS: return ARMCC::HS;\n  case ARMCC::GE: return ARMCC::LE;\n  case ARMCC::LT: return ARMCC::GT;\n  case ARMCC::GT: return ARMCC::LT;\n  case ARMCC::LE: return ARMCC::GE;\n  }\n}\n",
        "answer": "/** @brief Get the swapped condition code.\n*\n* This function returns the condition code if we modify the instructions such that flags are set by MI(b,a).\n*\n* @param CC The original condition code.\n* @return The swapped condition code.\n*/\ninline static ARMCC::CondCodes getSwappedCondition(ARMCC::CondCodes CC) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uint32_t alignToARMConstant(uint32_t Value) {\n  unsigned Shifted = 0;\n\n  if (Value == 0)\n      return 0;\n\n  while (!(Value & 0xC0000000)) {\n      Value = Value << 2;\n      Shifted += 2;\n  }\n\n  bool Carry = (Value & 0x00FFFFFF);\n  Value = ((Value & 0xFF000000) >> 24) + Carry;\n\n  if (Value & 0x0000100)\n      Value = Value & 0x000001FC;\n\n  if (Shifted > 24)\n      Value = Value >> (Shifted - 24);\n  else\n      Value = Value << (24 - Shifted);\n\n  return Value;\n}\n",
        "answer": "/**\n* @brief Aligns a value to an ARM constant.\n*\n* This function takes a 32-bit unsigned integer value and aligns it to the next\n* ARM constant that is greater than or equal to the input value. An ARM constant\n* is defined as any value that can be produced by rotating an 8-bit value to the\n* right by an even number of bits within a 32-bit word.\n*\n* @param Value The input value to align.\n* @return The aligned value.\n*/\nstatic uint32_t alignToARMConstant(uint32_t Value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SDValue PerformADDCCombine(SDNode *N,\n                                 TargetLowering::DAGCombinerInfo &DCI,\n                                 const ARMSubtarget *Subtarget) {\n\n  return AddCombineTo64bitMLAL(N, DCI, Subtarget);\n\n}\n",
        "answer": "/** @brief PerformADDCCombine - Target-specific dag combine transform from ISD::ADDC, ISD::ADDE, and ISD::MUL_LOHI to MLAL.\n*\n*  This function combines the ISD::ADDC, ISD::ADDE, and ISD::MUL_LOHI instructions into a single MLAL instruction for the ARM target.\n*\n* @param N The SDNode representing the ADDC/ADDE/MUL_LOHI operation.\n* @param DCI The TargetLowering::DAGCombinerInfo object containing information about the dag combine transform.\n* @param Subtarget The ARMSubtarget object containing information about the target architecture.\n* @return The SDValue representing the combined MLAL instruction, or null if the transformation is not possible.\n*/\nstatic SDValue PerformADDCCombine(SDNode *N, TargetLowering::DAGCombinerInfo &DCI, const ARMSubtarget *Subtarget) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool definedInCaller(const SetVector<BasicBlock *> &Blocks, Value *V) {\n  if (isa<Argument>(V)) return true;\n  if (Instruction *I = dyn_cast<Instruction>(V))\n    if (!Blocks.count(I->getParent()))\n      return true;\n  return false;\n}\n",
        "answer": "/** @brief Checks whether a value is defined in the caller but not in the extracted region.\n*\n* This function checks if the specified value is defined in the function being code extracted, but not in the region being extracted. These values must be passed in as live-ins to the function.\n*\n* @param Blocks The set of basic blocks that make up the extracted region.\n* @param V The value to check.\n* @return True if the value is defined in the caller but not in the extracted region, false otherwise.\n*/\nstatic bool definedInCaller(const SetVector<BasicBlock *> &Blocks, Value *V) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMBool LLVMPrintModuleToFile(LLVMModuleRef M, const char *Filename,\n                               char **ErrorMessage) {\n  std::error_code EC;\n  raw_fd_ostream dest(Filename, EC, sys::fs::F_Text);\n  if (EC) {\n    *ErrorMessage = strdup(EC.message().c_str());\n    return true;\n  }\n\n  unwrap(M)->print(dest, nullptr);\n\n  dest.close();\n\n  if (dest.has_error()) {\n    *ErrorMessage = strdup(\"Error printing to file\");\n    return true;\n  }\n\n  return false;\n}\n",
        "answer": "/** @brief Print a representation of a module to a file.\n*\n* This function prints a representation of the LLVMModuleRef M to the file specified by Filename.\n* The ErrorMessage needs to be disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.\n*\n* @param[in] M The module to print.\n* @param[in] Filename The name of the file to print to.\n* @param[out] ErrorMessage A pointer to a string that will be set to an error message if the function fails.\n*\n* @return 0 on success, 1 otherwise.\n*/\n*ErrorMessage = strdup(EC.message().c_str());\n*ErrorMessage = strdup(\"Error printing to file\");\nreturn true;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned AddressSpace) {\n  return wrap(PointerType::get(unwrap(ElementType), AddressSpace));\n}\n",
        "answer": "/** @brief Create a pointer type that points to a defined type. The created type will exist in the context that its pointee type exists in.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param ElementType The type of the element that the pointer points to.\n* @param AddressSpace The address space in which the pointer resides.\n*\n* @return A pointer type that points to the specified element type and resides in the specified address space.\n*/\nLLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned AddressSpace) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)\n{\n  auto *MD = cast<MetadataAsValue>(unwrap(V));\n  if (auto *MDV = dyn_cast<ValueAsMetadata>(MD->getMetadata())) {\n    *Dest = wrap(MDV->getValue());\n    return;\n  }\n  const auto *N = cast<MDNode>(MD->getMetadata());\n  const unsigned numOperands = N->getNumOperands();\n  LLVMContext &Context = unwrap(V)->getContext();\n  for (unsigned i = 0; i < numOperands; i++)\n    Dest[i] = getMDNodeOperandImpl(Context, N, i);\n}\n",
        "answer": "/**\n* @brief Obtains the operands of a given MDNode.\n*\n* This function obtains the operands of a given MDNode and stores them in an array of LLVMValueRefs. The passed\n* LLVMValueRef pointer should point to enough memory to hold all of the operands of the given MDNode (see\n* LLVMGetMDNodeNumOperands) as LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the MDNode's\n* operands.\n*\n* @param V The MDNode to get the operands for.\n* @param Dest A pointer to an array of LLVMValueRefs where the operands will be stored.\n*/\n*Dest = wrap(MDV->getValue());\nreturn;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB) {\n  return wrap(unwrap(BB)->getTerminator());\n}\n",
        "answer": "/** @brief Obtain the terminator instruction for a basic block.\n*\n* This is the description of the functionality of the function.\n*\n* If the basic block does not have a terminator (it is not well-formed if it doesn't), then NULL is returned.\n*\n* @param BB The basic block to obtain the terminator instruction for.\n* @return The terminator instruction for the given basic block, or NULL if the basic block is not well-formed.\n*/\nLLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst) {\n  Instruction *Instr = unwrap<Instruction>(Inst);\n  BasicBlock::iterator I = Instr;\n  if (++I == Instr->getParent()->end())\n    return nullptr;\n  return wrap(I);\n}\n",
        "answer": "/** @brief Obtain the instruction that occurs after the one specified.\n*\n* This function returns the next instruction in the same basic block as the given instruction. If this is the last instruction in a basic block, NULL will be returned.\n*\n* @param Inst The LLVMValueRef of the instruction to get the next instruction for.\n* @return The LLVMValueRef of the next instruction or nullptr if there is no next instruction.\n*/\nLLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned NumRetVals(const Function *F) {\n  Type *RetTy = F->getReturnType();\n  if (RetTy->isVoidTy())\n    return 0;\n  else if (StructType *STy = dyn_cast<StructType>(RetTy))\n    return STy->getNumElements();\n  else if (ArrayType *ATy = dyn_cast<ArrayType>(RetTy))\n    return ATy->getNumElements();\n  else\n    return 1;\n}\n",
        "answer": "/** @brief Convenience function that returns the number of return values.\n*\n* This is a static function that takes in a pointer to a Function object as its parameter. The function checks the return type of the function and returns an unsigned integer value based on the following conditions:\n* - If the return type is void, it returns 0.\n* - If the return type is a struct, it returns the number of elements in the struct using the getNumElements() method of the StructType class.\n* - If the return type is an array, it returns the number of elements in the array using the getNumElements() method of the ArrayType class.\n* - Otherwise, it returns 1.\n*\n* @param F A pointer to a Function object.\n* @return An unsigned integer value representing the number of return values.\n*/\nstatic unsigned NumRetVals(const Function *F) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool GlobalUsersSafeToSRA(GlobalValue *GV) {\n  for (User *U : GV->users())\n    if (!IsUserOfGlobalSafeForSRA(U, GV))\n      return false;\n\n  return true;\n}\n",
        "answer": "/** @brief Determines whether all uses of a global value are safe for SRA.\n*\n* This function checks if it is safe to perform the transformation on all uses of a global value.\n*\n* @param GV The global value whose users will be checked.\n* @return true if all users of the global value are safe for SRA, false otherwise.\n*/\nstatic bool GlobalUsersSafeToSRA(GlobalValue *GV) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isLoopInvariant(Value *V, const Loop *L, const DominatorTree *DT) {\n  Instruction *Inst = dyn_cast<Instruction>(V);\n  if (!Inst)\n    return true;\n\n  return DT->properlyDominates(Inst->getParent(), L->getHeader());\n}\n",
        "answer": "/** @brief Perform a quick domtree based check for loop invariance assuming that V is used within the loop. LoopInfo::isLoopInvariant() seems gratuitous for this purpose.\n*\n*  This function checks if a value is loop invariant by checking if it is dominated by the header of the loop.\n*\n* @param V The value to check for loop invariance.\n* @param L The loop to check for loop invariance.\n* @param DT The dominator tree of the function containing the loop.\n* @return True if the value is loop invariant, false otherwise.\n*/\nstatic bool isLoopInvariant(Value *V, const Loop *L, const DominatorTree *DT) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned conjugateICmpMask(unsigned Mask) {\n  unsigned NewMask;\n  NewMask = (Mask & (FoldMskICmp_AMask_AllOnes | FoldMskICmp_BMask_AllOnes |\n                     FoldMskICmp_Mask_AllZeroes | FoldMskICmp_AMask_Mixed |\n                     FoldMskICmp_BMask_Mixed))\n            << 1;\n\n  NewMask |=\n      (Mask & (FoldMskICmp_AMask_NotAllOnes | FoldMskICmp_BMask_NotAllOnes |\n               FoldMskICmp_Mask_NotAllZeroes | FoldMskICmp_AMask_NotMixed |\n               FoldMskICmp_BMask_NotMixed))\n      >> 1;\n\n  return NewMask;\n}\n",
        "answer": "/** @brief Conjugate an ICmp mask.\n*\n*  This function conjugates an ICmp mask by swapping the bits corresponding to the \"NotXXX\" flags (recording !=) with the corresponding normal flags (recording ==).\n*\n* @param Mask The input ICmp mask.\n* @return The conjugated ICmp mask.\n*/\nstatic unsigned conjugateICmpMask(unsigned Mask) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void EmitTargetBuiltins(const std::map<std::string, std::string> &BIM,\n                               const std::string &TargetPrefix,\n                               raw_ostream &OS) {\n\n  std::vector<StringMatcher::StringPair> Results;\n\n  for (std::map<std::string, std::string>::const_iterator I = BIM.begin(),\n       E = BIM.end(); I != E; ++I) {\n    std::string ResultCode =\n    \"return \" + TargetPrefix + \"Intrinsic::\" + I->second + \";\";\n    Results.emplace_back(I->first, ResultCode);\n  }\n\n  StringMatcher(\"BuiltinName\", Results, OS).Emit();\n}\n",
        "answer": "/** @brief Emit target builtins.\n*\n* This function emits the builtins for a specific target.\n* It takes in a map of builtin names and their corresponding code,\n* as well as the target prefix and an output stream.\n* The function iterates over the map and generates the result code\n* for each builtin, then uses a StringMatcher to emit the results.\n*\n* @param BIM A map of builtin names and their corresponding code.\n* @param TargetPrefix The target prefix for the builtins.\n* @param OS An output stream to write the emitted code to.\n*/\nstatic void EmitTargetBuiltins(const std::map<std::string, std::string> &BIM,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void copyGVAttributes(GlobalValue *DestGV, const GlobalValue *SrcGV) {\n  DestGV->copyAttributesFrom(SrcGV);\n  forceRenaming(DestGV, SrcGV->getName());\n}\n",
        "answer": "/** @brief Copies additional attributes from the source GlobalValue to the destination GlobalValue.\n*\n* This function copies the additional attributes (those not needed to construct a GlobalValue) from the SrcGV to the DestGV.\n*\n* @param DestGV The destination GlobalValue.\n* @param SrcGV The source GlobalValue.\n*/\nstatic void copyGVAttributes(GlobalValue *DestGV, const GlobalValue *SrcGV) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void lto_module_dispose(lto_module_t mod) { delete unwrap(mod); }\n",
        "answer": "/** @brief Frees all memory internally allocated by the module. Upon return the lto_module_t is no longer valid.\n*\n*  This function frees all memory internally allocated by the module, including any data structures or buffers that were created during the lifetime of the module. Upon return, the lto_module_t object is no longer valid and should not be used.\n*\n* @param mod The lto_module_t object to dispose.\n*/\nvoid lto_module_dispose(lto_module_t mod) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool lto_codegen_compile_to_file(lto_code_gen_t cg, const char **name) {\n  maybeParseOptions(cg);\n  return !unwrap(cg)->compile_to_file(\n      name, DisableInline, DisableGVNLoadPRE,\n      DisableLTOVectorization, sLastErrorString);\n}\n",
        "answer": "/** @brief Generates code for all added modules into one native object file.\n*\n* This function calls lto_codegen_optimize then lto_codegen_compile_optimized (instead of returning a generated mach-o/ELF buffer, it writes to a file). The name of the file is written to name. Returns true on error.\n*\n* @param cg A pointer to an lto_code_gen_t object that contains the code generation state.\n* @param name A pointer to a const char array that will be used as the output file name.\n* @return True if there was an error, false otherwise.\n*/\nbool lto_codegen_compile_to_file(lto_code_gen_t cg, const char **name) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void RemoveFromReverseMap(DenseMap<Instruction*,\n                                 SmallPtrSet<KeyTy, 4> > &ReverseMap,\n                                 Instruction *Inst, KeyTy Val) {\n  typename DenseMap<Instruction*, SmallPtrSet<KeyTy, 4> >::iterator\n  InstIt = ReverseMap.find(Inst);\n  assert(InstIt != ReverseMap.end() && \"Reverse map out of sync?\");\n  bool Found = InstIt->second.erase(Val);\n  assert(Found && \"Invalid reverse map!\"); (void)Found;\n  if (InstIt->second.empty())\n    ReverseMap.erase(InstIt);\n}\n",
        "answer": "/** @brief Removes a value from an instruction's set in a reverse map.\n*\n*  This is a helper function that removes a value from an instruction's set in a reverse map. If the set becomes empty, the instruction's entry is removed from the map.\n*\n* @param ReverseMap The reverse map to modify.\n* @param Inst The instruction whose set should be modified.\n* @param Val The value to remove from the set.\n*/\nstatic void RemoveFromReverseMap(DenseMap<Instruction*, SmallPtrSet<KeyTy, 4> > &ReverseMap, Instruction *Inst, KeyTy Val) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline unsigned getLoadStoreOffsetSizeInBits(const unsigned Opcode) {\n  switch (Opcode) {\n  case Mips::LD_B:\n  case Mips::ST_B:\n    return 10;\n  case Mips::LD_H:\n  case Mips::ST_H:\n    return 10 + 1 /* scale factor */;\n  case Mips::LD_W:\n  case Mips::ST_W:\n    return 10 + 2 /* scale factor */;\n  case Mips::LD_D:\n  case Mips::ST_D:\n    return 10 + 3 /* scale factor */;\n  default:\n    return 16;\n  }\n}\n",
        "answer": "/**\n* @brief Get the size of the offset supported by the given load/store.\n*\n* The result includes the effects of any scale factors applied to the instruction immediate.\n*\n* @param Opcode The opcode of the load or store instruction.\n* @return The size of the offset in bits.\n*/\nstatic inline unsigned getLoadStoreOffsetSizeInBits(const unsigned Opcode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isIntS16Immediate(SDNode *N, short &Imm) {\n  if (N->getOpcode() != ISD::Constant)\n    return false;\n\n  Imm = (short)cast<ConstantSDNode>(N)->getZExtValue();\n  if (N->getValueType(0) == MVT::i32)\n    return Imm == (int32_t)cast<ConstantSDNode>(N)->getZExtValue();\n  else\n    return Imm == (int64_t)cast<ConstantSDNode>(N)->getZExtValue();\n}\n",
        "answer": "/** @brief Checks if the given node is a constant integer that can be represented as a 16-bit immediate.\n*\n* This method tests to see if the node is either a 32-bit or 64-bit immediate, and if the value can be accurately represented as a sign extension from a 16-bit value. If so, this returns true and the immediate.\n*\n* @param N The node to test.\n* @param Imm The immediate value if the node is an immediate.\n* @return True if the node is an immediate that can be represented as a 16-bit value, false otherwise.\n*/\nstatic bool isIntS16Immediate(SDNode *N, short &Imm) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LLVMEnablePrettyStackTrace() {\n  EnablePrettyStackTrace();\n}\n",
        "answer": "/** @brief Enables LLVM's built-in stack trace code.\n*\n* This function intercepts the OS's crash signals and prints which component of LLVM you were in at the time if the crash.\n*\n* @return Should not return\n*/\nvoid LLVMEnablePrettyStackTrace() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool CanConstantFold(const Instruction *I) {\n  if (isa<BinaryOperator>(I) || isa<CmpInst>(I) ||\n      isa<SelectInst>(I) || isa<CastInst>(I) || isa<GetElementPtrInst>(I) ||\n      isa<LoadInst>(I))\n    return true;\n\n  if (const CallInst *CI = dyn_cast<CallInst>(I))\n    if (const Function *F = CI->getCalledFunction())\n      return canConstantFoldCallTo(F);\n  return false;\n}\n",
        "answer": "/** @brief Determines whether an instruction can be constant folded.\n*\n*  This function returns true if the specified instruction can be constant folded, assuming that all operands were constants.\n*\n* @param I The instruction to check.\n* @return True if the instruction can be constant folded, false otherwise.\n*/\nstatic bool CanConstantFold(const Instruction *I) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int isSignedOp(ISD::CondCode Opcode) {\n  switch (Opcode) {\n  default: llvm_unreachable(\"Illegal integer setcc operation!\");\n  case ISD::SETEQ:\n  case ISD::SETNE: return 0;\n  case ISD::SETLT:\n  case ISD::SETLE:\n  case ISD::SETGT:\n  case ISD::SETGE: return 1;\n  case ISD::SETULT:\n  case ISD::SETULE:\n  case ISD::SETUGT:\n  case ISD::SETUGE: return 2;\n  }\n}\n",
        "answer": "/** @brief Determines if an integer comparison is signed or unsigned.\n*\n* This function takes in an ISD::CondCode opcode and returns 1 if the comparison is a signed operation, 2 if the result is an unsigned comparison, and 0 if the operation does not depend on the sign of the input (setne and seteq).\n*\n* @param Opcode The ISD::CondCode opcode for the integer comparison.\n* @return An integer indicating whether the comparison is signed (1), unsigned (2), or neither (0).\n*/\nstatic int isSignedOp(ISD::CondCode Opcode) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef TLI,\n                              LLVMPassManagerRef PM) {\n  unwrap(PM)->add(new TargetLibraryInfoWrapperPass(*unwrap(TLI)));\n}\n",
        "answer": "/** @brief Adds target library information to a pass manager. This does not take ownership of the target library info. See the method llvm::PassManagerBase::add.\n*\n*  @param TLI TargetLibraryInfoRef object containing target library information.\n*  @param PM PassManagerRef object representing the pass manager to add the target library information to.\n*\n*  @return void\n*/\nvoid LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef TLI,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void getAllocatableSetForRC(const MachineFunction &MF,\n                                   const TargetRegisterClass *RC, BitVector &R){\n  assert(RC->isAllocatable() && \"invalid for nonallocatable sets\");\n  ArrayRef<MCPhysReg> Order = RC->getRawAllocationOrder(MF);\n  for (unsigned i = 0; i != Order.size(); ++i)\n    R.set(Order[i]);\n}\n",
        "answer": "/** @brief Get the allocatable set for a specific register class.\n*\n* This function toggles the bits that represent allocatable registers for the specified register class.\n*\n* @param MF The machine function.\n* @param RC The target register class.\n* @param R The bit vector to store the result in.\n*/\nstatic void getAllocatableSetForRC(const MachineFunction &MF, const TargetRegisterClass *RC, BitVector &R) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isCopyToReg(MachineInstr &MI, const TargetInstrInfo *TII,\n                        unsigned &SrcReg, unsigned &DstReg,\n                        bool &IsSrcPhys, bool &IsDstPhys) {\n  SrcReg = 0;\n  DstReg = 0;\n  if (MI.isCopy()) {\n    DstReg = MI.getOperand(0).getReg();\n    SrcReg = MI.getOperand(1).getReg();\n  } else if (MI.isInsertSubreg() || MI.isSubregToReg()) {\n    DstReg = MI.getOperand(0).getReg();\n    SrcReg = MI.getOperand(2).getReg();\n  } else\n    return false;\n\n  IsSrcPhys = TargetRegisterInfo::isPhysicalRegister(SrcReg);\n  IsDstPhys = TargetRegisterInfo::isPhysicalRegister(DstReg);\n  return true;\n}\n",
        "answer": "/**\n* @brief Checks if the specified MachineInstr is a copy instruction or an extract_subreg instruction.\n*\n* If it is, this function returns true and sets the source and destination registers and whether they are physical registers by reference.\n*\n* @param MI The MachineInstr to check.\n* @param TII A pointer to the TargetInstrInfo object for the current target.\n* @param SrcReg The source register of the instruction.\n* @param DstReg The destination register of the instruction.\n* @param IsSrcPhys Whether the source register is a physical register.\n* @param IsDstPhys Whether the destination register is a physical register.\n* @return True if the instruction is a copy or extract_subreg instruction, false otherwise.\n*/\nstatic bool isCopyToReg(MachineInstr &MI, const TargetInstrInfo *TII,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool rangeMetadataExcludesValue(MDNode* Ranges,\n                                       const APInt& Value) {\n  const unsigned NumRanges = Ranges->getNumOperands() / 2;\n  assert(NumRanges >= 1);\n  for (unsigned i = 0; i < NumRanges; ++i) {\n    ConstantInt *Lower =\n        mdconst::extract<ConstantInt>(Ranges->getOperand(2 * i + 0));\n    ConstantInt *Upper =\n        mdconst::extract<ConstantInt>(Ranges->getOperand(2 * i + 1));\n    ConstantRange Range(Lower->getValue(), Upper->getValue());\n    if (Range.contains(Value))\n      return false;\n  }\n  return true;\n}\n",
        "answer": "/** @brief rangeMetadataExcludesValue\n*\n* This function checks if the 'Range' metadata (which must be a valid MD_range operand list) ensures that the value it's attached to is never Value.\n* 'RangeType' is the type of the value described by the range.\n* @param Ranges The ranges to check\n* @param Value The value to check for\n* @return true if the value is excluded, false otherwise\n*/\nstatic bool rangeMetadataExcludesValue(MDNode* Ranges, const APInt& Value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool translateMaskRegister(MCInst &mcInst,\n                                uint8_t maskRegNum) {\n  if (maskRegNum >= 8) {\n    debug(\"Invalid mask register number\");\n    return true;\n  }\n\n  mcInst.addOperand(MCOperand::createReg(X86::K0 + maskRegNum));\n  return false;\n}\n",
        "answer": "/** @brief Translates a 3-bit mask register number to LLVM form, and appends it to an MCInst.\n*\n* This function translates a 3-bit mask register number to LLVM form, and appends it to an MCInst.\n* It checks if the mask register number is valid (less than 8) and adds the corresponding register operand to the MCInst.\n* If the mask register number is invalid, it returns true and prints a debug message.\n*\n* @param mcInst The MCInst to append the register operand to.\n* @param maskRegNum The 3-bit mask register number to translate.\n* @return True if the mask register number is invalid, false otherwise.\n*/\nstatic bool translateMaskRegister(MCInst &mcInst, uint8_t maskRegNum) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static unsigned getFusedLdStOpcode(EVT &LdVT, unsigned Opc) {\n  if (Opc == X86ISD::DEC) {\n    if (LdVT == MVT::i64) return X86::DEC64m;\n    if (LdVT == MVT::i32) return X86::DEC32m;\n    if (LdVT == MVT::i16) return X86::DEC16m;\n    if (LdVT == MVT::i8)  return X86::DEC8m;\n  } else {\n    assert(Opc == X86ISD::INC && \"unrecognized opcode\");\n    if (LdVT == MVT::i64) return X86::INC64m;\n    if (LdVT == MVT::i32) return X86::INC32m;\n    if (LdVT == MVT::i16) return X86::INC16m;\n    if (LdVT == MVT::i8)  return X86::INC8m;\n  }\n  llvm_unreachable(\"unrecognized size for LdVT\");\n}\n",
        "answer": "/** @brief Get the appropriate X86 opcode for an in memory increment or decrement. Opc should be X86ISD::DEC or X86ISD::INC.\n*\n*  This function returns the appropriate X86 opcode for an in memory increment or decrement based on the given parameters.\n*\n* @param LdVT The vector type of the load instruction.\n* @param Opc The opcode for the operation (X86ISD::DEC or X86ISD::INC).\n* @return The appropriate X86 opcode for the given parameters.\n*/\nstatic unsigned getFusedLdStOpcode(EVT &LdVT, unsigned Opc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SDValue Extract128BitVector(SDValue Vec, unsigned IdxVal,\n                                   SelectionDAG &DAG, SDLoc dl) {\n  assert((Vec.getValueType().is256BitVector() ||\n          Vec.getValueType().is512BitVector()) && \"Unexpected vector size!\");\n  return ExtractSubVector(Vec, IdxVal, DAG, dl, 128);\n}\n",
        "answer": "/** @brief Extracts a 128-bit vector from a larger vector.\n*\n* This function extracts a 128-bit vector from a larger vector (either 256 or 512 bits) based on the index provided. It sets up the extraction to match AVX VEXTRACTF128 / VEXTRACTI128 or AVX-512 VEXTRACTF32x4 / VEXTRACTI32x4 instructions or a simple subregister reference. The index does not need to be aligned to a 128-bit boundary, making it easier to lower EXTRACT_VECTOR_ELT operations.\n*\n* @param Vec The vector from which the 128-bit vector will be extracted.\n* @param IdxVal The index of the 128-bit vector to extract.\n* @param DAG The selection DAG.\n* @param dl The debug location.\n* @return A 128-bit vector extracted from the larger vector based on the provided index.\n*/\nstatic SDValue Extract128BitVector(SDValue Vec, unsigned IdxVal,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SDValue getV4X86ShuffleImm8ForMask(ArrayRef<int> Mask, SDLoc DL,\n                                          SelectionDAG &DAG) {\n  assert(Mask.size() == 4 && \"Only 4-lane shuffle masks\");\n  assert(Mask[0] >= -1 && Mask[0] < 4 && \"Out of bound mask element!\");\n  assert(Mask[1] >= -1 && Mask[1] < 4 && \"Out of bound mask element!\");\n  assert(Mask[2] >= -1 && Mask[2] < 4 && \"Out of bound mask element!\");\n  assert(Mask[3] >= -1 && Mask[3] < 4 && \"Out of bound mask element!\");\n\n  unsigned Imm = 0;\n  Imm |= (Mask[0] == -1 ? 0 : Mask[0]) << 0;\n  Imm |= (Mask[1] == -1 ? 1 : Mask[1]) << 2;\n  Imm |= (Mask[2] == -1 ? 2 : Mask[2]) << 4;\n  Imm |= (Mask[3] == -1 ? 3 : Mask[3]) << 6;\n  return DAG.getConstant(Imm, DL, MVT::i8);\n}\n",
        "answer": "/**\n* @brief Get an 8-bit shuffle immediate corresponding to a mask for use with x86 PSHUF instructions.\n*\n* This helper function produces an 8-bit shuffle immediate corresponding to the ubiquitous shuffle encoding scheme used in x86 instructions for shuffling 4 lanes. It can be used with most of the PSHUF instructions for example. NB: We rely heavily on \"undef\" masks preserving the input lane.\n*\n* @param Mask The array of integers representing the shuffle mask. Must have length 4 and contain values in the range [-1, 3].\n* @param DL The debug location for this instruction.\n* @param DAG The selection dag for this function.\n* @return An SDValue containing the 8-bit shuffle immediate.\n*/\nstatic SDValue getV4X86ShuffleImm8ForMask(ArrayRef<int> Mask, SDLoc DL, SelectionDAG &DAG) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static MCFixupKind getImmFixupKind(uint64_t TSFlags) {\n  unsigned Size = X86II::getSizeOfImm(TSFlags);\n  bool isPCRel = X86II::isImmPCRel(TSFlags);\n\n  if (X86II::isImmSigned(TSFlags)) {\n    switch (Size) {\n    default: llvm_unreachable(\"Unsupported signed fixup size!\");\n    case 4: return MCFixupKind(X86::reloc_signed_4byte);\n    }\n  }\n  return MCFixup::getKindForSize(Size, isPCRel);\n}\n",
        "answer": "/** @brief Return the appropriate fixup kind to use for an immediate in an instruction with the specified TSFlags.\n*\n*  This function returns the appropriate fixup kind to use for an immediate in an instruction with the specified TSFlags.\n*  It takes into account the size of the immediate and whether it is PC-relative or not.\n*\n* @param TSFlags The TSFlags value from the X86InstrInfo table.\n* @return The appropriate fixup kind to use for an immediate in an instruction with the specified TSFlags.\n*/\nstatic MCFixupKind getImmFixupKind(uint64_t TSFlags) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void GetSpillList(SmallVectorImpl<StackSlotInfo> &SpillList,\n                         MachineFrameInfo *MFI, XCoreFunctionInfo *XFI,\n                         bool fetchLR, bool fetchFP) {\n  if (fetchLR) {\n    int Offset = MFI->getObjectOffset(XFI->getLRSpillSlot());\n    SpillList.push_back(StackSlotInfo(XFI->getLRSpillSlot(),\n                                      Offset,\n                                      XCore::LR));\n  }\n  if (fetchFP) {\n    int Offset = MFI->getObjectOffset(XFI->getFPSpillSlot());\n    SpillList.push_back(StackSlotInfo(XFI->getFPSpillSlot(),\n                                      Offset,\n                                      FramePtr));\n  }\n  std::sort(SpillList.begin(), SpillList.end(), CompareSSIOffset);\n}\n",
        "answer": "/**\n* @brief Creates an ordered list of registers that are spilled during the emitPrologue/emitEpilogue. Registers are ordered according to their frame offset. As offsets are negative, the largest offsets will be first.\n*\n* @param SpillList A reference to a SmallVectorImpl object that will contain the list of stack slots and their corresponding frame offsets.\n* @param MFI A pointer to a MachineFrameInfo object that contains information about the machine frame.\n* @param XFI A pointer to an XCoreFunctionInfo object that contains information about the function being emitted.\n* @param fetchLR A boolean indicating whether or not the link register should be spilled.\n* @param fetchFP A boolean indicating whether or not the frame pointer should be spilled.\n*/\nvoid GetSpillList(SmallVectorImpl<StackSlotInfo> &SpillList, MachineFrameInfo *MFI, XCoreFunctionInfo *XFI, bool fetchLR, bool fetchFP) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QString formatSignedMemorySize(qint64 a_Size)\n{\n\tif (a_Size >= 0)\n\t{\n\t\treturn formatBigNumber(static_cast<quint64>((a_Size + 1023) / 1024));\n\t}\n\ta_Size = -a_Size;\n\treturn QString(\"-\") + formatBigNumber(static_cast<quint64>((a_Size + 1023) / 1024));\n}\n",
        "answer": "/** @brief Formats the number as signed memory size, converts to KiB (rounds away from zero) and uses space as thousand separator.\n*\n* @param a_Size The size to format.\n* @return The formatted string.\n*/\nQString formatSignedMemorySize(qint64 a_Size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int bitcoinconsensus_verify_script(const uint8_t *scriptPubKey,\n                                   unsigned int scriptPubKeyLen,\n                                   const uint8_t *txTo, unsigned int txToLen,\n                                   unsigned int nIn, unsigned int flags,\n                                   bitcoinconsensus_error *err) {\n    if (flags & bitcoinconsensus_SCRIPT_ENABLE_SIGHASH_FORKID ||\n        flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS_DEPRECATED) {\n        return set_error(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);\n    }\n\n    Amount am(0);\n    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen,\n                           nIn, flags, err);\n}\n",
        "answer": "/** @brief Verifies a Bitcoin transaction input against a given serialized transaction output.\n*\n*  This function checks whether the input of a Bitcoin transaction correctly spends the output of a previous transaction, given the serialized transaction data and the index of the input to verify. It also allows for additional constraints to be specified using flags. If an error occurs during verification, it is returned in the err parameter.\n*\n* @param scriptPubKey The serialized transaction output to verify against.\n* @param scriptPubKeyLen The length of the serialized transaction output.\n* @param txTo The serialized transaction input to verify.\n* @param txToLen The length of the serialized transaction input.\n* @param nIn The index of the input in the transaction to verify.\n* @param flags Additional constraints to apply during verification, such as enabling or disabling certain opcodes.\n* @param err A pointer to an error code that will be set if an error occurs during verification.\n*\n* @return 1 if the input correctly spends the output, 0 otherwise.\n*/\nint bitcoinconsensus_verify_script(const uint8_t *scriptPubKey, unsigned int scriptPubKeyLen, const uint8_t *txTo, unsigned int txToLen, unsigned int nIn, unsigned int flags, bitcoinconsensus_error *err) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool CheckFinalTx(const CTransaction &tx, int flags = -1) {\n    auto &config = GlobalConfig::GetConfig();\n    CValidationState state;\n    return ContextualCheckTransactionForCurrentBlock(config, tx, state, flags);\n}\n",
        "answer": "/** @brief Checks the final transaction.\n*\n*  This function checks the final transaction for the current block.\n*  It is deprecated and will be removed in a future version of Bitcoin Core.\n*\n* @param tx The transaction to check.\n* @param flags Optional flags to pass to the validation state.\n* @return Whether the transaction passes the check.\n*/\nbool CheckFinalTx(const CTransaction &tx, int flags = -1) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void RPCTypeCheck(const UniValue &params,\n                  const std::list<UniValue::VType> &typesExpected,\n                  bool fAllowNull) {\n    unsigned int i = 0;\n    for (UniValue::VType t : typesExpected) {\n        if (params.size() <= i) break;\n\n        const UniValue &v = params[i];\n        if (!(fAllowNull && v.isNull())) {\n            RPCTypeCheckArgument(v, t);\n        }\n        i++;\n    }\n}\n",
        "answer": "/** @brief Type-check arguments; throws JSONRPCError if wrong type given. Does not check that the right number of arguments are passed, just that any passed are the correct type.\n*\n*  This function checks the types of the arguments passed to an RPC call and throws a JSONRPCError if any of them do not match the expected types. It does not check that the correct number of arguments were passed, only that any passed are of the correct type.\n*\n* @param params The UniValue object containing the arguments passed to the RPC call.\n* @param typesExpected A list of the expected types for each argument.\n* @param fAllowNull Whether or not null values are allowed for any of the arguments.\n* @return Should not return anything, but throws a JSONRPCError if any of the arguments do not match the expected types.\n*/\nvoid RPCTypeCheck(const UniValue &params, const std::list<UniValue::VType> &typesExpected, bool fAllowNull) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static DisconnectResult DisconnectBlock(const CBlock &block,\n                                        const CBlockIndex *pindex,\n                                        CCoinsViewCache &view) {\n    CBlockUndo blockUndo;\n    CDiskBlockPos pos = pindex->GetUndoPos();\n    if (pos.IsNull()) {\n        error(\"DisconnectBlock(): no undo data available\");\n        return DISCONNECT_FAILED;\n    }\n\n    if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash())) {\n        error(\"DisconnectBlock(): failure reading undo data\");\n        return DISCONNECT_FAILED;\n    }\n\n    return ApplyBlockUndo(blockUndo, block, pindex, view);\n}\n",
        "answer": "/** @brief Disconnects a block from the UTXO set represented by coins.\n*\n*  This function undoes the effects of this block (with given index) on the UTXO set represented by coins. When FAILED is returned, view is left in an indeterminate state.\n*\n* @param[in] block The block to be disconnected.\n* @param[in] pindex The block index of the block to be disconnected.\n* @param[in,out] view The UTXO set represented by coins.\n* @return DISCONNECT_OK on success, DISCONNECT_FAILED if an error occurs.\n*/\nstatic DisconnectResult DisconnectBlock(const CBlock &block, const CBlockIndex *pindex, CCoinsViewCache &view) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_substring(const uint32_t N,\n                  const uint32_t M,\n                  const uint8_t i,\n                  const uint8_t j)\n{\n    std::bitset<32> N_bits(N);\n    std::bitset<32> M_bits(M);\n\n    for (uint8_t k = i; k <= j; ++k)\n    {\n        if (N_bits[k] != M_bits[k - i])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
        "answer": "/** @brief Checks if a substring is present in two given integers.\n*\n*  This function checks if the bits [m_0,...,m_(j-i)] of M are equal to the bits [n_i,...,n_j] of N, false otherwise.\n*\n* @param N The first integer.\n* @param M The second integer.\n* @param i The starting index for the substring in N.\n* @param j The ending index for the substring in N.\n* @return True if the substring is present, false otherwise.\n*/\nbool is_substring(const uint32_t N, const uint32_t M, const uint8_t i, const uint8_t j)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ofDrawBox( float x, float y, float z, float width, float height, float depth) {\n\tstatic ofMatrix4x4 m;\n\tm.makeScaleMatrix(width,height,depth);\n\tm.translate(x,y,z);\n\t\n    ofPushMatrix();\n    ofMultMatrix(m);\n    if(ofGetFill() == OF_FILLED) {\n    \tofMesh& mesh = getCached3dPrimitive( OF_3D_PRIMITIVE_BOX ).getMesh();\n        renderCached3dPrimitive( mesh );\n    } else {\n        ofMesh& mesh = getCached3dPrimitive( OF_3D_PRIMITIVE_BOX_WIREFRAME ).getMesh();\n        renderCached3dPrimitive( mesh );\n    }\n    ofPopMatrix();\n}\n",
        "answer": "/** @brief Draws a box in 3D space.\n*\n* This function draws a rectangular solid, or box, in 3D space. The box is defined by its width, height, and depth, as well as the position of its reference coordinate. The box is drawn with the current color, and can be filled or not filled depending on the value of the ofGetFill() function.\n*\n* @param x The x-coordinate of the reference point of the box.\n* @param y The y-coordinate of the reference point of the box.\n* @param z The z-coordinate of the reference point of the box.\n* @param width The width of the box.\n* @param height The height of the box.\n* @param depth The depth of the box.\n*/\nvoid ofDrawBox( float x, float y, float z, float width, float height, float depth) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ofDrawBox( float width, float height, float depth ) {\n\tstatic ofMatrix4x4 m;\n\tm.makeScaleMatrix(width,height,depth);\n    ofPushMatrix();\n    ofMultMatrix(m);\n    if(ofGetFill() == OF_FILLED) {\n    \tofMesh& mesh = getCached3dPrimitive( OF_3D_PRIMITIVE_BOX ).getMesh();\n        renderCached3dPrimitive( mesh );\n    } else {\n        ofMesh& mesh = getCached3dPrimitive( OF_3D_PRIMITIVE_BOX_WIREFRAME ).getMesh();\n        renderCached3dPrimitive( mesh );\n    }\n    ofPopMatrix();\n}\n",
        "answer": "/** @brief Draws a box with the given width, height, and depth.\n*\n*  This function draws a rectangular solid (a box) starting from the origin of the current reference frame. The box is drawn with the current color, e.g. set with ofSetColor(). The box is drawn filled by default; change this with ofFill();\n*\n* @param width The width of the box in x.\n* @param height The height of the box in y.\n* @param depth The depth of the box in z.\n*/\nvoid ofDrawBox( float width, float height, float depth ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "float ofClamp(float value, float min, float max) {\n\treturn value < min ? min : value > max ? max : value;\n}\n",
        "answer": "/** @brief Clamps a value between a minimum and maximum value.\n*\n*  This function takes in a value, a minimum, and a maximum, and returns the value clamped to be within the range of the minimum and maximum.\n*\n* @param[in] value The value to be clamped.\n* @param[in] min The minimum value that the output can take on.\n* @param[in] max The maximum value that the output can take on.\n* @return The clamped value.\n*/\nfloat ofClamp(float value, float min, float max) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ofSoundStreamSetup(int nOutputChannels, int nInputChannels, ofBaseApp * appPtr){\n\tif( appPtr == NULL ){\n\t\tappPtr = ofGetAppPtr();\n\t}\n\tofSoundStreamSetup(nOutputChannels, nInputChannels, appPtr, 44100, 256, 4);\n}\n",
        "answer": "/** @brief Set up a sound stream with default parameters.\n*\n* This function sets up a sound stream with a default sample rate of 44100, a buffer size of 256 samples, and a queue of 4 buffers.\n*\n* @param nOutputChannels The number of output channels (e.g., speakers) to use.\n* @param nInputChannels The number of input channels (e.g., microphones) to use.\n* @param appPtr A pointer to the application object that will handle the audio callbacks. If NULL, the default application pointer will be used.\n*/\nvoid ofSoundStreamSetup(int nOutputChannels, int nInputChannels, ofBaseApp * appPtr);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned long long ofGetElapsedTimeMicros(){\n\treturn ofGetSystemTimeMicros() - startTimeMicros;\n}\n",
        "answer": "/** @brief Returns the elapsed time since ofResetElapsedTimeCounter() was called.\n*\n* This function returns the elapsed time in microseconds since ofResetElapsedTimeCounter() was called. Usually, ofResetElapsedTimeCounter() is called automatically upon program startup.\n*\n* @return The elapsed time in microseconds.\n*/\nunsigned long long ofGetElapsedTimeMicros()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "svgtiny_code svgtiny_list_resize(struct svgtiny_list *list,\n\t\tunsigned int new_size)\n{\n\tunsigned int new_allocated;\n\tvoid *new_items;\n\n\tif (new_size <= list->allocated) {\n\t\tlist->size = new_size;\n\t\treturn svgtiny_OK;\n\t}\n\n\tnew_allocated = (new_size >> 3) + (new_size < 9 ? 3 : 6) + new_size;\n\tif (new_size == 0)\n\t\tnew_allocated = 0;\n\tnew_items = realloc(list->items, new_allocated * list->item_size);\n\tif (!new_items)\n\t\treturn svgtiny_OUT_OF_MEMORY;\n\n\tlist->size = new_size;\n\tlist->allocated = new_allocated;\n\tlist->items = (char *) new_items;\n\n\treturn svgtiny_OK;\n}\n",
        "answer": "/** @brief Resize a list.\n*\n*  This function resizes the list to the specified size. If the size is increased, the new objects are not initialized in any way. Objects may have moved after this call. Use svgtiny_list_get() to get new pointers.\n*\n* @param[in] list The list to resize.\n* @param[in] new_size The new size of the list.\n* @return svgtiny_OK if successful, svgtiny_OUT_OF_MEMORY if memory allocation failed.\n*/\nsvgtiny_code svgtiny_list_resize(struct svgtiny_list *list, unsigned int new_size)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "mt32emu_analog_output_mode mt32emu_get_best_analog_output_mode(const double target_samplerate) {\n\treturn mt32emu_analog_output_mode(SampleRateConverter::getBestAnalogOutputMode(target_samplerate));\n}\n",
        "answer": "/** @brief Get the best analog output mode for a given sample rate.\n*\n*  This function returns the value of analog_output_mode for which the output signal may retain its full frequency spectrum at the sample rate specified by the target_samplerate argument. See comment for mt32emu_analog_output_mode.\n*\n* @param[in] target_samplerate The desired sample rate.\n* @return The best analog output mode for the given sample rate.\n*/\nmt32emu_analog_output_mode mt32emu_get_best_analog_output_mode(const double target_samplerate) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mt32emu_set_stereo_output_samplerate(mt32emu_context context, const double samplerate) {\n\tif (0.0 <= samplerate) {\n\t\tcontext->srcState->outputSampleRate = samplerate;\n\t}\n}\n",
        "answer": "/** @brief Sets the stereo output sample rate for the synthesiser.\n*\n*  This function allows to convert the synthesiser output to any desired sample rate. The samplerate conversion processes the completely mixed stereo output signal as it passes the analogue circuit emulation, so emulating the synthesiser output signal passing further through an ADC. When the samplerate argument is set to 0, the default output sample rate is used which depends on the current mode of analog circuitry emulation. See mt32emu_analog_output_mode. This function doesn't immediately change the state of already opened synth. Newly set value will take effect upon next call of mt32emu_open_synth().\n*\n* @param context The MT-32 emulator context.\n* @param samplerate The desired output sample rate, or 0 to use the default output sample rate.\n*/\nvoid mt32emu_set_stereo_output_samplerate(mt32emu_context context, const double samplerate) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mt32emu_close_synth(mt32emu_const_context context) {\n\tcontext->synth->close();\n\tdelete context->srcState->src;\n\tcontext->srcState->src = NULL;\n}\n",
        "answer": "/** @brief Closes the emulation context freeing allocated resources. Added ROMs remain unaffected and ready for reuse.\n*\n*  @param[in] context The mt32emu_const_context to close.\n*\n*  @return void\n*/\nvoid mt32emu_close_synth(mt32emu_const_context context) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mt32emu_set_midi_receiver(mt32emu_context context, mt32emu_midi_receiver_i midi_receiver, void *instance_data) {\n\tdelete context->midiParser;\n\tcontext->midiParser = (midi_receiver.v0 != NULL) ? new DelegatingMidiStreamParser(context, midi_receiver, instance_data) : new DefaultMidiStreamParser(*context->synth);\n}\n",
        "answer": "/** @brief Installs custom MIDI receiver object intended for receiving MIDI messages generated by MIDI stream parser.\n*\n*  This function allows to override default behaviour of parsed short MIDI messages and System Exclusive messages being sent to the synth input MIDI queue. By default, the default behaviour is restored if midi_receiver argument is set to NULL.\n*\n* @param context The mt32emu context.\n* @param midi_receiver The custom MIDI receiver object.\n* @param instance_data The instance data for the custom MIDI receiver object.\n*/\nvoid mt32emu_set_midi_receiver(mt32emu_context context, mt32emu_midi_receiver_i midi_receiver, void *instance_data) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mt32emu_play_short_message_at(mt32emu_const_context context, mt32emu_bit32u message, mt32emu_bit32u timestamp) {\n\tcontext->midiParser->setTimestamp(timestamp);\n\tcontext->midiParser->processShortMessage(message);\n}\n",
        "answer": "/** @brief Enqueues a single mt32emu_bit32u-encoded short MIDI message to play at specified time with full processing.\n*\n*  This function enqueues a single mt32emu_bit32u-encoded short MIDI message to play at the specified timestamp with full processing. The short MIDI message may contain no status byte, the running status is used in this case. When the argument is a System Realtime MIDI message, onMIDISystemRealtime callback is invoked.\n*\n* @param context The mt32emu_const_context to use for processing the short message.\n* @param message The mt32emu_bit32u-encoded short MIDI message to process.\n* @param timestamp The timestamp at which to play the short MIDI message.\n*/\nvoid mt32emu_play_short_message_at(mt32emu_const_context context, mt32emu_bit32u message, mt32emu_bit32u timestamp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mt32emu_write_sysex(mt32emu_const_context context, mt32emu_bit8u channel, const mt32emu_bit8u *sysex, mt32emu_bit32u len) {\n\tcontext->synth->writeSysex(channel, sysex, len);\n}\n",
        "answer": "/** @brief Sends inner body of a System Exclusive MIDI message for direct processing. The length is in bytes. See the WARNING above.\n*\n*  This function sends the inner body of a System Exclusive MIDI message for direct processing. The length is specified in bytes, and it is important to note that this function should only be used with trusted data sources, as it can potentially cause harm if used with malicious input.\n*\n* @param context The mt32emu context.\n* @param channel The MIDI channel number (0-15).\n* @param sysex The System Exclusive message to be sent.\n* @param len The length of the System Exclusive message in bytes.\n* @return void\n*/\nvoid mt32emu_write_sysex(mt32emu_const_context context, mt32emu_bit8u channel, const mt32emu_bit8u *sysex, mt32emu_bit32u len) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mt32emu_set_nice_amp_ramp_enabled(mt32emu_const_context context, const mt32emu_boolean enabled) {\n\tcontext->synth->setNiceAmpRampEnabled(enabled != MT32EMU_BOOL_FALSE);\n}\n",
        "answer": "/**\n* @brief Enables or disables the NiceAmpRamp mode.\n*\n* In this mode, we want to ensure that amp ramp never jumps to the target value and always gradually increases or decreases. It seems that real units do not bother to always check if a newly started ramp leads to a jump. We also prefer the quality improvement over the emulation accuracy, so this mode is enabled by default.\n*\n* @param context The mt32emu context.\n* @param enabled Whether to enable or disable NiceAmpRamp mode.\n*/\nvoid mt32emu_set_nice_amp_ramp_enabled(mt32emu_const_context context, const mt32emu_boolean enabled) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "mt32emu_bit32u mt32emu_get_playing_notes(mt32emu_const_context context, mt32emu_bit8u part_number, mt32emu_bit8u *keys, mt32emu_bit8u *velocities) {\n\treturn context->synth->getPlayingNotes(part_number, keys, velocities);\n}\n",
        "answer": "/** @brief Fills in information about currently playing notes on the specified part into the arrays provided.\n*\n*  This function fills in information about currently playing notes on the specified part into the arrays provided. The arrays must be large enough to accommodate data for all the playing notes. The maximum number of simultaneously playing notes cannot exceed the number of partials. Argument partNumber should be 0..7 for Part 1..8, or 8 for Rhythm. Returns the number of currently playing notes on the specified part.\n*\n* @param context The synthesizer context.\n* @param part_number The part number to get the playing notes for.\n* @param keys An array to fill with the note keys.\n* @param velocities An array to fill with the note velocities.\n* @return The number of currently playing notes on the specified part.\n*/\nmt32emu_bit32u mt32emu_get_playing_notes(mt32emu_const_context context, mt32emu_bit8u part_number, mt32emu_bit8u *keys, mt32emu_bit8u *velocities) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual DistortionCoordinates_t ComputeDistortion( EVREye eEye, float fU, float fV ) \n\t{\n\t\tDistortionCoordinates_t coordinates;\n\t\tcoordinates.rfBlue[0] = fU;\n\t\tcoordinates.rfBlue[1] = fV;\n\t\tcoordinates.rfGreen[0] = fU;\n\t\tcoordinates.rfGreen[1] = fV;\n\t\tcoordinates.rfRed[0] = fU;\n\t\tcoordinates.rfRed[1] = fV;\n\t\treturn coordinates;\n\t}\n",
        "answer": "/** @brief ComputeDistortion\n*\n*  This function computes the distortion for a given eye and input UVs. The UVs go from 0,0 in the upper left of that eye's viewport and 1,1 in the lower right of that eye's viewport.\n*\n* @param eEye The eye for which to compute the distortion.\n* @param fU The U coordinate of the input UVs.\n* @param fV The V coordinate of the input UVs.\n* @return The result of the distortion function for the specified eye and input UVs.\n*/\nvirtual DistortionCoordinates_t ComputeDistortion( EVREye eEye, float fU, float fV )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline StringData _extractSign(const StringData& stringValue, bool* isNegative) {\n    if (stringValue.empty()) {\n        *isNegative = false;\n        return stringValue;\n    }\n\n    bool foundSignMarker;\n    switch (stringValue[0]) {\n        case '-':\n            foundSignMarker = true;\n            *isNegative = true;\n            break;\n        case '+':\n            foundSignMarker = true;\n            *isNegative = false;\n            break;\n        default:\n            foundSignMarker = false;\n            *isNegative = false;\n            break;\n    }\n\n    if (foundSignMarker)\n        return stringValue.substr(1);\n    return stringValue;\n}\n",
        "answer": "/** @brief Extracts the sign from a parseable number and returns a substring with any sign characters stripped away.\n*\n*  This function assumes that \"stringValue\" represents a parseable number, and extracts the sign by checking if the first character is '-' or '+'. If a sign marker is found, it sets the \"isNegative\" flag accordingly and returns a substring with the sign character stripped away. If no sign marker is found, it sets \"isNegative\" to false and returns the original string.\n*\n* @param[in] stringValue The input string representing a parseable number.\n* @param[out] isNegative A boolean flag indicating whether the extracted sign is negative or not.\n* @return A substring with any sign characters stripped away, or the original string if no sign marker was found.\n*/\n*isNegative = false;\n*isNegative = true;\n*isNegative = false;\n*isNegative = false;\n*isNegative = false;\nreturn stringValue;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string dateToISOStringUTC(Date_t date) {\n    DateStringBuffer buf;\n    _dateToISOString(date, false, &buf);\n    return std::string(buf.data, buf.size);\n}\n",
        "answer": "/** @brief Converts a date to an ISO string in the UTC timezone.\n*\n*  This function formats \"date\" according to the ISO 8601 extended form standard, including date, and time with milliseconds decimal component, in the UTC timezone. Sample format: \"2013-07-23T18:42:14.072Z\"\n*\n* @param[in] date The date to be formatted.\n* @return A string representing the date in ISO format.\n*/\nstd::string dateToISOStringUTC(Date_t date) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static double inter_low(double x, double x1, double y1, double x2, double y2)\n{\n  /* check parameters */\n  if( x1 > x2 || x < x1 || x > x2 )\n    error(\"inter_low: unsuitable input, 'x1>x2' or 'x<x1' or 'x>x2'.\");\n\n  /* interpolation */\n  if( double_equal(x1,x2) && y1<y2 ) return y1;\n  if( double_equal(x1,x2) && y1>y2 ) return y2;\n  return y1 + (x-x1) * (y2-y1) / (x2-x1);\n}\n",
        "answer": "/**\n* @brief Interpolate y value corresponding to 'x' value given, in the line 'x1,y1' to 'x2,y2'; if 'x1=x2' return the smaller of 'y1' and 'y2'.\n*\n* This function interpolates a y value for a given x value, based on two points (x1, y1) and (x2, y2). If x1 = x2, the function returns the smaller of y1 and y2.\n*\n* @param x The x value to be interpolated.\n* @param x1 The first point's x coordinate.\n* @param y1 The first point's y coordinate.\n* @param x2 The second point's x coordinate.\n* @param y2 The second point's y coordinate.\n*\n* @return The interpolated y value.\n*/\n/* check parameters */\n/* interpolation */\nif( double_equal(x1,x2) && y1<y2 ) return y1;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    level infer_resultant_universe(unsigned num_intro_rules, expr const * intro_rules) {\n        lean_assert(m_infer_result_universe);\n        buffer<level> r_lvls;\n        for (unsigned i = 0; i < num_intro_rules; i++) {\n            accumulate_levels(mlocal_type(intro_rules[i]), r_lvls);\n        }\n        return mk_result_level(r_lvls);\n    }\n",
        "answer": "/** @brief Infer resultant universe for inductive datatype declaration.\n*\n*  This function takes a sequence of introduction rules (encoded as local constants) and computes the resultant universe for the inductive datatype declaration.\n*\n* @param num_intro_rules The number of introduction rules in the sequence.\n* @param intro_rules The sequence of introduction rules.\n*\n* @return The resultant universe for the inductive datatype declaration.\n*/\nlevel infer_resultant_universe(unsigned num_intro_rules, expr const * intro_rules) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void check_command_period_open_binder_or_eof(parser const & p) {\n    if (!p.curr_is_command_like() && !p.curr_is_eof() && !p.curr_is_token(get_period_tk()) &&\n        !p.curr_is_token(get_lparen_tk()) && !p.curr_is_token(get_lbracket_tk()) &&\n        !p.curr_is_token(get_lcurly_tk()) && !p.curr_is_token(get_ldcurly_tk()))\n        throw parser_error(\"unexpected token, '(', '{', '[', '', '.', command, or end-of-file expected\", p.pos());\n}\n",
        "answer": "/** @brief Check if current token is a command, open binder, period, or EOF.\n*\n*  This function checks if the current token in the parser is a command, an open binder, a period, or an end-of-file. If it is not, it throws a parser error.\n*\n* @param p The parser object to check the current token of.\n* @return void\n*/\nvoid check_command_period_open_binder_or_eof(parser const & p) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "name_set get_class_attribute_symbols(environment const & env, name const & attr_name) {\n    class_state const & s = class_ext::get_state(env);\n    if (name_set const * S = s.m_attr_symbols.find(attr_name))\n        return *S;\n    else\n        return name_set();\n}\n",
        "answer": "/** @brief Get the symbols that occur in instances of any class marked with a given attribute.\n*\n*  This function returns the symbols that occur in instances of any class marked with the specified attribute.\n*\n* @param env The environment in which to search for classes with the given attribute.\n* @param attr_name The name of the attribute to search for.\n*\n* @return A set of symbols that occur in instances of any class marked with the given attribute, or an empty set if no such classes are found.\n*/\nname_set get_class_attribute_symbols(environment const & env, name const & attr_name) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_vm_supported_cases(environment const & env, expr const & e) {\n    return\n        is_internal_cases(e) ||\n        is_constant(e, get_nat_cases_on_name()) ||\n        (is_constant(e) && get_vm_builtin_cases_idx(env, const_name(e)));\n}\n",
        "answer": "/** @brief Checks if a given expression is a supported cases in the VM.\n*\n* This function checks if an expression 'e' is an internal cases, a nat.cases_on, or a VM builtin cases.\n* It returns true for constants that produce branching during code generation.\n*\n* @param env The environment of the expression.\n* @param e The expression to be checked.\n* @return True if 'e' is an internal cases, a nat.cases_on, or a VM builtin cases, false otherwise.\n*/\nbool is_vm_supported_cases(environment const & env, expr const & e) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "environment add_transient_decl_pos_info(environment const & env, name const & decl_name, pos_info const & pos) {\n    module_ext ext = get_extension(env);\n    ext.m_decl2pos_info.insert(decl_name, pos);\n    return update(env, ext);\n}\n",
        "answer": "/** @brief Add transient declaration position information.\n*\n*  This function associates the given position with the given declaration. The information is not saved on .olean files. We use this function for attaching position information to temporary functions.\n*\n* @param env The environment in which the declaration was made.\n* @param decl_name The name of the declaration.\n* @param pos The position information to be associated with the declaration.\n*\n* @return A new environment with the updated position information.\n*/\nenvironment add_transient_decl_pos_info(environment const & env, name const & decl_name, pos_info const & pos) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "name mk_aux_meta_rec_name(name const & n) {\n    return name(n, g_aux_meta_rec_prefix);\n}\n",
        "answer": "/** @brief Creates an auxiliary meta definition for a regular recursive definition.\n*\n* This function generates an auxiliary meta definition for the given name, which is used to represent the recursive structure of a regular recursive definition in the VM. The auxiliary meta definition has a clear runtime cost execution model and is used in the VM.\n*\n* @param n The name of the regular recursive definition.\n* @return The auxiliary meta definition for the given name.\n*/\nname mk_aux_meta_rec_name(name const & n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   void performWork(void* work) {\n      SampleJob* j = static_cast<SampleJob*>(work);\n      j->x++;\n   }\n",
        "answer": "/** @brief Performs work on a sample job.\n*\n*  This function is used to perform work on a sample job. It takes a void pointer as an argument, which is then cast to a SampleJob object. The x member of the SampleJob object is then incremented.\n*\n* @param[in] work A void pointer to a SampleJob object.\n*/\nvoid performWork(void* work) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline void line2wvec(unsigned int x, unsigned int y,\n                             pal::wf_int32 *vx, pal::wf_int32 *vy) {\n   unsigned int t;\n   int swap = 0;\n   if (x > y) {\n      t = x;\n      x = y;\n      y = t;\n      swap = 1;\n   }\n\n   t = y >> 4;\n   while (t) {\n      t >>= 1;\n      x >>= 1;\n      y >>= 1;\n   }\n   if (swap) {\n      *vy = intsine[x][y];\n      *vx = intsine[y][x];\n   }\n   else {\n      *vx = intsine[x][y];\n      *vy = intsine[y][x];\n   }\n}\n",
        "answer": "/**\n* @brief Converts a line in the first quadrant to a vector of length 128.\n*\n* Given a vector (x,y) in the first quadrant, returns one of roughly 90 possible approximate vectors of length 128.\n*\n* @param x The x-coordinate of the input vector.\n* @param y The y-coordinate of the input vector.\n* @param vx A pointer to an integer that will be set to the x-coordinate of the output vector.\n* @param vy A pointer to an integer that will be set to the y-coordinate of the output vector.\n*/\nstatic inline void line2wvec(unsigned int x, unsigned int y, pal::wf_int32 *vx, pal::wf_int32 *vy) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void nvs_dump(const char *partName)\n{\n    Lock lock;\n    nvs::Storage* pStorage;\n\n    pStorage = lookup_storage_from_name(partName);\n    if (pStorage == NULL) {\n        return;\n    }\n\n    pStorage->debugDump();\n    return;\n}\n",
        "answer": "/** @brief Dumps the contents of NVS pages.\n*\n*  This function may be used for debugging purposes to inspect the state of NVS pages. For each page, list of entries is also dumped.\n*\n* @param partName The name of the partition to dump.\n* @return Should not return\n*/\nextern \"C\" void nvs_dump(const char *partName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void process(std::shared_ptr<int> ptr)\n{\n    std::cout << \"inside the process function:\" << ptr.use_count() << \"\\n\";\n}\n",
        "answer": "/** @brief Processes a shared pointer to an integer.\n*\n*  This function takes a shared pointer to an integer as its argument and prints the use count of the shared pointer to the console.\n*\n* @param ptr A shared pointer to an integer.\n*/\nvoid process(std::shared_ptr<int> ptr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int compare(const T &v1, const T &v2)\n{\n    if (v1 < v2) return -1;\n    if (v2 < v1) return 1;\n    return 0;\n}\n",
        "answer": "/** @brief Compare two values of the same type.\n*\n* This function compares two values of the same type and returns an integer indicating their relationship.\n* If v1 is less than v2, it returns -1. If v2 is less than v1, it returns 1. If they are equal, it returns 0.\n* The function uses a template parameter to specify the type of the values being compared.\n* This allows the function to be used with different types, such as integers or floating-point numbers.\n*\n* @tparam T The type of the values being compared.\n* @param v1 The first value to compare.\n* @param v2 The second value to compare.\n* @return An integer indicating the relationship between the two values.\n*/\nint compare(const T &v1, const T &v2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::size_t count(const std::vector<T>& vec, T value)\n{\n    std::size_t count = 0;\n    for(auto& item : vec)\n        count += (item == value)? 1 : 0 ;\n\n    return count;\n}\n",
        "answer": "/** @brief Count the number of occurrences of a given value in a vector.\n*\n* This function takes a vector and a value as input, and returns the number of times the value appears in the vector.\n*\n* @tparam T The type of the elements in the vector.\n* @param vec The vector to search for the value.\n* @param value The value to count the occurrences of.\n* @return The number of occurrences of the value in the vector.\n*/\ntemplate <typename T>"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  QString createFileFilter_( QString const &longName, QString const &glob )\n  {\n    return QString( \"%1 (%2 %3)\" ).arg( longName ).arg( glob.toLower() ).arg( glob.toUpper() );\n  }\n",
        "answer": "/** @brief Convenience function for readily creating file filters.\n*\n* This is the description of the functionality of the function.\n* Given a long name for a file filter and a regular expression, return a file filter string suitable for use in a QFileDialog::OpenFiles() call. The regular express, glob, will have both all lower and upper case versions added.\n*\n* @param[in] longName A QString containing the long name of the file filter.\n* @param[in] glob A QString containing the regular expression for the file filter.\n* @return A QString containing the file filter string suitable for use in a QFileDialog::OpenFiles() call.\n*/\nQString createFileFilter_( QString const &longName, QString const &glob )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void reserve(std::string &buf, size_t needed)\n{\n  size_t size =buf.size();\n  size += needed;\n  buf.reserve(size);\n}\n",
        "answer": "/** @brief Reserve space in a buffer.\n*\n* This function reserves space in a buffer by allocating a new buffer at least twice as large as the current buffer if there is not enough space.\n*\n* @param buf The buffer to reserve space in.\n* @param needed The amount of space needed.\n*/\nvoid reserve(std::string &buf, size_t needed)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    string serialize(TreeNode *root) {\n        ostringstream out;\n        serializeHelper(root, out);\n        return out.str();\n    }\n",
        "answer": "/** @brief Serialize a binary tree to a string.\n*\n*  This method will be invoked first, you should design your own algorithm to serialize a binary tree which denote by a root node to a string which can be easily deserialized by your own \"deserialize\" method later.\n*\n* @param[in] root The root node of the binary tree to be serialized.\n* @return A string representation of the binary tree.\n*/\nstring serialize(TreeNode *root) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual boolean correctDriftSampleCount(int64 i64SampleCount)\r\n\t\t{\r\n\t\t\treturn m_rAcquisitionServer.correctDriftSampleCount(i64SampleCount);\r\n\t\t}\r\n",
        "answer": "/** @brief Corrects drift in sample count.\n*\n*  This function helps to correct the drifting, removing or adding dummy samples. In a strict signal processing point of view those samples can't be considered as valid. However, this is the only way to guarantee that the timings are preserved.\n*\n* @param i64SampleCount The sample count to correct drift for.\n* @return True if the drift was corrected successfully, false otherwise.\n*/\nvirtual boolean correctDriftSampleCount(int64 i64SampleCount)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string fromRaw(h256 _n)\r\n{\r\n\tif (_n)\r\n\t{\r\n\t\tstring s((char const*)_n.data(), 32);\r\n\t\tauto l = s.find_first_of('\\0');\r\n\t\tif (!l)\r\n\t\t\treturn \"\";\r\n\t\tif (l != string::npos)\r\n\t\t\ts.resize(l);\r\n\t\tfor (auto i: s)\r\n\t\t\tif (i < 32)\r\n\t\t\t\treturn \"\";\r\n\t\treturn s;\r\n\t}\r\n\treturn \"\";\r\n}\r\n",
        "answer": "/** @brief Convert h256 into user-readable string.\n*\n*  This function converts an h256 value into a user-readable string by directly using the std::string constructor. If it can't be interpreted as an ASCII string, an empty string is returned.\n*\n* @param _n The h256 value to convert.\n* @return A user-readable string representation of the h256 value, or an empty string if it cannot be interpreted as an ASCII string.\n*/\nstring fromRaw(h256 _n)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool luaval_is_usertype(lua_State* L,int lo,const char* type, int def)\r\n{\r\n    if (def && lua_gettop(L)<abs(lo))\r\n        return true;\r\n    \r\n    if (lua_isnil(L,lo) || lua_isusertype(L,lo,type))\r\n        return true;\r\n    \r\n    return false;\r\n}\r\n",
        "answer": "/** @brief Checks if the value at the given index on the Lua stack is a userdata of the specified type.\n*\n*  This function checks if the value at the given index on the Lua stack is a userdata of the specified type. If the value is nil or a userdata of the specified type, it returns true. Otherwise, it returns false.\n*\n* @param L The Lua state.\n* @param lo The index on the Lua stack to check.\n* @param type The name of the userdata type to check for.\n* @param def A flag indicating whether the value should be considered a userdata if it is not found in the stack. If this parameter is non-zero, the function will return true if the index is greater than the top of the stack.\n*\n* @return True if the value at the given index on the Lua stack is nil or a userdata of the specified type, false otherwise.\n*/\nbool luaval_is_usertype(lua_State* L, int lo, const char* type, int def) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool luaval_to_number(lua_State* L,int lo,double* outValue, const char* funcName)\r\n{\r\n    if (NULL == L || NULL == outValue)\r\n        return false;\r\n    \r\n    bool ok = true;\r\n\r\n    tolua_Error tolua_err;\r\n    if (!tolua_isnumber(L,lo,0,&tolua_err))\r\n    {\r\n#if COCOS2D_DEBUG >=1\r\n        luaval_to_native_err(L,\"#ferror:\",&tolua_err,funcName);\r\n#endif\r\n        ok = false;\r\n    }\r\n    \r\n    if (ok)\r\n    {\r\n        *outValue = tolua_tonumber(L, lo, 0);\r\n    }\r\n    \r\n    return ok;\r\n}\r\n",
        "answer": "/** @brief luaval_to_number.\n*\n* This function gets a double value from the given acceptable index of stack. If the value at the given acceptable index of stack is a number or a string convertible to a number it returns true, otherwise returns false.\n*\n* @param L lua state.\n* @param lo acceptable index of stack.\n* @param outValue double pointer to store the output value.\n* @param funcName function name.\n* @return true if the value at the given acceptable index of stack is a number or a string convertible to a number, false otherwise.\n*/\n*outValue = tolua_tonumber(L, lo, 0);\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool luaval_to_ulong(lua_State* L,int lo, unsigned long* outValue, const char* funcName)\r\n{\r\n    if (NULL == L || NULL == outValue)\r\n        return false;\r\n    \r\n    bool ok = true;\r\n    \r\n    tolua_Error tolua_err;\r\n    if (!tolua_isnumber(L,lo,0,&tolua_err))\r\n    {\r\n#if COCOS2D_DEBUG >=1\r\n        luaval_to_native_err(L,\"#ferror:\",&tolua_err,funcName);\r\n#endif\r\n        ok = false;\r\n    }\r\n    \r\n    if (ok)\r\n    {\r\n        *outValue = (unsigned long)tolua_tonumber(L, lo, 0);\r\n    }\r\n    \r\n    return ok;\r\n}\r\n",
        "answer": "/**\n* @brief Converts a Lua value to an unsigned long.\n*\n* This function takes a Lua state, an index on the stack, and a pointer to an\n* unsigned long as input. It checks if the value at the given index is a number\n* or a string convertible to a number, and if so, it converts it to an unsigned\n* long and stores the result in the output parameter. If the value is not a\n* number or a string convertible to a number, the function returns false.\n*\n* @param L The Lua state.\n* @param lo The index on the stack of the value to be converted.\n* @param outValue A pointer to an unsigned long where the result will be stored.\n* @param funcName The name of the calling function (for error reporting).\n*\n* @return True if the conversion was successful, false otherwise.\n*/\nbool luaval_to_ulong(lua_State* L, int lo, unsigned long* outValue, const char* funcName);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void size_to_luaval(lua_State* L,const Size& sz)\r\n{\r\n    if (NULL  == L)\r\n        return;\r\n    lua_newtable(L);                                    /* L: table */\r\n    lua_pushstring(L, \"width\");                         /* L: table key */\r\n    lua_pushnumber(L, (lua_Number) sz.width);           /* L: table key value*/\r\n    lua_rawset(L, -3);                                  /* table[key] = value, L: table */\r\n    lua_pushstring(L, \"height\");                        /* L: table key */\r\n    lua_pushnumber(L, (lua_Number) sz.height);          /* L: table key value*/\r\n    lua_rawset(L, -3);                                  /* table[key] = value, L: table */\r\n}\r\n",
        "answer": "/**\n* @brief Push a table converted from a cocos2d::Size object into the Lua stack. The format of table as follows: {width=numberValue1, height=numberValue2}\n*\n* This function creates a new table on the Lua stack and populates it with the width and height values of the given Size object. The resulting table has the following format: {width=numberValue1, height=numberValue2}.\n*\n* @param L The Lua state to push the table onto.\n* @param sz The cocos2d::Size object to convert to a table.\n*/\nvoid size_to_luaval(lua_State* L, const Size& sz);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mesh_vertex_attrib_to_luaval(lua_State* L, const cocos2d::MeshVertexAttrib& inValue)\r\n{\r\n    if (nullptr == L)\r\n        return;\r\n    \r\n    lua_newtable(L);\r\n    \r\n    lua_pushstring(L, \"size\");\r\n    lua_pushnumber(L, (lua_Number)inValue.size);\r\n    lua_rawset(L, -3);\r\n    \r\n    lua_pushstring(L, \"type\");\r\n    lua_pushnumber(L, (lua_Number)inValue.type);\r\n    lua_rawset(L, -3);\r\n    \r\n    lua_pushstring(L, \"vertexAttrib\");\r\n    lua_pushnumber(L, (lua_Number)inValue.vertexAttrib);\r\n    lua_rawset(L, -3);\r\n    \r\n    lua_pushstring(L, \"attribSizeBytes\");\r\n    lua_pushnumber(L, (lua_Number)inValue.attribSizeBytes);\r\n    lua_rawset(L, -3);\r\n}\r\n",
        "answer": "/** @brief Push a table converted from a cocos2d::MeshVertexAttrib object into the Lua stack. The format of table as follows: {size=numberValue1, type=numberValue2, vertexAttrib=numberValue3, attribSizeBytes=numberValue4}\n*\n*  This function pushes a table converted from a cocos2d::MeshVertexAttrib object into the Lua stack. The format of the table is as follows: {size=numberValue1, type=numberValue2, vertexAttrib=numberValue3, attribSizeBytes=numberValue4}.\n*\n* @param L The lua_State pointer.\n* @param inValue The cocos2d::MeshVertexAttrib object to be converted into a table.\n*/\nvoid mesh_vertex_attrib_to_luaval(lua_State* L, const cocos2d::MeshVertexAttrib& inValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void pause()\n  {\n    event::wait_event(event::key_press(event::key_space));\n  }\n",
        "answer": "/** @brief Pause the current thread until the user presses the space key in any of the windows. It needs at least one created window.\n* @return Should not return\n*/\nvoid pause()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t get_num_allocated_rows_from_gpu(Data_Namespace::DataMgr* data_mgr,\n                                       CUdeviceptr projection_size_gpu,\n                                       const int device_id) {\n  int32_t num_rows{0};\n  copy_from_gpu(data_mgr, &num_rows, projection_size_gpu, sizeof(num_rows), device_id);\n  CHECK(num_rows >= 0);\n  return static_cast<size_t>(num_rows);\n}\n",
        "answer": "/** @brief Returns the number of allocated rows per device.\n*\n* This function retrieves the total number of allocated rows per device from the GPU memory.\n* It uses the DataMgr class to copy the data from the GPU memory to the CPU memory and then returns it as a size_t value.\n* The function also checks if the number of rows is greater than or equal to zero before returning it.\n*\n* @param data_mgr A pointer to the DataMgr object that manages the data on the GPU.\n* @param projection_size_gpu A pointer to the GPU memory location where the projection size is stored.\n* @param device_id The ID of the device from which the data will be retrieved.\n* @return The total number of allocated rows per device as a size_t value.\n*/\nsize_t get_num_allocated_rows_from_gpu(Data_Namespace::DataMgr* data_mgr,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Ogre::MaterialPtr GetOrCreateUnlitTexturedMaterial(const std::string& materialName)\n{\n    std::string baseMaterialName = \"UnlitTextured\";\n\n    Ogre::MaterialManager &mm = Ogre::MaterialManager::getSingleton();\n    Ogre::MaterialPtr material = mm.getByName(AssetAPI::SanitateAssetRef(materialName));\n\n    if (!material.get())\n    {\n        Ogre::MaterialPtr baseMaterial = mm.getByName(AssetAPI::SanitateAssetRef(baseMaterialName));\n        if (baseMaterial.isNull())\n            return Ogre::MaterialPtr();\n        material = baseMaterial->clone(AssetAPI::SanitateAssetRef(materialName));\n    }\n\n    assert(material.get());\n    return material;\n}\n",
        "answer": "/**\n* @brief Gets or creates an unlit textured material.\n*\n* This function retrieves a material with the specified name from the Ogre Material Manager,\n* or creates a new one if it does not exist. The material is derived from an UnlitTextured material,\n* which is a simple material that can be used for debugging visualizations.\n*\n* @param materialName The name of the material to retrieve or create.\n* @return A pointer to the material, or nullptr if it could not be created.\n*/\nOgre::MaterialPtr GetOrCreateUnlitTexturedMaterial(const std::string& materialName);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void onLabelChange(const char oldLabel[], const char newLabel[])\n\t{\n\t\tthis->INHERITED::onLabelChange(oldLabel, newLabel);\n\n\t\tSkEvent evt(\"user\");\n\t\tevt.setString(\"id\", \"setLabel\");\n\t\tevt.setString(\"LABEL\", newLabel);\n\t\tfAnim.doUserEvent(evt);\n\t}\n",
        "answer": "/** @brief Called when the label changes. Override in subclasses. Default action invalidates the view's bounds. Called with the old and new labels, before the label has actually changed.\n*\n*  This function is called when the label of a view changes. It is called with the old and new labels as parameters, before the label has actually changed. The default action is to invalidate the view's bounds. Subclasses can override this function to provide custom behavior.\n*\n* @param oldLabel The old label of the view.\n* @param newLabel The new label of the view.\n*/\nvirtual void onLabelChange(const char oldLabel[], const char newLabel[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SkChopQuadAt(const SkPoint src[3], SkPoint dst[5], SkScalar t)\n{\n    SkASSERT(t > 0 && t < SK_Scalar1);\n\n    interp_quad_coords(&src[0].fX, &dst[0].fX, t);\n    interp_quad_coords(&src[0].fY, &dst[0].fY, t);\n}\n",
        "answer": "/** @brief Chop a quadratic bezier at the specified t value.\n*\n*  Given a src quadratic bezier, chop it at the specified t value, where 0 < t < 1, and return the two new quadratics in dst: dst[0..2] and dst[2..4].\n*\n* @param src The source quadratic bezier.\n* @param dst The destination quadratics.\n* @param t The chop point, where 0 < t < 1.\n*/\nvoid SkChopQuadAt(const SkPoint src[3], SkPoint dst[5], SkScalar t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SkChopCubicAt(const SkPoint src[4], SkPoint dst[7], SkScalar t)\n{\n    SkASSERT(t > 0 && t < SK_Scalar1);\n\n    interp_cubic_coords(&src[0].fX, &dst[0].fX, t);\n    interp_cubic_coords(&src[0].fY, &dst[0].fY, t);\n}\n",
        "answer": "/** @brief Chop a cubic bezier at the specified t value.\n*\n*  This function takes a source cubic bezier and chops it at the specified t value, where 0 < t < 1, and returns the two new cubics in dst: dst[0..3] and dst[3..6].\n*\n* @param src The source cubic bezier to be chopped.\n* @param dst The destination array for the two new cubics.\n* @param t The t value at which to chop the cubic.\n*\n* @return None.\n*/\nvoid SkChopCubicAt(const SkPoint src[4], SkPoint dst[7], SkScalar t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sk_out_of_memory(void)\n{\n#ifdef ANDROID\n    fprintf(stderr,\"- out of memory in SGL -\\n\");\n#endif\n    SkASSERT(!\"sk_out_of_memory\");\n    abort();\n}\n",
        "answer": "/** @brief Handles the case where we run out of memory.\n*\n*  This function is called internally if we run out of memory. The platform implementation must not return, but should either throw an exception or otherwise exit.\n*\n* @return Should not return\n*/\nvoid sk_out_of_memory(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int32_t sk_atomic_dec(int32_t* addr)\n{\n    return InterlockedDecrement(reinterpret_cast<LONG*>(addr)) + 1;\n}\n",
        "answer": "/** @brief Decrements the value pointed to by `addr` in a thread-safe manner.\n*\n* Implemented by the porting layer, this function subtracts 1 from the int\n* specified by the address (in a thread-safe manner), and returns the previous\n* value.\n*\n* @param addr The address of the integer to decrement.\n* @return The previous value of the integer.\n*/\nint32_t sk_atomic_dec(int32_t* addr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void WriteLogin (const boost::shared_ptr<OPacket> &pkt, const uint32_t clientID, const LOGIN_ERROR error)\n{\n    pkt->WriteOpcode(SERVER_ACCOUNT_PROCESS);\n    pkt->Write<uint32_t>(clientID);\n    pkt->Write<uint8_t>(ANSWER_ERROR);\n    pkt->Write<uint8_t>(error);\n}\n",
        "answer": "/** @brief Write a login error packet.\n*\n*  This function writes an encrypted login error packet to the client.\n*\n* @param pkt The packet to write to.\n* @param clientID The ID of the client.\n* @param error The login error code.\n*/\nvoid WriteLogin (const boost::shared_ptr<OPacket> &pkt, const uint32_t clientID, const LOGIN_ERROR error)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool GetBlockHash(uint256& hashRet, int nBlockHeight)\n{\n    LOCK(cs_main);\n    if (chainActive.Tip() == NULL)\n        return false;\n    if (nBlockHeight < -1 || nBlockHeight > chainActive.Height())\n        return false;\n    if (nBlockHeight == -1)\n        nBlockHeight = chainActive.Height();\n    hashRet = chainActive[nBlockHeight]->GetBlockHash();\n    return true;\n}\n",
        "answer": "/** @brief Get block hash.\n*\n*  This function returns the block hash for a given height in the active chain.\n*  If no nBlockHeight is specified, it uses the current tip of the active chain.\n*\n* @param[out] hashRet The found hash.\n* @param[in] nBlockHeight The height of the block to find.\n* @return True if the hash was found, false otherwise.\n*/\nbool GetBlockHash(uint256& hashRet, int nBlockHeight)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void plbWarning(std::string message) {\n    if (global::mpi().isMainProcessor()) {\n        warningFile().write(message);\n    }\n}\n",
        "answer": "/**\n* @brief Issues a warning message to the warning file if the main processor.\n*\n* This function checks if the current processor is the main processor, and if so, it writes the given message to the warning file.\n*\n* @param message The message to be written to the warning file.\n*/\nvoid plbWarning(std::string message) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "MultiBlockManagement2D intersect( MultiBlockManagement2D const& management1,\n                                  MultiBlockManagement2D const& management2, bool crop )\n{\n    return MultiBlockManagement2D (\n            intersect(management1.getSparseBlockStructure(),\n                      management2.getSparseBlockStructure(), crop),\n            management1.getThreadAttribution().clone(),\n            management1.getEnvelopeWidth(),\n            management1.getRefinementLevel() );\n}\n",
        "answer": "/** @brief Intersect two MultiBlockManagement2D objects.\n*\n*  This function intersects the bounding boxes of two MultiBlockManagement2D objects and returns a new object with the resulting bounding box. If crop is true, the resulting bounding box will be the intersection of the two original bounding boxes. Otherwise, it will be the union of the two. The block-ids and thread-attribution are inherited from management1.\n*\n* @param[in] management1 The first MultiBlockManagement2D object to intersect.\n* @param[in] management2 The second MultiBlockManagement2D object to intersect.\n* @param[in] crop If true, the resulting bounding box will be the intersection of the two original bounding boxes. Otherwise, it will be the union of the two.\n* @return A new MultiBlockManagement2D object with the resulting bounding box.\n*/\nMultiBlockManagement2D intersect( MultiBlockManagement2D const& management1,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void applyProcessingFunctional(BoxProcessingFunctional2D* functional,\n                               Box2D domain, std::vector<MultiBlock2D*> multiBlocks)\n{\n    executeDataProcessor( BoxProcessorGenerator2D(functional, domain),\n                          multiBlocks );\n}\n",
        "answer": "/** @brief Applies a 2D boxed data functional to a set of multi-blocks.\n*\n* This is the most general wrapper for applying a 2D boxed data functional. Use this if none of the more specific wrappers works.\n*\n* @param [in] functional The 2D boxed data functional to apply.\n* @param [in] domain The 2D domain on which to apply the functional.\n* @param [in,out] multiBlocks The set of multi-blocks to which to apply the functional.\n*/\nvoid applyProcessingFunctional(BoxProcessingFunctional2D* functional,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void copy_generic (\n        MultiBlock2D const& from, Box2D const& fromDomain,\n        MultiBlock2D& to, Box2D const& toDomain, modif::ModifT typeOfModif )\n{\n    Box2D fromDomain_(fromDomain);\n    Box2D toDomain_(toDomain);\n    adjustEqualSize(fromDomain_, toDomain_);\n    std::vector<Overlap2D> dataTransfer = copyDomainDataTransfer (\n                from.getMultiBlockManagement().getSparseBlockStructure(), fromDomain_,\n                to.getMultiBlockManagement().getSparseBlockStructure(), toDomain_ );\n    to.getBlockCommunicator().communicate (\n            dataTransfer, from, to, typeOfModif );\n    to.getBlockCommunicator().duplicateOverlaps(to, typeOfModif);\n}\n",
        "answer": "/** @brief Copies the contents of one MultiBlock2D object to another based on a specified domain and modification type.\n*\n*  This function copies the data from one MultiBlock2D object to another, using a specified domain and modification type. The two blocks must be of the same kind, and the smaller domain is taken to be the valid one if they have different extents.\n*\n* @param[in] from The source MultiBlock2D object.\n* @param[in] fromDomain The domain to copy data from in the source block.\n* @param[out] to The destination MultiBlock2D object.\n* @param[in] toDomain The domain to copy data to in the destination block.\n* @param[in] typeOfModif The modification type to use when copying data.\n*\n* @return void\n*/\nvoid copy_generic ("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void applyProcessingFunctional(BoxProcessingFunctional3D* functional,\n                               Box3D domain, std::vector<MultiGrid3D*> multiBlocks, plint referenceLevel )\n{\n    executeDataProcessor( BoxProcessorGenerator3D(functional, domain),\n                          multiBlocks, referenceLevel );\n}\n",
        "answer": "/** @brief Applies a processing functional to a 3D boxed data.\n*\n* This is the most general wrapper for applying a 3D boxed data functional. Use this if none of the more specific wrappers works.\n*\n* @param [in] functional The BoxProcessingFunctional3D object that contains the processing functional to be applied.\n* @param [in] domain The Box3D object that defines the domain on which the functional is to be applied.\n* @param [in,out] multiBlocks A vector of MultiGrid3D objects that contain the data to be processed.\n* @param [in] referenceLevel The level at which the data is defined.\n*/\nvoid applyProcessingFunctional(BoxProcessingFunctional3D* functional, Box3D domain, std::vector<MultiGrid3D*> multiBlocks, plint referenceLevel )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\nvoid ElGamal_TestInstantiations()\n{\n\tElGamalEncryptor test1(1, 1, 1);\n\tElGamalDecryptor test2(NullRNG(), 123);\n\tElGamalEncryptor test3(test2);\n}\n",
        "answer": "/** @brief ElGamal encryption and decryption instantiations.\n*\n* This function tests the instantiation of ElGamal encryptor and decryptor objects with various parameters.\n*\n* @param[in] test1 An instance of ElGamalEncryptor with parameters 1, 1, and 1.\n* @param[in] test2 An instance of ElGamalDecryptor with a NullRNG object and parameter 123.\n* @param[in] test3 An instance of ElGamalEncryptor with the same parameters as test2.\n*/\nvoid ElGamal_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void action(const gcn::ActionEvent& actionEvent)\n    {\n      int selected_item;\n      char foldername[MAX_PATH] = \"\";\n\n      selected_item = lstFolders->getSelected();\n      strncpy(foldername, workingDir, MAX_PATH - 1);\n      strncat(foldername, \"/\", MAX_PATH - 1);\n      strncat(foldername, dirList.getElementAt(selected_item).c_str(), MAX_PATH - 1);\n      checkfoldername(foldername);\n    }\n",
        "answer": "/** @brief Handles an action event from a widget.\n*\n*  This function is called when an action event is received from a widget. It is used to receive notifications that an action has occurred.\n*\n* @param[in] actionEvent The action event object containing information about the action.\n*/\nvoid action(const gcn::ActionEvent& actionEvent)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Eigen::Vector3d linearPart(Vector6d& vector)\n{\n\treturn vector.bottomRows<3>();\n}\n",
        "answer": "/** @brief Returns the 3-coordinate vector with the linear components (linear velocity or force) of the given spatial vector.\n*\n* This function extracts the bottom three rows of a six-dimensional vector and returns them as a three-dimensional vector.\n* The bottom three rows represent the linear components (linear velocity or force) of the spatial vector.\n*\n* @param[in] vector The input spatial vector.\n* @return The 3-coordinate vector with the linear components of the given spatial vector.\n*/\nEigen::Vector3d linearPart(Vector6d& vector)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool filterPath(SkPath* dst, const SkPath& src, SkScalar* width) {\n        if (this->INHERITED::filterPath(dst, src, width)) {\n            *width = fWidth;\n            return true;\n        }\n        return false;\n    }\n",
        "answer": "/** @brief Filter a path.\n*\n*  Given a source path and a width value, return true if the patheffect has produced a new path (dst) and a new width value. If false is returned, ignore dst and width. On input, width >= 0 means the src should be stroked On output, width >= 0 means the dst should be stroked\n*\n* @param[out] dst The destination path.\n* @param[in] src The source path.\n* @param[in, out] width The width of the path.\n*\n* @return True if the patheffect has produced a new path and a new width value, false otherwise.\n*/\n*width = fWidth;\nreturn true;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int compute_image_height (const SkBitmap& bmp) {\n    int retval = 240;\n    if (bmp.height() < retval) {\n        retval = bmp.height();\n    }\n    float scale = (float) retval / bmp.height();\n    if (bmp.width() * scale > 360) {\n        scale = (float) 360 / bmp.width();\n        retval = bmp.height() * scale;\n    }\n    return retval;\n}\n",
        "answer": "/**\n* @brief Computes the height of an image after scaling it to fit within a 240x360 bounding box.\n*\n* The function takes a SkBitmap object as input and returns the scaled height of the image.\n* The image is scaled to fit within a 240x360 bounding box, maintaining its aspect ratio.\n* If the width of the image after scaling exceeds 360 pixels, the function scales the image\n* down to fit within the bounding box while maintaining its aspect ratio.\n*\n* @param bmp The SkBitmap object representing the image to be scaled.\n*\n* @return The scaled height of the image.\n*/\nstatic int compute_image_height(const SkBitmap& bmp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    std::string rstrip( const std::string & str, const std::string & chars )\n    {\n        return do_strip( str, RIGHTSTRIP, chars );\n    }\n",
        "answer": "/**\n* @brief Remove trailing characters from a string.\n*\n* This function removes any trailing characters that are specified in the\n* `chars` parameter from the end of the input string. If `chars` is an empty\n* string, then whitespace characters will be removed instead.\n*\n* @param str The input string to strip.\n* @param chars The characters to remove from the end of the input string.\n*\n* @return A copy of the input string with trailing characters removed.\n*/\nstd::string rstrip( const std::string & str, const std::string & chars )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool islower( const std::string & str )\n    {\n        std::string::size_type len = str.size(), i;\n        if ( len == 0 ) return false;\n        if( len == 1 ) return ::islower( str[0] );\n\n        for ( i = 0; i < len; ++i )\n        {\n           if ( !::islower( str[i] ) ) return false;\n        }\n        return true;\n    }\n",
        "answer": "/**\n* @brief Checks if all cased characters in a string are lowercase.\n*\n* This function checks if all cased characters in a string are lowercase, and returns true if so. If there are no cased\n* characters or any of them is not lowercase, the function returns false.\n*\n* @param str The input string to check.\n* @return True if all cased characters in the string are lowercase, false otherwise.\n*/\nbool islower(const std::string& str) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    std::string rjust( const std::string & str, int width )\n    {\n        std::string::size_type len = str.size();\n        if ( (( int ) len ) >= width ) return str;\n        return std::string( width - len, ' ' ) + str;\n    }\n",
        "answer": "/**\n* @brief Right justify a string in a field of a given width.\n*\n* This function right justifies a string in a field of a given width by padding it with spaces on the left. If the original string is longer than the width, it is returned unchanged.\n*\n* @param str The input string to be right-justified.\n* @param width The width of the field in which the string should be right-justified.\n* @return A new string that is the right-justified version of the input string.\n*/\nstd::string rjust( const std::string & str, int width )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool isabs(const std::string & path)\n    {\n#ifdef WINDOWS\n        return isabs_nt(path);\n#else\n        return isabs_posix(path);\n#endif\n    }\n",
        "answer": "/** @brief Checks if the given path is an absolute pathname.\n*\n* This function checks if the given path is an absolute pathname on Unix or Windows systems. On Unix, an absolute pathname starts with a slash. On Windows, it starts with a (back)slash after chopping off a potential drive letter.\n*\n* @param[in] path The path to check.\n* @return True if the path is an absolute pathname, false otherwise.\n*/\nbool isabs(const std::string &path)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void splitext(std::string & root, std::string & ext, const std::string & path)\n    {\n#ifdef WINDOWS\n        return splitext_nt(root, ext, path);\n#else\n        return splitext_posix(root, ext, path);\n#endif\n    }\n",
        "answer": "/** @brief Splits the pathname into a pair (root, ext) such that root + ext == path, and ext is empty or begins with a period and contains at most one period. Leading periods on the basename are ignored; splitext('.cshrc') returns ('.cshrc', '').\n*\n* @param[in] path The input path to be split.\n* @param[out] root The root of the path.\n* @param[out] ext The extension of the path.\n*\n* @return void\n*/\nvoid splitext(std::string &root, std::string &ext, const std::string &path)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    std::string rstrip(const std::string &str, const std::string &chars) {\n        return do_strip(str, RIGHTSTRIP, chars);\n    }\n",
        "answer": "/** @brief Removes trailing characters from a string.\n*\n*  This function returns a copy of the input string with all trailing characters removed. If the input string is empty,\n*  whitespace characters are removed. Otherwise, the characters in the input string will be stripped from the end of the\n*  string.\n*\n* @param str The input string to strip.\n* @param chars The characters to remove from the end of the string. If this parameter is empty, whitespace characters\n*              are removed.\n*\n* @return A copy of the input string with all trailing characters removed.\n*/\nstd::string rstrip(const std::string &str, const std::string &chars) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool islower(const std::string &str) {\n        std::string::size_type len = str.size(), i;\n        if (len == 0) return false;\n        if (len == 1) return ::islower(str[0]);\n\n        for (i = 0; i < len; ++i) {\n            if (!::islower(str[i])) return false;\n        }\n        return true;\n    }\n",
        "answer": "/**\n* @brief Checks if all cased characters in a string are lowercase.\n*\n* This function checks if all cased characters in a string are lowercase and returns true if so, false otherwise.\n* If the string is empty or contains no cased characters, it will return false.\n*\n* @param str The input string to check.\n* @return True if all cased characters in the string are lowercase, false otherwise.\n*/\nbool islower(const std::string &str) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    std::string ljust(const std::string &str, int width) {\n        std::string::size_type len = str.size();\n        if (((int) len) >= width) return str;\n        return str + std::string(width - len, ' ');\n    }\n",
        "answer": "/** @brief Left justify a string in a field of a given width.\n*\n*  This function takes a string and left-justifies it in a field of the specified width. If the string is longer than the field, it is returned unchanged. Otherwise, spaces are added to the right of the string until it reaches the desired width.\n*\n* @param str The input string.\n* @param width The desired width of the field.\n* @return The left-justified string in a field of the specified width.\n*/\nstd::string ljust(const std::string &str, int width) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void splitlines(const std::string &str, std::vector<std::string> &result, bool keepends) {\n        result.clear();\n        std::string::size_type len = str.size(), i, j, eol;\n\n        for (i = j = 0; i < len;) {\n            while (i < len && str[i] != '\\n' && str[i] != '\\r') i++;\n\n            eol = i;\n            if (i < len) {\n                if (str[i] == '\\r' && i + 1 < len && str[i + 1] == '\\n') {\n                    i += 2;\n                }\n                else {\n                    i++;\n                }\n                if (keepends)\n                    eol = i;\n\n            }\n\n            result.push_back(str.substr(j, eol - j));\n            j = i;\n\n        }\n\n        if (j < len) {\n            result.push_back(str.substr(j, len - j));\n        }\n\n    }\n",
        "answer": "/** @brief Splits a string into lines, breaking at line boundaries.\n*\n*  This function takes a string and splits it into lines, breaking at line boundaries. The resulting list of lines does not include the line breaks unless keepends is given and true.\n*\n* @param str The input string to be split.\n* @param result A vector of strings that will hold the resulting lines.\n* @param keepends If true, the line breaks are included in the resulting list.\n*/\nvoid splitlines(const std::string &str, std::vector<std::string> &result, bool keepends) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "            std::string dirname(const std::string &path) {\n#ifdef WINDOWS\n                return dirname_nt(path);\n#else\n                return dirname_posix(path);\n#endif\n            }\n",
        "answer": "/**\n* @brief Returns the directory name of a path.\n*\n* This function returns the directory name of a given path. It uses the\n* dirname_nt() function on Windows and the dirname_posix() function on other\n* platforms.\n*\n* @param path The path to get the directory name for.\n*\n* @return The directory name of the path.\n*/\nstd::string dirname(const std::string &path) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double rand_chance(void)\n{\n    return (*mtRand)->randExc(100.0);\n}\n",
        "answer": "/** @brief Generates a random chance between 0 and 100.\n*\n* This function generates a random chance between 0 and 100 using the mtRand library.\n* The return value is a double, which supports up to 15 valid decimal digits.\n*\n* @return A random chance between 0 and 100 as a double.\n*/\ndouble rand_chance(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void vector_iset__(::Opm::RestartIO::vector_type * vector , int index , ::Opm::RestartIO::node_data_type * node) {\n  if (vector->size <= index)\n    ::Opm::RestartIO::vector_grow_NULL( vector , index );\n\n  if (index == vector->size)\n    ::Opm::RestartIO::vector_append_node( vector , node );\n  else {\n    if (vector->data[index] != NULL)\n      ::Opm::RestartIO::node_data_free( vector->data[index] );\n\n    vector->data[index] = node;\n  }\n}\n",
        "answer": "/** @brief Set the value of a node in a vector.\n*\n* This function sets the value of a node in a vector at a given index. If the index is beyond the length of the vector, the hole in the vector will be filled with NULL nodes.\n*\n* @param [in] vector The vector to modify.\n* @param [in] index The index of the node to set.\n* @param [in] node The new value for the node at the given index.\n*\n* @return None.\n*/\nstatic void vector_iset__(::Opm::RestartIO::vector_type * vector , int index , ::Opm::RestartIO::node_data_type * node) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool bc_is_base58_Char(const char ch)\n{\n    return libbitcoin::is_base58(ch);\n}\n",
        "answer": "/** @brief Checks if a character is a base58 character.\n*\n*  This function checks if the given character is a valid base58 character.\n*\n* @param ch The character to check.\n* @return True if the character is a base58 character, false otherwise.\n*/\nbool bc_is_base58_Char(const char ch)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool bc_ec_add_uncompressed(\n    bc_ec_uncompressed_t* point, const bc_ec_secret_t* secret)\n{\n    return libbitcoin::ec_add(*point->obj, *secret->obj);\n}\n",
        "answer": "/** @brief Compute the sum a += G*b, where G is the curve's generator point. Return false on failure (such as infinity or zero).\n*/\nbool bc_ec_add_uncompressed(bc_ec_uncompressed_t* point, const bc_ec_secret_t* secret)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint32_t bc_hd_first_hardened_key()\n{\n    return libbitcoin::wallet::hd_first_hardened_key;\n}\n",
        "answer": "/** @brief Returns the first hardened key for a Bitcoin HD wallet.\n*\n*  This function returns the first hardened key for a Bitcoin HD wallet, as defined by BIP32.\n*\n* @return The first hardened key for a Bitcoin HD wallet.\n*/\nuint32_t bc_hd_first_hardened_key()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t bc_mnemonic_word_multiple()\n{\n    return libbitcoin::wallet::mnemonic_word_multiple;\n}\n",
        "answer": "/** @brief Returns the multiple of words in a mnemonic phrase.\n*\n*  This function returns the number of words that are required to form a valid mnemonic phrase.\n*\n* @return The number of words in a mnemonic phrase.\n*/\nsize_t bc_mnemonic_word_multiple()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void bc_destroy_output_point_validation(bc_output_point_validation_t* self)\n{\n    if (self->delete_obj)\n        delete self->obj;\n    delete self;\n}\n",
        "answer": "/** @brief Destroys an output point validation object.\n*\n*  This function destroys an output point validation object, freeing any memory associated with it.\n*\n* @param self The output point validation object to destroy.\n*/\nvoid bc_destroy_output_point_validation(bc_output_point_validation_t* self)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool bc_is_stealth_script(const bc_script_t* script)\n{\n    return libbitcoin::is_stealth_script(*script->obj);\n}\n",
        "answer": "/** @brief Checks if a Bitcoin script is a stealth script.\n*\n*  This function checks if the given Bitcoin script is a stealth script, which is a type of script that can be used to hide the recipient's public key in a transaction.\n*\n* @param[in] script The Bitcoin script to check.\n* @return True if the script is a stealth script, false otherwise.\n*/\nbool bc_is_stealth_script(const bc_script_t* script)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void test_bulk_nonexistent() {\n    std::unique_ptr<cirrus::BladeClient> client =\n        cirrus::test_internal::GetClient(use_rdma_client);\n    cirrus::serializer_simple<int> serializer;\n    cirrus::ostore::FullBladeObjectStoreTempl<int> store(IP, PORT, client.get(),\n            serializer,\n            cirrus::deserializer_simple<int, sizeof(int)>);\n\n    cirrus::LRAddedEvictionPolicy policy(10);\n    cirrus::CacheManager<int> cm(&store, &policy, 10);\n    cm.put(1, 1);\n    std::vector<int> ret_values(10);\n    cm.get_bulk(1492, 1501, ret_values.data());\n}\n",
        "answer": "/** @brief Tests the bulk get functionality of the cache manager.\n*\n* This test ensures that error messages that would normally be generated during a get are still received during a get bulk.\n*\n* @param[in] use_rdma_client Whether to use an RDMA client or not.\n*/\nvoid test_bulk_nonexistent(bool use_rdma_client) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool RtLoadCarPitSetupFilename(void* hdlecar, const char* filepath,  tCarPitSetup* s, bool minmaxonly)\n{\n\tvoid* hdlesetup = GfParmReadFile(filepath, GFPARM_RMODE_STD);\n\tif (hdlesetup) {\n\t\thdlesetup = GfParmMergeHandles(hdlecar, hdlesetup, GFPARM_MMODE_DST | GFPARM_MMODE_RELDST);\n\t\tRtInitCarPitSetup(hdlesetup, s, minmaxonly);\n\t\tGfParmReleaseHandle(hdlesetup);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n",
        "answer": "/** @brief Load a custom car setup from a given filename.\n*\n*  This function loads a custom car setup from a given filename and validates it against the setup given in hdlecar.\n*\n* @param[in] hdlecar A handle to the car setup.\n* @param[in] filepath The path of the file containing the car setup.\n* @param[out] s A pointer to a tCarPitSetup structure that will be filled with the loaded setup.\n* @param[in] minmaxonly A boolean indicating whether to load only the minimum and maximum values for each parameter.\n* @return True if the setup was successfully loaded, false otherwise.\n*/\nbool RtLoadCarPitSetupFilename(void* hdlecar, const char* filepath, tCarPitSetup* s, bool minmaxonly)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "PetscReal parseOptionalPetscCmd_real(const std::string optionname, const PetscReal defval)\n{\n\tStatusCode ierr = 0;\n\tPetscBool set = PETSC_FALSE;\n\tPetscReal output = 0;\n\tierr = PetscOptionsGetReal(NULL, NULL, optionname.c_str(), &output, &set);\n\tpetsc_throw(ierr, std::string(\"Could not get real \")+ optionname);\n\tif(!set) {\n\t\tstd::cout << \"PETSc cmd option \" << optionname << \" not set; using default.\\n\";\n\t\toutput = defval;\n\t}\n\treturn output;\n}\n",
        "answer": "/** @brief Parses an optional PETSc command-line argument as a real number.\n*\n*  This function retrieves the value of a PETSc command-line option with the specified name, if it is set. If the option is not set, the default value is used instead. The function returns the parsed value as a `PetscReal`.\n*\n* @param optionname The name of the command-line option to parse.\n* @param defval The default value to use if the option is not set.\n*\n* @return The parsed value of the command-line option, or the default value if the option is not set.\n*/\nPetscReal parseOptionalPetscCmd_real(const std::string optionname, const PetscReal defval)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool FileStream_SetCallback(TFileStream * pStream, STREAM_DOWNLOAD_CALLBACK pfnCallback, void * pvUserData)\n{\n    TBlockStream * pBlockStream = (TBlockStream *)pStream;\n\n    if(pStream->BlockRead == NULL)\n    {\n        SetLastError(ERROR_NOT_SUPPORTED);\n        return false;\n    }\n\n    pBlockStream->pfnCallback = pfnCallback;\n    pBlockStream->UserData = pvUserData;\n    return true;\n}\n",
        "answer": "/** @brief Sets a download callback for the file stream.\n*\n*  This function sets a download callback for the file stream, which is called whenever the stream needs to download one or more blocks from the server.\n*\n* @param[in] pStream The file stream object.\n* @param[in] pfnCallback The download callback function.\n* @param[in] pvUserData User data that will be passed to the callback function.\n* @return true if the callback was set successfully, false otherwise.\n*/\nbool FileStream_SetCallback(TFileStream *pStream, STREAM_DOWNLOAD_CALLBACK pfnCallback, void *pvUserData) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SOUNDTOUCHDLL_API void __stdcall soundtouch_setRateChange(HANDLE h, float newRate)\r\n{\r\n    STHANDLE *sth = (STHANDLE*)h;\r\n    if (sth->dwMagic != STMAGIC) return;\r\n\r\n    sth->pst->setRateChange(newRate);\r\n}\r\n",
        "answer": "/**\n* @brief Sets new rate control value as a difference in percents compared to the original rate (-50 .. +100 %).\n*\n* This function sets the new rate control value as a difference in percents compared to the original rate. The range of values is from -50% to +100%.\n*\n* @param h A handle to the soundtouch object.\n* @param newRate The new rate control value.\n*/\nvoid __stdcall soundtouch_setRateChange(HANDLE h, float newRate);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void jsonnet_native_callback(struct JsonnetVm *vm, const char *name, JsonnetNativeCallback *cb,\n                             void *ctx, const char * const *params)\n{\n    std::vector<std::string> params2;\n    for (; *params != nullptr; params++)\n        params2.push_back(*params);\n    vm->nativeCallbacks[name] = VmNativeCallback {cb, ctx, params2};\n}\n",
        "answer": "/** @brief Register a native extension. This will appear in Jsonnet as a function type and can be accessed from std.nativeExt(\"foo\"). DO NOT register native callbacks with side-effects! Jsonnet is a lazy functional language and will call your function when you least expect it, more times than you expect, or not at all.\n*  @param vm The Jsonnet virtual machine.\n*  @param name The name of the native extension.\n*  @param cb The callback function to be called when the native extension is invoked.\n*  @param ctx The context in which the callback function will be executed.\n*  @param params A list of parameters that will be passed to the callback function.\n*/\nvoid jsonnet_native_callback(struct JsonnetVm *vm, const char *name, JsonnetNativeCallback *cb,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void jsonnet_static_analysis(AST *ast)\n{\n    static_analysis(ast, false, IdSet{});\n}\n",
        "answer": "/** @brief Perform static analysis on a JSONNet AST.\n*\n*  This function performs static analysis on the given JSONNet AST, including checking for correct use of self, super, and correctly bound variables. It also initializes the freeVariables member of function and object ASTs.\n*\n* @param ast The JSONNet AST to perform static analysis on.\n* @return void\n*/\nvoid jsonnet_static_analysis(AST *ast)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t safe_strncpy(char* dest_buffer, const char* src_buffer, size_t num) {\n  /* Make sure arguments are valid */\n  if (num == 0 || dest_buffer == NULL || src_buffer == NULL)\n    return 0;\n\n  size_t len = min(num - 1, strlen(src_buffer));\n  strncpy(dest_buffer, src_buffer, len); /* Copy only as much as needed */\n  dest_buffer[len] = '\\0'; /* NULL terminate in case strncpy copies exactly num-1 characters */\n\n  /* Returns the number of bytes copied into the destination buffer (excluding the null terminator)*/\n  return len;\n}\n",
        "answer": "/** @brief Safe version of strncpy that guarantees the existence of '\\0' at the end of the supplied buffer to prevent buffer overruns.\n*\n*  This function is a safer alternative to strncpy, as it ensures that the destination buffer is always null-terminated, even if the source string is longer than num-1 characters.\n*\n* @param dest_buffer The destination buffer where the string will be copied.\n* @param src_buffer The source buffer from which the string will be copied.\n* @param num The maximum number of bytes to copy from the source buffer into the destination buffer.\n*\n* @return The number of bytes written to the destination buffer (excluding the null terminator).\n*/\n/* Make sure arguments are valid */\n/* Returns the number of bytes copied into the destination buffer (excluding the null terminator)*/\nreturn len;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "helics_bool helicsCoreIsConnected (helics_core core)\n{\n    auto cr = getCore (core, nullptr);\n    if (cr == nullptr)\n    {\n        return helics_false;\n    }\n    return (cr->isConnected ()) ? helics_true : helics_false;\n}\n",
        "answer": "/** @brief Check if a core is connected.\n*\n*  This function checks if a core is connected to a federate or other cores.\n*\n* @param[in] core The helics_core object to check for connection.\n*\n* @return helics_true if the core is connected, helics_false otherwise.\n*/\nhelics_bool helicsCoreIsConnected (helics_core core)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline int centerWindowHeight(float height)\n{\n\treturn static_cast<int>(Utility<Renderer>::get().center_y() - height / 2);\n}\n",
        "answer": "/** @brief Centers a window's height.\n*\n* This function performs common computations for window centering and casts the resulting fractional value to an int.\n*\n* @param height The height of the window to be centered.\n* @return The centered height as an integer.\n*/\nstatic inline int centerWindowHeight(float height)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tuint8_t get_port_input(MOS::MOS6522::Port port) {\n\t\t\tif(!port) {\n\t\t\t\tuint8_t result = 0xff;\n\t\t\t\tfor(int c = 0; c < 8; c++) {\n\t\t\t\t\tif(!(activation_mask_&(1 << c)))\n\t\t\t\t\t\tresult &= columns_[c];\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn port_b_;\n\t\t}\n",
        "answer": "/** @brief Gets input from the keyboard on Port A and returns a small amount of joystick state on Port B.\n*\n*  Called by the 6522 to get input. Reads the keyboard on Port A, returns a small amount of joystick state on Port B.\n*\n* @param port The port to read from (either Port A or Port B)\n* @return The value read from the port\n*/\nuint8_t get_port_input(MOS::MOS6522::Port port) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int8_t eeprom_write_poll(uint8_t i2c_address)\r\n{\r\n  _delay_us(10);\r\n  return(eeprom_poll(i2c_address));\r\n}\r\n",
        "answer": "/** @brief Wait for the EEPROM write cycle to complete by executing the acknowledge polling loop. Returns 0 if an acknowledge is generated and 1 if not.\n*\n* This function waits for the EEPROM write cycle to complete by executing the acknowledge polling loop. It returns 0 if an acknowledge is generated and 1 if not.\n*\n* @param i2c_address The I2C address of the EEPROM device.\n* @return Returns 0 if an acknowledge is generated and 1 if not.\n*/\nint8_t eeprom_write_poll(uint8_t i2c_address)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tActivityStatus onCreate() {\n\t\tROS_INFO(\"onCreate Called\");\n\t\treturn utils::LifeCycle::SUCCESS;\n\t}\n",
        "answer": "/** @brief Initialization of the entity. Will be called only once. Useful for memory allocation purpose. Sets state to ActivityState::CREATED.\n*\n*  This is the description of the functionality of the function.\n*\n* @return Should not return\n*/\nActivityStatus onCreate() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tActivityStatus onRestart() {\n\t\tROS_INFO(\"onRestart Called\");\n\t\treturn utils::LifeCycle::SUCCESS;\n\t}\n",
        "answer": "/** @brief Called when a restart is required. Can be called multiple times if it was stopped. Sets state to ActivityState::PAUSED\n*\n*  This function is called when a restart is required. It can be called multiple times if the activity was stopped. The function sets the state to ActivityState::PAUSED and returns utils::LifeCycle::SUCCESS.\n*\n* @return Should not return\n*/\nvoid onRestart() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class HoldoutClosure : CClosurePrimitive {\npublic:\n\tvoid setup(ShaderData *sd, int /* path_flag */, float3 weight)\n\t{\n\t\tclosure_alloc(sd, sizeof(ShaderClosure), CLOSURE_HOLDOUT_ID, weight);\n\t\tsd->flag |= SD_HOLDOUT;\n\t}\n};\n",
        "answer": "/** @brief Holdout closure.\n*\n*  This function will be used by the shader to mark the amount of holdout for the current shading point. No parameters, only the weight will be used.\n*\n* @param sd The ShaderData object that contains information about the current shading point.\n* @param path_flag The flag indicating whether the current shading point is on a path or not.\n* @param weight The weight of the holdout closure.\n*/\nvoid HoldoutClosure::setup(ShaderData *sd, int /* path_flag */, float3 weight)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int loadScript( const std::string &file, std::string &outScript ) {\n        if( file == \"test_script.js\" ) {\n            outScript = _script;\n            return JSR_ERROR_NO_ERROR;\n        }\n        return JSR_ERROR_FILE_NOT_FOUND;\n    }\n",
        "answer": "/**\n* @brief Handles requests for loading external scripts.\n*\n* This method handles requests for loading external scripts, which should be rare because the JS engine is aware of all source code. However, this method is mandatory if we would like to see any source code while debugging.\n*\n* @param file The name of the script file to load.\n* @param outScript A reference to a string that will contain the loaded script.\n*\n* @return JSR_ERROR_NO_ERROR if the script was loaded successfully, or JSR_ERROR_FILE_NOT_FOUND if the script could not be found.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    SkFixed nextSFixed1() { return this->nextS() >> 15; }\n",
        "answer": "/** @brief Returns the next pseudo random number expressed as a signed SkFixed in the range [-SK_Fixed1..SK_Fixed1).\n*\n*  This function returns the next pseudo random number expressed as a signed SkFixed in the range [-SK_Fixed1..SK_Fixed1).\n*  The returned value is obtained by shifting the result of the nextS() function right by 15 bits.\n*\n* @return A signed SkFixed in the range [-SK_Fixed1..SK_Fixed1) representing the next pseudo random number.\n*/\nSkFixed nextSFixed1();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_constant(const Expression& expr, double value) {\n    switch (expr.fKind) {\n        case Expression::kIntLiteral_Kind:\n            return ((IntLiteral&) expr).fValue == value;\n        case Expression::kFloatLiteral_Kind:\n            return ((FloatLiteral&) expr).fValue == value;\n        case Expression::kConstructor_Kind: {\n            Constructor& c = (Constructor&) expr;\n            if (c.fType.kind() == Type::kVector_Kind && c.isConstant()) {\n                for (int i = 0; i < c.fType.columns(); ++i) {\n                    if (!is_constant(c.getVecComponent(i), value)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        default:\n            return false;\n    }\n}\n",
        "answer": "/** @brief Determines whether an expression is a constant numeric literal with the specified value, or a constant vector with all elements equal to the specified value.\n*\n*  This function checks if an expression is a constant numeric literal with the specified value, or a constant vector with all elements equal to the specified value. It uses a switch statement to check the kind of expression and then performs the appropriate comparison. If the expression is a constructor, it checks if it is a vector constructor with all elements equal to the specified value.\n*\n* @param expr The expression to be checked.\n* @param value The value to compare against.\n* @return True if the expression is a constant numeric literal with the specified value, or a constant vector with all elements equal to the specified value; false otherwise.\n*/\nbool is_constant(const Expression& expr, double value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool make_ringed_alpha_bitmap(TestPixels* result, int width, int height) {\n    constexpr uint8_t kZero = 0x00;\n    constexpr uint8_t kHalf = 0x80;\n    constexpr uint8_t k3Q   = 0xC0;\n    constexpr uint8_t kOne  = 0xFF;\n    return make_ringed_bitmap<uint8_t>(result, width, height, kAlpha_8_SkColorType,\n                                       kPremul_SkAlphaType, kZero, kOne, k3Q, kHalf);\n}\n",
        "answer": "/** @brief Creates a ringed alpha bitmap with 1 wide rect/ring of 0s, an inset of 1s, and the interior is a 2x2 checker board of 3/4 and 1/2. The inner checkers are large enough to fill the interior with the 2x2 checker grid.\n*\n* @param result A pointer to the TestPixels object that will hold the resulting bitmap.\n* @param width The width of the bitmap.\n* @param height The height of the bitmap.\n* @return True if the bitmap was created successfully, false otherwise.\n*/\nstatic bool make_ringed_alpha_bitmap(TestPixels* result, int width, int height) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static constexpr BlendFormula MakeCoverageSrcCoeffZeroFormula(\n        BlendFormula::OutputType oneMinusDstCoeffModulateOutput) {\n    return BlendFormula(oneMinusDstCoeffModulateOutput, BlendFormula::kNone_OutputType,\n                        kReverseSubtract_GrBlendEquation, kDC_GrBlendCoeff, kOne_GrBlendCoeff);\n}\n",
        "answer": "/** @brief Creates a BlendFormula for when coverage is 1 and src coeff is zero.\n*\n* This function creates a BlendFormula that implements the formula for when coverage is 1 and src coeff is zero. The formula can be rewritten as:\n* [f * (1 - dstCoeff)] for the primary color and uses a reverse subtract HW blend equation with coeffs of (DC, One). Xfer modes: clear, dst-out (Sa=1), dst-in (Sa!=1), modulate (Sc!=1)\n*\n* @param oneMinusDstCoeffModulateOutput The output for the primary color.\n* @return A BlendFormula that implements the formula for when coverage is 1 and src coeff is zero.\n*/\nstatic constexpr BlendFormula MakeCoverageSrcCoeffZeroFormula("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sk_paint_set_shader(sk_paint_t* cpaint, sk_shader_t* cshader) {\n    AsPaint(cpaint)->setShader(sk_ref_sp(AsShader(cshader)));\n}\n",
        "answer": "/** @brief Set the paint's shader to the specified parameter.\n*\n*  This function sets the paint's shader to the specified parameter, automatically calling unref() on any previous value and call ref() on the new value.\n*\n* @param cpaint The paint object whose shader will be set.\n* @param cshader The shader that will be set as the paint's shader.\n*/\nvoid sk_paint_set_shader(sk_paint_t* cpaint, sk_shader_t* cshader) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "sk_stroke_join_t sk_paint_get_stroke_join(const sk_paint_t* cpaint) {\n    sk_stroke_join_t cjoin;\n    if (find_c(AsPaint(*cpaint).getStrokeJoin(), &cjoin)) {\n        cjoin = MITER_SK_STROKE_JOIN;\n    }\n    return cjoin;\n}\n",
        "answer": "/** @brief Get the stroke join type of a paint object.\n*\n*  This function returns the stroke join type of a paint object, which specifies the treatment that is applied to corners in paths and rectangles.\n*\n* @param[in] cpaint The paint object whose stroke join type will be returned.\n* @return The stroke join type of the paint object.\n*/\nsk_stroke_join_t sk_paint_get_stroke_join(const sk_paint_t* cpaint) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sk_path_conic_to(sk_path_t* cpath, float x0, float y0, float x1, float y1, float w) {\n    as_path(cpath)->conicTo(x0, y0, x1, y1, w);\n}\n",
        "answer": "/** @brief Add a conic curve from the last point, approaching control point (x0,y0), and ending at (x1,y1) with weight w. If no sk_path_move_to() call has been made for this contour, the first point is automatically set to (0,0).\n*\n* @param cpath The path to add the conic curve to.\n* @param x0 The x-coordinate of the control point.\n* @param y0 The y-coordinate of the control point.\n* @param x1 The x-coordinate of the end point.\n* @param y1 The y-coordinate of the end point.\n* @param w The weight of the conic curve.\n*\n* @return None.\n*/\nvoid sk_path_conic_to(sk_path_t* cpath, float x0, float y0, float x1, float y1, float w) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sk_canvas_restore(sk_canvas_t* ccanvas) {\n    AsCanvas(ccanvas)->restore();\n}\n",
        "answer": "/** @brief Restores the canvas to a previous state.\n*\n* This function restores the canvas to a previous state, undoing any modifications made to the matrix and clip state since the last call to sk_canvas_save() or sk_canvas_save_layer(). It is an error to call sk_canvas_restore() more times than save and save_layer were called.\n*\n* @param ccanvas The canvas to restore.\n*/\nvoid sk_canvas_restore(sk_canvas_t* ccanvas) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sk_picture_unref(sk_picture_t* cpic) {\n    SkSafeUnref(AsPicture(cpic));\n}\n",
        "answer": "/** @brief Decrement the reference count. If the reference count is 1 before the decrement, then release both the memory holding the sk_picture_t and any resouces it may be managing. New sk_picture_t are created with a reference count of 1.\n*\n* @param cpic The picture to unref.\n*/\nvoid sk_picture_unref(sk_picture_t* cpic) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SkPMColor SkPreMultiplyColor(SkColor c) {\n    return SkPremultiplyARGBInline(SkColorGetA(c), SkColorGetR(c),\n                                   SkColorGetG(c), SkColorGetB(c));\n}\n",
        "answer": "/** @brief Returns the closest SkPMColor to color c.\n*\n*  This function multiplies c RGB components by the c alpha, and arranges the bytes to match the format of kN32_SkColorType.\n*\n* @param[in] c The color to be premultiplied.\n* @return The closest SkPMColor to color c.\n*/\nSkPMColor SkPreMultiplyColor(SkColor c) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static HRESULT create_unique_font_name(char* buffer, size_t bufferSize) {\n    GUID guid = {};\n    if (FAILED(CoCreateGuid(&guid))) {\n        return E_UNEXPECTED;\n    }\n    format_guid_b64(guid, buffer, bufferSize);\n\n    return S_OK;\n}\n",
        "answer": "/** @brief Creates a unique font name.\n*\n*  This function creates a unique font name by generating a GUID and encoding it in Base64. The resulting string is placed into the provided buffer, which should have space for at least BASE64_GUID_ID_LEN characters. The string will always be null terminated.\n*\n* @param[in] buffer A pointer to a buffer that will hold the unique font name.\n* @param[in] bufferSize The size of the provided buffer, in bytes.\n*\n* @return S_OK if successful, E_UNEXPECTED if an error occurs while generating the GUID or encoding it in Base64.\n*/\nstatic HRESULT create_unique_font_name(char* buffer, size_t bufferSize) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SkChopCubicAt(const SkPoint src[4], SkPoint dst[7], SkScalar t) {\n    SkASSERT(t > 0 && t < SK_Scalar1);\n\n    Sk2s    p0 = from_point(src[0]);\n    Sk2s    p1 = from_point(src[1]);\n    Sk2s    p2 = from_point(src[2]);\n    Sk2s    p3 = from_point(src[3]);\n    Sk2s    tt(t);\n\n    Sk2s    ab = interp(p0, p1, tt);\n    Sk2s    bc = interp(p1, p2, tt);\n    Sk2s    cd = interp(p2, p3, tt);\n    Sk2s    abc = interp(ab, bc, tt);\n    Sk2s    bcd = interp(bc, cd, tt);\n    Sk2s    abcd = interp(abc, bcd, tt);\n\n    dst[0] = to_point(p0);\n    dst[1] = to_point(ab);\n    dst[2] = to_point(abc);\n    dst[3] = to_point(abcd);\n    dst[4] = to_point(bcd);\n    dst[5] = to_point(cd);\n    dst[6] = to_point(p3);\n}\n",
        "answer": "/** @brief Chop a cubic bezier at the specified t value.\n*\n*  This function chops a src cubic bezier at the specified t value, where 0 < t < 1, and returns the two new cubics in dst: dst[0..3] and dst[3..6].\n*\n* @param [in] src The source cubic bezier.\n* @param [out] dst The destination array for the chopped cubics.\n* @param [in] t The t value at which to chop the cubic.\n*\n* @return None.\n*/\nvoid SkChopCubicAt(const SkPoint src[4], SkPoint dst[7], SkScalar t) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SkImage_unpinAsTexture(const SkImage* image, GrContext* ctx) {\n    SkASSERT(image);\n    SkASSERT(ctx);\n    as_IB(image)->onUnpinAsTexture(ctx);\n}\n",
        "answer": "/** @brief Unpins a texture from an image.\n*\n*  This function unpins a texture from an image, allowing the texture to be purged or reused. The context passed to unpin must match the one passed to pin.\n*\n* @param image The image to unpin as a texture.\n* @param ctx The context that was used for pinning the texture.\n*\n* @return Should not return\n*/\nvoid SkImage_unpinAsTexture(const SkImage* image, GrContext* ctx) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sk_out_of_memory(void) {\n    SkDEBUGFAIL(\"sk_out_of_memory\");\n#if defined(IS_FUZZING_WITH_AFL)\n    exit(1);\n#else\n    abort();\n#endif\n}\n",
        "answer": "/** @brief Handles the case where we run out of memory.\n*\n*  This function is called internally if we run out of memory. The platform implementation must not return, but should either throw an exception or otherwise exit.\n*\n* @return Should not return\n*/\nvoid sk_out_of_memory(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static SkScalar approx_arc_length(const SkPoint points[], int count) {\n    if (count < 2) {\n        return 0;\n    }\n    SkScalar arcLength = 0;\n    for (int i = 0; i < count - 1; i++) {\n        arcLength += SkPoint::Distance(points[i], points[i + 1]);\n    }\n    return SkScalarIsFinite(arcLength) ? arcLength : -1;\n}\n",
        "answer": "/**\n* @brief Calculate the approximate arc length given a bezier curve's control points. Returns -1 if bad calc (i.e. non-finite)\n*\n* This function calculates the approximate arc length of a bezier curve using the control points provided. The arc length is calculated by summing the distances between each pair of consecutive control points. If the calculation results in a non-finite value, -1 is returned.\n*\n* @param points An array of SkPoint objects representing the control points of the bezier curve\n* @param count The number of control points in the array\n* @return The approximate arc length of the bezier curve, or -1 if the calculation results in a non-finite value\n*/\nstatic SkScalar approx_arc_length(const SkPoint points[], int count) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool Simplify(const SkPath& path, SkPath* result) {\n#if DEBUG_DUMP_VERIFY\n    if (SkPathOpsDebug::gVerifyOp) {\n        if (!SimplifyDebug(path, result  SkDEBUGPARAMS(false) SkDEBUGPARAMS(nullptr))) {\n            SkPathOpsDebug::ReportSimplifyFail(path);\n            return false;\n        }\n        SkPathOpsDebug::VerifySimplify(path, *result);\n        return true;\n    }\n#endif\n    return SimplifyDebug(path, result  SkDEBUGPARAMS(true) SkDEBUGPARAMS(nullptr));\n}\n",
        "answer": "/** @brief Simplifies a path by reducing the number of curves while maintaining its overall shape.\n*\n* This function takes a path as input and produces a simplified version of it as output. The resulting path is made up of a set of non-overlapping contours that describe the same area as the original path, with reduced curve order where possible (i.e., cubics may be turned into quadratics, and quadratics maybe turned into lines).\n*\n* @param[in] path The input path to simplify.\n* @param[out] result The simplified output path.\n* @return True if the operation was able to produce a result; otherwise, the result is unmodified.\n*/\nbool Simplify(const SkPath& path, SkPath* result) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline Contour3D roofs(const ExPolygon& poly, coord_t z_distance) {\n    auto lower = triangulate_expolygon_3d(poly);\n    auto upper = triangulate_expolygon_3d(poly, z_distance*SCALING_FACTOR, true);\n    Contour3D ret;\n    ret.merge(lower); ret.merge(upper);\n    return ret;\n}\n",
        "answer": "/** @brief Generates top and bottom plates from a 2D shape.\n*\n* This function is only used for debugging purposes and not part of the algorithm. It generates top and bottom plates from a 2D shape.\n*\n* @param poly The ExPolygon to generate the plates from.\n* @param z_distance The distance between the top and bottom plates.\n*\n* @return A Contour3D object containing the generated plates.\n*/\ninline Contour3D roofs(const ExPolygon& poly, coord_t z_distance) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int decode_char(unsigned char c)\r\n{\r\n\tchar retval = -1;\r\n\r\n\tif (c >= 'A' && c <= 'Z')\r\n\t\tretval = c - 'A';\r\n\tif (c >= '2' && c <= '7')\r\n\t\tretval = c - '2' + 26;\r\n\r\n\tassert(retval == -1 || ((retval & 0x1F) == retval));\r\n\r\n\treturn  retval;\r\n}\r\n",
        "answer": "/** @brief Decode given character into a 5 bits value. Returns -1 iff the argument given was an invalid base32 character or a padding character.\n*\n* This function decodes a given character into a 5-bit value using the Base32 encoding scheme. It returns -1 if the input character is not a valid Base32 character or a padding character.\n*\n* @param c The character to decode.\n* @return The decoded 5-bit value, or -1 if the input character was invalid.\n*/\nstatic int decode_char(unsigned char c)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    static void gdb_hex_to_mem(std::uint8_t *dest, const std::uint8_t *src, std::size_t len) {\n        while (len-- > 0) {\n            *dest++ = (hex_char_to_value(src[0]) << 4) | hex_char_to_value(src[1]);\n            src += 2;\n        }\n    }\n",
        "answer": "/** @brief Converts input gdb-formatted hex string characters into an array of equivalent std::uint8_t bytes.\n*\n* This function converts a gdb-formatted hex string into an array of equivalent std::uint8_t bytes. It takes three arguments: dest, src, and len. Dest is the destination buffer where the converted data will be stored, src is the source buffer containing the gdb-formatted hex string, and len is the length of the source buffer.\n*\n* The function first checks if the length of the source buffer is even, as each byte in the gdb-formatted hex string consists of two characters. If the length is odd, it returns an error message indicating that the input is invalid.\n*\n* Next, the function iterates over the source buffer while the length is greater than zero. For each iteration, it extracts two characters from the source buffer and converts them into a single byte using the hex_char_to_value() function. The converted byte is then stored in the destination buffer. Finally, the function returns the destination buffer.\n*\n* @param dest The destination buffer where the converted data will be stored.\n* @param src The source buffer containing the gdb-formatted hex string.\n* @param len The length of the source buffer.\n* @return The destination buffer with the converted data.\n*/\n*dest++ = (hex_char_to_value(src[0]) << 4) | hex_char_to_value(src[1]);\nsrc += 2;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutInQuad(kn_double t)\n{\n    if (t < 0.5) return easeOutQuad (t*2)/2;\n    return easeInQuad((2*t)-1)/2 + 0.5;\n}\n",
        "answer": "/** @brief Easing equation function for a quadratic (t^2) easing out/in: deceleration until halfway, then acceleration.\n*/\nstatic kn_double easeOutInQuad(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeInOutQuint(kn_double t)\n{\n    t*=2.0;\n    if (t < 1) return 0.5*t*t*t*t*t;\n    else {\n        t -= 2.0;\n        return 0.5*(t*t*t*t*t + 2);\n    }\n}\n",
        "answer": "/** @brief Easing equation function for a quintic (t^5) easing in/out: acceleration until halfway, then deceleration.\n*\n* This is the description of the functionality of the function.\n*\n* @param t The input value to be used in the easing calculation.\n* @return The output value after applying the easing equation.\n*/\nstatic kn_double easeInOutQuint(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutInExpo(kn_double t)\n{\n    if (t < 0.5) return easeOutExpo (2*t)/2;\n    return easeInExpo(2*t - 1)/2 + 0.5;\n}\n",
        "answer": "/** @brief Easing equation function for an exponential (2^t) easing out/in: deceleration until halfway, then acceleration.\n*\n* This is the description of the functionality of the function.\n*\n* @param t The input parameter for the easeOutInExpo function.\n* @return The output value of the easeOutInExpo function.\n*/\nstatic kn_double easeOutInExpo(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeInOutElastic(kn_double t, kn_double a, kn_double p)\n{\n    if (t==0) return 0.0;\n    t*=2.0;\n    if (t==2) return 1.0;\n\n    kn_double s;\n    if(a < 1.0) {\n        a = 1.0;\n        s = p / 4.0f;\n    } else {\n        s = p / (2 * M_PI) * asin(1.0 / a);\n    }\n\n    if (t < 1) return -.5*(a*pow(kn_double(2.0f),10*(t-1)) * sin( (t-1-s)*(2*M_PI)/p ));\n    return a*pow(kn_double(2.0f),-10*(t-1)) * sin( (t-1-s)*(2*M_PI)/p )*.5 + 1.0;\n}\n",
        "answer": "/** @brief Easing equation function for an elastic (exponentially decaying sine wave) easing in/out: acceleration until halfway, then deceleration.\n*\n*  This function implements the easing equation for an elastic (exponentially decaying sine wave) easing in/out: acceleration until halfway, then deceleration.\n*\n* @param t The current time (in seconds).\n* @param a The amplitude of the sine wave.\n* @param p The period of the sine wave (in seconds).\n* @return The value of the easing equation at the given time.\n*/\nstatic kn_double easeInOutElastic(kn_double t, kn_double a, kn_double p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutBounce(kn_double t, kn_double a)\n{\n    return easeOutBounce_helper(t, 1, a);\n}\n",
        "answer": "/** @brief Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out: decelerating from zero velocity.\n*\n*  This function calculates the ease out bounce of a given value t, with an amplitude of a.\n*\n* @param t The input value to be eased.\n* @param a The amplitude of the ease out bounce.\n* @return The eased output value.\n*/\nstatic kn_double easeOutBounce(kn_double t, kn_double a)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static kn_double easeOutCurve(kn_double t)\n{\n    const kn_double progress = sinProgress(t);\n    const kn_double mix = smoothBeginEndMixFactor(1 - t);\n    return progress * mix + t * (1 - mix);\n}\n",
        "answer": "/** @brief Easing function that starts growing steadily, then ends slowly. The speed will be constant at the beginning of the curve.\n*\n* @param t A kn_double representing the current time or position on the curve.\n* @return A kn_double representing the new position or time based on the easing function.\n*/\nstatic kn_double easeOutCurve(kn_double t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   bool rev_sparse_jac(\n      size_t                     q,          /**< number of rows in R */\n      const CppAD::vector<bool>& r,          /**< sparsity of R, rowwise */\n      CppAD::vector<bool>&       s           /**< vector to store sparsity of S, rowwise */\n      )\n   {\n      return univariate_rev_sparse_jac(q, r, s);\n   }\n",
        "answer": "/** @brief Computes the sparsity pattern of a matrix during a reverse sweep.\n*\n*  This function computes the sparsity pattern of a matrix S(x) = R * f'(x), where R is a q x 1 matrix and f'(x) is dense. Since f'(x) is dense, the sparsity of S will be the sparsity of R.\n*\n* @param[in] q Number of rows in R.\n* @param[in] r Sparsity pattern of R, rowwise.\n* @param[out] s Vector to store the sparsity pattern of S, rowwise.\n* @return True if the sparsity pattern was computed successfully, false otherwise.\n*/\nbool rev_sparse_jac(size_t q, const CppAD::vector<bool>& r, CppAD::vector<bool>& s) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool univariate_rev_sparse_jac(\n   size_t                     q,             /**< number of rows in R */\n   const CppAD::vector<bool>& r,             /**< sparsity of R, rowwise */\n   CppAD::vector<bool>&       s              /**< vector to store sparsity of S, rowwise */\n   )\n{\n   assert(r.size() == q);\n   assert(s.size() == q);\n\n   s = r;\n\n   return true;\n}\n",
        "answer": "/**\n* @brief Computes sparsity of Jacobian during a reverse sweep.\n*\n* For a q x 1 matrix R, we have to return the sparsity pattern of the q x 1 matrix S(x) = R * f'(x). Since f'(x) is dense, the sparsity of S will be the sparsity of R.\n*\n* @param q Number of rows in R.\n* @param r Sparsity of R, rowwise.\n* @param s Vector to store sparsity of S, rowwise.\n* @return True if successful, false otherwise.\n*/\nbool univariate_rev_sparse_jac(size_t q, const CppAD::vector<bool>& r, CppAD::vector<bool>& s);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SCIP_RETCODE SCIPexprintNewParametrization(\n   SCIP_EXPRINT*         exprint,            /**< interpreter data structure */\n   SCIP_EXPRTREE*        tree                /**< expression tree */\n   )\n{\n   assert(exprint != NULL);\n   assert(tree    != NULL);\n\n   SCIP_EXPRINTDATA* data = SCIPexprtreeGetInterpreterData(tree);\n   if( data != NULL )\n   {\n      data->need_retape     = true;\n      data->int_need_retape = true;\n   }\n\n   return SCIP_OKAY;\n}\n",
        "answer": "/** @brief Notify expression interpreter that a new parameterization is used.\n*\n*  This probably causes retaping by AD algorithms.\n*\n* @param exprint Interpreter data structure.\n* @param tree Expression tree.\n* @return SCIP_OKAY if the function was successful, otherwise an error code.\n*/\nSCIP_RETCODE SCIPexprintNewParametrization("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    float randSfloat()\n    {\n        uint32 randBits = (uint32) (randUint64() >> 16);\n        randBits = (randBits & 0x007fffff) | 0x40000000;\n        return *reinterpret_cast<float*>(&randBits) - 3.0f;\n    }\n",
        "answer": "/** @brief Generate a random floating point value in [ -1, 1 ).\n*\n* This function directly manipulates the bits of a floating point number, and will not work properly on a system that doesn't use IEEE754 floats.\n*\n* @return A random floating point value in [ -1, 1 )\n*/\nfloat randSfloat()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool powerHandler(const HomieRange& range, const String& value) {\n  if (value != \"ON\" && value !=\"OFF\" && value != \"RESET\") {\n    senseoNode.setProperty(\"debug\").setRetained(false).send(\"power: malformed message content. Allowed: [ON,OFF].\");\n    return false;\n  }\n\n  if (value == \"ON\" && mySenseoSM.getState() == SENSEO_OFF) {\n    myControl.pressPowerButton();\n  }\n  else if (value == \"OFF\" && mySenseoSM.getState() != SENSEO_OFF) {\n    myControl.pressPowerButton();\n  }\n  else if (value == \"RESET\") {\n    tone(beeperPin, 4096, 8000);\n    Homie.reset();\n  }\n  return true;\n}\n",
        "answer": "/** @brief Handles MQTT messages to the power topic.\n*\n* This function is called by Homie upon an MQTT message to '.../power'. No MQTT response is sent from this routine, as pessimistic feedback will be handled in the state machine.\n*\n* @param range The range of the MQTT message.\n* @param value The value of the MQTT message.\n* @return True if the message was handled successfully, false otherwise.\n*/\nbool powerHandler(const HomieRange& range, const String& value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void mapLetterWindow(const string &window, size_t idx,\n                            Handle<float> tensor) {\n  EXPECT_EQ(window.size(), 6);\n  for (size_t row = 0; row < 6; row++) {\n    size_t col = mapLetter(window[row]);\n    tensor.at({idx, row, col}) = 1;\n  }\n}\n",
        "answer": "/** @brief Maps a 6-letter window of a word to an input tensor using one-hot encoding.\n*\n* This function takes in a 6-letter window of a word, and maps it to an input tensor\n* using one-hot encoding. The tensor must be N x 6 x 27: batch x position x letter.\n*\n* @param[in] window A 6-letter window of a word.\n* @param[in] idx The index of the current row in the tensor.\n* @param[out] tensor An input tensor to be filled with one-hot encoded values.\n*/\nvoid mapLetterWindow(const string &window, size_t idx, Handle<float> tensor) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class MyEventHandler : public SEEventHandler {\npublic:\n  MyEventHandler(Logger* logger)\n    : SEEventHandler(logger)\n  {\n  }\n  virtual void HandlePatientEvent(CDM::enumPatientEvent::value type, bool active, const SEScalarTime* time = nullptr) {}\n  virtual void HandleAnesthesiaMachineEvent(CDM::enumAnesthesiaMachineEvent::value type, bool active, const SEScalarTime* time = nullptr) {}\n};\n",
        "answer": "/** @brief Event handler for MyEventHandler.\n*\n*  This class is used to handle events triggered by the simulation engine.\n*  It provides methods to be called when a patient event or anesthesia machine event occurs.\n*\n* @param logger A pointer to the logger object, used for logging events.\n*/\n/** @brief Handles a patient event.\n*\n*  This method is called when a patient event occurs. It logs the event and updates the state of the patient.\n*\n* @param type The type of patient event that occurred.\n* @param active Whether the event is currently active or not.\n* @param time The current engine time, used for logging purposes.\n*/\n/** @brief Handles an anesthesia machine event.\n*\n*  This method is called when an anesthesia machine event occurs. It logs the event and updates the state of the anesthesia machine.\n*\n* @param type The type of anesthesia machine event that occurred.\n* @param active Whether the event is currently active or not.\n* @param time The current engine time, used for logging purposes.\n*/\nvirtual void HandleAnesthesiaMachineEvent(CDM::enumAnesthesiaMachineEvent::value type, bool active, const SEScalarTime* time = nullptr) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "pstatus pal_bearer_addCallbackFunc(BearerCallbackFunc callbackFunc,\n                                   void* data)\n{\n   /*\n   networkContext->callbackFunctions.insert(\n      new NetworkCallbackFunction(netCallbackFunc, data));\n   */\n\n   return PAL_OK;\n}\n",
        "answer": "/** @brief Add a callback function to the bearer.\n*\n*  This function adds a callback that PALNetwork uses to send network status updates to CV3. Observe that when destroyNetworkContext is called all callbacks that is still registered will be removed.\n*\n* @param[in] callbackFunc The callback function to add.\n* @param[in] data The data to pass to the callback function.\n*\n* @return PAL_OK if successful, or an error code if not.\n*/\npstatus pal_bearer_addCallbackFunc(BearerCallbackFunc callbackFunc, void* data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "pstatus setFontForContext(GraphicsContext context,\n                          const wf_char* fontFamily,\n                          const wf_char* fontStyle,\n                          wf_uint32 fontSize)\n{\n   return PAL_OK;\n}\n",
        "answer": "/** @brief Sets the font for a specified graphics context.\n*\n*  This function attempts to change the current font for a specified graphics context. Subsequent calls to functions like drawTextToBuffer will use this new font. The implementation of this function and subsequent context behavior is different depending upon the platform. As such, a font family which is valid for Windows Mobile might not be valid at all for Linux Mobile.\n*\n* @param[in] context The graphics context for which to set the font.\n* @param[in] fontFamily The font family to use for the specified context.\n* @param[in] fontStyle The font style to use for the specified context.\n* @param[in] fontSize The font size to use for the specified context.\n*\n* @return PAL_OK if successful, or an error code otherwise.\n*/\npstatus setFontForContext(GraphicsContext context,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "pstatus pal_socket_create(SocketContext* socketContext)\n{\n   if(socketContext == NULL)\n   {\n      return PAL_SOCKET_INPUT_PARAM;\n   }\n   \n   int result = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n   if(result == -1) {\n      switch (errno) {\n      case EACCES:\n         return PAL_SOCKET_PERMISSION_DENIED;\n      case EINVAL:\n      case EPROTONOSUPPORT:\n         return PAL_PROTOCOL_NOT_SUPPORTED;\n      case ENOBUFS:\n      case ENOMEM:\n         return PAL_OUT_OF_MEMORY;\n      default:\n         return PAL_SOCKET_ERROR;\n         \n      }\n   }\n\n   socketContext->fd = result;\n   \n   return PAL_OK;\n}\n",
        "answer": "/**\n* @brief Creates a socket to use for connections.\n*\n* This function creates a socket with an IPv4 domain, i.e. PF_INET on Linux and the connection type should be sequenced, reliable, two-way, connection-based byte streams.\n*\n* @param[in] socketContext The socket context used for this socket.\n* @return PAL_OK if successful, or an error code otherwise.\n*/\npstatus pal_socket_create(SocketContext* socketContext);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid UpdateOskState()\n\t{\n\t\tthis->shift = HasBit(_keystate, KEYS_CAPS) ^ HasBit(_keystate, KEYS_SHIFT);\n\n\t\tfor (uint i = 0; i < OSK_KEYBOARD_ENTRIES; i++) {\n\t\t\tthis->SetWidgetDisabledState(WID_OSK_LETTERS + i,\n\t\t\t\t\t!IsValidChar(_keyboard[this->shift][i], this->qs->text.afilter) || _keyboard[this->shift][i] == ' ');\n\t\t}\n\t\tthis->SetWidgetDisabledState(WID_OSK_SPACE, !IsValidChar(' ', this->qs->text.afilter));\n\n\t\tthis->SetWidgetLoweredState(WID_OSK_SHIFT, HasBit(_keystate, KEYS_SHIFT));\n\t\tthis->SetWidgetLoweredState(WID_OSK_CAPS, HasBit(_keystate, KEYS_CAPS));\n\t}\n",
        "answer": "/** @brief Updates the OSK state.\n*\n*  This function updates the state of the on-screen keyboard (OSK) based on the current keystate and text filter.\n*\n* @param[in] _keystate The current keystate.\n* @param[in] _keyboard The keyboard layout to use for valid characters.\n* @param[in] _qs The question state, which contains the text filter.\n*/\nvoid UpdateOskState(uint _keystate, uint _keyboard[OSK_KEYBOARD_ENTRIES], QuestionState *_qs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tstatic uint CALLBACK stThreadProc(void *thr)\n\t{\n\t\t((ThreadObject_Win32 *)thr)->ThreadProc();\n\t\treturn 0;\n\t}\n",
        "answer": "/** @brief Thread creation callback.\n*\n*  This function is called when a new thread is created, which calls the real startup function. This to get back into the correct instance again.\n*\n* @param thr The thread object.\n* @return Should not return.\n*/\nstatic uint CALLBACK stThreadProc(void *thr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CommandFlags GetCommandFlags(uint32 cmd)\n{\n\tassert(IsValidCommand(cmd));\n\n\treturn _command_proc_table[cmd & CMD_ID_MASK].flags;\n}\n",
        "answer": "/** @brief Get the command flags for a given command.\n*\n* This function masks the parameter with CMD_ID_MASK and returns the flags which belongs to the given command.\n*\n* @param cmd The command to get the flags for.\n* @return The flags for the given command.\n*/\nCommandFlags GetCommandFlags(uint32 cmd)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void IConsoleError(const char *string)\n{\n\tIConsolePrintF(CC_ERROR, \"ERROR: %s\", string);\n}\n",
        "answer": "/** @brief Prints an error message to the console.\n*\n*  This function prints an error message to the console, with the format \"ERROR: <message>\".\n*\n* @param string The error message to print.\n*/\nvoid IConsoleError(const char *string)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void Disaster_Small_Ufo_Init()\n{\n\tif (!Vehicle::CanAllocateItem(2)) return;\n\n\tint x = TileX(Random()) * TILE_SIZE + TILE_SIZE / 2;\n\tDisasterVehicle *v = new DisasterVehicle(x, 0, DIR_SE, ST_SMALL_UFO);\n\tv->dest_tile = TileXY(MapSizeX() / 2, MapSizeY() / 2);\n\n\t/* Allocate shadow */\n\tDisasterVehicle *u = new DisasterVehicle(x, 0, DIR_SE, ST_SMALL_UFO_SHADOW);\n\tv->SetNext(u);\n}\n",
        "answer": "/** @brief Initializes the small UFO disaster.\n*\n* This function initializes the small UFO disaster by creating a new DisasterVehicle object and setting its properties. It also creates a shadow for the vehicle and sets it as the next vehicle in the chain.\n*\n* @return void\n*/\n/* Allocate shadow */\nDisasterVehicle *u = new DisasterVehicle(x, 0, DIR_SE, ST_SMALL_UFO_SHADOW);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ShowHighscoreTable(int difficulty, int8 ranking)\n{\n\tDeleteWindowByClass(WC_HIGHSCORE);\n\tnew HighScoreWindow(&_highscore_desc, difficulty, ranking);\n}\n",
        "answer": "/** @brief Show the highscore table for a given difficulty.\n*\n*  When called from endgame, ranking is set to the top5 element that was newly added and is thus highlighted.\n*\n* @param[in] difficulty The difficulty level of the game.\n* @param[in] ranking The ranking of the player in the highscore table.\n*/\nvoid ShowHighscoreTable(int difficulty, int8 ranking)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void GameSizeChanged()\n{\n\t_cur_resolution.width  = _screen.width;\n\t_cur_resolution.height = _screen.height;\n\tScreenSizeChanged();\n\tRelocateAllWindows(_screen.width, _screen.height);\n\tMarkWholeScreenDirty();\n}\n",
        "answer": "/** @brief Game size changed.\n*\n*  This function is called when the game screen size has been changed. It adapts the game screen-size, re-allocates the open windows, and repaints everything.\n*\n* @param[in] _screen The new screen size.\n*/\nvoid GameSizeChanged(const Screen& _screen)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void DisableStaticNewGRFInfluencingNonStaticNewGRFs(GRFConfig *c)\n{\n\tGRFError *error = DisableGrf(STR_NEWGRF_ERROR_STATIC_GRF_CAUSES_DESYNC, c);\n\terror->data = stredup(_cur.grfconfig->GetName());\n}\n",
        "answer": "/** @brief Disable a static NewGRF when it is influencing another (non-static) NewGRF as this could cause desyncs.\n*\n*  This function disables a static NewGRF when it is influencing another non-static NewGRF, which could cause desyncs.\n*\n* @param c A pointer to the GRFConfig object representing the static NewGRF to be disabled.\n* @return Should not return\n*/\nvoid DisableStaticNewGRFInfluencingNonStaticNewGRFs(GRFConfig *c)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void DoAutosave()\n{\n\tchar buf[MAX_PATH];\n\n\tif (_settings_client.gui.keep_all_autosave) {\n\t\tGenerateDefaultSaveName(buf, lastof(buf));\n\t\tstrecat(buf, \".sav\", lastof(buf));\n\t} else {\n\t\tstatic int _autosave_ctr = 0;\n\n\t\t/* generate a savegame name and number according to _settings_client.gui.max_num_autosaves */\n\t\tseprintf(buf, lastof(buf), \"autosave%d.sav\", _autosave_ctr);\n\n\t\tif (++_autosave_ctr >= _settings_client.gui.max_num_autosaves) _autosave_ctr = 0;\n\t}\n\n\tDEBUG(sl, 2, \"Autosaving to '%s'\", buf);\n\tif (SaveOrLoad(buf, SLO_SAVE, DFT_GAME_FILE, AUTOSAVE_DIR) != SL_OK) {\n\t\tShowErrorMessage(STR_ERROR_AUTOSAVE_FAILED, INVALID_STRING_ID, WL_ERROR);\n\t}\n}\n",
        "answer": "/**\n* @brief Creates an autosave. The default name is \"autosave#.sav\". However with the setting 'keep_all_autosave' the name defaults to company-name + date\n*\n* This function creates an autosave with a generated name based on the current settings. If the `keep_all_autosave` setting is enabled, the name will be in the format \"company-name + date\". Otherwise, the name will be in the format \"autosave#.sav\", where # is a number that increments with each autosave.\n*\n* @return Should not return\n*/\n/* generate a savegame name and number according to _settings_client.gui.max_num_autosaves */\nseprintf(buf, lastof(buf), \"autosave%d.sav\", _autosave_ctr);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void SlStubSaveProc()\n{\n\tSlAutolength(SlStubSaveProc2, NULL);\n}\n",
        "answer": "/** @brief Stub chunk handlers to only calculate length and do nothing else. Call SlAutoLenth with our stub save proc that will eventually call the intended chunk handler.\n*\n*  This function is used to test and debug drivers by providing a way to calculate the length of a chunk without actually saving it. It calls the SlAutolength function with a stub save proc that will eventually call the intended chunk handler.\n*\n* @param[in] void\n* @return Should not return\n*/\nvoid SlStubSaveProc()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void ShowRejectOrAcceptNews(const Station *st, uint num_items, CargoID *cargo, StringID msg)\n{\n\tfor (uint i = 0; i < num_items; i++) {\n\t\tSetDParam(i + 1, CargoSpec::Get(cargo[i])->name);\n\t}\n\n\tSetDParam(0, st->index);\n\tAddNewsItem(msg, NT_ACCEPTANCE, NF_INCOLOUR | NF_SMALL, NR_STATION, st->index);\n}\n",
        "answer": "/** @brief Show Reject or Accept News.\n*\n*  This function displays a news item with the specified message and cargo names.\n*\n* @param st The station that is accepting or rejecting the cargo.\n* @param num_items The number of items in the cargo array.\n* @param cargo An array of CargoIDs representing the cargo being accepted or rejected.\n* @param msg The string ID of the message to display.\n*/\nstatic void ShowRejectOrAcceptNews(const Station *st, uint num_items, CargoID *cargo, StringID msg)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static TileIndex AlignTileToGrid(TileIndex tile, TownLayout layout)\n{\n\tswitch (layout) {\n\t\tcase TL_2X2_GRID: return TileXY(TileX(tile) - TileX(tile) % 3, TileY(tile) - TileY(tile) % 3);\n\t\tcase TL_3X3_GRID: return TileXY(TileX(tile) & ~3, TileY(tile) & ~3);\n\t\tdefault:          return tile;\n\t}\n}\n",
        "answer": "/** @brief Aligns a tile to the grid.\n*\n*  This function adjusts a tile so that it aligns properly with the grid.\n*  Towns must all be placed on the same grid or when they eventually interpenetrate their road networks will not mesh nicely; this function adjusts a tile so that it aligns properly.\n*\n* @param[in] tile The tile to align.\n* @param[in] layout The town layout.\n*\n* @return The aligned tile index.\n*/\nstatic TileIndex AlignTileToGrid(TileIndex tile, TownLayout layout)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static TreeType GetRandomTreeType(TileIndex tile, uint seed)\n{\n\tswitch (_settings_game.game_creation.landscape) {\n\t\tcase LT_TEMPERATE:\n\t\t\treturn (TreeType)(seed * TREE_COUNT_TEMPERATE / 256 + TREE_TEMPERATE);\n\n\t\tcase LT_ARCTIC:\n\t\t\treturn (TreeType)(seed * TREE_COUNT_SUB_ARCTIC / 256 + TREE_SUB_ARCTIC);\n\n\t\tcase LT_TROPIC:\n\t\t\tswitch (GetTropicZone(tile)) {\n\t\t\t\tcase TROPICZONE_NORMAL:  return (TreeType)(seed * TREE_COUNT_SUB_TROPICAL / 256 + TREE_SUB_TROPICAL);\n\t\t\t\tcase TROPICZONE_DESERT:  return (TreeType)((seed > 12) ? TREE_INVALID : TREE_CACTUS);\n\t\t\t\tdefault:                 return (TreeType)(seed * TREE_COUNT_RAINFOREST / 256 + TREE_RAINFOREST);\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn (TreeType)(seed * TREE_COUNT_TOYLAND / 256 + TREE_TOYLAND);\n\t}\n}\n",
        "answer": "/** @brief Get a random TreeType for the given tile based on a given seed.\n*\n* This function returns a random TreeType which can be placed on the given tile. The seed for randomness must be less or equal 256, use #GB on the value of Random() to get such a value.\n*\n* @param[in] tile The TileIndex of the tile where the tree will be placed.\n* @param[in] seed The seed used to generate the random TreeType.\n* @return A random TreeType that can be placed on the given tile.\n*/\nstatic TreeType GetRandomTreeType(TileIndex tile, uint seed)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Point TranslateXYToTileCoord(const ViewPort *vp, int x, int y, bool clamp_to_map)\n{\n\tif (!IsInsideBS(x, vp->left, vp->width) || !IsInsideBS(y, vp->top, vp->height)) {\n\t\tPoint pt = { -1, -1 };\n\t\treturn pt;\n\t}\n\n\treturn InverseRemapCoords2(\n\t\t\tScaleByZoom(x - vp->left, vp->zoom) + vp->virtual_left,\n\t\t\tScaleByZoom(y - vp->top, vp->zoom) + vp->virtual_top, clamp_to_map);\n}\n",
        "answer": "/** @brief Translate screen coordinate in a viewport to underlying tile coordinate.\n*\n*  This function translates the screen coordinates (x, y) within a given viewport to the corresponding tile coordinate on the map. The height of tiles and foundations matters in this translation.\n*\n* @param vp Pointer to the viewport object.\n* @param x Screen coordinate along the x-axis.\n* @param y Screen coordinate along the y-axis.\n* @param clamp_to_map If true, the tile coordinates are clamped to the map boundaries.\n*\n* @return The tile coordinate corresponding to the screen coordinate (x, y) in the viewport.\n*/\nPoint TranslateXYToTileCoord(const ViewPort *vp, int x, int y, bool clamp_to_map);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void AddCombinedSprite(SpriteID image, PaletteID pal, int x, int y, int z, const SubSprite *sub)\n{\n\tPoint pt = RemapCoords(x, y, z);\n\tconst Sprite *spr = GetSprite(image & SPRITE_MASK, ST_NORMAL);\n\n\tif (pt.x + spr->x_offs >= _vd.dpi.left + _vd.dpi.width ||\n\t\t\tpt.x + spr->x_offs + spr->width <= _vd.dpi.left ||\n\t\t\tpt.y + spr->y_offs >= _vd.dpi.top + _vd.dpi.height ||\n\t\t\tpt.y + spr->y_offs + spr->height <= _vd.dpi.top)\n\t\treturn;\n\n\tconst ParentSpriteToDraw *pstd = _vd.parent_sprites_to_draw.End() - 1;\n\tAddChildSpriteScreen(image, pal, pt.x - pstd->left, pt.y - pstd->top, false, sub, false);\n}\n",
        "answer": "/** @brief Adds a child sprite to a parent sprite in world coordinates.\n*\n*  This function adds a child sprite to a parent sprite using world coordinates.\n*  In contrast to \"AddChildSpriteScreen()\", the sprite position is in world coordinates, not screen coordinates.\n*\n* @param image The ID of the sprite image to use for the child sprite.\n* @param pal The ID of the palette to use for the child sprite.\n* @param x The X coordinate of the child sprite in world coordinates.\n* @param y The Y coordinate of the child sprite in world coordinates.\n* @param z The Z coordinate of the child sprite in world coordinates.\n* @param sub A pointer to a SubSprite structure that defines the sub-sprite to use for the child sprite.\n*/\nstatic void AddCombinedSprite(SpriteID image, PaletteID pal, int x, int y, int z, const SubSprite *sub)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline void MarkTileDirtyIfCanalOrRiver(TileIndex tile)\n{\n\tif (IsValidTile(tile) && IsTileType(tile, MP_WATER) && (IsCanal(tile) || IsRiver(tile))) MarkTileDirtyByTile(tile);\n}\n",
        "answer": "/** @brief Marks tile dirty if it is a canal or river tile. Called to avoid glitches when flooding tiles next to canal tile.\n*\n*  This function checks if the given tile is valid, and if it is a water tile that is either a canal or river. If these conditions are met, the tile is marked as dirty using MarkTileDirtyByTile().\n*\n* @param tile The index of the tile to check and mark as dirty.\n*/\nstatic inline void MarkTileDirtyIfCanalOrRiver(TileIndex tile)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void vw_rx_stop()\n{\n    vw_rx_enabled = false;\n}\n",
        "answer": "/** @brief Stop the Phase Locked Loop listening to the receiver.\n*\n*  No messages will be received until vw_rx_start() is called again. Saves interrupt processing cycles.\n*\n* @return Should not return\n*/\nvoid vw_rx_stop()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    Dataset getDataset(const Molecule * const mol,\n                       OpenBabel::OBUnitCell *cell,\n                       const double cartTol)\n    {\n      Q_ASSERT(mol);\n      if (!cell) {\n        cell = mol->OBUnitCell();\n      }\n      Q_ASSERT(cell);\n\n      QList<Eigen::Vector3d> fcoords;\n      QList<unsigned int> atomicNums;\n      Eigen::Matrix3d cellMatrix;\n\n      prepareMolecule(mol, cell, &fcoords, &atomicNums, &cellMatrix);\n\n      return getDataset(fcoords, atomicNums, cellMatrix, cartTol);\n    }\n",
        "answer": "/**\n* @brief Get the dataset of a molecule.\n*\n* This function returns the dataset of a molecule, which includes the fractional coordinates, atomic numbers, and unit cell matrix.\n* The function takes as input a pointer to an OpenBabel::OBMolecule object, a pointer to an OpenBabel::OBUnitCell object (optional), and a double value representing the cartesian tolerance.\n* If no unit cell is provided, the function uses the unit cell of the molecule.\n* The function returns a Dataset object containing the fractional coordinates, atomic numbers, and unit cell matrix.\n*\n* @param mol A pointer to an OpenBabel::OBMolecule object representing the molecule.\n* @param cell A pointer to an OpenBabel::OBUnitCell object representing the unit cell (optional).\n* @param cartTol A double value representing the cartesian tolerance.\n* @return A Dataset object containing the fractional coordinates, atomic numbers, and unit cell matrix of the molecule.\n*/\nDataset getDataset(const Molecule * const mol, OpenBabel::OBUnitCell *cell, const double cartTol)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Esp32MQTTClient_SetSendConfirmationCallback(SEND_CONFIRMATION_CALLBACK send_confirmation_callback)\n{\n    _send_confirmation_callback = send_confirmation_callback;\n}\n",
        "answer": "/** @brief Sets up send confirmation status callback to be invoked representing the status of sending message to IOT Hub.\n*\n* This function sets up a send confirmation status callback to be invoked when the status of sending a message to the IoT Hub changes. The callback will be passed the new status as an argument, which can be used to update the UI or perform other actions as needed.\n*\n* @param send_confirmation_callback A pointer to the function that should be called when the send confirmation status changes. This function must take a single argument of type SEND_CONFIRMATION_CALLBACK, which is defined in the ESP32 MQTT Client library.\n*/\nvoid Esp32MQTTClient_SetSendConfirmationCallback(SEND_CONFIRMATION_CALLBACK send_confirmation_callback)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int SDL_SemWait(SDL_sem *sem) \n{\n\treturn SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);\n}\n",
        "answer": "/** @brief Suspends the calling thread until the semaphore pointed to by sem has a positive count.\n*\n*  This function suspends the calling thread until the semaphore pointed to by sem has a positive count. It then atomically decreases the semaphore count.\n*\n* @param sem A pointer to the semaphore structure.\n* @return 0 if the wait succeeds, -1 on error.\n*/\nint SDL_SemWait(SDL_sem *sem)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "            virtual int write_out_given_data( const char_type* buffer, std::streamsize sz )\n            {\n                EVP_DigestUpdate(mdctx, buffer, sz );\n                return sz;\n            }\n",
        "answer": "/** @brief Write out given data to the \"external\" device.\n*\n*  This function writes out the data starting at buffer of length sz to the \"external\" device.\n*  It returns -1 for error or 0 for success.\n*\n* @param[in] buffer The buffer containing the data to be written out.\n* @param[in] sz The size of the data in bytes.\n* @return -1 for error, 0 for success.\n*/\nvirtual int write_out_given_data( const char_type* buffer, std::streamsize sz )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual std::string TryToCheckServerExists( const std::string& rdn )\n            {\n                LG_DBUS_D << \"TryToCheckServerExists() rdn:\" << rdn << endl;\n                return \"\";\n            }\n",
        "answer": "/** @brief Try to check if a server exists.\n*\n*  This function tries to check if a server with the given name exists.\n*  It returns an empty string if the server does not exist, or a non-empty\n*  string if the server exists but is not available in the future.\n*\n* @param rdn The name of the server to check.\n* @return An empty string if the server does not exist, or a non-empty\n*         string if the server exists but is not available in the future.\n*/\nvirtual std::string TryToCheckServerExists( const std::string& rdn )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "            virtual std::string asString( IndexableValue& v, AttrType_t att )\n                {\n                    return m_primaryWriteIndex->asString( v, att );\n                }\n",
        "answer": "/** @brief Convert the value into a string format with possible quoting of the value or conversion of time values into correct date formats. This method is virtual to allow for example, the ODBC module to format and quote time_t values into SQL date syntax.\n*\n*  @param v The IndexableValue object to be converted into a string.\n*  @param att The AttrType_t attribute of the value being converted.\n*\n*  @return A string representation of the value, possibly with quoting or conversion to a date format.\n*/\nvirtual std::string asString( IndexableValue& v, AttrType_t att )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "            virtual guint64 convertStringToInteger( const std::string& v )\n                {\n                    return m_primaryWriteIndex->convertStringToInteger( v );\n                }\n",
        "answer": "/** @brief Convert a string to an integer.\n*\n*  This function will make a best effort to convert a string to an integer.\n*  It is used for executing heuristic queries.\n*\n* @param v The string to be converted.\n* @return The integer representation of the string, or 0 if conversion failed.\n*/\nvirtual guint64 convertStringToInteger( const std::string& v );"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void setViewIsBootstrappingNCols( int ncols ) \n            {\n                m_viewIsBootstrappingNCols = ncols;\n            }\n",
        "answer": "/** @brief Sets the number of columns for the view to bootstrap.\n*\n* This method allows the view to cheat by having the model return simple inline data instead of querying the VFS for the real data. The model doesn't know how many columns are actually being displayed, so you must set that as ncols\n*\n* @param[in] ncols The number of columns to bootstrap.\n*/\nvoid setViewIsBootstrappingNCols( int ncols )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual fh_context SubCreate_dir( fh_context ctx, fh_context md )\n        {\n            return SubCreate_file( ctx, md );\n        }\n",
        "answer": "/** @brief Creates a directory in the file system.\n*\n*  This method creates a new directory in the file system, using the provided context and metadata.\n*\n* @param ctx The context to use for creating the directory.\n* @param md The metadata for the directory.\n* @return A pointer to the created directory.\n*/\nvirtual fh_context SubCreate_dir(fh_context ctx, fh_context md)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void priv_read()\n            {\n                DEBUG << \"PastebinServerContext::priv_read(T) path:\" << this->getDirPath() << endl;\n                Context::EnsureStartStopReadingIsFiredRAII _raii1( this );\n                emitExistsEventForEachItem();\n            }\n",
        "answer": "/** @brief Virtual method for subclasses to override to perform the read operation. Note that this method may cause an overmounter to read over this context.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid priv_read()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual void addExtraDataChunk( const std::string& s )\n            {\n                m_extraDataChunks.push_back(s);\n            }\n",
        "answer": "/** @brief Add an extra complete data chunk to send to the server this is wrapped in the mime border and should be everything you want between two mime borders, not including the border.\n*/\nvoid addExtraDataChunk(const std::string& s) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual fh_context SubCreate_file( fh_context c, fh_context md )\n            {\n                string rdn = getStrSubCtx( md, \"name\", \"\" );\n                LG_WEBPHOTO_D << \"create_file for rdn:\" << rdn << endl;\n                \n                fh_context child = 0;\n                child = new WebPhotosUploadFileContext( this, rdn );\n                Insert( GetImpl(child), false, true );\n\n                \n                LG_WEBPHOTO_D << \"create_file OK for rdn:\" << rdn << endl;\n                return child;\n            }\n",
        "answer": "/** @brief Virtual function to create a file.\n*\n*  This is the entrypoint for creating a file.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param c The context of the file to be created.\n* @param md The metadata of the file to be created.\n* @return Should not return\n*/\nvirtual fh_context SubCreate_file(fh_context c, fh_context md) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    string getConfigString( const string& dbname_relhome,\n                            const string& k,\n                            const string& def,\n                            bool throw_for_errors )\n    {\n        string filename = Shell::getHomeDirPath_nochecks()+dbname_relhome;\n        fh_database db = getCachedDb4( dbname_relhome, dbname_relhome, k, throw_for_errors, \"get\" );\n        if( db )\n        {\n            return get_db4_string( db, k, def, throw_for_errors );\n        }\n        \n        return def;\n    }\n",
        "answer": "/** @brief Retrieves a configuration string from the database.\n*\n*  This function retrieves a configuration string from the database, using the provided key and default value. If an error occurs and throw_for_errors is true, it will throw an exception. Otherwise, it will return the default value.\n*\n* @param dbname_relhome The name of the database file, relative to the home directory.\n* @param k The key for the configuration string.\n* @param def The default value to use if the key is not found or an error occurs.\n* @param throw_for_errors Whether to throw an exception if an error occurs.\n* @return The configuration string, or the default value if it was not found or an error occurred.\n*/\nstring getConfigString( const string& dbname_relhome,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    fh_emblem getFerrisSystemEmblem( fh_etagere et )\n    {\n        if( !et )\n            et = Factory::getEtagere();\n\n        try\n        {\n            fh_emblem ret = et->getEmblemByName( EMBLEM_TOPLEVEL_SYSTEM_NAME );\n            return ret;\n        }\n        catch( EmblemNotFoundException& e )\n        {\n            fh_cemblem ret = et->createColdEmblem( EMBLEM_TOPLEVEL_SYSTEM_NAME );\n            return ret;\n        }\n    }\n",
        "answer": "/** @brief Gets the Ferris system emblem from an etagere.\n*\n*  This function gets the top level \"libferris\" emblem and makes it if its not already there.\n*\n* @param et The etagere to get the emblem from. If null, uses the default etagere.\n* @return The Ferris system emblem.\n*/\nfh_emblem getFerrisSystemEmblem( fh_etagere et )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        fh_context ExecuteQuery( const std::string& qs, fh_idx idx,\n                                 fh_context selectionCtx, int limit )\n        {\n            fh_eaquery q = Factory::makeEAQuery( qs, idx );\n            return q->execute( selectionCtx, limit );\n        }\n",
        "answer": "/** @brief Executes a query on the given context.\n*\n*  This function executes a query on the given context and returns the result as a new context. The query is specified by the string qs, and the index idx is used to determine which type of query to execute (e.g., exact match, prefix match, etc.). The selectionCtx parameter allows you to pass in the parent context for all the context's matching the query, and the limit parameter specifies the maximum number of results to return.\n*\n* @param qs The string representing the query to execute.\n* @param idx The index used to determine which type of query to execute.\n* @param selectionCtx The parent context for all the context's matching the query.\n* @param limit The maximum number of results to return.\n* @return A new context containing the result of the query.\n*/\nfh_context ExecuteQuery( const std::string& qs, fh_idx idx,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        fh_context MakeDiffContext( const fh_context& parent,\n                                    std::list< fh_context > sdContexts )\n        {\n            if( sdContexts.size() < 2 )\n            {\n                fh_stringstream ss;\n                ss << \"Can't make a set diff context without 2 or more sdContexts to use\"\n                   << \" as a model\" << endl;\n                Throw_BadParam( tostr(ss), 0 );\n            }\n            return MakeManyToOneContext< DiffContext >( parent, sdContexts );\n        }\n",
        "answer": "/**\n* @brief Create a context whose parent is \"parent\" and whose contents are the set union of the children in sdContexts.\n*\n* This function creates a new context whose parent is the specified \"parent\" context, and whose children are the union of all the children from the list of contexts in \"sdContexts\". The returned context will have the same attributes as the first context in \"sdContexts\", but with changes relative to the first context shown as \"EA\". In the above, parent is the return value's parent, sdContexts.n are the contexts in their list order from sdContexts. The return value will look very similar to sdContexts.1. The children of the return value are groomed from ucN.x with those children sharing the same filename culled to only showing the first such child context. The difference from the first to the second context object added is shown. Interesting attributes such as was-created, was-deleted, is-same, unidiff, and different-line-count are added to the view and the union of both contexts is presented. Objects that are not in the first context will be shown with was-deleted=1 and new objects in the first context will appear with was-created=1.\n*\n* @param parent The parent context for the returned context.\n* @param sdContexts A list of contexts to use as a model for the set union operation.\n*\n* @return A new context whose parent is \"parent\" and whose children are the set union of the children in \"sdContexts\".\n*/\nfh_context MakeDiffContext(const fh_context& parent, std::list<fh_context> sdContexts);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        fh_personality getCurrentUserPersonality( fh_etagere et )\n        {\n            return getCurrentUserPersonalityImpl( et );\n        }\n",
        "answer": "/** @brief Get the personality of the current user.\n*\n*  This function gets the personality of the current user. It should be used in direct HCI manipulation when the user is asserting or retracting facts. Agents should register and use a personaility of their own to discern agents from direct user beliefs.\n*\n* @param et The fh_etagere object that represents the current user.\n* @return The personality of the current user.\n*/\nfh_personality getCurrentUserPersonality( fh_etagere et )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void ConvertFromCompressedChunkContext( fh_context c,\n                                                ConvertToCompressedChunkContextProgress_Sig_t& progress_sig )\n        {\n            string rdn = c->getDirName();\n            \n            int mode       = toint( getStrAttr( c, \"mode\", \"644\" ));\n            fh_context target = Shell::CreateFile( c->getParent(),\n                                                   c->getDirName() + \".uncompressed\",\n                                                   mode );\n            ConvertFromCompressedChunkContext( c, target, progress_sig );\n            c->getParent()->remove( c );\n            target->getParent()->rename( target->getDirName(), rdn );\n        }\n",
        "answer": "/** @brief Convert a chunked compressed file back into a normal one and delete the no longer needed compressed chunks. This is a simple operation but can be handy for defragmenting a context that has changed alot since it was chunked. Note that if the compressed object was a file before compression it will be converted back into a file when the chunks are deleted.\n*\n* @param c The fh_context to convert from compressed chunks.\n* @param progress_sig A reference to a ConvertToCompressedChunkContextProgress_Sig_t object that will receive progress updates during the conversion process.\n*/\nvoid ConvertFromCompressedChunkContext(fh_context c, ConvertToCompressedChunkContextProgress_Sig_t& progress_sig) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        stringlist_t parseSeperatedList( const std::string& s, const char sepchar )\n        {\n            stringlist_t ret;\n            return parseSeperatedList( s, sepchar, ret );\n        }\n",
        "answer": "/** @brief Parses a separated list of strings.\n*\n*  This function parses a string 's' which is in the form item1,item2,item3 into a string list. The version taking ret as an argument will be faster on large lists because it avoids having to copy the list for the return value can create a null-separated list using a non-default sepchar.\n*\n* @param s The input string to parse.\n* @param sepchar The separator character used in the input string.\n* @return A stringlist_t containing the parsed strings.\n*/\nstringlist_t parseSeperatedList( const std::string& s, const char sepchar )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void insert(int v0, int v1, int faceIndex) {\r\n        \r\n        debugAssert(v0 <= v1);\r\n        EdgeArray& edgeArray = table[v0];\r\n        for (int i = 0; i < edgeArray.size(); ++i) {\r\n            if (edgeArray[i].i1 == v1) {\r\n                edgeArray[i].faceIndexArray.push(faceIndex);\r\n                return;\r\n            }\r\n        }\r\n\r\n        Edge& p = edgeArray.next();\r\n        p.i1 = v1;\r\n        p.faceIndexArray.push(faceIndex);\r\n    }\r\n",
        "answer": "/** @brief Inserts the face index into the edge's face list. The index may be a negative number indicating a backface.\n*\n*  This function inserts the face index into the edge's face list. The index may be a negative number indicating a backface.\n*\n* @param v0 The first vertex of the edge.\n* @param v1 The second vertex of the edge.\n* @param faceIndex The face index to insert.\n*/\nvoid insert(int v0, int v1, int faceIndex) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long fastlz_compress(tst::TSTMorikawa* morikawa, tst::StorageType istorage, unsigned long input, long length, tst::StorageType ostorage, unsigned long output, tst::StorageType wstorage, unsigned long work, tst::TSTError* error)\n{\n    StorageIO<unsigned char> isio(morikawa, istorage, input);\n    StorageIO<unsigned char> osio(morikawa, ostorage, output);\n    StorageIO<unsigned long> wsio(morikawa, wstorage, work);\n    \n#ifdef OPTION_BUILD_MEMORYLOG\n    tst::TSTMorikawa::saveMemoryLog();\n#endif\n    /* for short block, choose fastlz1 */\n    if(length < 65536)\n        return fastlz1_compress(morikawa, isio, length, osio, wsio, error);\n    \n    /* else... */\n    return fastlz2_compress(morikawa, isio, length, osio, wsio, error);\n}\n",
        "answer": "/** @brief Compress a block of data in the input buffer and returns the size of compressed block.\n*\n*  This function compresses a block of data in the input buffer and returns the size of compressed block. The size of input buffer is specified by length. The minimum input buffer size is 16. The output buffer must be at least 5% larger than the input buffer and can not be smaller than 66 bytes. If the input is not compressible, the return value might be larger than length (input buffer size). The input buffer and the output buffer can not overlap.\n*\n* @param morikawa Pointer to a TSTMorikawa object.\n* @param istorage Storage type of the input buffer.\n* @param input Address of the input buffer.\n* @param length Size of the input buffer.\n* @param ostorage Storage type of the output buffer.\n* @param output Address of the output buffer.\n* @param wstorage Storage type of the work buffer.\n* @param work Address of the work buffer.\n* @param error Pointer to a TSTError object.\n* @return Size of compressed block.\n*/\n/* for short block, choose fastlz1 */\n/* else... */\nreturn fastlz2_compress(morikawa, isio, length, osio, wsio, error);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tTargetPtr deduceTargetHome(NodePtr & node)\r\n\t{\r\n\t\tif (currentTarget)\r\n\t\t{\r\n\t\t\treturn currentTarget;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tMACARONI_ASSERT(defaultTarget, \"Default Target null in Parser!\");\r\n\t\t\treturn defaultTarget;\r\n\t\t}\r\n\t}\r\n",
        "answer": "/** @brief Deduces the home for an element based on its target.\n*\n*  This function determines where an element should live by checking if a target was passed in and if it has been changed manually. If no target was passed in, an empty pointer is returned and \"library\" should be used instead. Otherwise, if the target was passed in but not changed manually, a new UnitTarget is created for each unique element.\n*\n* @param node The NodePtr to the element being placed.\n* @return A TargetPtr to the home of the element.\n*/\nTargetPtr deduceTargetHome(NodePtr & node)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n{\n    const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n    const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n}\n",
        "answer": "/** @brief Build the genesis block.\n*\n*  This function creates a new block with the given parameters and returns it. The output of its generation transaction cannot be spent since it did not originally exist in the database.\n*\n* @param nTime The timestamp for the block.\n* @param nNonce A random value used to satisfy the proof-of-work requirement.\n* @param nBits The target threshold for the proof-of-work algorithm.\n* @param nVersion The version number of the block.\n* @param genesisReward The reward given to the miner who solved the proof-of-work puzzle and created the block.\n* @return A new block with the given parameters.\n*/\nstatic CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CheckSizeAndType(const ImageBase& Img1, const ImageBase& Img2)\n{\n   CheckCompatibility(Img1, Img2);\n\n   if (Img1.Depth() != Img2.Depth())\n      throw cl::Error(CL_INVALID_VALUE, \"Different image depth used\");\n\n   if (Img1.IsUnsigned() != Img2.IsUnsigned())\n      throw cl::Error(CL_INVALID_VALUE, \"Different image types used\");\n}\n",
        "answer": "/** @brief Checks sizes + float/signed/unsigned + depth, throws a cl::Error if not.\n* Checks that both images are of the same size and same type (float/signed/unsigned & depth) Useful for channel conversion kernels\n* @param Img1 The first image to check\n* @param Img2 The second image to check\n*/\nvoid CheckSizeAndType(const ImageBase& Img1, const ImageBase& Img2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "FLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder) {\n    return 0;\n}\n",
        "answer": "/** @brief Decodes the stream until the end of metadata.\n*\n* This function decodes the stream until the end of metadata is reached. As the decoder needs more input, it will call the read callback. As each metadata block is decoded, the metadata callback will be called with the decoded metadata.\n*\n* @param[in] decoder The FLAC__StreamDecoder instance to use for decoding.\n*\n* @return Returns true if the end of metadata was reached successfully, false otherwise.\n*/\nFLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void memory_region_add_subregion_overlap(MemoryRegion *mr,\n                                         hwaddr offset,\n                                         MemoryRegion *subregion,\n                                         unsigned priority)\n{\n}\n",
        "answer": "/**\n* @brief Adds a subregion to a container with overlap.\n*\n* Adds a subregion at offset in mr. The subregion may overlap with other subregions.\n* Conflicts are resolved by having a higher priority hide a lower priority. Subregions without\n* priority are taken as 0. A region may only be added once as a subregion (unless removed with\n* memory_region_del_subregion()); use memory_region_init_alias() if you want a region to be a\n* subregion in multiple locations.\n*\n* @param mr The region to contain the new subregion; must be a container initialized with\n*           memory_region_init().\n* @param offset The offset relative to mr where subregion is added.\n* @param subregion The subregion to be added.\n* @param priority Used for resolving overlaps; highest priority wins.\n*/\nvoid memory_region_add_subregion_overlap(MemoryRegion *mr,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void memory_region_sync_dirty_bitmap(MemoryRegion *mr)\n{\n}\n",
        "answer": "/** @brief Synchronize a region's dirty bitmap with any external TLBs (e.g. kvm).\n*\n*  This function flushes dirty information from accelerators such as kvm and vhost-net and makes it available to users of the memory API.\n*\n* @param mr The region being flushed.\n*/\nvoid memory_region_sync_dirty_bitmap(MemoryRegion *mr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "yy::GraphQLParserImpl::syntax_error make_error(const yy::location &loc, const std::string &str) {\n  return yy::GraphQLParserImpl::syntax_error(loc, str);\n}\n",
        "answer": "/** @brief Creates an error message for the GraphQL parser.\n*\n* This function creates a syntax error message for the GraphQL parser. It takes in a location and a string as input, and returns a syntax_error object.\n*\n* @param loc The location of the error in the source code.\n* @param str The error message to display.\n* @return A syntax_error object containing the error message and location.\n*/\nyy::GraphQLParserImpl::syntax_error make_error(const yy::location &loc, const std::string &str) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int Gia_ManSatAndCollect_rec( Gia_Man_t * p, int iObj, Vec_Int_t * vObjsUsed, Vec_Int_t * vCiVars )\n{\n    Gia_Obj_t * pObj; int iVar;\n    if ( (iVar = Gia_ObjCopyArray(p, iObj)) >= 0 )\n        return iVar;\n    pObj = Gia_ManObj( p, iObj );\n    assert( Gia_ObjIsCand(pObj) );\n    if ( Gia_ObjIsAnd(pObj) )\n    {\n        Gia_ManSatAndCollect_rec( p, Gia_ObjFaninId0(pObj, iObj), vObjsUsed, vCiVars );\n        Gia_ManSatAndCollect_rec( p, Gia_ObjFaninId1(pObj, iObj), vObjsUsed, vCiVars );\n    }\n    iVar = Vec_IntSize( vObjsUsed );\n    Vec_IntPush( vObjsUsed, iObj );\n    Gia_ObjSetCopyArray( p, iObj, iVar );\n    if ( vCiVars && Gia_ObjIsCi(pObj) )\n        Vec_IntPush( vCiVars, iVar );\n    return iVar;\n}                             \n",
        "answer": "/**\n* @brief Gia_ManSatAndCollect_rec\n*\n* This function performs SAT-based quantification. It recursively traverses the AND gate of a given object, and collects the variables used in the gate.\n*\n* @param p: A pointer to a Gia_Man_t structure representing the AIG manager.\n* @param iObj: The ID of the current object being processed.\n* @param vObjsUsed: A vector of integers representing the objects used in the gate.\n* @param vCiVars: A vector of integers representing the CI variables used in the gate.\n*\n* @return The number of variables used in the gate.\n*/\nint Gia_ManSatAndCollect_rec( Gia_Man_t * p, int iObj, Vec_Int_t * vObjsUsed, Vec_Int_t * vCiVars )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool get_youtube_property(const std::string & content, const char * propname, std::string & propValue)\r\n{\r\n    if (get_youtube_property_impl1(content, propname, propValue))\r\n        return true;\r\n    else\r\n        return get_youtube_property_impl2(content, propname, propValue);\r\n}\r\n",
        "answer": "/** @brief Get YouTube property.\n*\n*  This function retrieves a specific property from the content of a YouTube video.\n*\n* @param[in] content The content of the YouTube video.\n* @param[in] propname The name of the property to retrieve.\n* @param[out] propValue The value of the retrieved property.\n*\n* @return True if the property was found and retrieved, false otherwise.\n*/\nbool get_youtube_property(const std::string & content, const char * propname, std::string & propValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual GDALColorInterp GetColorInterpretation()\n    {\n        return GCI_PaletteIndex;\n    }\n",
        "answer": "/** @brief Returns the color interpretation of this raster band.\n*\n*  This method returns the color interpretation of this raster band, which\n*  describes how the values in the band should be interpreted as colors. The\n*  returned value is one of the GDALColorInterp enumeration values. If the\n*  format doesn't know anything about the color interpretation, GCI_Undefined\n*  will be returned. This method is the same as the C function\n*  GDALGetRasterColorInterpretation().\n*\n* @return The color interpretation of this raster band.\n*/\nvirtual GDALColorInterp GetColorInterpretation()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual GDALColorInterp GetColorInterpretation()\n        { return eInterp; }\n",
        "answer": "/**\n* @brief Returns the color interpretation of the raster band.\n*\n* This method returns the color interpretation of the raster band, which can be one of the following values:\n* - GCI_Undefined: The format doesn't know anything about the color interpretation.\n* - GCI_GrayIndex: The color interpretation is grayscale.\n* - GCI_PaletteIndex: The color interpretation is a palette index.\n* - GCI_RedBand: The color interpretation is red.\n* - GCI_GreenBand: The color interpretation is green.\n* - GCI_BlueBand: The color interpretation is blue.\n* - GCI_AlphaBand: The color interpretation is alpha (transparency).\n* - GCI_HueBand: The color interpretation is hue.\n* - GCI_SaturationBand: The color interpretation is saturation.\n* - GCI_LightnessBand: The color interpretation is lightness.\n* - GCI_CyanBand: The color interpretation is cyan.\n* - GCI_MagentaBand: The color interpretation is magenta.\n* - GCI_YellowBand: The color interpretation is yellow.\n* - GCI_BlackBand: The color interpretation is black.\n*\n* @return The color interpretation of the raster band.\n*/\nvirtual GDALColorInterp GetColorInterpretation()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int Transform( int nCount,\n                   double *x, double *y, double *z )\n        { return TransformEx( nCount, x, y, z, NULL ); }\n",
        "answer": "/**\n* @brief Transform points from source to destination space. This method is the same as the C function OCTTransform().\n*\n* @param nCount The number of points to transform.\n* @param x The array of x-coordinates of the points to transform.\n* @param y The array of y-coordinates of the points to transform.\n* @param z The array of z-coordinates of the points to transform.\n* @return Should not return\n*/\nint Transform( int nCount, double *x, double *y, double *z ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int TransformEx( int nCount,\n                     double *adfX, double *adfY, double *adfZ,\n                     int *pabSuccess = NULL )\n        {\n            int i;\n            for( i = 0; i < nCount; i++ )\n            {\n                double x = adfX[i], y = adfY[i], z = adfZ[i];\n\n                adfX[i] = x * adfAX[0] + y * adfAY[0] + z * adfN[0];\n                adfY[i] = x * adfAX[1] + y * adfAY[1] + z * adfN[1];\n                adfZ[i] = x * adfAX[2] + y * adfAY[2] + z * adfN[2];\n\n                if( pabSuccess )\n                    pabSuccess[i] = TRUE;\n            }\n            return TRUE;\n        }\n",
        "answer": "/**\n* @brief Transform points from source to destination space.\n*\n* This method is the same as the C function OCTTransformEx().\n*\n* @param nCount The number of points to transform.\n* @param adfX The x coordinates of the points to transform.\n* @param adfY The y coordinates of the points to transform.\n* @param adfZ The z coordinates of the points to transform.\n* @param pabSuccess An optional array of boolean values indicating whether each point was successfully transformed.\n*\n* @return TRUE if all points were successfully transformed, FALSE otherwise.\n*/\nint TransformEx( int nCount, double *adfX, double *adfY, double *adfZ, int *pabSuccess = NULL )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual int         GetGeomFieldIndex( const char * pszName)\n            { if (poLayer != NULL && !poLayer->HasGeometryInformation())\n                  SolveFields();\n              return OGRPGFeatureDefn::GetGeomFieldIndex(pszName); }\n",
        "answer": "/**\n* @brief Get the geometry field index of the first geometry field matching the passed field name (case insensitively).\n*\n* This method is the same as the C function OGR_FD_GetGeomFieldIndex().\n*\n* @param pszName The name of the geometry field to search for.\n* @return The index of the first geometry field matching the passed field name (case insensitively).\n*/\nvirtual int GetGeomFieldIndex(const char *pszName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GDALColorInterp WMTSBand::GetColorInterpretation()\n{\n    WMTSDataset* poGDS = (WMTSDataset*) poDS;\n    if (poGDS->nBands == 1)\n    {\n        return GCI_GrayIndex;\n    }\n    else if (poGDS->nBands == 3 || poGDS->nBands == 4)\n    {\n        if (nBand == 1)\n            return GCI_RedBand;\n        else if (nBand == 2)\n            return GCI_GreenBand;\n        else if (nBand == 3)\n            return GCI_BlueBand;\n        else if (nBand == 4)\n            return GCI_AlphaBand;\n    }\n\n    return GCI_Undefined;\n}\n",
        "answer": "/** @brief Get the color interpretation of a WMTSBand.\n*\n*  This function returns the color interpretation of a WMTSBand, which is one of the following:\n*  - GCI_GrayIndex: The band is a grayscale image.\n*  - GCI_RedBand: The band is the red channel of an RGB or RGBA image.\n*  - GCI_GreenBand: The band is the green channel of an RGB or RGBA image.\n*  - GCI_BlueBand: The band is the blue channel of an RGB or RGBA image.\n*  - GCI_AlphaBand: The band is the alpha (transparency) channel of an RGBA image.\n*  - GCI_Undefined: The color interpretation is not known.\n*\n* @param poDS A pointer to a WMTSDataset object.\n* @param nBand The band number.\n*\n* @return The color interpretation of the specified band.\n*/\nGDALColorInterp WMTSBand::GetColorInterpretation()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPLPrintString( char *pszDest, const char *pszSrc, int nMaxLen )\n{\n    if ( !pszDest )\n        return 0;\n\n    if ( !pszSrc )\n    {\n        *pszDest = '\\0';\n        return 1;\n    }\n\n    int  nChars = 0;\n    char *pszTemp = pszDest;\n\n    while ( nChars < nMaxLen && *pszSrc )\n    {\n        *pszTemp++ = *pszSrc++;\n        nChars++;\n    }\n\n    return nChars;\n}\n",
        "answer": "/** @brief Copies a string to an array, excluding the terminating '\\0' character.\n*\n*  This function copies the string pointed to by pszSrc, NOT including the terminating '\\0' character, to the array pointed to by pszDest.\n*\n* @param[in] pszSrc The source string to be copied.\n* @param[out] pszDest The destination array where the string will be copied.\n* @param[in] nMaxLen The maximum number of characters to copy.\n* @return The number of characters copied, excluding the terminating '\\0' character.\n*/\n*pszDest = '\\0';\n*pszTemp++ = *pszSrc++;\nnChars++;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CPLErrorNum CPL_STDCALL CPLGetLastErrorNo()\n{\n    CPLErrorContext *psCtx = CPLGetErrorContext();\n    if( psCtx == NULL )\n        return 0;\n\n    return psCtx->nLastErrNo;\n}\n",
        "answer": "/** @brief Fetch the last error number.\n*\n* This function fetches the last error number posted with CPLError(), that hasn't been cleared by CPLErrorReset(). This is the error number, not the error class.\n*\n* @return The last error number.\n*/\nCPLErrorNum CPL_STDCALL CPLGetLastErrorNo()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CPL_STDCALL CPLPopErrorHandler()\n\n{\n    CPLErrorContext *psCtx = CPLGetErrorContext();\n\n    if( psCtx == NULL || IS_PREFEFINED_ERROR_CTX(psCtx) )\n    {\n        fprintf(stderr, \"CPLPopErrorHandler() failed.\\n\");\n        return;\n    }\n\n    if( psCtx->psHandlerStack != NULL )\n    {\n        CPLErrorHandlerNode     *psNode = psCtx->psHandlerStack;\n\n        psCtx->psHandlerStack = psNode->psNext;\n        VSIFree( psNode );\n    }\n}\n",
        "answer": "/**\n* @brief Pop error handler off stack.\n*\n* Discards the current error handler on the error handler stack, and restores the one in use before the last CPLPushErrorHandler() call. This method has no effect if there are no error handlers on the current threads error handler stack.\n*\n* @return Should not return\n*/\nvoid CPL_STDCALL CPLPopErrorHandler();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CPLHashSetClear(CPLHashSet* set)\n{\n    CPLHashSetClearInternal(set, FALSE);\n    set->tabList = (CPLList**) CPLRealloc(set->tabList, sizeof(CPLList*) * 53);\n    set->nIndiceAllocatedSize = 0;\n    set->nAllocatedSize = 53;\n#ifdef HASH_DEBUG\n    set->nCollisions = 0;\n#endif\n    set->nSize = 0;\n}\n",
        "answer": "/** @brief Clear all elements from a hash set.\n*\n* This function clears all elements from a hash set and frees the memory used by the elements if a free function was provided at the creation of the hash set.\n*\n* @param set The hash set to clear.\n*/\nvoid CPLHashSetClear(CPLHashSet* set)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CPLAddXMLAttributeAndValue( CPLXMLNode *psParent,\n                                 const char *pszName,\n                                 const char *pszValue )\n{\n    CPLAssert(psParent != NULL);\n    CPLXMLNode *psAttributeNode\n        = CPLCreateXMLNode( psParent, CXT_Attribute, pszName );\n    CPLCreateXMLNode( psAttributeNode, CXT_Text, pszValue );\n}\n",
        "answer": "/** @brief Adds an XML attribute and value to a parent node.\n*\n*  This function creates a CXT_Attribute node with the specified name and value,\n*  and attaches it to the passed parent node.\n*\n* @param psParent The parent node to which the attribute will be added.\n* @param pszName The name of the attribute to add.\n* @param pszValue The value of the attribute to add.\n*/\nvoid CPLAddXMLAttributeAndValue(CPLXMLNode *psParent, const char *pszName, const char *pszValue) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CPLQuadTreeSetBucketCapacity(CPLQuadTree *hQuadTree, int nBucketCapacity)\n{\n    if( nBucketCapacity > 0 )\n        hQuadTree->nBucketCapacity = nBucketCapacity;\n}\n",
        "answer": "/** @brief Set the maximum capacity of a node of a quadtree.\n*\n* This function sets the maximum capacity of a node of a quadtree. The default value is 8. Note that the maximum capacity will only be honoured if the features inserted have a point geometry. Otherwise it may be exceeded.\n*\n* @param hQuadTree A pointer to the CPLQuadTree object.\n* @param nBucketCapacity The maximum capacity of a node of the quadtree.\n*/\nvoid CPLQuadTreeSetBucketCapacity(CPLQuadTree *hQuadTree, int nBucketCapacity)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CSLCount(const char * const *papszStrList)\n{\n    if (!papszStrList)\n        return 0;\n\n    int nItems=0;\n\n    while(*papszStrList != NULL)\n    {\n        ++nItems;\n        ++papszStrList;\n    }\n\n    return nItems;\n}\n",
        "answer": "/** @brief Returns the number of items in a string list.\n*\n* This function returns the number of items in a string list, not counting the terminating NULL. Passing in NULL is safe, and will result in a count of zero. Lists are counted by iterating through them so long lists will take more time than short lists. Care should be taken to avoid using CSLCount() as an end condition for loops as it will result in O(n^2) behavior.\n*\n* @param papszStrList The string list to count.\n* @return The number of items in the string list, not counting the terminating NULL.\n*/\nint CSLCount(const char * const *papszStrList);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPLsnprintf(char *str, size_t size, const char* fmt, ...)\n{\n    va_list args;\n\n    va_start( args, fmt );\n    const int ret = CPLvsnprintf( str, size, fmt, args );\n    va_end( args );\n    return ret;\n}\n",
        "answer": "/** @brief snprintf() wrapper that is not sensitive to LC_NUMERIC settings.\n*\n*  This function has the same contract as standard snprintf(), except that formatting of floating-point numbers will use decimal point, whatever the current locale is set.\n*\n* @param str The string buffer to write to.\n* @param size The maximum number of characters to write.\n* @param fmt The format string.\n* @param ... The arguments for the format string.\n*\n* @return The number of characters written, or -1 if an error occurred.\n*/\nint CPLsnprintf(char *str, size_t size, const char* fmt, ...)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t CPLStrlcpy(char* pszDest, const char* pszSrc, size_t nDestSize)\n{\n    if (nDestSize == 0)\n        return strlen(pszSrc);\n\n    char* pszDestIter = pszDest;\n    const char* pszSrcIter = pszSrc;\n\n    --nDestSize;\n    while(nDestSize != 0 && *pszSrcIter != '\\0')\n    {\n        *pszDestIter = *pszSrcIter;\n        ++pszDestIter;\n        ++pszSrcIter;\n        --nDestSize;\n    }\n    *pszDestIter = '\\0';\n    return pszSrcIter - pszSrc + strlen(pszSrcIter);\n}\n",
        "answer": "/** @brief Copy source string to a destination buffer.\n*\n* This function ensures that the destination buffer is always NUL terminated (provided that its length is at least 1). This function is designed to be a safer, more consistent, and less error prone replacement for strncpy. Its contract is identical to libbsd's strlcpy. Truncation can be detected by testing if the return value of CPLStrlcpy is greater or equal to nDestSize.\n*\n* @param pszDest The destination buffer.\n* @param pszSrc The source string.\n* @param nDestSize The size of the destination buffer.\n* @return The length of the source string, including the NUL terminator if it fits in the destination buffer, or the number of characters that would have been copied if the destination buffer was large enough.\n*/\n*pszDestIter = *pszSrcIter;\n*pszDestIter = '\\0';\nreturn pszSrcIter - pszSrc + strlen(pszSrcIter);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double CPLAtofM( const char *nptr )\n\n{\n    const int nMaxSearch = 50;\n\n    for( int i = 0; i < nMaxSearch; i++ )\n    {\n        if( nptr[i] == ',' )\n            return CPLStrtodDelim( nptr, NULL, ',' );\n        if( nptr[i] == '.' || nptr[i] == '\\0' )\n            return CPLStrtodDelim( nptr, NULL, '.' );\n    }\n\n    return CPLStrtodDelim( nptr, NULL, '.' );\n}\n",
        "answer": "/**\n* @brief Converts ASCII string to floating point number using any numeric locale.\n*\n* This function converts the initial portion of the string pointed to by nptr to double floating point representation.\n* This function does the same as standard atof(), but it allows a variety of locale representations. That is it supports\n* numeric values with either a comma or a period for the decimal delimiter. PS. The M stands for Multi-lingual.\n*\n* @param nptr Pointer to the string to be converted.\n* @return Double floating point representation of the input string.\n*/\ndouble CPLAtofM( const char *nptr )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CPLVirtualMemFree(CPLVirtualMem* ctxt)\n{\n    if( ctxt == NULL || --(ctxt->nRefCount) > 0 )\n        return;\n\n    if( ctxt->pVMemBase != NULL )\n    {\n        CPLVirtualMemFree(ctxt->pVMemBase);\n        if( ctxt->pfnFreeUserData != NULL )\n            ctxt->pfnFreeUserData(ctxt->pCbkUserData);\n        CPLFree(ctxt);\n        return;\n    }\n\n#ifdef HAVE_MMAP\n    if( ctxt->eType == VIRTUAL_MEM_TYPE_FILE_MEMORY_MAPPED )\n        CPLVirtualMemFreeFileMemoryMapped(ctxt);\n#endif\n#ifdef HAVE_VIRTUAL_MEM_VMA\n    if( ctxt->eType == VIRTUAL_MEM_TYPE_VMA )\n      CPLVirtualMemFreeFileMemoryMapped(\n          reinterpret_cast<CPLVirtualMemVMA*>(ctxt));\n#endif\n\n    if( ctxt->pfnFreeUserData != NULL )\n        ctxt->pfnFreeUserData(ctxt->pCbkUserData);\n    CPLFree(ctxt);\n}\n",
        "answer": "/** @brief Free a virtual memory mapping.\n*\n*  This function frees a virtual memory mapping created with CPLVirtualMemGetAddr(). The pointer returned by CPLVirtualMemGetAddr() will no longer be valid. If the virtual memory mapping was created with read/write permissions and that they are dirty (i.e. modified) pages, they will be flushed through the pfnUnCachePage callback before being freed.\n*\n* @param ctxt The CPLVirtualMem context to free.\n*/\nvoid CPLVirtualMemFree(CPLVirtualMem* ctxt);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const char* CPL_STDCALL VSIGetLastErrorMsg()\n{\n    VSIErrorContext *psCtx = VSIGetErrorContext();\n    if( psCtx == NULL )\n        return \"\";\n\n    return psCtx->szLastErrMsg;\n}\n",
        "answer": "/** @brief Get the last error message.\n*\n*  Fetches the last error message posted with VSIError(), that hasn't been cleared by VSIErrorReset(). The returned pointer is to an internal string that should not be altered or freed.\n*\n* @return A const char* pointer to the last error message, or NULL if there is no error message.\n*/\nconst char* CPL_STDCALL VSIGetLastErrorMsg()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int VSIStatL( const char * pszFilename, VSIStatBufL *psStatBuf )\n\n{\n    return VSIStatExL(pszFilename, psStatBuf, 0);\n}\n",
        "answer": "/** @brief Fetches status information about a filesystem object (file, directory, etc).\n*\n* This function retrieves the size and file type of a given file system object. It is similar to VSIStat(), but it can handle large files on systems where this requires special calls. This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX stat() function.\n*\n* @param pszFilename The path to the file system object for which status information is desired.\n* @param psStatBuf A pointer to a VSIStatBufL structure where the status information will be stored.\n*\n* @return 0 on success, -1 on error.\n*/\nint VSIStatL( const char * pszFilename, VSIStatBufL *psStatBuf )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "vsi_l_offset VSIFTellL( VSILFILE * fp )\n\n{\n    VSIVirtualHandle *poFileHandle = reinterpret_cast<VSIVirtualHandle *>( fp );\n\n    return poFileHandle->Tell();\n}\n",
        "answer": "/** @brief Returns the current file read/write offset in bytes from the beginning of the file.\n*\n* This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX ftell() call.\n*\n* @param fp The VSILFILE pointer to the file.\n* @return The current file read/write offset in bytes from the beginning of the file.\n*/\nvsi_l_offset VSIFTellL(VSILFILE *fp) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int VSIFTruncateL( VSILFILE * fp, vsi_l_offset nNewSize )\n\n{\n  VSIVirtualHandle *poFileHandle = reinterpret_cast<VSIVirtualHandle *>( fp );\n\n    return poFileHandle->Truncate(nNewSize);\n}\n",
        "answer": "/** @brief Truncates a file to the specified size.\n*\n* This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX ftruncate() call.\n*\n* @param[in] fp The file pointer to truncate.\n* @param[in] nNewSize The new size for the file.\n*\n* @return 0 on success, -1 on error.\n*/\nint VSIFTruncateL(VSILFILE *fp, vsi_l_offset nNewSize)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void VSIInstallGZipFileHandler(void)\n{\n    VSIFileManager::InstallHandler( \"/vsigzip/\", new VSIGZipFilesystemHandler );\n}\n",
        "answer": "/** @brief Installs a GZip file handler for reading and writing GZip files.\n*\n*  This function installs a special file handler that allows reading on-the-fly and writing in GZip (.gz) files. All portions of the file system underneath the base path \"/vsigzip/\" will be handled by this driver.\n*\n* @return Should not return\n*/\nvoid VSIInstallGZipFileHandler(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int VSIStatL( const char * pszFilename, VSIStatBufL *psStatBuf )\n\n{\n    return( VSIStat( pszFilename, (VSIStatBuf *) psStatBuf ) );\n}\n",
        "answer": "/** @brief Fetches status information about a filesystem object.\n*\n*  This function fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls. This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory. Analog of the POSIX stat() function.\n*\n* @param pszFilename The name of the file or directory to get information about.\n* @param psStatBuf A pointer to a VSIStatBufL structure where the information will be stored.\n* @return 0 on success, -1 on error.\n*/\nint VSIStatL( const char * pszFilename, VSIStatBufL *psStatBuf )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "GIntBig  CPLGetUsablePhysicalRAM(void)\n{\n    GIntBig nRAM = CPLGetPhysicalRAM();\n#if SIZEOF_VOIDP == 4\n    if( nRAM > INT_MAX )\n        nRAM = INT_MAX;\n#endif\n    return nRAM;\n}\n",
        "answer": "/**\n* @brief Returns the total physical RAM, usable by a process, in bytes.\n*\n* This function returns the total amount of physical RAM available on the system,\n* taking into account the limitations of 32-bit processes. It is the same as\n* `CPLGetPhysicalRAM()` except that it will limit to 2 GB for 32-bit processes.\n* Note: This memory may already be partly used by other processes.\n*\n* @return The total physical RAM, usable by a process, in bytes.\n*/\nGIntBig CPLGetUsablePhysicalRAM(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void DGNSetOptions( DGNHandle hDGN, int nOptions )\n\n{\n    DGNInfo     *psDGN = (DGNInfo *) hDGN;\n\n    psDGN->options = nOptions;\n}\n",
        "answer": "/** @brief Set file access options. Sets a flag affecting how the file is accessed. Currently there is only one support flag:\n*\n* @param hDGN Handle to the DGN file.\n* @param nOptions The option to set.\n*/\nvoid DGNSetOptions( DGNHandle hDGN, int nOptions )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int DGNGetExtents( DGNHandle hDGN, double * padfExtents )\n\n{\n    DGNInfo     *psDGN = (DGNInfo *) hDGN;\n    DGNPoint    sMin, sMax;\n\n    DGNBuildIndex( psDGN );\n\n    if( !psDGN->got_bounds )\n        return FALSE;\n\n    sMin.x = psDGN->min_x - 2147483648.0;\n    sMin.y = psDGN->min_y - 2147483648.0;\n    sMin.z = psDGN->min_z - 2147483648.0;\n\n    DGNTransformPoint( psDGN, &sMin );\n\n    padfExtents[0] = sMin.x;\n    padfExtents[1] = sMin.y;\n    padfExtents[2] = sMin.z;\n\n    sMax.x = psDGN->max_x - 2147483648.0;\n    sMax.y = psDGN->max_y - 2147483648.0;\n    sMax.z = psDGN->max_z - 2147483648.0;\n\n    DGNTransformPoint( psDGN, &sMax );\n\n    padfExtents[3] = sMax.x;\n    padfExtents[4] = sMax.y;\n    padfExtents[5] = sMax.z;\n\n    return TRUE;\n}\n",
        "answer": "/** @brief Fetch overall file extents.\n*\n*  This function collects the extents for each element while building an index, so if an index has not already been built, it will be built when DGNGetExtents() is called. The Z min/max values are generally meaningless (0 and 0xffffffff in uor space).\n*\n* @param hDGN Handle to the DGN file.\n* @param padfExtents Array of six doubles where the extents will be placed.\n* @return TRUE if successful or FALSE if an error occurs.\n*/\nint DGNGetExtents( DGNHandle hDGN, double * padfExtents )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": " const char * CPL_STDCALL GDALGetAsyncStatusTypeName( GDALAsyncStatusType eAsyncStatusType )\n\n{\n    switch( eAsyncStatusType )\n    {\n      case GARIO_PENDING:\n        return \"PENDING\";\n\n      case GARIO_UPDATE:\n        return \"UPDATE\";\n\n      case GARIO_ERROR:\n        return \"ERROR\";\n\n      case GARIO_COMPLETE:\n        return \"COMPLETE\";\n      default:\n        return NULL;\n    }\n}\n",
        "answer": "/** @brief Get name of AsyncStatus data type.\n*\n*  Returns a symbolic name for the AsyncStatus data type. This is essentially the the enumerated item name with the GARIO_ prefix removed. So GARIO_COMPLETE returns \"COMPLETE\". The returned strings are static strings and should not be modified or freed by the application. These strings are useful for reporting datatypes in debug statements, errors and other user output.\n*\n* @param eAsyncStatusType The AsyncStatus data type to get the name of.\n* @return A string representing the name of the AsyncStatus data type.\n*/\nconst char * CPL_STDCALL GDALGetAsyncStatusTypeName( GDALAsyncStatusType eAsyncStatusType )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRLayerH GDALDatasetCreateLayer( GDALDatasetH hDS,\n                              const char * pszName,\n                              OGRSpatialReferenceH hSpatialRef,\n                              OGRwkbGeometryType eGType,\n                              char ** papszOptions )\n\n{\n    VALIDATE_POINTER1( hDS, \"GDALDatasetCreateLayer\", NULL );\n\n    if (pszName == NULL)\n    {\n        CPLError ( CE_Failure, CPLE_ObjectNull, \"Name was NULL in GDALDatasetCreateLayer\");\n        return NULL;\n    }\n    return (OGRLayerH) ((GDALDataset *)hDS)->CreateLayer(\n        pszName, (OGRSpatialReference *) hSpatialRef, eGType, papszOptions );\n}\n",
        "answer": "/**\n* @brief Creates a new layer in the dataset.\n*\n* This function creates a new layer in the dataset with the specified name, spatial reference system, and geometry type. The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.\n*\n* @param hDS A handle to the dataset.\n* @param pszName The name of the new layer.\n* @param hSpatialRef The spatial reference system for the new layer.\n* @param eGType The geometry type for the new layer.\n* @param papszOptions Driver specific options for creating the layer.\n*\n* @return A handle to the newly created layer, or NULL if an error occurs.\n*/\nOGRLayerH GDALDatasetCreateLayer( GDALDatasetH hDS, const char *pszName, OGRSpatialReferenceH hSpatialRef, OGRwkbGeometryType eGType, char **papszOptions );"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "const char * CPL_STDCALL GDALGetDriverShortName( GDALDriverH hDriver )\n\n{\n    VALIDATE_POINTER1( hDriver, \"GDALGetDriverShortName\", NULL );\n\n    return ((GDALDriver *) hDriver)->GetDescription();\n}\n",
        "answer": "/** @brief Gets the short name of a GDAL driver.\n*\n*  This function returns the short name of a GDAL driver, which can be used to identify the driver in various contexts.\n*\n* @param hDriver The handle to the GDAL driver.\n*\n* @return A string containing the short name of the driver.\n*/\nconst char * CPL_STDCALL GDALGetDriverShortName( GDALDriverH hDriver )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPL_STDCALL GDALGetCacheMax()\n{\n    GIntBig nRes = GDALGetCacheMax64();\n    if (nRes > INT_MAX)\n    {\n        static bool bHasWarned = false;\n        if (!bHasWarned)\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"Cache max value doesn't fit on a 32 bit integer. \"\n                     \"Call GDALGetCacheMax64() instead\");\n            bHasWarned = true;\n        }\n        nRes = INT_MAX;\n    }\n    return (int)nRes;\n}\n",
        "answer": "/**\n* @brief Gets the maximum cache memory.\n*\n* This function reads the GDAL_CACHEMAX configuration option to initialize the maximum cache memory. Starting with GDAL 2.1, the value can be expressed as x% of the usable physical RAM (which may potentially be used by other processes). Otherwise it is expected to be a value in MB. This function cannot return a value higher than 2 GB. Use GDALGetCacheMax64() to get a non-truncated value.\n*\n* @return The maximum cache memory, or INT_MAX if the value exceeds 32 bits.\n*/\nint CPL_STDCALL GDALGetCacheMax();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static boolean fill_input_buffer_dec(j_decompress_ptr cinfo)\n{\n    if (0 != cinfo->src->bytes_in_buffer)\n        return TRUE;\n    CPLError(CE_Failure, CPLE_AppDefined, \"Invalid JPEG stream\");\n    return FALSE;\n}\n",
        "answer": "/** @brief Fill input buffer for decompression.\n*\n*  This function is used to fill the input buffer for decompression. It checks if there are any bytes in the buffer, and if not, it returns an error.\n*\n* @param cinfo A pointer to a j_decompress_ptr struct that contains information about the decompression process.\n* @return TRUE if the buffer was filled successfully, FALSE otherwise.\n*/\nstatic boolean fill_input_buffer_dec(j_decompress_ptr cinfo)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_G_RemoveGeometry( OGRGeometryH hGeom, int iGeom, int bDelete )\n\n{\n    VALIDATE_POINTER1( hGeom, \"OGR_G_RemoveGeometry\", OGRERR_FAILURE );\n\n    OGRwkbGeometryType eType = wkbFlatten(((OGRGeometry *) hGeom)->getGeometryType());\n    if( OGR_GT_IsSubClassOf(eType, wkbCurvePolygon) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"OGR_G_RemoveGeometry() not supported on polygons yet.\" );\n        return OGRERR_UNSUPPORTED_OPERATION;\n    }\n    else if( OGR_GT_IsSubClassOf(eType, wkbGeometryCollection) )\n    {\n        return ((OGRGeometryCollection *)hGeom)->removeGeometry( iGeom,bDelete);\n    }\n    else\n    {\n        return OGRERR_UNSUPPORTED_OPERATION;\n    }\n}\n",
        "answer": "/** @brief Removes a geometry from an OGRGeometry.\n*\n*  This function removes the geometry at index iGeom from the geometry collection hGeom. If bDelete is TRUE, the removed geometry will be deleted.\n*\n* @param hGeom The handle to the geometry collection.\n* @param iGeom The index of the geometry to remove.\n* @param bDelete Whether to delete the removed geometry.\n* @return OGRERR_NONE if successful, OGRERR_FAILURE if hGeom is not a valid geometry collection, or OGRERR_UNSUPPORTED_OPERATION if the operation is not supported for the type of geometry.\n*/\nOGRErr OGR_G_RemoveGeometry( OGRGeometryH hGeom, int iGeom, int bDelete )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OSRImportFromOzi( OGRSpatialReferenceH hSRS,\n                         const char * const* papszLines )\n\n{\n    VALIDATE_POINTER1( hSRS, \"OSRImportFromOzi\", OGRERR_FAILURE );\n\n    return ((OGRSpatialReference *) hSRS)->importFromOzi( papszLines );\n}\n",
        "answer": "/** @brief Import coordinate system from OziExplorer projection definition.\n*\n*  This function will import projection definition in style, used by OziExplorer software. Note: another version of this function with a different signature existed in GDAL 1.X.\n*\n* @param hSRS Spatial reference handle to be imported into.\n* @param papszLines Array of strings containing the projection definition.\n* @return OGRErr code indicating success or failure.\n*/\nOGRErr OSRImportFromOzi( OGRSpatialReferenceH hSRS, const char * const* papszLines )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_F_SetGeomField( OGRFeatureH hFeat, int iField, OGRGeometryH hGeom )\n\n{\n    VALIDATE_POINTER1( hFeat, \"OGR_F_SetGeomField\", OGRERR_FAILURE );\n\n    return ((OGRFeature *) hFeat)->SetGeomField(iField, (OGRGeometry *) hGeom);\n}\n",
        "answer": "/** @brief Updates the features geometry and operates exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.\n*\n*  This function updates the features geometry by making a copy of the passed in geometry, and then operating exactly as SetGeometryDirectly().\n*\n* @param hFeat The feature handle.\n* @param iField The field index.\n* @param hGeom The geometry handle.\n*\n* @return OGRERR_NONE if successful, or an error code if the operation fails.\n*/\nOGRErr OGR_F_SetGeomField( OGRFeatureH hFeat, int iField, OGRGeometryH hGeom )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void OGR_F_SetFieldInteger64( OGRFeatureH hFeat, int iField, GIntBig nValue )\n\n{\n    VALIDATE_POINTER0( hFeat, \"OGR_F_SetFieldInteger64\" );\n\n    ((OGRFeature *)hFeat)->SetField( iField, nValue );\n}\n",
        "answer": "/** @brief Sets the value of an OFTInteger64 field.\n*\n*  This function sets the value of an OFTInteger64 field in an OGRFeature. The value is set directly, without any formatting or validation.\n*\n*  @param hFeat The handle to the OGRFeature.\n*  @param iField The index of the field to be set.\n*  @param nValue The new value for the field.\n*/\nvoid OGR_F_SetFieldInteger64(OGRFeatureH hFeat, int iField, GIntBig nValue) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int OGR_F_Validate( OGRFeatureH hFeat, int nValidateFlags, int bEmitError )\n\n{\n    VALIDATE_POINTER1( hFeat, \"OGR_F_Validate\", FALSE );\n\n    return ((OGRFeature *) hFeat)->Validate( nValidateFlags, bEmitError );\n}\n",
        "answer": "/** @brief Validates an OGR feature.\n*\n*  This function validates an OGR feature according to the specified flags and emits errors if necessary.\n*\n* @param hFeat The handle of the feature to validate.\n* @param nValidateFlags The validation flags.\n* @param bEmitError Whether to emit errors or not.\n*\n* @return TRUE if the feature is valid, FALSE otherwise.\n*/\nint OGR_F_Validate( OGRFeatureH hFeat, int nValidateFlags, int bEmitError )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void OGR_FD_AddGeomFieldDefn( OGRFeatureDefnH hDefn,\n                              OGRGeomFieldDefnH hNewGeomField )\n\n{\n    ((OGRFeatureDefn *) hDefn)->AddGeomFieldDefn( (OGRGeomFieldDefn *) hNewGeomField );\n}\n",
        "answer": "/** @brief Adds a new geometry field definition to a layer definition.\n*\n* This function is used to add a new geometry field definition to a layer definition.\n* It takes two arguments: the handle of the layer definition and the handle of the\n* geometry field definition to be added. The function adds the geometry field definition\n* to the layer definition and returns nothing.\n*\n* @param hDefn Handle to the layer definition.\n* @param hNewGeomField Handle to the geometry field definition to be added.\n* @return Nothing.\n*/\nvoid OGR_FD_AddGeomFieldDefn(OGRFeatureDefnH hDefn, OGRGeomFieldDefnH hNewGeomField) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_G_Transform( OGRGeometryH hGeom,\n                        OGRCoordinateTransformationH hTransform )\n\n{\n    VALIDATE_POINTER1( hGeom, \"OGR_G_Transform\", OGRERR_FAILURE );\n\n    return ((OGRGeometry *) hGeom)->transform(\n        (OGRCoordinateTransformation *) hTransform );\n}\n",
        "answer": "/** @brief Transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system.\n*\n*  This function will transform the vectors of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.\n*\n* @param hGeom The handle to the geometry that needs to be transformed.\n* @param hTransform The handle to the coordinate transformation object that will be used to perform the transformation.\n* @return OGRERR_NONE if the transformation was successful, or an error code if it failed.\n*/\nOGRErr OGR_G_Transform( OGRGeometryH hGeom,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int OGR_G_WkbSize( OGRGeometryH hGeom )\n\n{\n    VALIDATE_POINTER1( hGeom, \"OGR_G_WkbSize\", 0 );\n\n    return ((OGRGeometry *) hGeom)->WkbSize();\n}\n",
        "answer": "/**\n* @brief Returns the exact number of bytes required to hold the well-known binary representation of this geometry object.\n*\n* This function computes the size of the WKB representation of the geometry, which may be slightly expensive for complex geometries.\n*\n* @param hGeom The handle to the geometry object.\n* @return The number of bytes required to hold the WKB representation of the geometry.\n*/\nint OGR_G_WkbSize(OGRGeometryH hGeom);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_G_ExportToIsoWkt( OGRGeometryH hGeom, char **ppszSrcText )\n\n{\n    VALIDATE_POINTER1( hGeom, \"OGR_G_ExportToIsoWkt\", OGRERR_FAILURE );\n\n    return ((OGRGeometry *) hGeom)->exportToWkt( ppszSrcText, wkbVariantIso );\n}\n",
        "answer": "/** @brief Exports the geometry to ISO WKT.\n*\n*  This function exports the geometry in ISO WKT format, which includes the extended dimension (Z&M) WKB types. It is similar to the CPP method OGRGeometry::exportToWkt(,wkbVariantIso).\n*\n* @param hGeom The handle of the geometry to export.\n* @param ppszSrcText A pointer to a string that will contain the resulting WKT.\n*\n* @return OGRERR_NONE if successful, or an error code if something goes wrong.\n*/\nOGRErr OGR_G_ExportToIsoWkt( OGRGeometryH hGeom, char **ppszSrcText )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGRSetGenerate_DB2_V72_BYTE_ORDER( int bGenerate_DB2_V72_BYTE_ORDER )\n\n{\n#if defined(HACK_FOR_IBM_DB2_V72)\n    OGRGeometry::bGenerate_DB2_V72_BYTE_ORDER = bGenerate_DB2_V72_BYTE_ORDER;\n    return OGRERR_NONE;\n#else\n    if( bGenerate_DB2_V72_BYTE_ORDER )\n        return OGRERR_FAILURE;\n    else\n        return OGRERR_NONE;\n#endif\n}\n",
        "answer": "/** @brief Sets the generate DB2 V72 byte order flag.\n*\n*  This function sets the generate DB2 V72 byte order flag, which determines whether or not to generate WKB with an extra 0x30 or'ed with the byte order in WKB.\n*\n* @param bGenerate_DB2_V72_BYTE_ORDER The value to set the flag to. If true, WKB will be generated with the extra 0x30 or'ed with the byte order. If false, WKB will not be generated with the extra 0x30.\n* @return OGRERR_NONE if successful, OGRERR_FAILURE if bGenerate_DB2_V72_BYTE_ORDER is true and HACK_FOR_IBM_DB2_V72 is not defined.\n*/\nOGRErr OGRSetGenerate_DB2_V72_BYTE_ORDER( int bGenerate_DB2_V72_BYTE_ORDER )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRGeometryH OGR_G_Union( OGRGeometryH hThis, OGRGeometryH hOther )\n\n{\n    VALIDATE_POINTER1( hThis, \"OGR_G_Union\", NULL );\n\n    return (OGRGeometryH)\n        ((OGRGeometry *) hThis)->Union( (OGRGeometry *) hOther );\n}\n",
        "answer": "/** @brief Generates a new geometry which is the region of union of the two geometries operated on.\n*\n*  This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.\n*\n* @param hThis The first geometry to operate on.\n* @param hOther The second geometry to operate on.\n* @return A new geometry representing the region of union of the two input geometries.\n*/\nOGRGeometryH OGR_G_Union( OGRGeometryH hThis, OGRGeometryH hOther )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int OGR_G_Touches( OGRGeometryH hThis, OGRGeometryH hOther )\n\n{\n    VALIDATE_POINTER1( hThis, \"OGR_G_Touches\", FALSE );\n\n    return ((OGRGeometry *) hThis)->Touches( (OGRGeometry *) hOther );\n}\n",
        "answer": "/** @brief Tests if this geometry and another geometry are touching.\n*\n*  This function uses the GEOS library to perform the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.\n*\n* @param hThis The handle of the first geometry.\n* @param hOther The handle of the second geometry.\n* @return TRUE if the geometries touch, FALSE otherwise.\n*/\nint OGR_G_Touches( OGRGeometryH hThis, OGRGeometryH hOther )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void OGR_G_CloseRings( OGRGeometryH hGeom )\n\n{\n    VALIDATE_POINTER0( hGeom, \"OGR_G_CloseRings\" );\n\n    ((OGRGeometry *) hGeom)->closeRings();\n}\n",
        "answer": "/** @brief Closes any open rings in the geometry.\n*\n*  If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end.\n*\n* @param hGeom The handle to the geometry to close rings for.\n*/\nvoid OGR_G_CloseRings(OGRGeometryH hGeom)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRwkbGeometryType OGR_GT_Flatten( OGRwkbGeometryType eType )\n{\n    eType = (OGRwkbGeometryType) (eType & (~wkb25DBitInternalUse));\n    if( eType >= 1000 && eType < 2000 ) /* ISO Z */\n        return (OGRwkbGeometryType) (eType - 1000);\n    if( eType >= 2000 && eType < 3000 ) /* ISO M */\n        return (OGRwkbGeometryType) (eType - 2000);\n    if( eType >= 3000 && eType < 4000 ) /* ISO ZM */\n        return (OGRwkbGeometryType) (eType - 3000);\n    return eType;\n}\n",
        "answer": "/**\n* @brief Flattens a geometry type to its 2D equivalent.\n*\n* This function takes an OGRwkbGeometryType and returns its 2D equivalent,\n* which is obtained by removing the Z and M dimensions from the type.\n*\n* @param eType The input geometry type.\n*\n* @return The flattened geometry type.\n*/\nOGRwkbGeometryType OGR_GT_Flatten(OGRwkbGeometryType eType)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr CPL_DLL OGR_G_CreateFromWkb( unsigned char *pabyData,\n                                    OGRSpatialReferenceH hSRS,\n                                    OGRGeometryH *phGeometry,\n                                    int nBytes )\n\n{\n    return OGRGeometryFactory::createFromWkb( pabyData,\n                                              (OGRSpatialReference *) hSRS,\n                                              (OGRGeometry **) phGeometry,\n                                              nBytes );\n}\n",
        "answer": "/** @brief Creates an OGR geometry object from a WKB representation.\n*\n*  This function creates an OGR geometry object from a WKB (Well-Known Binary) representation. The WKB format is a\n*  standardized binary format for representing geometric objects, and it is supported by many GIS systems.\n*\n* @param pabyData A pointer to the WKB data.\n* @param hSRS A handle to an OGRSpatialReferenceH object that represents the spatial reference system of the geometry.\n* @param phGeometry A pointer to an OGRGeometryH object that will be created and returned by this function.\n* @param nBytes The number of bytes in the WKB data. If this parameter is set to zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt.\n*\n* @return An OGRErr value indicating whether the creation was successful or not. If the creation was successful, the returned geometry object will be stored in phGeometry.\n*/\nOGRErr CPL_DLL OGR_G_CreateFromWkb( unsigned char *pabyData,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void OGR_GFld_SetNullable( OGRGeomFieldDefnH hDefn, int bNullableIn )\n{\n    ((OGRGeomFieldDefn *) hDefn)->SetNullable( bNullableIn );\n}\n",
        "answer": "/** @brief Sets the nullability of an OGR geometry field definition.\n*\n*  This method sets whether a geometry field can be null or not. By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint. Drivers that support writing not-null constraint will advertize the GDAL_DCAP_NOTNULL_GEOMFIELDS driver metadata item.\n*\n* @param hDefn The handle of the geometry field definition to modify.\n* @param bNullableIn Whether the field should be nullable or not.\n*/\nvoid OGR_GFld_SetNullable( OGRGeomFieldDefnH hDefn, int bNullableIn )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OGRErr OGR_L_Update( OGRLayerH pLayerInput,\n                     OGRLayerH pLayerMethod,\n                     OGRLayerH pLayerResult,\n                     char** papszOptions,\n                     GDALProgressFunc pfnProgress,\n                     void * pProgressArg )\n\n{\n    VALIDATE_POINTER1( pLayerInput, \"OGR_L_Update\", OGRERR_INVALID_HANDLE );\n    VALIDATE_POINTER1( pLayerMethod, \"OGR_L_Update\", OGRERR_INVALID_HANDLE );\n    VALIDATE_POINTER1( pLayerResult, \"OGR_L_Update\", OGRERR_INVALID_HANDLE );\n\n    return ((OGRLayer *)pLayerInput)->Update( (OGRLayer *)pLayerMethod, (OGRLayer *)pLayerResult, papszOptions, pfnProgress, pProgressArg );\n}\n",
        "answer": "/**\n* @brief Updates features in a layer based on features in another layer.\n*\n* This function updates features in the result layer (pLayerResult) based on\n* features in the input layer (pLayerInput) and the method layer (pLayerMethod).\n* The result layer contains features whose geometries represent areas that are\n* either in the input layer or in the method layer. The features in the result\n* layer have areas of the features of the method layer or those ares of the\n* features of the input layer that are not covered by the method layer. The\n* features of the result layer get their attributes from the input layer. The\n* schema of the result layer can be set by the user or, if it is empty, is\n* initialized to contain all fields in the input layer.\n*\n* @param pLayerInput The input layer.\n* @param pLayerMethod The method layer.\n* @param pLayerResult The result layer.\n* @param papszOptions NULL-terminated list of options.\n* @param pfnProgress Progress callback function.\n* @param pProgressArg Callback argument for progress function.\n*\n* @return OGRERR_NONE if successful, or an error code if not.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual Input::ReadStatus readFrame(mtime_t& date, unsigned char* /* dst */) {\n    date = readFrameStatus;\n    return Status{Origin::Input, ErrType::RuntimeError, std::to_string(readFrameStatus++)};\n  }\n",
        "answer": "/** @brief Read a frame into videoFrame and advance to the next frame. Optionally read an audio packet synchronized with this frame. It is the Reader's job to ensure correct synchronization.\n*\n* This function reads a frame into videoFrame and advances to the next frame. Optionally, it also reads an audio packet synchronized with this frame. The Reader's job is to ensure correct synchronization.\n*\n* @param date The date of the current frame.\n* @param dst The destination buffer for the read frame.\n*\n* @return The status of the read operation.\n*/\nvirtual Input::ReadStatus readFrame(mtime_t& date, unsigned char* /* dst */) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void action(const gcn::ActionEvent& actionEvent)\n    {\n       char tmp[MAX_PATH];\n       strncpy(tmp, txtCurrent->getText().c_str(), MAX_PATH - 1);\n       checkfoldername(tmp);\n    }\n",
        "answer": "/** @brief Action event handler.\n*\n*  This function is called when an action event is received from a widget. It is used to receive notification that an action has occurred.\n*\n* @param[in] actionEvent The action event object containing information about the action that was performed.\n*/\nvoid action(const gcn::ActionEvent& actionEvent)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT int STDCALL FPDFAvail_GetFirstPageNum(FPDF_DOCUMENT doc) {\n  CPDF_Document* pDoc = CPDFDocumentFromFPDFDocument(doc);\n  return pDoc ? pDoc->GetParser()->GetFirstPageNo() : 0;\n}\n",
        "answer": "/** @brief Get page number for the first available page in a linearized PDF.\n*\n*  This function returns the zero-based index of the first available page in a linearized PDF.\n*  For most linearized PDFs, the first available page would be just the first page, however, some PDFs might make other pages to be the first available page.\n*  For non-linearized PDFs, this function will always return zero.\n*\n* @param doc A document handle returned by FPDFAvail_GetDocument.\n* @return Zero-based index for the first available page.\n*/\nDLLEXPORT int STDCALL FPDFAvail_GetFirstPageNum(FPDF_DOCUMENT doc) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT void STDCALL FPDF_SetSystemFontInfo(FPDF_SYSFONTINFO* pFontInfoExt) {\n  if (pFontInfoExt->version != 1)\n    return;\n\n  CFX_GEModule::Get()->GetFontMgr()->SetSystemFontInfo(\n      new CFX_ExternalFontInfo(pFontInfoExt));\n}\n",
        "answer": "/**\n* @brief Set the system font info interface into Foxit SDK.\n*\n* Platform support implementation should implement required methods of FFDF_SYSFONTINFO interface, then call this function during SDK initialization process.\n*\n* @param[in] pFontInfo - Pointer to a FPDF_SYSFONTINFO structure\n* @return None\n*/\nDLLEXPORT void STDCALL FPDF_SetSystemFontInfo(FPDF_SYSFONTINFO* pFontInfoExt);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT FPDF_BOOL STDCALL FORM_OnLButtonDown(FPDF_FORMHANDLE hHandle,\n                                               FPDF_PAGE page,\n                                               int modifier,\n                                               double page_x,\n                                               double page_y) {\n  CPDFSDK_PageView* pPageView = FormHandleToPageView(hHandle, page);\n  if (!pPageView)\n    return FALSE;\n\n  CPDF_Point pt((FX_FLOAT)page_x, (FX_FLOAT)page_y);\n  return pPageView->OnLButtonDown(pt, modifier);\n}\n",
        "answer": "/** @brief FORM_OnLButtonDown is a member function that can be called when the user presses the left mouse button.\n*\n*  This function takes in a handle to the form fill module, a handle to the page, an indicator of whether various virtual keys are down, and the x-coordinate and y-coordinate of the cursor in PDF user space. It returns TRUE if successful; otherwise, it returns false.\n*\n* @param hHandle - Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.\n* @param page - Handle to the page. Returned by FPDF_LoadPage function.\n* @param modifier - Indicates whether various virtual keys are down.\n* @param page_x - Specifies the x-coordinate of the cursor in PDF user space.\n* @param page_y - Specifies the y-coordinate of the cursor in PDF user space.\n* @return TRUE indicates success; otherwise false.\n*/\nDLLEXPORT FPDF_BOOL STDCALL FORM_OnLButtonDown(FPDF_FORMHANDLE hHandle,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT void STDCALL FPDF_Widget_Redo(FPDF_DOCUMENT document,\n                                        FPDF_WIDGET hWidget) {\n  if (NULL == hWidget || NULL == document)\n    return;\n\n  CPDFXFA_Document* pDocument = (CPDFXFA_Document*)document;\n  if (pDocument->GetDocType() != XFA_DOCTYPE_Dynamic &&\n      pDocument->GetDocType() != XFA_DOCTYPE_Static)\n    return;\n\n  IXFA_MenuHandler* pXFAMenuHander =\n      CPDFXFA_App::GetInstance()->GetXFAApp()->GetMenuHandler();\n  if (pXFAMenuHander == NULL)\n    return;\n\n  pXFAMenuHander->Redo((IXFA_Widget*)hWidget);\n}\n",
        "answer": "/**\n* @brief Implements the redo feature for a specified XFA field.\n*\n* This method will implement the redo feature for the specified xfa field.\n*\n* @param[in] document Handle to document. Returned by FPDF_LoadDocument function.\n* @param[in] hWidget  Handle to the xfa field. Returned by FPDF_GetXFAField function.\n*\n* @return None.\n*/\nDLLEXPORT void STDCALL FPDF_Widget_Redo(FPDF_DOCUMENT document, FPDF_WIDGET hWidget);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLEXPORT void STDCALL FPDF_SetFormFieldHighlightAlpha(FPDF_FORMHANDLE hHandle,\n                                                       unsigned char alpha) {\n  if (CPDFSDK_InterForm* pInterForm = FormHandleToInterForm(hHandle))\n    pInterForm->SetHighlightAlpha(alpha);\n}\n",
        "answer": "/** @brief Set the transparency of the form field highlight color in the document.\n*\n*  This function sets the transparency of the form field highlight color in the document.\n*\n* @param hHandle - Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.\n* @param doc - Handle to the document. Returned by FPDF_LoadDocument function.\n* @param alpha - The transparency of the form field highlight color. between 0-255.\n*\n* @return NONE.\n*/\nDLLEXPORT void STDCALL FPDF_SetFormFieldHighlightAlpha(FPDF_FORMHANDLE hHandle, unsigned char alpha) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvoid set(size_t i, size_t j, _T value) {\n\t\t\tif (i <= j) {\n\t\t\t\tdata[calcIndex(i, j)] = value;\n\t\t\t}\n\t\t}\n",
        "answer": "/** @brief Set an entry of the matrix to the given value.\n*\n*  Attempts to set a value in the lower triangle with i > j are ignored.\n*\n* @param[in] i Row index of the entry to be set.\n* @param[in] j Column index of the entry to be set.\n* @param[in] value Value to be set at the specified entry.\n*/\nvoid set(size_t i, size_t j, _T value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "HRESULT resourceAllocMapMemory(ResourceAllocator* allocator, ResourceAllocation* allocation, void** ppData)\n{\n\tASSERT(allocator && allocation && ppData);\n\n\tRESOURCE_DEBUG_GLOBAL_MUTEX_LOCK\n\n\tif (allocation->GetResource())\n\t\treturn allocation->GetResource()->Map(0, NULL, ppData);\n\n\treturn S_FALSE;\n}\n",
        "answer": "/** @brief Maps memory for a resource.\n*\n*  This function maps memory for a resource. It is used to map the memory of a resource that has been created using the resource allocator.\n*\n* @param allocator The resource allocator object.\n* @param allocation The resource allocation object.\n* @param ppData A pointer to a void* that will receive the mapped memory address.\n*\n* @return S_OK if successful, E_INVALIDARG if the parameters are invalid, or E_FAIL if an error occurred while mapping the memory.\n*/\nASSERT(allocator && allocation && ppData);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)\r\n{\r\n  if (!a_pins_local_ptr->interface_is_interrupt)\r\n  {\r\n    m_aci_event_check();\r\n  }\r\n\r\n  if (aci_queue_peek(&aci_rx_q, p_aci_data))\r\n  {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Peeks an event from the ACI event queue.\n*\n* This function is called by lib_aci_event_peek to peek an event from the ACI event queue.\n* It first checks if the interface is interrupt-driven, and if not, it calls m_aci_event_check() to check for any pending events.\n* If there are no pending events, it returns false. Otherwise, it dequeues the next event from the aci_rx_q queue and stores it in p_aci_data.\n* @param[in] p_aci_data Pointer to an ACI data structure where the peeked event will be stored.\n* @return True if there was an event to peek, false otherwise.\n*/\nbool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline void buffer_line_to_destination(const float fr_mm_s) {\n  planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);\n}\n",
        "answer": "/** @brief Move the planner to the position stored in the destination array.\n*\n*  This function moves the planner to the position stored in the destination array, which is used by G0/G1/G2/G3/G5 and many other functions to set a destination.\n*\n* @param fr_mm_s The feedrate of the move in mm/s.\n* @return void\n*/\nvoid buffer_line_to_destination(const float fr_mm_s) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M208() {\n    if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);\n    if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));\n    if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));\n    if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);\n  }\n",
        "answer": "/** @brief Set firmware un-retraction values S[+units] retract_recover_length (in addition to M207 S*) W[+units] swap_retract_recover_length (multi-extruder) F[units/min] retract_recover_feedrate_mm_s R[units/min] swap_retract_recover_feedrate_mm_s\n*  This function sets the firmware un-retraction values for S, W, F, and R.\n*\n* @param parser The GCode parser object.\n* @return void\n*/\ninline void gcode_M208() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int parseInt(const char *errmsg, const char *arg) {\n\tlong l;\n\tchar *endPtr = NULL;\n\tl = strtol(arg, &endPtr, 10);\n\tif (endPtr != NULL) {\n\t\treturn (int32_t)l;\n\t}\n\tcerr << errmsg << endl;\n\tthrow 1;\n\treturn -1;\n}\n",
        "answer": "/** @brief Parse an int out of optarg and enforce that it be at least 'lower'; if it is less than 'lower', than output the given error message and exit with an error and a usage message.\n*\n*  This function parses an integer from the command line argument using strtol() and checks if it is greater than or equal to the lower bound. If it is not, it outputs an error message and exits with an error code.\n*\n* @param errmsg The error message to output if the parsed integer is less than the lower bound.\n* @param arg The command line argument to parse as an integer.\n* @return The parsed integer if it is greater than or equal to the lower bound, otherwise exits with an error code.\n*/\nstatic int parseInt(const char *errmsg, const char *arg) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static T parseNumber(T lower, const char *errmsg) {\n\tchar *endPtr= NULL;\n\tT t = (T)strtoll(optarg, &endPtr, 10);\n\tif (endPtr != NULL) {\n\t\tif (t < lower) {\n\t\t\tcerr << errmsg << endl;\n\t\t\tprintUsage(cerr);\n\t\t\tthrow 1;\n\t\t}\n\t\treturn t;\n\t}\n\tcerr << errmsg << endl;\n\tprintUsage(cerr);\n\tthrow 1;\n\treturn -1;\n}\n",
        "answer": "/** @brief Parse an int out of optarg and enforce that it be at least 'lower'; if it is less than 'lower', then output the given error message and exit with an error and a usage message.\n*\n*  This function parses an integer from the command line argument using strtoll, and enforces that it be at least a certain value (lower). If the parsed value is less than lower, then it outputs an error message and exits with an error and a usage message.\n*\n* @param lower The minimum allowed value for the parsed integer.\n* @param errmsg The error message to output if the parsed value is less than lower.\n* @return The parsed integer, or -1 if there was an error parsing the integer.\n*/\nstatic int parseNumber(int lower, const char *errmsg) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void initResources()\n{\n  Q_INIT_RESOURCE(QtPDF_trans);\n  Q_INIT_RESOURCE(QtPDF_icons);\n}\n",
        "answer": "/** @brief Initializes resources for the application.\n*\n*  This function initializes the resources required by the application, such as\n*  translations and icons.\n*\n* @return void\n*/\nstatic void initResources()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool GOUse_go_defias_cannon(Player* /*pPlayer*/, GameObject* pGo)\n{\n    ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData();\n\n    if (!pInstance)\n        return false;\n\n    if (pInstance->GetData(TYPE_IRON_CLAD_DOOR) == DONE)\n        return false;\n\n    pInstance->SetData(TYPE_IRON_CLAD_DOOR, DONE);\n    return false;\n}\n",
        "answer": "/**\n* @brief GOUse_go_defias_cannon\n*\n* This function is used to handle the use of a game object that triggers the Defias Cannon.\n*\n* @param pPlayer The player who triggered the game object.\n* @param pGo The game object that was triggered.\n*\n* @return true if the cannon was successfully triggered, false otherwise.\n*/\nbool GOUse_go_defias_cannon(Player* /*pPlayer*/, GameObject* pGo)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double rand_norm(void)\n{\n    return mtRand->randExc();\n}\n",
        "answer": "/** @brief Generates a random number between 0 and 1 using the Mersenne Twister algorithm.\n*\n* This function uses the Mersenne Twister algorithm to generate a random number between 0 and 1.\n* The Mersenne Twister is a widely used algorithm for generating pseudorandom numbers, and it has\n* a period of 2^19937-1.\n*\n* @return A double value between 0 and 1 representing the random number generated by the Mersenne Twister algorithm.\n*/\ndouble rand_norm(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "VX_API_ENTRY vx_status VX_API_CALL vxSetReferenceName(vx_reference ref, const vx_char *name)\n{\n\tvx_status status = VX_ERROR_INVALID_REFERENCE;\n\tif (agoIsValidReference(ref) && ((ref->type >= VX_TYPE_DELAY && ref->type <= VX_TYPE_REMAP) || \n\t\t(ref->type == VX_TYPE_TENSOR) ||\n\t\t(ref->type >= VX_TYPE_VENDOR_OBJECT_START && ref->type <= VX_TYPE_VENDOR_OBJECT_END)))\n\t{\n\t\tAgoData * data = (AgoData *)ref;\n\t\tdata->name = name;\n\t\tstatus = VX_SUCCESS;\n\t}\n\treturn status;\n}\n",
        "answer": "/** @brief Sets the name of a reference.\n*\n*  This function sets the name of a reference in OpenVX. The name must be unique within the scope of the context or graph that contains the reference.\n*\n* @param ref The reference to set the name for.\n* @param name The new name for the reference.\n*\n* @return VX_SUCCESS if the name was set successfully, VX_ERROR_INVALID_REFERENCE if the reference is not valid, or VX_ERROR_INVALID_NAME if the name is not unique within the scope of the context or graph.\n*/\nVX_API_ENTRY vx_status VX_API_CALL vxSetReferenceName(vx_reference ref, const vx_char *name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)\r\n{\r\n#ifdef HAL_ACI_TL_INTERRUPT\r\n  if (!a_pins_local_ptr->interface_is_interrupt)\r\n#endif\r\n  {\r\n    m_aci_event_check();\r\n  }\r\n\r\n  if (aci_queue_peek(&aci_rx_q, p_aci_data))\r\n  {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n",
        "answer": "/** @brief Peeks an event from the ACI event queue.\n*\n* This function is called by lib_aci_event_peek to peek an event from the ACI event queue.\n* It first checks if the interface is interrupt-driven, and if not, it calls m_aci_event_check() to check for events.\n* If there are any events in the aci_rx_q, it returns true and sets p_aci_data to point to the event data.\n* Otherwise, it returns false.\n*\n* @param[out] p_aci_data Pointer to the ACI data structure that will be filled with the peeked event data.\n* @return True if there is an event in the queue, false otherwise.\n*/\nbool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool qFuzzyCompare(const CVector3d &v1, const CVector3d &v2)\n{\n    for (size_t i = 0; i < 3; i++)\n        if (fabs(v1[i] - v2[i]) > EPS)\n            return false;\n    return true;\n}\n",
        "answer": "/** @brief qFuzzyCompare function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param v1 The first vector to compare.\n* @param v2 The second vector to compare.\n* @return true if v1 and v2 are equal, allowing for a small fuzziness factor for floating-point comparisons; false otherwise.\n*/\nbool qFuzzyCompare(const CVector3d &v1, const CVector3d &v2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void corsCallback(HTTPRequest * req, HTTPResponse * res) {\n\tres->setHeader(\"Access-Control-Allow-Methods\", \"HEAD,GET,POST,DELETE,PUT,OPTIONS\");\n\tres->setHeader(\"Access-Control-Allow-Origin\",  \"*\");\n\tres->setHeader(\"Access-Control-Allow-Headers\", \"*\");\n}\n",
        "answer": "/**\n* @brief CORS callback.\n*\n* This callback is configured to match all OPTIONS requests (see pattern configuration below)\n* This allows to define headers there that are required to allow cross-domain-xhr-requests, which enabled a REST-API that can be used on the esp32, while the WebInterface is hosted somewhere else (on a host with more storage space to provide huge JS libraries etc.) An example use case would be an IoT dashboard that connects to a bunch of local esp32s, which provide data via their REST-interfaces that is aggregated in the dashboard.\n*\n* @param req The HTTP request object.\n* @param res The HTTP response object.\n*/\nvoid corsCallback(HTTPRequest *req, HTTPResponse *res) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int LineIsUnclippedOnSameSide(int code1, int code2)\n{\n\treturn code1 & code2;\n}\n",
        "answer": "/** @brief Checks if a line is unclipped on the same side outside of the clip rectangle.\n*\n*  This function checks if two points on a line are both located at the same side (left, right, above, or below)\n*  outside of the clip rectangle.\n*\n* @param code1 The clipping code for the first point on the line.\n* @param code2 The clipping code for the second point on the line.\n* @return True if the line is unclipped on the same side outside of the clip rectangle, false otherwise.\n*/\nstatic int LineIsUnclippedOnSameSide(int code1, int code2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CleanGame()\n{\n\tEndReplayLog();\n\tCleanMessages();\n\n\tCleanGame_Lua();\n\tCleanTriggers();\n\tCleanAi();\n\tCleanGroups();\n\tCleanMissiles();\n\tCleanUnits();\n\tCleanSelections();\n\tCleanTilesets();\n\tMap.Clean();\n\tCleanReplayLog();\n\tFreePathfinder();\n\tCursorBuilding = NULL;\n\tUnitUnderCursor = NULL;\n}\n",
        "answer": "/** @brief Cleanup game. Call each module to clean up. Contrary to CleanModules, maps can be restarted without reloading all lua files.\n*\n*  This function cleans up the game by calling each module's cleanup function. It is used when the game needs to be restarted without reloading all Lua files.\n*\n* @return Should not return\n*/\nvoid CleanGame()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void NetworkSendExtendedCommand(int command, int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\tint arg4, int status)\n{\n\tCNetworkCommandQueue *ncq = AllocNCQ();\n\tCommandsIn.push_back(ncq);\n\n\tncq->Time = GameCycle;\n\tCNetworkExtendedCommand *nec = (CNetworkExtendedCommand *)&ncq->Data;\n\n\tncq->Type = MessageExtendedCommand;\n\tif (status) {\n\t\tncq->Type |= 0x80;\n\t}\n\tnec->ExtendedType = command;\n\tnec->Arg1 = arg1;\n\tnec->Arg2 = htons(arg2);\n\tnec->Arg3 = htons(arg3);\n\tnec->Arg4 = htons(arg4);\n}\n",
        "answer": "/** @brief Prepare send of extended command message. Convert arguments into network format and place it into output queue.\n*\n*  This function prepares the sending of an extended command message by converting the arguments into network format and placing them into the output queue.\n*\n* @param[in] command The extended command to be sent.\n* @param[in] arg1 The first argument for the extended command.\n* @param[in] arg2 The second argument for the extended command.\n* @param[in] arg3 The third argument for the extended command.\n* @param[in] arg4 The fourth argument for the extended command.\n* @param[in] status The status of the extended command.\n*\n* @return None.\n*/\nvoid NetworkSendExtendedCommand(int command, int arg1, int arg2, int arg3,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int CclAiDebugPlayer(lua_State *l)\n{\n\tconst int args = lua_gettop(l);\n\tfor (int j = 0; j < args; ++j) {\n\t\tconst char *item;\n\n\t\tif (lua_isstring(l, j + 1)) {\n\t\t\titem = LuaToString(l, j + 1);\n\t\t} else {\n\t\t\titem = NULL;\n\t\t}\n\t\tif (item && !strcmp(item, \"none\")) {\n\t\t\tfor (int i = 0; i != NumPlayers; ++i) {\n\t\t\t\tif (!Players[i].AiEnabled || !Players[i].Ai) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPlayers[i].Ai->ScriptDebug = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint playerid;\n\t\t\tif (item && !strcmp(item, \"self\")) {\n\t\t\t\tif (!ThisPlayer) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tplayerid = ThisPlayer->Index;\n\t\t\t} else {\n\t\t\t\tplayerid = LuaToNumber(l, j + 1);\n\t\t\t}\n\n\t\t\tif (!Players[playerid].AiEnabled || !Players[playerid].Ai) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPlayers[playerid].Ai->ScriptDebug = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Enables or disables AI debugging for the given player(s).\n*\n*  This function enables or disables AI debugging for the specified player(s) based on the input parameters.\n*  If \"none\" is passed as an argument, it will disable AI debugging for all players.\n*  If \"self\" is passed as an argument, it will enable AI debugging for the current human player (if any).\n*  Otherwise, it will enable AI debugging for the specified player(s) by their index.\n*\n* @param lua_State *l The Lua state pointer.\n* @return int 0 if successful, non-zero otherwise.\n*/\nstatic int CclAiDebugPlayer(lua_State *l)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void MapSound(const std::string &name, CSound *id)\n{\n\tif (!id) {\n\t\tDebugPrint(\"Null Sound for %s is not acceptable by sound table\\n\" _C_ name.c_str());\n\t\treturn;\n\t}\n\tid->Mapref++;\n\tSoundMap[name] = id;\n}\n",
        "answer": "/** @brief Maps a sound to an ID in the hash table.\n*\n*  This function creates a new mapping between a sound name and an already valid sound ID.\n*\n* @param name The name of the sound to be mapped.\n* @param id The ID of the sound to be mapped.\n* @return void\n*/\nvoid MapSound(const std::string &name, CSound *id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void SetViewportModeSplitVert()\n{\n\tCViewport new_vps[MAX_NUM_VIEWPORTS];\n\n\tDebugPrint(\"Two vertical viewports set\\n\");\n\n\tnew_vps[0].TopLeftPos.x = UI.MapArea.X;\n\tnew_vps[0].TopLeftPos.y = UI.MapArea.Y;\n\tClipViewport(new_vps[0],\n\t\t\t\t UI.MapArea.X + (UI.MapArea.EndX - UI.MapArea.X + 1) / 2,\n\t\t\t\t UI.MapArea.EndY);\n\n\tnew_vps[1].TopLeftPos.x = new_vps[0].BottomRightPos.x + 1;\n\tnew_vps[1].TopLeftPos.y = UI.MapArea.Y;\n\tClipViewport(new_vps[1], UI.MapArea.EndX, UI.MapArea.EndY);\n\n\tFinishViewportModeConfiguration(new_vps, 2);\n}\n",
        "answer": "/** @brief Sets the viewport mode to split vertically.\n*\n* This function sets the viewport mode to split vertically and computes the viewport parameters for each part of the screen.\n*\n* @param new_vps An array of CViewport objects that will be used to store the viewport parameters.\n* @param UI The UI object that contains information about the map area.\n* @return void\n*/\nvoid SetViewportModeSplitVert(CViewport new_vps[MAX_NUM_VIEWPORTS], UI)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void minisketch_add_uint64(minisketch* sketch, uint64_t element) {\n    Sketch* s = (Sketch*)sketch;\n    s->Check();\n    s->Add(element);\n}\n",
        "answer": "/** @brief Add an element to a sketch.\n*\n*  This function adds an element to a sketch, if the element is not equal to 0 (after potentially dropping the most significant bits), then this function is a no-op. Sketches cannot contain an element with the value 0.\n*\n* @param[in] sketch The sketch to add the element to.\n* @param[in] element The element to be added.\n* @return void\n*/\nvoid minisketch_add_uint64(minisketch* sketch, uint64_t element) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n{\n    const char* pszTimestamp = \"Sep 29, 2018 LockTrip Publishes its own Blockchain Manifest  And it is Amazing\";\n     const CScript genesisOutputScript = CScript() << ParseHex(\"033a537fcd935fba9f532ef78bb97154b5ea7b8dfd8b74facc36f7193e9d5b1cab\") << OP_CHECKSIG;\n\n    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n}\n",
        "answer": "/** @brief Build the genesis block.\n*\n*  This function creates the genesis block for the blockchain. The output of its generation transaction cannot be spent since it did not originally exist in the database.\n*\n* @param nTime The timestamp for the block.\n* @param nNonce A random value used to satisfy the proof-of-work requirement.\n* @param nBits The target difficulty for the block.\n* @param nVersion The version number of the block.\n* @param genesisReward The reward for the generation transaction.\n*\n* @return The genesis block.\n*/\nstatic CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tinline static void internal_loadFromRangeScan2D_postPushBack(\n\t\tCPointsMapXYZI& me,\n\t\tmrpt::maps::CPointsMap::TLaserRange2DInsertContext& lric)\n\t{\n\t\tfloat pI = 1.0f;\n\t\tme.m_intensity.push_back(pI);\n\t}\n",
        "answer": "/** @brief Helper method for the generic implementation of CPointsMap::loadFromRangeScan(), to be called after each \"{x,y,z}.push_back(...);\"\n*\n* This is a helper function for the generic implementation of CPointsMap::loadFromRangeScan(). It should be called after each \"{x,y,z}.push_back(...);\" statement in the loadFromRangeScan() method.\n*\n* @param me The CPointsMapXYZI object that is being loaded from a range scan.\n* @param lric The TLaserRange2DInsertContext object that contains information about the current range scan.\n*/\ninline static void internal_loadFromRangeScan2D_postPushBack("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tinline static void internal_loadFromRangeScan2D_prepareOneRange(\n\t\tCSimplePointsMap& me, const float gx, const float gy, const float gz,\n\t\tmrpt::maps::CPointsMap::TLaserRange2DInsertContext& lric)\n\t{\n\t\tMRPT_UNUSED_PARAM(me);\n\t\tMRPT_UNUSED_PARAM(gx);\n\t\tMRPT_UNUSED_PARAM(gy);\n\t\tMRPT_UNUSED_PARAM(gz);\n\t\tMRPT_UNUSED_PARAM(lric);\n\t}\n",
        "answer": "/** @brief Helper method for the generic implementation of CPointsMap::loadFromRangeScan(), to be called once per range data.\n*\n* This function is used to prepare one range for the loadFromRangeScan() method. It takes in the current object, gx, gy, and gz as parameters, and a TLaserRange2DInsertContext object as lric.\n*\n* @param me The current object.\n* @param gx The x-coordinate of the range.\n* @param gy The y-coordinate of the range.\n* @param gz The z-coordinate of the range.\n* @param lric A TLaserRange2DInsertContext object containing information about the range data.\n*/\ninline static void internal_loadFromRangeScan2D_prepareOneRange("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tinline static void internal_loadFromRangeScan3D_postOneRange(\n\t\tCSimplePointsMap& me,\n\t\tmrpt::maps::CPointsMap::TLaserRange3DInsertContext& lric)\n\t{\n\t\tMRPT_UNUSED_PARAM(me);\n\t\tMRPT_UNUSED_PARAM(lric);\n\t}\n",
        "answer": "/** @brief Helper method for the generic implementation of CPointsMap::loadFromRangeScan(), to be called once per range data, at the end.\n*\n* This function is an inline static member function of CSimplePointsMap that helps with the implementation of loadFromRangeScan() for 3D points maps. It should be called once per range data, at the end.\n*\n* @param me The CSimplePointsMap object.\n* @param lric The TLaserRange3DInsertContext object.\n*/\nvoid internal_loadFromRangeScan3D_postOneRange(CSimplePointsMap& me, mrpt::maps::CPointsMap::TLaserRange3DInsertContext& lric)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tinline static void internal_loadFromRangeScan3D_prepareOneRange(\n\t\tCWeightedPointsMap& me, const float gx, const float gy, const float gz,\n\t\tmrpt::maps::CPointsMap::TLaserRange3DInsertContext& lric)\n\t{\n\t\tMRPT_UNUSED_PARAM(me);\n\t\tMRPT_UNUSED_PARAM(gx);\n\t\tMRPT_UNUSED_PARAM(gy);\n\t\tMRPT_UNUSED_PARAM(gz);\n\t\tMRPT_UNUSED_PARAM(lric);\n\t}\n",
        "answer": "/** @brief Helper method for the generic implementation of CPointsMap::loadFromRangeScan(), to be called once per range data.\n*\n* This function is used to prepare one range data for insertion into a 3D points map. It takes the current point cloud, the grid coordinates of the point, and the laser range finder return information as input, and updates the point cloud with the new point if it is valid.\n*\n* @param[in] me The current point cloud.\n* @param[in] gx The x-coordinate of the grid cell containing the point.\n* @param[in] gy The y-coordinate of the grid cell containing the point.\n* @param[in] gz The z-coordinate of the grid cell containing the point.\n* @param[in] lric The laser range finder return information for the current point.\n*/\ninline static void internal_loadFromRangeScan3D_prepareOneRange("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long safeConvert(const int64_t num) {\n    assert(num <= INT_MAX && num >= INT_MIN);\n    return (long)num;\n}\n",
        "answer": "/** @brief Safely converts 64-bit types to 32-bit.\n*\n* This function safely converts 64-bit types to 32-bit, or from unsigned to signed.\n* It checks if the input number is within the range of a 32-bit integer and returns an error if it is not.\n*\n* @param num The input number to be converted.\n* @return The converted number, or an error code if the input number is out of range.\n*/\nlong safeConvert(const int64_t num) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool as_waksman_get_top_bottom_decision_from_switch_setting(const size_t row_offset, const size_t packet_idx, const bool switch_setting)\n{\n    const size_t row_idx = as_waksman_get_canonical_row_idx(row_offset, packet_idx);\n    return (row_idx == packet_idx) ^ switch_setting;\n}\n",
        "answer": "/** @brief Returns the top or bottom decision from a switch setting.\n*\n*  This function returns true if the switch with input port at (column_idx, row_idx) when set to \"straight\" (if top = true), resp., \"cross\" (if top = false), routes the packet at (column_idx, row_idx) via the top subnetwork.\n*\n* @param[in] row_offset The offset of the row in the network.\n* @param[in] packet_idx The index of the packet in the network.\n* @param[in] switch_setting The setting of the switch.\n* @return True if the top subnetwork is used, false otherwise.\n*/\nbool as_waksman_get_top_bottom_decision_from_switch_setting(const size_t row_offset, const size_t packet_idx, const bool switch_setting)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "size_t benes_packet_cross_source(const size_t dimension, const size_t column_idx, const size_t packet_idx)\n{\n    return benes_packet_cross_destination(dimension, column_idx-1, packet_idx); /* by symmetry */\n}\n",
        "answer": "/** @brief Returns the row index of the \"cross\" source packet for a given packet and column in the Benes network.\n*\n*  This function is used to determine the source of a packet in the Benes network, where each packet has two possible sources.\n*  The function returns the row index of the \"cross\" source packet, which is determined by the symmetry of the Benes network.\n*\n* @param dimension The number of rows and columns in the Benes network.\n* @param column_idx The column index of the packet.\n* @param packet_idx The packet index.\n*\n* @return The row index of the \"cross\" source packet.\n*/\nsize_t benes_packet_cross_source(const size_t dimension, const size_t column_idx, const size_t packet_idx)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid connectionCreated(Stream* stream)\n\t{\n\t\tcout << \"+ Incoming connection from \" << stream->getTargetName() << \" (\" << stream << \")\" << endl;\n\t\tstring nick = readLine(stream);\n\t\tnick.erase(nick.length() - 1);\n\t\tnicks[stream] = nick;\n\t\tcout << \"+ User \" << nick << \" is connected.\" << endl;\n\t}\n",
        "answer": "/** @brief Called when any data connection is created.\n*\n*  This function is called when any data connection is created, but not when a listening connection (eg tcpin:) is created. If the stream is closed during this method, an exception occurs: the caller is responsible to handle it. The stream is already inserted in the stream list when this function is called. Subclass can implement this method. Called with the stream lock held.\n*\n* @param stream The stream that was created.\n*/\nvoid connectionCreated(Stream* stream)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid connectionClosed(Stream* stream, bool abnormal)\n\t{\n\t\tcout << \"Closed connection \" << stream->getTargetName() << \" (\" << stream << \")\";\n\t\tif (abnormal)\n\t\t\tcout << \" : \" << stream->getFailReason();\n\t\tcout << endl;\n\t\tstop();\n\t}\n",
        "answer": "/** @brief Called when target closes connection. The only valid method to call on the stream is getTargetName(), input/output operations are forbidden. You must not call closeStream(stream) from within this method for the same stream as the one passed as parameter. Subclass can implement this method. Called with the stream lock held.\n*  @param stream The stream that was closed.\n*  @param abnormal Whether the connection was closed abnormally.\n*/\nvoid connectionClosed(Stream* stream, bool abnormal)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void connectionClosed(Stream* stream, bool abnormal)\n\t{\n\t\tconnected = false;\n\t\tcout << endl\n\t\t\t << \"Lost connection to \" << stream->getTargetName();\n\t\tif (abnormal)\n\t\t\tcout << \" : \" << stream->getFailReason();\n\t\tcout << endl;\n\t}\n",
        "answer": "/** @brief Called when target closes connection.\n*\n*  This method is called when the target closes the connection. The only valid method to call on the stream is getTargetName(), input/output operations are forbidden. You must not call closeStream(stream) from within this method for the same stream as the one passed as parameter. Subclass can implement this method. Called with the stream lock held.\n*\n* @param stream The stream that was closed.\n* @param abnormal True if the connection was closed abnormally, false otherwise.\n*/\nvoid connectionClosed(Stream* stream, bool abnormal)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual bool receiveDataAndCheckDisconnection()\n\t\t{\n\t\t\tselectWasCalled = true;\n\t\t\treturn false;\n\t\t}\n",
        "answer": "/** @brief Receive data and check for disconnection.\n*\n*  This function receives data from a socket and checks if the connection is still active.\n*\n* @return True if the connection is disconnected, false otherwise.\n*/\nvirtual bool receiveDataAndCheckDisconnection()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int register_event_handler(\n        const async_msg_t::event_code_t event_code, async_handler_type handler)\n    {\n        _event_handlers.insert(std::pair<async_msg_t::event_code_t, async_handler_type>(\n            event_code, handler));\n        return _event_handlers.count(event_code);\n    }\n",
        "answer": "/** @brief Register an event handler. Multiple handlers per event code may be registered. The order they are called in is non-deterministic.\n*\n*  This function registers an event handler for a given event code. Multiple handlers can be registered for the same event code, and the order in which they are called is non-deterministic.\n*\n* @param[in] event_code The event code to register the handler for.\n* @param[in] handler The event handler function.\n* @return The number of handlers registered for the given event code.\n*/\nint register_event_handler(const async_msg_t::event_code_t event_code, async_handler_type handler)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    double get_input_scale_factor(size_t port = ANY_PORT)\n    {\n        port = (port == ANY_PORT) ? 0 : port;\n        if (not(_tx_streamer_active.count(port) and _tx_streamer_active.at(port))) {\n            return SCALE_UNDEFINED;\n        }\n        return get_arg<double>(\"scalar_correction\", port);\n    }\n",
        "answer": "/**\n* @brief Returns the scaling factor for this block on input. A DUC block will return the scaling factor as determined by the duc stage.\n*\n* @param port The port number of the input to get the scale factor for (default is ANY_PORT)\n*\n* @return The scaling factor for the specified input, or SCALE_UNDEFINED if the block is not active on the specified port\n*/\ndouble get_input_scale_factor(size_t port = ANY_PORT);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    int submit(uint8_t request_type,\n        uint8_t request,\n        uint16_t value,\n        uint16_t index,\n        unsigned char* buff,\n        uint16_t length,\n        uint32_t libusb_timeout = 0)\n    {\n        boost::mutex::scoped_lock lock(_mutex);\n        return libusb_control_transfer(_handle->get(),\n            request_type,\n            request,\n            value,\n            index,\n            buff,\n            length,\n            libusb_timeout);\n    }\n",
        "answer": "/** @brief Submits a USB device request.\n*\n*  This function submits a USB device request and blocks until the request returns.\n*  The format and corresponding USB request fields can be found in the USB Specification Revision 2.0 - 9.3 USB Device Requests.\n*  Usage is device specific.\n*\n* @param request_type The type of USB request (e.g., standard, class, vendor).\n* @param request The specific USB request (e.g., GET_DESCRIPTOR, SET_CONFIGURATION).\n* @param value The wValue field of the USB request.\n* @param index The wIndex field of the USB request.\n* @param buff A pointer to a buffer for data associated with the request.\n* @param length The size of the buffer in bytes.\n* @param libusb_timeout The timeout for the request in milliseconds. If set to 0, the request will block indefinitely.\n* @return The result of the USB control transfer.\n*/\nint submit(uint8_t request_type,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void set_time_now(const time_spec_t &time_spec, size_t mboard){\n        if (mboard != ALL_MBOARDS){\n            _tree->access<time_spec_t>(mb_root(mboard) / \"time/now\").set(time_spec);\n            return;\n        }\n        for (size_t m = 0; m < get_num_mboards(); m++){\n            set_time_now(time_spec, m);\n        }\n    }\n",
        "answer": "/**\n* @brief Sets the time registers on the usrp immediately.\n*\n* If only one MIMO master is present in your configuration, set_time_now is safe to use because the slave's time automatically follows the master's time. Otherwise, this call cannot set the time synchronously across multiple devices. Please use the set_time_next_pps or set_time_unknown_pps calls with a PPS signal.\n*\n* @param time_spec The time to be set.\n* @param mboard The MIMO board to set the time on. If ALL_MBOARDS, sets the time on all boards.\n*/\nvoid set_time_now(const time_spec_t &time_spec, size_t mboard);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    size_t get_rx_num_channels(void){\n        size_t sum = 0;\n        for (size_t m = 0; m < get_num_mboards(); m++){\n            sum += get_rx_subdev_spec(m).size();\n        }\n        return sum;\n    }\n",
        "answer": "/**\n* @brief Get the number of RX channels in this configuration.\n*\n* This is the number of USRPs times the number of RX channels per board, where the number of RX channels per board is homogeneous among all USRPs.\n*\n* @return The number of RX channels in this configuration.\n*/\nsize_t get_rx_num_channels(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    double get_input_samp_rate(size_t)\n    {\n        return _samp_rate;\n    };\n",
        "answer": "/** @brief Returns the sampling rate this block expects at its input.\n*\n* This function returns the sampling rate that this block expects at its input. A radio will simply return the sampling rate it is set to. A decimating FIR filter will ask downstream for the input sampling rate and then return that value multiplied by the decimation factor.\n*\n* @param size_t The size of the input buffer.\n* @return double The sampling rate this block expects at its input.\n*/\ndouble get_input_samp_rate(size_t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void release(void)\n    {\n        _wsa_buff.len = size();\n        WSASend(_sock_fd, &_wsa_buff, 1, NULL, 0, &_overlapped, NULL);\n    }\n",
        "answer": "/**\n* @brief Releases the buffer to the transport object.\n*\n* This function should be called after using the buffer to release it to the transport object. After calling, the referenced memory should be considered invalid.\n*\n* @return Should not return\n*/\nvoid release(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uhd_error uhd_get_last_error(\n    char* error_out,\n    size_t strbuffer_len\n){\n    try{\n        auto error_str = get_c_global_error_string();\n        memset(error_out, '\\0', strbuffer_len);\n        strncpy(error_out, error_str.c_str(), strbuffer_len);\n    }\n    catch(...){\n        return UHD_ERROR_UNKNOWN;\n    }\n    return UHD_ERROR_NONE;\n}\n",
        "answer": "/**\n* @brief Get the last error message.\n*\n* This function retrieves the last error message that was generated by a UHD function.\n* If no error has occurred, the buffer will be filled with an empty string.\n*\n* @param[out] error_out A pointer to a character array where the error message will be stored.\n* @param[in] strbuffer_len The length of the character array pointed to by `error_out`.\n*\n* @return UHD_ERROR_NONE if no error occurred, or an appropriate error code otherwise.\n*/\nuhd_error uhd_get_last_error(char* error_out, size_t strbuffer_len);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uhd_error uhd_meta_range_make(\n    uhd_meta_range_handle* h\n){\n    UHD_SAFE_C(\n        (*h) = new uhd_meta_range_t;\n    )\n}\n",
        "answer": "/** @brief Creates a meta range handle.\n*\n*  This function creates a new meta range handle and initializes it to an empty state.\n*\n* @param h A pointer to the meta range handle to be created.\n* @return UHD_ERROR_NONE on success, or an error code on failure.\n*/\nuhd_error uhd_meta_range_make("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uhd_error uhd_rx_streamer_make(uhd_rx_streamer_handle* h){\n    UHD_SAFE_C(\n        boost::mutex::scoped_lock lock(_rx_streamer_make_mutex);\n        (*h) = new uhd_rx_streamer;\n    )\n}\n",
        "answer": "/**\n* @brief Creates a new UHD RX streamer.\n*\n* This function creates a new UHD RX streamer and returns it in the provided handle.\n* The streamer is not yet initialized, and must be initialized using `uhd_rx_streamer_init` before use.\n*\n* @param h A pointer to a handle that will receive the newly created streamer.\n* @return UHD error code (0 on success).\n*/\nuhd_error uhd_rx_streamer_make(uhd_rx_streamer_handle* h);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void real2complex(const real_t *real, long size, complex_t *complex) {\n    auto* iter = reinterpret_cast<std::complex<real_t>*>(complex);\n    edsp::real2complex(real, real + size, iter);\n}\n",
        "answer": "/** @brief Converts a range of scalar numbers in to an equivalent complex number and stores the result in another range.\n*\n*  This function converts a range of scalar numbers into an equivalent complex number and stores the result in another range.\n*\n* @param real A pointer to the first element of the input range of scalar numbers.\n* @param size The number of elements in the input range.\n* @param complex A pointer to the first element of the output range of complex numbers.\n*/\nvoid real2complex(const real_t *real, long size, complex_t *complex) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "auto wrapper_filter(Class& obj, bn::ndarray& input) {\n    if (input.get_nd() != 1) {\n        throw std::invalid_argument(\"Expected one-dimensional arrays\");\n    }\n    const auto size      = input.shape(0);\n    Py_intptr_t shape[1] = {size};\n    auto result          = bn::empty(1, shape, bn::dtype::get_builtin<real_t>());\n    auto data            = reinterpret_cast<real_t*>(input.get_data());\n    auto output          = reinterpret_cast<real_t*>(result.get_data());\n    obj.filter(data, data + size, output);\n    return result;\n}\n",
        "answer": "/**\n* @brief Wrapper function for filtering an array of real numbers using a filter object.\n*\n* This function takes a reference to a filter object and an ndarray of real numbers, and applies the filter to the input array. The output is stored in a new ndarray with the same shape as the input.\n*\n* @param obj A reference to a filter object.\n* @param input An ndarray of real numbers to be filtered.\n* @return A new ndarray containing the filtered output.\n*/\nauto wrapper_filter(Class& obj, bn::ndarray& input) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void rq_com_do_zero_force_flag()\n{\n\trq_com_zero_force_flag = 1;\n}\n",
        "answer": "/** @brief Set the \"zero sensor\" flag to 1.\n*\n* When the next stream message will be decoded, the effort values will be stored as offsets a substracted from the next values.\n*\n* @return void\n*/\nvoid rq_com_do_zero_force_flag()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  std::string help() { return std::string(\"Retrieve the help string for a named method\"); }\n",
        "answer": "/** @brief Retrieve the help string for a named method.\n*\n*  This function returns a help string for a named method. Subclasses should define this method if introspection is being used.\n*\n* @return A help string for the method.\n*/\nstd::string help() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int gcd(int a, int b)\n{\n    if(a == 0) return b;\n    return gcd(b%a, a);\n}\n",
        "answer": "/**\n* @brief Calculates the greatest common divisor of two integers.\n*\n* This function calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm.\n* The GCD is the largest positive integer that divides both numbers without leaving a remainder.\n*\n* @param a The first integer.\n* @param b The second integer.\n*\n* @return The GCD of `a` and `b`.\n*/\nint gcd(int a, int b)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void rotate3D(dmat33& dst,\n              const double phi,\n              const dvec3& axis)\n{\n    dvec4 quat;\n\n    quaternion(quat, phi, axis);\n\n    rotate3D(dst, quat);\n}\n",
        "answer": "/** @brief Rotates a 3D matrix along a given axis by a certain angle.\n*\n* This function calculates the rotation matrix of rotation along a certain axis given by a direction vector of phi.\n*\n* @param dst The destination matrix to store the result in.\n* @param phi The angle of rotation, in radians.\n* @param axis The direction vector of the axis of rotation.\n*/\nvoid rotate3D(dmat33& dst, const double phi, const dvec3& axis) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void translate(Image& dst,\n               const RFLOAT r,\n               const RFLOAT nTransCol,\n               const RFLOAT nTransRow)\n{\n    RFLOAT rCol = nTransCol / dst.nColRL();\n    RFLOAT rRow = nTransRow / dst.nRowRL();\n\n    IMAGE_FOR_PIXEL_R_FT(r)\n        if (QUAD(i, j) < TSGSL_pow_2(r))\n        {\n            RFLOAT phase = M_2X_PI * (i * rCol + j * rRow);\n            dst.setFT(COMPLEX_POLAR(-phase), i, j);\n        }\n}\n",
        "answer": "/** @brief Translate an image by a given vector in Fourier space.\n*\n*  This function generates a \"translation image\" in a certain frequency threshold with a given vector indicating the number of columns and the number of rows. An image can be tranlated by this vector, just by multiplying this \"translation image\" in Fourier space.\n*\n* @param dst The destination image to translate.\n* @param r The frequency threshold for the translation.\n* @param nTransCol The number of columns in the translation vector.\n* @param nTransRow The number of rows in the translation vector.\n*/\nvoid translate(Image& dst, const RFLOAT r, const RFLOAT nTransCol, const RFLOAT nTransRow) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void translateMT(Image& dst,\n                 const Image& src,\n                 const RFLOAT r,\n                 const RFLOAT nTransCol,\n                 const RFLOAT nTransRow)\n{\n    RFLOAT rCol = nTransCol / src.nColRL();\n    RFLOAT rRow = nTransRow / src.nRowRL();\n\n    #pragma omp parallel for schedule(dynamic)\n    IMAGE_FOR_EACH_PIXEL_FT(src)\n        if (QUAD(i, j) < TSGSL_pow_2(r))\n        {\n            RFLOAT phase = M_2X_PI * (i * rCol + j * rRow);\n            dst.setFTHalf(src.getFTHalf(i, j) * COMPLEX_POLAR(-phase), i, j);\n        }\n}\n",
        "answer": "/** @brief Translate an image in a certain frequency threshold with a given vector indicating by the number of columns and the number of rows using multiple threads.\n*\n*  This function translations an image in a certain frequency threshold with a given vector indicating by the number of columns and the number of rows using multiple threads.\n*\n* @param[in] dst The destination image.\n* @param[in] src The source image.\n* @param[in] r The frequency threshold.\n* @param[in] nTransCol The number of columns in the translation vector.\n* @param[in] nTransRow The number of rows in the translation vector.\n*/\nvoid translateMT(Image& dst, const Image& src, const RFLOAT r, const RFLOAT nTransCol, const RFLOAT nTransRow)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void softMask(Volume& dst,\n              const Volume& src,\n              const RFLOAT r,\n              const RFLOAT ew)\n{\n    RFLOAT bg = background(src, r, ew);\n\n    softMask(dst, src, r, ew, bg);\n}\n",
        "answer": "/** @brief Applies a soft mask on a volume.\n*\n*  This function applies a soft mask on a volume by calculating the soft mask from the source volume with a certain radius and edge width.\n*\n* @param dst The destination volume where the soft mask will be applied.\n* @param src The source volume that will be used to calculate the soft mask.\n* @param r The radius of the soft mask.\n* @param ew The edge width of the soft mask.\n* @return void\n*/\nvoid softMask(Volume& dst, const Volume& src, const RFLOAT r, const RFLOAT ew)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ar_kernel_update_round_robin()\n{\n    ar_list_node_t * node = g_ar.readyList.m_head;\n    assert(node);\n    uint8_t pri1 = node->getObject<ar_thread_t>()->m_priority;\n    if (node->m_next != node)\n    {\n        node = node->m_next;\n        uint8_t pri2 = node->getObject<ar_thread_t>()->m_priority;\n\n        g_ar.flags.needsRoundRobin = (pri1 == pri2);\n    }\n    else\n    {\n        g_ar.flags.needsRoundRobin = false;\n    }\n}\n",
        "answer": "/**\n* @brief Updates the round-robin flag based on the ready list.\n*\n* This function checks if there are multiple ready threads with the same priority in the ready list, and sets the `needsRoundRobin` flag accordingly.\n*\n* @return void\n*/\nvoid ar_kernel_update_round_robin()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void stdLog(void*, int level, const char *file, int line, const char *msg, ...) {\n\tva_list ap;\n\tconst char *levels[5] = {\"NIL\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"};\n\tfprintf(stderr, \"%s: FILE:%s, LINE:%i, MSG:\",levels[level], file, line);\n\tva_start(ap, msg);\n\tvfprintf(stderr, msg, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n",
        "answer": "/** @brief Static void stdLog.\n*\n*  This function logs messages to stderr with a specified level, file, line number, and message.\n*\n* @param[in] void * - The first parameter of the function is unused.\n* @param[in] int level - The second parameter specifies the log level (0-4).\n* @param[in] const char *file - The third parameter specifies the file name where the log message originated from.\n* @param[in] int line - The fourth parameter specifies the line number in the file where the log message originated from.\n* @param[in] const char *msg - The fifth parameter specifies the log message to be printed.\n* @param[in] ... - Additional parameters for the variadic function.\n*\n* @return void - This function does not return a value.\n*/\nstatic void stdLog(void*, int level, const char *file, int line, const char *msg, ...) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void calibrate_current_sensors(dcdc_t *dcdc, load_output_t *load)\n{\n    dcdc_current_offset = -dcdc->ls_current;\n    load_current_offset = -load->current;\n}\n",
        "answer": "/** @brief Calibrates the current sensors.\n*\n*  Sets offset to actual measured value, i.e. sets zero current point. All input/output switches and consumers should be switched off before calling this function\n*\n* @param[in] dcdc Pointer to the DCDC structure\n* @param[in] load Pointer to the load output structure\n* @return None\n*/\nvoid calibrate_current_sensors(dcdc_t *dcdc, load_output_t *load)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int centroid(int u, int p, int n) {\n  for (int v : TREE[u]) {\n    if (v != p && SIZE[v] > n / 2) {\n      return centroid(v, u, n);\n    }\n  }\n\n  return u;\n}\n",
        "answer": "/** @brief Finds the centroid of a tree with n nodes rooted at node u without backtracking through node p.\n*\n* This function finds the centroid of a tree with n nodes rooted at node u, without backtracking through node p.\n* The centroid is the node that is closest to the root and has the largest subtree size.\n*\n* @param[in] u The root node of the tree.\n* @param[in] p A node in the tree that should not be backtracked through.\n* @param[in] n The number of nodes in the tree.\n* @return The centroid of the tree with n nodes rooted at node u, without backtracking through node p.\n*/\nint centroid(int u, int p, int n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int psring_enqueue_bulk(struct ps_ring* psr, struct rte_mbuf** obj, uint32_t n) {\n\tif ((rte_ring_count(psr->ring) + n) < psr->capacity) {\n\t\treturn rte_ring_sp_enqueue_bulk(psr->ring, (void**)obj, n, NULL);\n\t}\n\treturn 0;\n}\n",
        "answer": "/** @brief Enqueues a bulk of objects onto the ring.\n*\n* This function enqueues a bulk of objects onto the ring in either bulk or burst mode, depending on the value of n.\n* In bulk mode, it will only enqueue a full batch if n>1. In burst mode, it will enqueue whatever there is space for, or dequeue as many as are available, up to n.\n*\n* @param psr The ring onto which the objects should be enqueued.\n* @param obj The array of objects to be enqueued.\n* @param n The number of objects to be enqueued.\n* @return The number of objects that were successfully enqueued, or 0 if there was an error.\n*/\nint psring_enqueue_bulk(struct ps_ring* psr, struct rte_mbuf** obj, uint32_t n) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void getEnabledFeatures()\n\t{\n\t\tif (deviceFeatures.samplerAnisotropy) {\n\t\t\tenabledFeatures.samplerAnisotropy = VK_TRUE;\n\t\t}\n\t}\n",
        "answer": "/** @brief Get enabled features after reading physical device features.\n*\n*  This function is called after the physical device features have been read, and can be used to set features to enable on the device.\n*\n* @return Should not return\n*/\nvirtual void getEnabledFeatures()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Func_Controller1Mempak()\r\n{\r\n\tFRAME_BUTTONS[0].button->setSelected(true);\r\n\tFRAME_BUTTONS[1].button->setSelected(false);\r\n\tControls[0].Plugin = PLUGIN_MEMPAK;\r\n\tpakMode[0] = PAKMODE_MEMPAK;\r\n}\r\n",
        "answer": "/** @brief Func_Controller1Mempak.\n*\n*  This function is used to set the controller buttons and plugin for MemPak.\n*\n* @return void\n*/\nvoid Func_Controller1Mempak()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool onSecurityRequest(){\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Handles security requests from peer devices.\n*\n*  This function is called when a peer device requests authorization.\n*  It should return true if we accept this request, or false otherwise.\n*\n* @return True if we accept the request, false otherwise.\n*/\nbool onSecurityRequest()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SIAMESE_EXPORT SiameseResult siamese_encoder_ack(\n    SiameseEncoder encoder_t,\n    const void* buffer,\n    unsigned bytes,\n    unsigned* nextExpectedPacketNum)\n{\n    siamese::Encoder* encoder = reinterpret_cast<siamese::Encoder*>(encoder_t);\n    if (!encoder || !buffer || bytes < 1 || !nextExpectedPacketNum)\n        return Siamese_InvalidInput;\n\n    return encoder->Acknowledge((uint8_t*)buffer, bytes, *nextExpectedPacketNum);\n}\n",
        "answer": "/** @brief Read an acknowledgement from the decoder. Consumes the data generated by siamese_decoder_ack(). It is preferred for the application to check if Acknowledgement messages are being received out of order, and to reject them if they are re-ordered. On success 'nextExpectedPacketNum' will be set to the next packet number that is expected by the remote peer. To properly calculate RTT, siamese_encoder_ack() must be called within about a millisecond of when the Ack packet is received. Returns 0 on success and other codes on error.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SIAMESE_EXPORT SiameseResult siamese_decoder_add_recovery(\n    SiameseDecoder decoder_t,\n    const SiameseRecoveryPacket* packet)\n{\n    siamese::Decoder* decoder = reinterpret_cast<siamese::Decoder*>(decoder_t);\n    if (!decoder || !packet || !packet->Data || packet->DataBytes <= 0 ||\n        packet->DataBytes > SIAMESE_MAX_PACKET_BYTES /* extra check to avoid integer overflows */)\n    {\n        return Siamese_InvalidInput;\n    }\n\n    return decoder->AddRecovery(*packet);\n}\n",
        "answer": "/** @brief Pass recovery data to the decoder from the encoder.\n*\n*  This function passes recovery data from the encoder to the decoder. The recovery data is used by the decoder to recover lost or corrupted packets.\n*\n*  @param[in] decoder_t A handle to the decoder instance.\n*  @param[in] packet A pointer to a SiameseRecoveryPacket structure containing the recovery data.\n*\n*  @return 0 on success and other codes on error.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SIAMESE_EXPORT SiameseResult siamese_decoder_stats(\n    SiameseDecoder decoder_t,\n    uint64_t* statsOut,\n    unsigned statsCount)\n{\n    siamese::Decoder* decoder = reinterpret_cast<siamese::Decoder*>(decoder_t);\n    if (!decoder || !statsOut || statsCount <= 0)\n        return Siamese_InvalidInput;\n\n    return decoder->GetStatistics(\n        statsOut,\n        statsCount);\n}\n",
        "answer": "/** @brief Collects statistics from the decoder.\n*\n*  This function collects an array of statistics from the decoder for all time.\n*\n* @param[in] decoder_t The decoder to collect statistics from.\n* @param[out] statsOut An array to store the collected statistics in.\n* @param[in] statsCount The number of elements in the statsOut array.\n*\n* @return 0 on success and other codes on error.\n*/\nSiameseResult siamese_decoder_stats("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "QCString generateMarker(int id)\r\n{\r\n  QCString result;\r\n  result.sprintf(\"@%d\",id);\r\n  return result;\r\n}\r\n",
        "answer": "/** @brief Generate a place holder for a position in a list. Used for translators to be able to specify different elements orders depending on whether text flows from left to right or visa versa.\n*\n*  This function generates a place holder for a position in a list, which can be used by translators to specify different element orders depending on the direction of the text flow. The generated placeholder is a string that starts with an \"@\" symbol followed by the id of the position.\n*\n* @param id The id of the position in the list.\n*\n* @return A string representing the place holder for the specified position in the list.\n*/\nQCString generateMarker(int id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\n#if !defined(NDEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\nvoid ESIGN_TestInstantiations()\n{\n\tESIGN<SHA>::Verifier x1(1, 1);\n\tESIGN<SHA>::Signer x2(NullRNG(), 1);\n\tESIGN<SHA>::Verifier x3(x2);\n\tESIGN<SHA>::Verifier x4(x2.GetKey());\n\tESIGN<SHA>::Verifier x5(x3);\n\tESIGN<SHA>::Signer x6 = x2;\n\n\tx6 = x2;\n\tx3 = ESIGN<SHA>::Verifier(x2);\n\tx4 = x2.GetKey();\n}\n",
        "answer": "/** @brief Test instantiations of ESIGN template class.\n*\n*  This function tests the instantiation of the ESIGN template class with different parameters.\n*\n* @return None\n*/\nvoid ESIGN_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\n\n#if !defined(NDEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\nvoid Modes_TestInstantiations()\n{\n\tCFB_Mode<DES>::Encryption m0;\n\tCFB_Mode<DES>::Decryption m1;\n\tOFB_Mode<DES>::Encryption m2;\n\tCTR_Mode<DES>::Encryption m3;\n\tECB_Mode<DES>::Encryption m4;\n\tCBC_Mode<DES>::Encryption m5;\n}\n",
        "answer": "/** @brief Modes test instantiations.\n*\n*  This function tests the instantiation of various modes with DES.\n*\n* @return None\n*/\nvoid Modes_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string otherParen(const std::string& paren) {\n  if (\"(\" == paren) {\n    return \")\";\n  } else if (\")\" == paren) {\n    return \"(\";\n  } else if (\"[\" == paren) {\n    return \"]\";\n  } else if (\"]\" == paren) {\n    return \"[\";\n  } else if (\"{\" == paren) {\n    return \"}\";\n  } else if (\"}\" == paren) {\n    return \"{\";\n  }\n  return \"\";\n}\n",
        "answer": "/** @brief Returns the opposing parenthesis for (), [], or {} pairs.\n*\n* This function takes a string as input and returns the opposing parenthesis if it is one of (), [], or {}.\n* If the input is not one of these, an empty string is returned.\n*\n* @param paren A string representing a parenthesis.\n* @return The opposing parenthesis for the input, or an empty string if the input is not one of (), [], or {}.\n*/\nstd::string otherParen(const std::string& paren) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double get_monotonic_time()\n{\n#if (defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0) && defined(_POSIX_MONOTONIC_CLOCK))\n  struct timespec ts;\n  clock_gettime(CLOCK_MONOTONIC, &ts);\n  return ts.tv_sec + ts.tv_nsec*1e-9;\n#else\n  return get_time();\n#endif\n}\n",
        "answer": "/** @brief Get monotonic time.\n*\n* This function returns a monotonic increasing time which does not need to have a reference point. It is used for measuring how long some code fragments required to execute.\n*\n* @return A double value representing the monotonic time in seconds.\n*/\ndouble get_monotonic_time()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Interpolate(const vector<Real>& times,const vector<Config>& milestones,Spline::PiecewisePolynomialND& out)\n{\n  Vector zero(milestones[0].size(),0.0);\n  out.elements.resize(0);\n  for(size_t i=0;i+1<milestones.size();i++) \n    out.Concat(QuadraticPolynomial(milestones[i],milestones[i+1],zero,zero,times[i],times[i+1]));\n}\n",
        "answer": "/** @brief Interpolates the given milestone configurations using a piecewise polynomial.\n*\n*  This function creates a smooth path that goes through each milestone with zero velocity.\n*  The path is represented as a piecewise polynomial, where each polynomial is a quadratic spline.\n*\n* @param times A vector of time values for each milestone.\n* @param milestones A vector of configuration values for each milestone.\n* @param out The output piecewise polynomial representing the interpolated path.\n*/\nvoid Interpolate(const vector<Real>& times, const vector<Config>& milestones, Spline::PiecewisePolynomialND& out)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void SampleTransform(const IKObjective& obj,double out[9],double out2[3])\n{\n  RigidTransform T;\n  SampleTransform(obj.goal,T);\n  T.R.get(out);\n  T.t.get(out2);\n}\n",
        "answer": "/** @brief Samples a transformation (R, t) from link relative to link2, sampled at random from the space of transforms that satisfies the objective obj.\n*\n*  This function samples a transformation (R, t) from link relative to link2, sampled at random from the space of transforms that satisfies the objective obj.\n*\n* @param[in] obj The IKObjective object that specifies the goal for the sampled transformation.\n* @param[out] out A 3x3 matrix representing the rotation component of the sampled transformation.\n* @param[out] out2 A 3-vector representing the translation component of the sampled transformation.\n*/\nvoid SampleTransform(const IKObjective& obj, double out[9], double out2[3]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool forceClosure2D(const std::vector<std::vector<double > >& contactPositions,const std::vector<std::vector<double> >& frictionCones)\n{\n  vector<CustomContactPoint2D> cps;\n  Convert(contactPositions,frictionCones,cps);\n  return TestForceClosure(cps);\n}\n",
        "answer": "/** @brief forceClosure2D\n*\n* This function checks if the given contact points and friction cones satisfy the force closure condition.\n* The contact points are represented as a list of 4 floats, [x,y,theta,k], where (x,y) is the position, theta is the normal angle, and k is the coefficient of friction.\n* The friction cones are represented as a list of 3 floats, [mu_x, mu_y, mu_n], where mu_x and mu_y are the friction coefficients in the x and y directions, respectively, and mu_n is the normal friction coefficient.\n*\n* @param contactPositions A vector of vectors representing the contact points. Each inner vector contains 4 floats representing a contact point.\n* @param frictionCones A vector of vectors representing the friction cones. Each inner vector contains 3 floats representing a friction cone.\n* @return True if the force closure condition is satisfied, false otherwise.\n*/\nbool forceClosure2D(const std::vector<std::vector<double > >& contactPositions, const std::vector<std::vector<double> >& frictionCones) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool ROSInit(const char* nodeName)\n{\n  if(gRosNh) return true;\n  int argc = 1;\n  char* argv [1]={(char*)\"klampt\"}; \n  ros::init(argc, &argv[0], nodeName);\n  gRosNh.reset(new ros::NodeHandle);\n  return true;\n}\n",
        "answer": "/** @brief Initializes the ROS system.\n*\n* This function initializes the ROS system by calling the ros::init() function with an optional node name. If the node name is not provided, it defaults to \"klampt\". This function must be called before all other ROS[X] calls. It can safely be called many times.\n*\n* @param nodeName The name of the ROS node.\n* @return True if the initialization was successful, false otherwise.\n*/\nbool ROSInit(const char* nodeName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool ROSSubscribeTrajectory(LinearPath& path,const char* topic) \n{\n  return RosSubscribe<LinearPath,trajectory_msgs::JointTrajectory>(path,topic);\n}\n",
        "answer": "/** @brief Subscribes to Trajectory updates from the given topic. Note: the object must not be destroyed while ROSSubscribeUpdate is being called. If you want to detach it from future updates, call RosDetach([topic]);\n*\n*  This function subscribes to trajectory updates from a given topic. It takes a LinearPath reference and a const char pointer as input. The LinearPath reference is used to store the received trajectory data, while the const char pointer specifies the topic to subscribe to.\n*\n* @param path A reference to a LinearPath object that will be used to store the received trajectory data.\n* @param topic A const char pointer specifying the topic to subscribe to.\n* @return Returns true if the subscription was successful, false otherwise.\n*/\nbool ROSSubscribeTrajectory(LinearPath& path,const char* topic)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ThreeJSExport(const RobotWorld& world,AnyCollection& out)\n{\n  ThreeJSCache cache;\n  ThreeJSExport(world,out,cache);\n}\n",
        "answer": "/** @brief Exports a world to a JSON object that can be used in the three.js editor. Contains metadata, geometries, materials, and object items.\n*\n*  This function exports a world to a JSON object that can be used in the three.js editor. It contains metadata, geometries, materials, and object items.\n*\n* @param[in] world The world to export.\n* @param[out] out The output JSON object.\n* @return void\n*/\nvoid ThreeJSExport(const RobotWorld& world, AnyCollection& out) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ThreeJSExportGeometry(const ManagedGeometry& geom,AnyCollection& out)\n{\n  ThreeJSCache cache;\n  ThreeJSExportGeometry(geom,out,cache);\n}\n",
        "answer": "/** @brief Exports geometry to a three.js scene Geometry instance.\n*\n* This function exports the geometry of a ManagedGeometry object to a ThreeJS scene Geometry instance. The \"uuid\" element of the output gives the unique ID number that can be used elsewhere in the code.\n*\n* @param geom The ManagedGeometry object to export.\n* @param out The AnyCollection object where the exported geometry will be stored.\n* @param cache A ThreeJSCache object that stores the exported geometry.\n*/\nvoid ThreeJSExportGeometry(const ManagedGeometry& geom,AnyCollection& out,ThreeJSCache& cache)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void GetCOMDerivs(Robot& robot,const Config& q,const Vector& dq,const Vector& ddq,Vector3& cm,Vector3& dcm,Vector3& ddcm,NewtonEulerSolver& ne)\n{\n  robot.UpdateConfig(q);\n  robot.dq = dq;\n  ne.CalcLinkAccel(ddq);\n  cm = robot.GetCOM();\n  dcm.setZero();\n  ddcm.setZero();\n  for(size_t j=0;j<ne.velocities.size();j++) {\n    Vector3 cmofs = robot.links[j].T_World.R*robot.links[j].com;\n    Vector3 vcmj = ne.velocities[j].v + cross(ne.velocities[j].w,cmofs);\n    Vector3 acmj = ne.accelerations[j].v + cross(ne.accelerations[j].w,cmofs) + cross(ne.velocities[j].w,cross(ne.velocities[j].w,cmofs));\n    dcm += robot.links[j].mass*vcmj;\n    ddcm += robot.links[j].mass*acmj;\n  }\n  Real mtotal = robot.GetTotalMass();\n  dcm /= mtotal;\n  ddcm /= mtotal;\n}\n",
        "answer": "/**\n* @brief Returns the center of mass first and second derivatives given joint positions and first and second derivatives.\n*\n* Utility: changes the robot's configuration and velocity to q and dq, respectively.\n*\n* @param[in] robot The robot object.\n* @param[in] q The joint positions.\n* @param[in] dq The joint velocities.\n* @param[in] ddq The joint accelerations.\n* @param[out] cm The center of mass position.\n* @param[out] dcm The center of mass velocity.\n* @param[out] ddcm The center of mass acceleration.\n* @param[in] ne The Newton-Euler solver object.\n*/\nvoid GetCOMDerivs(Robot& robot, const Config& q, const Vector& dq, const Vector& ddq, Vector3& cm, Vector3& dcm, Vector3& ddcm, NewtonEulerSolver& ne)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void Free(void* data, size_t) {\n        free(data);\n    }\n",
        "answer": "/** @brief Frees the memory block of size |length|, pointed to by |data|.\n*\n*  This function is used to free a memory block that was previously allocated using Allocate().\n*  The memory block must be freed with this function to ensure that it is properly released and made available for reuse.\n*\n* @param data A pointer to the memory block to be freed.\n* @param length The size of the memory block, in bytes.\n*/\nvirtual void Free(void* data, size_t length) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void onReceive( Connection& conn ) {\n    receivePackets( conn );\n  }\n",
        "answer": "/** @brief Event triggered when one or more packets have been received. It is possible to get more packets while in this function, but if packets arrive during this event, it will be called again, so you don't have to make sure they have all been processed (there is no sure way to do that.).\n* @param conn The connection object that triggered the receive event.\n*/\nvoid onReceive( Connection& conn ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void onNewConn(SyncConnection& conn) {\n    ourConn = conn.getConnection();\n    sDisplay->addConn(ourConn, &packetsIn, &packetsOut);\n  }\n",
        "answer": "/**\n* @brief Event triggered when a new connection has been negotiated and error checked.\n*\n* This object is a newly allocated object created from your ServerConnectionCreator object, and this function will be the first time you code has \"seen\" this object, so you will have to register it into some internal list if you want to interact with it later. If an error occurs then the connection needs to be killed, so conn can throw its Error outside your function. Catch it if you need to clean up anything you were doing, but remember to rethrow it. If this is the case, ServerConnectionListner::onListenFailure will be generated but not onDisconnect, so any needed cleanup needs to be done in your exception handler or in onListenFailure. See ServerConnection::run() for an event generation summary. You can also choose to refuse a connection by throwing an Error with an error code of Error::ConnectionRefused, and will it will make the connection act as if an error just occurred, so onListenFailure will be called and the above section of text still applies. Note: Only ServerConnection generates this function. The SyncConnection is currently wrapped around a ServerConnection, and you should use SyncConnection::getConnection to get the ServerConnection. If the connection failed before this event, though, the function ServerConnectionListener::onListenFailure instead of this function is called. If onNewConn succeeds, ServerConnectionListener::onListenSucess is called, and the connection process will be completed after that event completes.\n*\n* @param conn The newly created connection object.\n*/\nvoid onNewConn(SyncConnection& conn) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void simulate8bit(Bitmap<float> &bitmap) {\n    int w = bitmap.width(), h = bitmap.height();\n    for (int y = 0; y < h; ++y)\n        for (int x = 0; x < w; ++x) {\n            unsigned char v = clamp(int(bitmap(x, y)*0x100), 0xff);\n            bitmap(x, y) = v/255.f;\n        }\n}\n",
        "answer": "/** @brief Simulate an 8-bit display by rounding floating-point values to the nearest 8-bit value representable in a standard 8-bit bitmap.\n*\n* This function takes a reference to a Bitmap object containing floating-point values and iterates over each pixel, rounding the value to the nearest 8-bit value representable in a standard 8-bit bitmap. The rounded value is then stored back into the original Bitmap object.\n*\n* @param[in,out] bitmap A reference to a Bitmap object containing floating-point values.\n*/\nvoid simulate8bit(Bitmap<float> &bitmap) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tTqFloat weight(const CqVector3D& N)\n\t\t{\n\t\t\treturn N*m_negViewDirec;\n\t\t}\n",
        "answer": "/** @brief Calculates the weight of the ambient light.\n*\n*  The amount of ambient light reaching the surface from the direction of this view depends on a simple geometric factor: the cosine of the angle between the surface normal and the view direction. This function calculates that weight.\n*\n* @param N The surface normal vector.\n* @return The weight of the ambient light.\n*/\nTqFloat weight(const CqVector3D& N)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tstatic void removeRefCountObj(CqRefCount *refCount)\n\t\t{\n\t\t\ttheTracker()->_removeRefCountObj(refCount);\n\t\t}\n",
        "answer": "/** @brief Removes a reference count object from the global list.\n*\n*  This method should be called just before the reference count object is finally released, after reaching zero references (ie: not each time RELEASEREF is called!).\n*\n* @param refCount The reference count object to remove.\n*/\nstatic void removeRefCountObj(CqRefCount *refCount)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        virtual RtVoid ArchiveRecord(RtConstToken type, const char* string)\n        {\n            m_branch.ArchiveRecord(type, string);\n            nextFilter().ArchiveRecord(type, string);\n        }\n",
        "answer": "/** @brief ArchiveRecord is a virtual function that takes in a RtConstToken type and a const char* string as parameters.\n*\n*  This function is used to archive records for the RIB binding. It is not part of the RIB binding, but a variant of it here is included here for convenience in passing RIB comments.\n*\n* @param[in] type The token type that identifies the record being archived.\n* @param[in] string A pointer to the character array containing the record data.\n* @return void\n*/\nvirtual RtVoid ArchiveRecord(RtConstToken type, const char* string)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "EqImageFileType guessFileType(const boostfs::path& fileName)\n{\n\tstd::ifstream inFile(native(fileName).c_str());\n\tif(!inFile)\n\t{\n\t\tAQSIS_THROW_XQERROR(XqInvalidFile, EqE_NoFile, \"Cannot open file \\\"\"\n\t\t\t\t<< fileName << \"\\\" for reading\");\n\t}\n\treturn guessFileType(inFile);\n}\n",
        "answer": "/** @brief Guess the file type based on its contents.\n*\n*  This function reads the first few bytes of a file and tries to determine its type.\n*  It is not reliable, as many file formats have similar patterns at their beginning.\n*\n* @param fileName The path to the file to be analyzed.\n* @return An enum representing the guessed file type.\n*/\nEqImageFileType guessFileType(const boostfs::path& fileName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void Subdivide(RtPointer blinddata, RtFloat detailsize)\n{\n\tconst MengerSponge* p = reinterpret_cast<MengerSponge*>(blinddata);\n\tp->subdivide();\n}\n",
        "answer": "/** @brief Subdivides the procedural into smaller primitives.\n*\n*  This function splits the procedural into smaller primitives which are inserted into the renderer pipeline via the RI. These can be any primitive type supported by the renderer, including further procedurals.\n*\n* @param blinddata A pointer to the MengerSponge object.\n* @param detailsize The size of the detail.\n* @return void\n*/\nextern \"C\" void Subdivide(RtPointer blinddata, RtFloat detailsize)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void optionChanged(const std::string &name)\n        {\n            if (name == \"guialpha\")\n            {\n                mDropDown->mAlpha = config.getValue(\"guialpha\", 0.8);\n\n                mDropDown->buttons[0][0]->setAlpha(mDropDown->mAlpha);\n                mDropDown->buttons[0][1]->setAlpha(mDropDown->mAlpha);\n                mDropDown->buttons[1][0]->setAlpha(mDropDown->mAlpha);\n                mDropDown->buttons[1][1]->setAlpha(mDropDown->mAlpha);\n\n                for (int a = 0; a < 9; a++)\n                    mDropDown->skin.grid[a]->setAlpha(mDropDown->mAlpha);\n            }\n        }\n",
        "answer": "/** @brief Called when an option changed. The config listener will have to be registered to the option name first.\n*\n*  This function is called whenever an option changes its value. It takes a string parameter representing the name of the option that has changed, and updates the corresponding UI elements accordingly.\n*\n* @param name The name of the option that has changed.\n*/\nvoid optionChanged(const std::string &name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "        void optionChanged(const std::string &name)\n        {\n            if (name == \"guialpha\")\n            {\n                mItemContainer->mAlpha = config.getValue(\"guialpha\", 0.8);\n                mItemContainer->mBackgroundImg->setAlpha(mItemContainer->mAlpha);\n            }\n        }\n",
        "answer": "/** @brief Called when an option changed. The config listener will have to be registered to the option name first.\n*\n* This function is called whenever an option changes its value. It updates the corresponding GUI element's alpha value and background image alpha value based on the new value of the \"guialpha\" option.\n*\n* @param name The name of the option that changed.\n*/\nvoid optionChanged(const std::string &name)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void optionChanged(const std::string &)\n    {\n        if (skinLoader)\n            skinLoader->updateAlpha();\n    }\n",
        "answer": "/** @brief Called when an option changed. The config listener will have to be registered to the option name first.\n*\n*  This function is called whenever an option changes. It updates the alpha value of the skin loader if it exists.\n*\n* @param optionName The name of the option that changed.\n*/\nvoid optionChanged(const std::string &optionName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AA_API int aa_rx_sg_init ( struct aa_rx_sg *scene_graph )\n{\n    return scene_graph->sg->index();\n}\n",
        "answer": "/** @brief Setup the scenegraph internal indices.\n*\n*  This function must be called before any frame_ids or config_ids can be used with the scenegraph.\n*\n* @param scene_graph The scenegraph to initialize.\n* @return The number of frames in the scenegraph.\n*/\nAA_API int aa_rx_sg_init ( struct aa_rx_sg *scene_graph )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool DirectoriesInTree(::std::string const &path,\n                       ::std::vector< ::std::string > &paths)\n{\n    vector<DirectoryEntry> entries;\n\n    if (!DirectoryEntries(path, entries)) {\n        return false;\n    }\n\n    vector<DirectoryEntry>::iterator i = entries.begin();\n    for (; i != entries.end(); i++) {\n        if (i->type != DIRECTORY) continue;\n\n        if (i->name[0] == '.') continue;\n\n        string full_path = PathJoin(path, i->name);\n\n        paths.push_back(full_path);\n\n        DirectoriesInTree(full_path, paths);\n    }\n\n    return true;\n\n}\n",
        "answer": "/** @brief Recursively find all directories in a given directory.\n*\n*  Upon successful completion, the passed vector will be filled with path of all child directories. Paths will be relative to path specified.\n*\n* @param[in] path The root directory to search for child directories.\n* @param[out] paths A vector that will be filled with the paths of all child directories found in the given directory.\n* @return True if successful, false otherwise.\n*/\nbool DirectoriesInTree(::std::string const &path, ::std::vector< ::std::string > &paths) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "inline float InterpolateCubic(float t, T fm1, T f0, T f1, T f2)\n{\n    float delta_k = (float)f1 - f0;\n    float dk = ((float)f1 - fm1)*0.5f, dk1 = ((float)f2 - f0)*0.5f;\n\n    float a0 = f0, a1 = dk, a2 = 3.0f*delta_k - 2.0f*dk - dk1,\n        a3 = (float)dk + dk1 - 2.0f*delta_k;\n\n    return t*(t*(a3*t + a2)+a1)+a0;\n}\n",
        "answer": "/** @brief Cubic interpolation of 4 subsequent values fm1, f0, f1, f2 at location 0<=t<=1 between the middle elements (f0 and f1)\n*\n* This function performs cubic interpolation of 4 subsequent values fm1, f0, f1, f2 at location 0<=t<=1 between the middle elements (f0 and f1).\n* The interpolation is done using Hermite splines.\n*\n* @param t The location where the interpolation should be performed. Must be between 0 and 1.\n* @param fm1 The value of the function at the previous point in time.\n* @param f0 The value of the function at the current point in time.\n* @param f1 The value of the function at the next point in time.\n* @param f2 The value of the function at the point after the next point in time.\n*\n* @return The interpolated value of the function at location t.\n*/\ninline float InterpolateCubic(float t, T fm1, T f0, T f1, T f2)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "          virtual base::DataSourceBase::shared_ptr createPropertyDataSource(CService_ptr serv, const std::string& vname) {\n              CORBA::String_var tname = serv->getPropertyTypeName( CORBA::string_dup(vname.c_str()));\n              log(Warning) << \"Corba: Remote property '\"<< vname << \"' has unknown type \" << tname.in()  << endlog();\n              return base::DataSourceBase::shared_ptr( );\n          }\n",
        "answer": "/**\n* @brief Create a data source for an attribute or property. Will create an assignable data source when the property or attribute can be changed, a normal data source otherwise.\n*\n* This function creates a data source for an attribute or property. If the property or attribute can be changed, it will create an assignable data source. Otherwise, it will create a normal data source.\n*\n* @param serv The service that contains the property or attribute.\n* @param vname The name of the property or attribute.\n* @return A shared pointer to the created data source.\n*/\nvirtual base::DataSourceBase::shared_ptr createPropertyDataSource(CService_ptr serv, const std::string& vname) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual std::string getName() { return \"TypesTest\"; }\n",
        "answer": "/** @brief Get the name of the plugin.\n*\n*  Each plugin must have a unique name. This name is used globally in the process to identify this instance.\n*\n* @return The name of the plugin as a string.\n*/\nvirtual std::string getName() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern C int atoi(const char *nptr)\n{\n    String s = nptr;\n    return s.toLong();\n}\n",
        "answer": "/** @brief Converts the initial portion of a string to an integer representation.\n*\n*  This function converts the initial portion of the string pointed to by nptr to int, long int, and long long int representation, respectively.\n*\n* @param[in] nptr A pointer to the string to be converted.\n* @return The converted value.\n*/\nextern C int atoi(const char *nptr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid think()\r\n\t{\r\n\t\tgrab_old();\r\n\r\n\t\tunoccupy_location();\r\n\r\n\t\tx += 0.01f;\r\n\t\tfind_target();\r\n\r\n\t\tif (occupy_location())\r\n\t\t{\r\n\t\t\trequest_think();\r\n\t\t}\r\n\t}\r\n",
        "answer": "/** @brief Think function.\n*\n*  This function is called every game tick. A game tick is always 1/10th of a second. You can safely assume that no other object is modifying any data while you think.\n*\n* @return Should not return\n*/\nvoid think()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void receive_event(i4_event * ev)\r\n\t{\r\n\t\tif (ev->type()==i4_event::MOUSE_BUTTON_DOWN && state!=NO_CHILDREN)\r\n\t\t{\r\n\t\t\tif (state==EXPANDED)\r\n\t\t\t{\r\n\t\t\t\tstate=COMPACTED;\r\n\t\t\t\tbrowse_parent->compress();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstate=EXPANDED;\r\n\t\t\t\tbrowse_parent->expand();\r\n\r\n\t\t\t}\r\n\t\t\trequest_redraw();\r\n\t\t}\r\n\t}\r\n",
        "answer": "/** @brief Receive event.\n*\n*  This method receives any event sent to the window. If you don't handle a specific event, you should pass it to the parent handler.\n*\n* @param ev The event to be handled.\n* @return void\n*/\nvoid receive_event(i4_event * ev)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual void set_z_range(float _near_z, float _far_z)\r\n\t{\r\n\t\tr1_near_clip_z = _near_z;\r\n\t\tr1_far_clip_z  = _far_z;\r\n\r\n\t\tgr_static_info.gr_w_mul = _far_z / (float)GR_WDEPTHVALUE_FARTHEST;\r\n\t}\r\n",
        "answer": "/** @brief Set the Range of the Z-Buffer.\n*\n*  This function sets the range of the z-buffer, scaling all z's (or w's) to reflect this range with best precision. Near_z must be greater than 0. Hint: For golg, a great z value (default 1000.0) is far away, for directx, this is mapped to 0.0, the near value, since the z-buffer is used the wrong way round. (With comparison for greater instead of less) Any implementation of this function must set r1_near_clip_z and r1_far_clip_z.\n*\n* @param _near_z The near z value.\n* @param _far_z The far z value.\n*/\nvoid set_z_range(float _near_z, float _far_z)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvoid uninit()\r\n\t{\r\n\t\tdelete tmanager;\r\n\t}\r\n",
        "answer": "/** @brief Deinitialize the renderer.\n*\n*  This function will delete the texture manager (and free textures associated with) created by init.\n*\n* @return Should not return\n*/\nvoid uninit()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void nRF905_setFrequency(nRF905_band_t band, uint32_t freq)\n{\n\tnRF905_setChannel(band, NRF905_CALC_CHANNEL(freq, band));\n}\n",
        "answer": "/** @brief Set the frequency for the nRF905 radio.\n*\n* This function sets the frequency for the nRF905 radio by calculating the channel number based on the frequency and band.\n* The frequency must be within the range of the specified band (422.4MHz - 473.5MHz or 844.8MHz - 947MHz) and the step size must be 100KHz for the former and 200KHz for the latter.\n*\n* @param band The frequency band to use (433MHz or 868/915MHz).\n* @param freq The desired frequency in MHz.\n*/\nvoid nRF905_setFrequency(nRF905_band_t band, uint32_t freq)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "class FrameInspector : public sys::ConnectionOutputHandler\n{\npublic:\n    FrameInspector(ConnectionOutputHandler* p, framing::FrameHandler* i) :\n        next(p),\n        intercepter(i)\n    {\n        assert(next);\n        assert(intercepter);\n    }\n\n    void close() { next->close(); }\n    void abort() { next->abort(); }\n    void connectionEstablished() { next->connectionEstablished(); }\n    void activateOutput() { next->activateOutput(); }\n    void handle(framing::AMQFrame& f) { intercepter->handle(f); next->handle(f); }\n\nprivate:\n    ConnectionOutputHandler* next;\n    framing::FrameHandler* intercepter;\n};\n",
        "answer": "/** @brief A ConnectionOutputHandler that delegates to another ConnectionOutputHandler. Allows you to inspect outputting frames\n*/\nclass FrameInspector : public sys::ConnectionOutputHandler"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "puglLeaveContext(PuglView* view, bool flush)\n{\n#ifdef PUGL_HAVE_GL\n\tif (view->ctx_type == PUGL_GL && flush) {\n\t\tglFlush();\n\t\tSwapBuffers(view->impl->hdc);\n\t}\n#endif\n\n\tPAINTSTRUCT ps;\n\tEndPaint(view->impl->hwnd, &ps);\n}\n",
        "answer": "/**\n* @brief Leaves the drawing context.\n*\n* This function must be called after puglEnterContext and applies the results of the drawing code (for example, by swapping buffers).\n*\n* @param view The PuglView object.\n* @param flush Whether to flush the graphics pipeline before leaving the context.\n*/\nvoid puglLeaveContext(PuglView* view, bool flush)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void operator delete(void* p)\n{\n\tkfree(p);\n}\n",
        "answer": "/** @brief Overloaded operator delete for custom memory management.\n*\n*  This function is used to free memory allocated by the overloaded operator new.\n*  It takes a pointer to the memory block and frees it using kfree.\n*\n* @param p A pointer to the memory block to be deleted.\n*/\nvoid operator delete(void* p)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void parse_inductive_univ_params() {\n        buffer<name> curr_ls_buffer;\n        if (parse_univ_params(m_p, curr_ls_buffer)) {\n            if (!m_first) {\n                throw_error(\"invalid mutually recursive declaration, \"\n                            \"explicit universe levels should only be provided to first inductive type in this declaration\");\n            }\n            m_using_explicit_levels = true;\n            m_explicit_levels.append(curr_ls_buffer);\n        }\n    }\n",
        "answer": "/** @brief Parses inductive universe parameters.\n*\n*  This function parses the universe levels for an inductive type, if they are provided explicitly.\n*  If this is not the first declaration, then it checks if the user is not providing explicit universe levels again.\n*\n* @param m_p The parser object.\n* @param curr_ls_buffer A buffer containing the current level symbols.\n* @return void\n*/\nvoid parse_inductive_univ_params() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual action_result next() {\n        while (!empty(m_hs)) {\n            curr_state()        = m_state;\n            hypothesis_idx hidx = head(m_hs);\n            m_hs                = tail(m_hs);\n            action_result r     = try_hypothesis(hidx);\n            if (!failed(r)) {\n                lean_trace_search(tout() << \"next of choice #\" << m_choice_idx\n                                  << \", recurse \" << mk_href(hidx) << \"\\n\";);\n                return r;\n            }\n        }\n        return action_result::failed();\n    }\n",
        "answer": "/**\n* @brief The next method result can be: 1- Failed: failure 2- NewBranch: the current state has been updated, and it contains a new branch to be solved. 3- Solved(pr): the current state has been updated, and its current branch has been closed by the next choice.\n*\n* @return The result of the next method\n*/\nvirtual action_result next() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void check_command_period_open_binder_or_eof(parser const & p) {\n    if (!p.curr_is_command() && !p.curr_is_eof() && !p.curr_is_token(get_period_tk()) &&\n        !p.curr_is_token(get_lparen_tk()) && !p.curr_is_token(get_lbracket_tk()) &&\n        !p.curr_is_token(get_lcurly_tk()) && !p.curr_is_token(get_ldcurly_tk()))\n        throw parser_error(\"unexpected token, '(', '{', '[', '', '.', command, or end-of-file expected\", p.pos());\n}\n",
        "answer": "/** @brief Check if the current token is a command, an open binder, a period, an end-of-file, or throw an error otherwise.\n*\n*  This function checks if the current token in the parser is a command, an open binder, a period, an end-of-file, or throws an error otherwise.\n*\n* @param p The parser object.\n* @return Void.\n*/\nvoid check_command_period_open_binder_or_eof(parser const & p) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "certified_declaration check(environment const & env, declaration const & d) {\n    return check(env, d, [](name const &) { return false; });\n}\n",
        "answer": "/** @brief Checks the type correctness of a given declaration.\n*\n*  This function takes an environment and a declaration as input, and returns a certified declaration if it is type correct. If the declaration is not type correct, an exception is thrown.\n*\n* @param env The environment in which to check the declaration.\n* @param d The declaration to be checked.\n* @return A certified declaration if the input declaration is type correct, or throws an exception otherwise.\n*/\ncertified_declaration check(environment const & env, declaration const & d) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool has_num_decls(environment const & env) {\n    return\n        env.find(get_zero_name()) &&\n        env.find(get_one_name()) &&\n        env.find(get_bit0_name()) &&\n        env.find(get_bit1_name());\n}\n",
        "answer": "/** @brief Checks if the given environment contains the declarations needed to encode numerals: zero, one, bit0, and bit1.\n*\n*  This function checks if the given environment contains the necessary declarations for encoding numerals. It returns true iff the environment contains the declarations for zero, one, bit0, and bit1.\n*\n* @param env The environment to check.\n* @return True iff the environment contains the declarations needed to encode numerals.\n*/\nbool has_num_decls(environment const & env) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void check_term(type_checker & tc, expr const & e) {\n    expr tmp = unfold_untrusted_macros(tc.env(), e);\n    tc.check_ignore_undefined_universes(tmp);\n}\n",
        "answer": "/** @brief Checks the term for type correctness.\n*\n*  This function checks whether a given term is type correct using the provided type checker and environment.\n*  It first unfolds any untrusted macros in the term, then checks the resulting expression for undefined universes.\n*\n* @param tc The type checker to use for checking the term.\n* @param e The term to be checked.\n*/\nvoid check_term(type_checker & tc, expr const & e) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned register_branch_extension(branch_extension * initial) {\n    return get_extension_manager().register_extension(initial);\n}\n",
        "answer": "/** @brief Registers a branch extension with the system.\n*\n*  This procedure must be invoked at Lean initialization time for each branch extension. The unique id returned should be used to retrieve the branch extension associated with the current state.\n*\n* @param initial A pointer to the branch extension to register.\n* @return The unique id of the registered branch extension.\n*/\nunsigned register_branch_extension(branch_extension * initial) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    bool sortOnLength(const string *a, const string *b) {\n        return (*a).length() > (*b).length();\n    }\n",
        "answer": "/** @brief Sort comparison function. Compares the length of the value of pointers in the vectors. The LONGEST strings will be first in the vector.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nbool sortOnLength(const string *a, const string *b) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void expandSelectionToEntities ()\n{\n\tGlobalSceneGraph().traverse(ExpandSelectionToEntitiesWalker());\n}\n",
        "answer": "/** @brief Expand the selection to entities.\n*\n*  This function expands the selection to all entities that are children of the current entity, given that a child of this entity is already selected. For instance, if a child brush of a func_static is selected, this command will select every other child (but not the func_static entity itself). Select a single primitive of the worldspawn entity and this command will select every primitive that is child of worldspawn.\n*\n* @return Should not return\n*/\nvoid expandSelectionToEntities ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void set_default_bfd_target (void)\n{\n\t/* The macro TARGET is defined by Makefile.\n\t E.g.: -DTARGET='\"i686-pc-linux-gnu\"'.  */\n\tconst char *target = TARGET;\n\n\tif (!bfd_set_default_target(target)) {\n\t\tnon_fatal(\"can't set BFD default target to `%s': %s\", target, bfd_errmsg(bfd_get_error()));\n\t\treturn;\n\t}\n\n\treturn;\n}\n",
        "answer": "/** @brief Set the default BFD target based on the configured target.\n*\n*  This function sets the default BFD target based on the configured target.\n*  It is used to permit the binutils to be configured for a particular target,\n*  and linked against a shared BFD library which was configured for a different target.\n*\n* @param void\n* @return void\n*/\n/* The macro TARGET is defined by Makefile.\nE.g.: -DTARGET='\"i686-pc-linux-gnu\"'.  */"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void GAME_SK_SetMissionParameters (const mapDef_t* md)\n{\n\tcgi->Cvar_SetValue(\"ai_numcivilians\", 8);\n\tif (md->civTeam != nullptr)\n\t\tcgi->Cvar_Set(\"ai_civilianteam\", \"%s\", md->civTeam);\n\telse\n\t\tcgi->Cvar_Set(\"ai_civilianteam\", \"europe\");\n\n\tcgi->Cvar_Set(\"sv_hurtaliens\", \"0\");\n\n\t/* now store the alien teams in the shared csi struct to let the game dll\n\t * have access to this data, too */\n\tcgi->csi->numAlienTeams = 0;\n\tfor (int i = 0; i < cgi->csi->numTeamDefs; i++) {\n\t\tconst teamDef_t* td = &cgi->csi->teamDef[i];\n\t\tif (CHRSH_IsTeamDefAlien(td)) {\n\t\t\tcgi->csi->alienChrTemplates[cgi->csi->numAlienTeams] = nullptr;\n\t\t\tcgi->csi->alienTeams[cgi->csi->numAlienTeams++] = td;\n\t\t}\n\t\tif (cgi->csi->numAlienTeams >= MAX_TEAMS_PER_MISSION)\n\t\t\tbreak;\n\t}\n}\n",
        "answer": "/** @brief Registers data in shared client/server structs to ensure that every known alien race is used in a skirmish game.\n*\n*  This function sets the number of civilian players, the civilian team, and stores the alien teams in the shared csi struct to let the game dll have access to this data, too.\n*\n* @param md The map definition struct containing information about the current mission.\n*/\n/* now store the alien teams in the shared csi struct to let the game dll\n* have access to this data, too */\ncgi->csi->numAlienTeams = 0;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Cmd_ForwardToServer (void)\n{\n\tconst char* cmd = Cmd_Argv(0);\n\n\tif (cls.state <= ca_connected || cmd[0] == '-' || cmd[0] == '+') {\n\t\tCom_Printf(\"Unknown command \\\"%s\\\" - wasn't sent to server\\n\", cmd);\n\t\treturn;\n\t}\n\n\tdbuffer msg;\n\tNET_WriteByte(&msg, clc_stringcmd);\n\tmsg.add(cmd, strlen(cmd));\n\tif (Cmd_Argc() > 1) {\n\t\tmsg.add(\" \", 1);\n\t\tmsg.add(Cmd_Args(), strlen(Cmd_Args()));\n\t}\n\tmsg.add(\"\", 1);\n\tNET_WriteMsg(cls.netStream, msg);\n}\n",
        "answer": "/** @brief Forwards the current command line to the server.\n*\n* This function adds the current command line as a clc_stringcmd to the client message. It is used for commands such as godmode, noclip, etc., which are directed to the server and need to be forwarded when typed in at the console.\n*\n* @param void\n* @return void\n*/\nvoid Cmd_ForwardToServer(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void CL_ViewCalcFieldOfViewX (void)\n{\n\tif (cl_isometric->integer) {\n\t\tconst float zoom =  3.6 * (cl.cam.zoom - cl_camzoommin->value) + 0.3 * cl_camzoommin->value;\n\t\trefdef.fieldOfViewX = std::max(std::min(FOV / zoom, 140.0), 1.0);\n\t} else {\n\t\trefdef.fieldOfViewX = std::max(std::min(FOV / cl.cam.zoom, 95.0), 55.0);\n\t}\n}\n",
        "answer": "/** @brief Calculates refdef's FOV_X. Should generally be called after any changes are made to the zoom level (via cl.cam.zoom)\n*\n* This is the description of the functionality of the function.\n*\n* @return Should not return\n*/\nvoid CL_ViewCalcFieldOfViewX (void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void Cmd_Test_f (void)\n{\n\tfor (cmd_function_t* cmd = cmd_functions; cmd; cmd = cmd->next) {\n\t\tif (!Q_streq(cmd->getName(), \"quit\"))\n\t\t\tCmd_ExecuteString(\"%s\", cmd->getName());\n\t}\n}\n",
        "answer": "/** @brief Cmd_Test_f is a function that tries to call every command (except the quit command) in the command list.\n*\n* This function is used to test whether some console bindings produce asserts or segfaults in some situations.\n*\n* @param void\n* @return void\n*/\nstatic void Cmd_Test_f(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void INS_ChangeInstallationName_f (void)\n{\n\tinstallation_t* installation = INS_GetCurrentSelectedInstallation();\n\n\t/* maybe called without installation initialized or active */\n\tif (!installation)\n\t\treturn;\n\n\tQ_strncpyz(installation->name, cgi->Cvar_GetString(\"mn_installation_title\"), sizeof(installation->name));\n}\n",
        "answer": "/** @brief Changes the name of an installation.\n*\n*  This function copies the value of the cvar mn_installation_title over as the name of the current selected installation.\n*\n* @param[in] void\n* @return void\n*/\n/* maybe called without installation initialized or active */\nif (!installation)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void SP_player_start (Edict* ent)\n{\n\t/* only used in multi player */\n\tif (G_IsSinglePlayer()) {\n\t\tG_FreeEdict(ent);\n\t\treturn;\n\t}\n\n\t/** @todo Wrong place here */\n\t/* maybe there are already the max soldiers allowed per team connected */\n\tif (sv_maxsoldiersperteam->integer > level.num_spawnpoints[ent->getTeam()]) {\n\t\tG_ActorSpawn(ent);\n\t} else\n\t\tG_FreeEdict(ent);\n}\n",
        "answer": "/** @brief Player start point.\n*\n*  This function creates a starting point for a player in multiplayer mode.\n*  It checks if there are already the maximum number of soldiers allowed per team connected, and if so, frees the edict.\n*\n* @param ent The edict representing the player.\n*/\n/* only used in multi player */\n/** @todo Wrong place here */\n/* maybe there are already the max soldiers allowed per team connected */\nif (sv_maxsoldiersperteam->integer > level.num_spawnpoints[ent->getTeam()]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void SampleNormal (const lightinfo_t* l, const vec3_t pos, vec3_t normal)\n{\n\tfloat dist[MAX_VERT_FACES];\n\n\tfloat nearest = 9999.0;\n\tint nearv = 0;\n\n\t/* calculate the distance to each vertex */\n\tfor (int i = 0; i < l->face->numedges; i++) {  /* find nearest and farthest verts */\n\t\tint v;\n\t\tconst int e = curTile->surfedges[l->face->firstedge + i];\n\t\tif (e >= 0)\n\t\t\tv = curTile->edges[e].v[0];\n\t\telse\n\t\t\tv = curTile->edges[-e].v[1];\n\n\t\tvec3_t temp;\n\t\tVectorSubtract(pos, curTile->vertexes[v].point, temp);\n\t\tdist[i] = VectorLength(temp);\n\t\tif (dist[i] < nearest) {\n\t\t\tnearest = dist[i];\n\t\t\tnearv = v;\n\t\t}\n\t}\n\tVectorCopy(curTile->normals[nearv].normal, normal);\n}\n",
        "answer": "/**\n* @brief Samples the normal at a point on a surface.\n*\n* This function calculates the distance to each vertex of the surface and weights them according to their proximity to the sample position.\n* The weighted normals are then used to calculate the final normal for the surface at the given point.\n*\n* @param l A pointer to a lightinfo_t struct containing information about the light source.\n* @param pos The position of the point on the surface to be sampled.\n* @param normal The resulting normal vector.\n*/\n/* calculate the distance to each vertex */\nfor (int i = 0; i < l->face->numedges; i++) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void NET_ReadFormat (dbuffer* buf, const char* format, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, format);\n\tNET_vReadFormat(buf, format, ap);\n\tva_end(ap);\n}\n",
        "answer": "/** @brief User-friendly version of NET_ReadFormat that reads variable arguments from a buffer according to format.\n*\n*  This function is a wrapper for the NET_vReadFormat function, which reads variable arguments from a buffer according to format.\n*  It takes a dbuffer pointer and a const char pointer as input, and uses va_list to read the variable arguments.\n*\n* @param buf Pointer to the dbuffer structure that contains the data to be read.\n* @param format A string that specifies the format of the data in the buffer.\n* @return void\n*/\nvoid NET_ReadFormat (dbuffer* buf, const char* format, ...)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void R_LoadObjModel_ (model_t* mod, mobj_t* obj, const byte* buffer, int bufSize)\n{\n\tconst byte* c = buffer;\n\tbool comment = false;\n\tint i = 0;\n\tchar line[MAX_STRING_CHARS];\n\n\twhile (c[0] != '\\0') {\n\t\tif (c[0] == '#') {\n\t\t\tcomment = true;\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c[0] == '\\r' || c[0] == '\\n') {\n\t\t\tline[i] = 0;\n\t\t\ti = 0;\n\n\t\t\tif (!comment)\n\t\t\t\tR_LoadObjModelLine(mod, obj, Com_Trim(line));\n\n\t\t\tcomment = false;\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tline[i++] = *c++;\n\t}\n}\n",
        "answer": "/** @brief R_LoadObjModel_.\n*\n*  This function is responsible for parsing an object file. It reads the file twice: once to acquire primitive counts, and a second time to load them.\n*\n* @param mod The model being loaded.\n* @param obj The object being loaded.\n* @param buffer A pointer to the buffer containing the object file data.\n* @param bufSize The size of the buffer.\n* @return void\n*/\nstatic void R_LoadObjModel_ (model_t* mod, mobj_t* obj, const byte* buffer, int bufSize)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void Com_SHA1Input (SHA1Context *context, const unsigned char* message_array, unsigned length)\n{\n\tif (!length) {\n\t\treturn;\n\t}\n\n\tif (context->Computed || context->Corrupted) {\n\t\tcontext->Corrupted = 1;\n\t\treturn;\n\t}\n\n\twhile (length-- && !context->Corrupted) {\n\t\tcontext->Message_Block[context->Message_Block_Index++] = (*message_array & 0xFF);\n\n\t\tcontext->Length_Low += 8;\n\t\t/* Force it to 32 bits */\n\t\tcontext->Length_Low &= 0xFFFFFFFF;\n\t\tif (context->Length_Low == 0) {\n\t\t\tcontext->Length_High++;\n\t\t\t/* Force it to 32 bits */\n\t\t\tcontext->Length_High &= 0xFFFFFFFF;\n\t\t\tif (context->Length_High == 0) {\n\t\t\t\t/* Message is too long */\n\t\t\t\tcontext->Corrupted = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (context->Message_Block_Index == 64) {\n\t\t\tCom_SHA1ProcessMessageBlock(context);\n\t\t}\n\n\t\tmessage_array++;\n\t}\n}\n",
        "answer": "/** @brief Com_SHA1Input Description: This function accepts an array of octets as the next portion of the message. Parameters: context: [in/out] The SHA-1 context to update message_array: [in] An array of characters representing the next portion of the message. length: [in] The length of the message in message_array Returns: Nothing. Comments: This function updates the SHA-1 context with the next portion of the message. It first checks if the context is corrupted or if the message length is zero, and returns early if so. Then it iterates through the message array, updating the context's message block and length variables as needed. If the message block becomes full (i.e., has 64 elements), the function calls Com_SHA1ProcessMessageBlock to process the message block. */\n/* Force it to 32 bits */\n/* Force it to 32 bits */\n/* Message is too long */\ncontext->Corrupted = 1;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void UI_CallHandler_OnLoad (lua_State* L, const char* key)\n{\n\tCL_ExecuteCallback(L, key);\n}\n",
        "answer": "/** @brief Call the registered callback handler.\n*\n*  This stub primarily exists should the signature of the call change in the future. CL_ExecuteCallback only supports a callback with no arguments.\n*\n* @param L The Lua state.\n* @param key The key to use for the callback.\n*/\nvoid UI_CallHandler_OnLoad (lua_State* L, const char* key)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "      bool getInputSpecification(PlugInArgList*& pArgs)\n      {\n         pArgs = NULL;\n         return true;\n      }\n",
        "answer": "/** @brief Retrieves the plug-in input parameters.\n*\n*  This method queries the plug-in for its input parameters that are needed to execute properly. The input arguments may be different in interactive mode and batch mode.\n*\n* @param pArgs Pointer to a PlugInArgList object, which will hold the input parameters.\n* @return true if the input parameters were retrieved successfully, false otherwise.\n*/\nbool getInputSpecification(PlugInArgList*& pArgs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "   bool setDataToWrite(void* pObject)\n   {\n      if (pObject == NULL)\n      {\n         return false;\n      }\n\n      mpValue = reinterpret_cast<vector<T>*>(pObject);\n      mValid = true;\n      return true;\n   }\n",
        "answer": "/** @brief Sets the data that should be written by this writer. If the given data is not supported by this writer, false should be returned.\n*\n*  This function sets the data that should be written by this writer. If the given data is not supported by this writer, it will return false.\n*\n* @param pObject A pointer to the object that contains the data that should be written.\n*\n* @return True if the data was successfully set, false otherwise.\n*/\nbool setDataToWrite(void* pObject)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string, string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: swiftcash-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH (const PAIRTYPE(string, string) & item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\"\n      << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/**\n* @brief Sends an HTTP POST request with a JSON message and custom headers.\n*\n* This function sends an HTTP POST request to the specified URL, with a JSON message as the request body, and custom headers. The response from the server is returned as a string.\n*\n* @param strMsg The JSON message to send in the request body.\n* @param mapRequestHeaders A map of custom headers to include in the request.\n*\n* @return The response from the server as a string.\n*/\n```"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual void Start (uint32 threadCount,\r\n\t\t\t\t\t\t\tconst dng_point &tileSize,\r\n\t\t\t\t\t\t\tdng_memory_allocator *allocator,\r\n\t\t\t\t\t\t\tdng_abort_sniffer * /* sniffer */)\r\n\t\t\t{\r\n\t\t\t\r\n\t\t\tuint32 pixelSize = TagTypeSize (fPixelType);\r\n\t\t\t\t\t\t\t\t   \r\n\t\t\tuint32 bufferSize = tileSize.v *\r\n\t\t\t\t\t\t\t\tRoundUpForPixelSize (tileSize.h, pixelSize) *\r\n\t\t\t\t\t\t\t\tpixelSize *\r\n\t\t\t\t\t\t\t\tfImage.Planes ();\r\n\t\t\t\t\t\t\t\t   \r\n\t\t\tfor (uint32 threadIndex = 0; threadIndex < threadCount; threadIndex++)\r\n\t\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tfBuffer [threadIndex] . Reset (allocator->Allocate (bufferSize));\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\tfOpcode.Prepare (fNegative,\r\n\t\t\t\t\t\t\t threadCount,\r\n\t\t\t\t\t\t     tileSize,\r\n\t\t\t\t\t\t\t fImage.Bounds (),\r\n\t\t\t\t\t\t\t fImage.Planes (),\r\n\t\t\t\t\t\t\t fPixelType,\r\n\t\t\t\t\t\t     *allocator);\r\n\t\t\r\n\t\t\t}\r\n",
        "answer": "/** @brief Task startup method called before any processing is done on partitions. The Start method is called before any processing is done and can be overridden to allocate temporary buffers, etc.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param threadCount The number of threads to start.\n* @param tileSize The size of the tile to process.\n* @param allocator The memory allocator to use for buffer allocation.\n* @param sniffer The abort sniffer to check for aborts.\n* @return Should not return\n*/\n*allocator);\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "XMP_Status XMPFileDump(void * refCon, XMP_StringPtr buffer, XMP_StringLen bufferSize)\n{\n\tXMP_Status status = 0;\n\ttry\n\t{\n\t\tofstream * outFile = static_cast<ofstream*>(refCon);\n\t\t(*outFile).write(buffer, bufferSize);\n\t}\n\tcatch(XMP_Error & e)\n\t{\n\t\tcout << e.GetErrMsg() << endl;\n\t\treturn -1;\n\t}\n\treturn status;\n}\n",
        "answer": "/** @brief XMPFileDump function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @return Should not return\n*/\nvoid XMPFileDump(void * refCon, XMP_StringPtr buffer, XMP_StringLen bufferSize)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static uid_t get_keystore_euid(uid_t uid) {\n    for (size_t i = 0; i < sizeof(user_euids)/sizeof(user_euids[0]); i++) {\n        struct user_euid user = user_euids[i];\n        if (user.uid == uid) {\n            return user.euid;\n        }\n    }\n\n    return uid;\n}\n",
        "answer": "/**\n* @brief Returns the effective UID that the calling UID should act as.\n*\n* This function is used to support legacy systems and should be removed when WiFi can operate in its own namespace.\n*\n* @param uid The UID of the user.\n* @return The effective UID that the calling UID should act as.\n*/\nstatic uid_t get_keystore_euid(uid_t uid) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void RunUserCb(VCallback<> cb) { cb(); }\n",
        "answer": "/** @brief Runs a user-provided callback.\n*\n*  This function runs a user-provided callback, which can be used to test and debug drivers.\n*  The callback should not return any value.\n*\n* @param cb The callback to run.\n*/\nvoid RunUserCb(VCallback<> cb) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void clearPendingUpdates() {\n   updates.clear();\n}\n",
        "answer": "/** @brief Clears the pending updates queue without taking any additional action.\n*\n* This function is usually called after a successful fork to empty the pending updates queue.\n*\n* @param[in] updates The queue of pending updates to clear.\n*/\nvoid clearPendingUpdates(std::queue<Update>& updates) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool getBasicType(BasicType::BasicTypes& basicType, const TypeBase& type)\n{\n\tif (type.is_a<BasicType>())\n\t{\n\t\tbasicType = type.cast_to<BasicType>().getKind();\n\t\treturn true;\n\t}\n\n\tif (type.is_a<TypedefType>())\n\t\treturn getBasicType(\n\t\t\tbasicType,\n\t\t\ttype.cast_to<TypedefType>().getBaseType());\n\n\tif (type.is_a<DeclaredType>())\n\t\treturn getBasicType(\n\t\t\tbasicType,\n\t\t\ttype.cast_to<DeclaredType>().getDeclaration().getType());\n\n\treturn false;\n}\n",
        "answer": "/** @brief Finds a basic type (int, char, float, etc.) associated with a specified type instance. The accepted type can be a basic type, a typedef and so on.\n*\n*  This function takes two parameters: the first is an output parameter that will contain the basic type found, and the second is the input type to search for the basic type.\n*  The function returns true if a basic type was found, false otherwise.\n*\n* @param[out] basicType The basic type found in the input type.\n* @param[in] type The input type to search for the basic type.\n* @return True if a basic type was found, false otherwise.\n*/\nbool getBasicType(BasicType::BasicTypes& basicType, const TypeBase& type)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void reset(UErrorCode& status) {\n        if (status == U_ENUM_OUT_OF_SYNC_ERROR) {\n            status = U_ZERO_ERROR;\n        }\n        if (U_SUCCESS(status)) {\n            _timestamp = _service->getTimestamp();\n            _pos = 0;\n            _service->getVisibleIDs(_ids, status);\n        }\n    }\n",
        "answer": "/**\n* @brief Resets the iterator.\n*\n* This re-establishes sync with the service and rewinds the iterator to start at the first element. Previous pointers returned by next, unext, or snext become invalid, and the value returned by count might change.\n*\n* @param status The UErrorCode variable that will be set if an error occurs.\n*/\nvirtual void reset(UErrorCode& status) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static UBool _load() {\n    UErrorCode ec = U_ZERO_ERROR;\n    UDataMemory* data =\n        udata_openChoice(0, PNAME_DATA_TYPE, PNAME_DATA_NAME,\n                         isPNameAcceptable, 0, &ec);\n    if (U_SUCCESS(ec)) {\n        umtx_lock(NULL);\n        if (UDATA == NULL) {\n            UDATA = data;\n            PNAME = (const PropertyAliases*) udata_getMemory(UDATA);\n            ucln_common_registerCleanup(UCLN_COMMON_PNAME, pname_cleanup);\n            data = NULL;\n        }\n        umtx_unlock(NULL);\n    }\n    if (data) {\n        udata_close(data);\n    }\n    return PNAME!=NULL;\n}\n",
        "answer": "/** @brief Load the property names data.\n*\n*  This function loads the property names data and returns TRUE if the load succeeds.\n*  Caller should check that data is not loaded BEFORE calling this function.\n*\n* @return Returns TRUE if the load succeeds, FALSE otherwise.\n*/\nstatic UBool _load() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uiter_setState(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode) {\n    if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {\n        /* do nothing */\n    } else if(iter==NULL) {\n        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;\n    } else if(iter->setState==NULL) {\n        *pErrorCode=U_UNSUPPORTED_ERROR;\n    } else {\n        iter->setState(iter, state, pErrorCode);\n    }\n}\n",
        "answer": "/**\n* @brief Restore the \"state\" of the iterator using a state word from a getState() call.\n*\n* This is a convenience function that calls iter->setState(iter, state, pErrorCode) if iter->setState is not NULL; if it is NULL, then U_UNSUPPORTED_ERROR is set.\n*\n* @param iter The iterator to restore the state of.\n* @param state The state word from a getState() call.\n* @param pErrorCode A pointer to an error code value. If not NULL, it will be set to U_UNSUPPORTED_ERROR if iter->setState is NULL.\n*/\nvoid uiter_setState(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void set_current_from_steppers_for_axis(const AxisEnum axis) {\n  get_cartesian_from_steppers();\n  #if PLANNER_LEVELING\n    planner.unapply_leveling(cartes);\n  #endif\n  if (axis == ALL_AXES)\n    memcpy(current_position, cartes, sizeof(cartes));\n  else\n    current_position[axis] = cartes[axis];\n}\n",
        "answer": "/** @brief Set the current position for an axis based on the stepper positions, removing any leveling that may have been applied.\n*\n*  This function sets the current position for a specified axis based on the stepper positions, while also removing any leveling that may have been applied.\n*\n* @param axis The axis for which to set the current position.\n*/\nvoid set_current_from_steppers_for_axis(const AxisEnum axis) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M113() {\n    if (code_seen('S')) {\n      host_keepalive_interval = code_value_byte();\n      NOMORE(host_keepalive_interval, 60);\n    }\n    else {\n      SERIAL_ECHO_START;\n      SERIAL_ECHOLNPAIR(\"M113 S\", (unsigned long)host_keepalive_interval);\n    }\n  }\n",
        "answer": "/** @brief Get or set Host Keepalive interval (0 to disable) S<seconds> Optional. Set the keepalive interval.\n*\n* This function is used to get or set the host keepalive interval. If the 'S' parameter is seen, it sets the keepalive interval to the given value. Otherwise, it returns the current keepalive interval.\n*\n* @param code_seen Checks if the 'S' parameter is present in the input string.\n* @param code_value_byte Gets the value of the 'S' parameter as a byte.\n* @param host_keepalive_interval The current keepalive interval.\n* @return Should not return\n*/\nvoid gcode_M113() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M207() {\n    if (code_seen('S')) retract_length = code_value_axis_units(E_AXIS);\n    if (code_seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(code_value_axis_units(E_AXIS));\n    if (code_seen('Z')) retract_zlift = code_value_axis_units(Z_AXIS);\n    #if EXTRUDERS > 1\n      if (code_seen('W')) retract_length_swap = code_value_axis_units(E_AXIS);\n    #endif\n  }\n",
        "answer": "/**\n* @brief M207: Set firmware retraction values.\n*\n* This function sets the firmware retraction values for the printer. It takes\n* three parameters: S, F, and Z. The S parameter specifies the length of the\n* retract in units (either millimeters or inches, depending on the value of\n* the `units` variable). The F parameter specifies the feedrate at which to\n* retract in units per minute (either millimeters or inches, depending on the\n* value of the `units` variable). The Z parameter specifies the z-lift for the\n* retraction.\n*\n* If the printer has multiple extruders, the W parameter can be used to set\n* the length of the retract for each extruder individually.\n*\n* @param S The length of the retract in units.\n* @param F The feedrate at which to retract in units per minute.\n* @param Z The z-lift for the retraction.\n* @param W The length of the retract for each extruder (if applicable).\n*/\ninline void gcode_M207() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M355() {\n    if (code_seen('P')) case_light_brightness = code_value_byte();\n    if (code_seen('S')) case_light_on = code_value_bool();\n    update_case_light();\n    SERIAL_ECHO_START;\n    SERIAL_ECHOPGM(\"Case lights \");\n    case_light_on ? SERIAL_ECHOLNPGM(\"on\") : SERIAL_ECHOLNPGM(\"off\");\n  }\n",
        "answer": "/** @brief Turn case lights on/off and set brightness.\n*\n* This function turns the case light on or off and sets its brightness using a PWM pin.\n*\n* @param S bool Turn case light on or off.\n* @param P byte Set case light brightness (PWM pin required).\n*/\ninline void gcode_M355() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void getFileNames(int argumentCount, char *argumentArray[]) {\n    if (argumentCount < 2) {\n        songsPathMap[0] = \"You didn't provide a music file\\n\";\n    } else {\n        for (int argument = 0; argument < argumentCount - 1; ++argument) {\n            songsPathMap[argument] = argumentArray[argument + 1];\n            std::cout << argumentArray[argument + 1] << std::endl;\n        }\n    }\n}\n",
        "answer": "/** @brief Get file names from main() arguments.\n*\n* This function retrieves the file names passed as arguments to the main() function.\n* It checks if at least one file name was provided and stores it in a map. If no file names were provided,\n* it sets the first element of the map to \"You didn't provide a music file\\n\".\n*\n* @param argumentCount The number of arguments passed to main().\n* @param argumentArray An array of strings containing the arguments passed to main().\n* @return A map with the file names passed as arguments.\n*/\nvoid getFileNames(int argumentCount, char *argumentArray[]) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int roc_sender_close(roc_sender* sender) {\n    if (!sender) {\n        roc_log(LogError, \"roc_sender_close: invalid arguments: sender == NULL\");\n        return -1;\n    }\n\n    if (sender->writer) {\n        sender->context.trx.remove_port(sender->address);\n    }\n\n    roc_context& context = sender->context;\n\n    sender->context.allocator.destroy(*sender);\n    --context.counter;\n\n    roc_log(LogInfo, \"roc_sender: closed sender\");\n\n    return 0;\n}\n",
        "answer": "/** @brief Closes the ROC sender.\n*\n* This function closes the ROC sender and deinitializes and deallocates it from the context. The user should ensure that nobody uses the sender since this function is called. If this function fails, the sender is kept opened and attached to the context.\n*\n* @param[in] sender A pointer to the ROC sender to be closed.\n* @return 0 on success, -1 on failure.\n*/\nint roc_sender_close(roc_sender* sender) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int ScheduleBatchPriority()\n{\n#ifdef SCHED_BATCH\n    const static sched_param param{};\n    if (int ret = pthread_setschedparam(pthread_self(), SCHED_BATCH, &param)) {\n        LogPrintf(\"Failed to pthread_setschedparam: %s\\n\", strerror(errno));\n        return ret;\n    }\n    return 0;\n#else\n    return 1;\n#endif\n}\n",
        "answer": "/**\n* @brief Sets the batch priority for the current thread.\n*\n* On platforms that support it, this function sets the scheduling policy of the current thread to SCHED_BATCH and the priority to 0.\n*\n* @return 0 if successful, or an error code if unsuccessful.\n*/\nint ScheduleBatchPriority();"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool IsWithinAxisAlignedBox(const glm::vec2 &position, const glm::vec2 &minimum, const glm::vec2 &maximum) {\n\tauto actualMinimum = glm::vec2(std::min(minimum.x, maximum.x), std::min(minimum.y, maximum.y));\n\tauto actualMaximum = glm::vec2(std::max(minimum.x, maximum.x), std::max(minimum.y, maximum.y));\n\n\tbool xcheck = position.x >= actualMinimum.x && position.x <= actualMaximum.x;\n\tbool ycheck = position.y >= actualMinimum.y && position.y <= actualMaximum.y;\n\n\treturn xcheck && ycheck;\n}\n",
        "answer": "/** @brief Determines if 'position' is within (inclusive) the axis aligned box (2 dimensional) formed from the points minimum and maximum.\n*\n*  This function checks if a given position is within an axis-aligned box, which is defined by two points: minimum and maximum. The function returns true if the position is within the box, and false otherwise.\n*\n* @param position A glm::vec2 representing the position to be checked.\n* @param minimum A glm::vec2 representing the minimum point of the axis-aligned box.\n* @param maximum A glm::vec2 representing the maximum point of the axis-aligned box.\n* @return A boolean value indicating whether the position is within the axis-aligned box.\n*/\nbool IsWithinAxisAlignedBox(const glm::vec2 &position, const glm::vec2 &minimum, const glm::vec2 &maximum) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\t\tvoid SetXForm(Vector^ position, float32 rotation)\r\n\t\t\t{\r\n\t\t\t\tbody->SetXForm(position->getVec2(), rotation);\r\n\t\t\t}\r\n",
        "answer": "/** @brief Sets the position of the body's origin and rotation (radians).\n*\n*  This function sets the position of the body's origin and rotation (in radians) using the provided Vector and float32 values. It breaks any contacts and wakes the other bodies.\n*\n* @param position A Vector representing the new position of the body's origin.\n* @param rotation A float32 value representing the new rotation (in radians) of the body.\n*/\nvoid SetXForm(Vector^ position, float32 rotation)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  static std::string macBundlePath()\n  {\n    char path[1024];\n    CFBundleRef mainBundle = CFBundleGetMainBundle();\n    assert(mainBundle);\n\n    CFURLRef mainBundleURL = CFBundleCopyBundleURL(mainBundle);\n    assert(mainBundleURL);\n\n    CFStringRef cfStringRef = CFURLCopyFileSystemPath( mainBundleURL, kCFURLPOSIXPathStyle);\n    assert(cfStringRef);\n\n    CFStringGetCString(cfStringRef, path, 1024, kCFStringEncodingASCII);\n\n    CFRelease(mainBundleURL);\n    CFRelease(cfStringRef);\n\n    return std::string(path);\n  }\n",
        "answer": "/** @brief Returns the path of the main bundle for the macOS application.\n*\n* This function returns the path of the main bundle for the macOS application, which is the directory where the application's resources are located.\n*\n* @return The path of the main bundle as a string.\n*/\nstatic std::string macBundlePath()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void getCpsMass(double* const p_Cp) \n    {\n        const int ns = m_thermo.nSpecies();\n        m_thermo.speciesCpOverR(m_T, mp_work);\n\n        for(int i = 0; i < ns; ++i)\n            p_Cp[i] = mp_work[i]*RU/m_thermo.speciesMw(i);\n    }\n",
        "answer": "/** @brief Returns a vector of length n_species times n_energies with each corresponding cp per unit mass. Each n_species vector corresponds to a temperature in the state model. The first one is associated with the heavy particle translational temperature.\n*\n*  This function returns a vector of length n_species times n_energies with each corresponding cp per unit mass. Each n_species vector corresponds to a temperature in the state model. The first one is associated with the heavy particle translational temperature.\n*\n* @param p_Cp A pointer to an array of doubles that will be filled with the cp values.\n* @return void\n*/\nvoid getCpsMass(double* const p_Cp)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void getCvsMass(double* const p_Cv)\n    {       \n        int ns = m_thermo.nSpecies();\n        int offset = (m_thermo.hasElectrons() ? 1 : 0);\n        m_thermo.speciesCpOverR(\n\t\t\tm_T, m_Tv, m_T, m_Tv, m_Tv, NULL, mp_work1, mp_work2, mp_work3, mp_work4);\n\n        for(int i = offset; i < ns; ++i)\n            p_Cv[i] = (mp_work1[i]+mp_work2[i]-1.0)*RU/m_thermo.speciesMw(i);\n        for(int i = offset; i < ns; ++i)\n            p_Cv[i+ns] = (mp_work3[i]+mp_work4[i])*RU/m_thermo.speciesMw(i);\n        if(m_thermo.hasElectrons()) {\n            p_Cv[0] = 0.0;\n            p_Cv[ns] = (mp_work1[0]-1.0)*RU/m_thermo.speciesMw(0);\n        }\n    }\n",
        "answer": "/**\n* @brief Calculates the specific heat capacity per unit mass for each species at a given temperature.\n*\n* This function calculates the specific heat capacity per unit mass for each species in the system,\n* based on the number of species and energies. The first n_species vector corresponds to the heavy particle\n* translational temperature.\n*\n* @param p_Cv A pointer to an array of length n_species times n_energies with each corresponding cp per unit mass.\n*/\nvoid getCvsMass(double* const p_Cv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void hE(double T, double* const p_h, const OP& op)\n    {\n        updateElecBoltzmannFactors(T);\n        op(p_h[0], 0.0);\n\n        double* facs = mp_el_bfacs;\n        for (int i = 0; i < m_elec_data.nheavy; ++i, facs += 3) {\n            if (facs[0] > 0)\n                op(p_h[i+m_elec_data.offset], facs[1]/facs[0]);\n            else\n                op(p_h[i+m_elec_data.offset], 0.0);\n        }\n    }\n",
        "answer": "/** @brief Computes the electronic enthalpy of each species in K and applies the value to the enthalpy array using the given operation.\n*\n*  This function computes the electronic enthalpy of each species in Kelvin (K) and applies the value to the enthalpy array using the given operation.\n*\n* @param T The temperature in Kelvin (K).\n* @param p_h A pointer to an array of enthalpies for each species.\n* @param op An operation to apply to the enthalpy array.\n*/\nvoid hE(double T, double* const p_h, const OP& op)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "extern \"C\" void AsebaPutVmToSleep(AsebaVMState* vm) {\n    std::cerr << \"AsebaPutVmToSleep\" << std::endl;\n}\n",
        "answer": "/** @brief AsebaPutVmToSleep.\n*\n*  This function is called by AsebaVMDebugMessage when VM must put to node in deep sleep.\n*  It is an empty function that leaves the feature unsupported.\n*\n* @param vm The AsebaVMState object.\n* @return void.\n*/\nextern \"C\" void AsebaPutVmToSleep(AsebaVMState* vm) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void apigee_plcrash_async_image_list_set_reading (apigee_plcrash_async_image_list_t *list, bool enable) {\n    list->_list->set_reading(enable);\n}\n",
        "answer": "/** @brief Sets the reading state of the image list.\n*\n* This function sets the reading state of the image list to either enabled or disabled.\n* It is important to call this method prior to attempting to iterate the list, and must be called again once reads have completed.\n*\n* @param list The image list to set the reading state for.\n* @param enable A boolean value indicating whether reading should be enabled (true) or disabled (false).\n*/\nvoid apigee_plcrash_async_image_list_set_reading(apigee_plcrash_async_image_list_t *list, bool enable);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\n\r\n#ifdef CRYPTOPP_GNU_STYLE_INLINE_ASSEMBLY\r\nextern \"C\" {\r\n    typedef void (*SigHandler)(int);\r\n\r\n    static jmp_buf s_jmpSIGILL;\r\n    static void SigIllHandler(int)\r\n    {\r\n        longjmp(s_jmpSIGILL, 1);\r\n    }\r\n}\r\n",
        "answer": "/** @brief Wake stream cipher information. Hash size in bytes. The DSA signature format used by Crypto++ is as defined by IEEE P1363. Java and .Net use the DER format, and OpenPGP uses the OpenPGP format. A trapdoor function is a function that is easy to compute in one direction, but difficult to compute in the opposite direction without special knowledge. The special knowledge is usually the private key.\n*/\nNAMESPACE_BEGIN(CryptoPP)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "NAMESPACE_BEGIN(CryptoPP)\r\nNAMESPACE_BEGIN(Weak1)\r\n\r\n#if defined(CRYPTOPP_DEBUG) && !defined(CRYPTOPP_DOXYGEN_PROCESSING)\r\nvoid MD5_TestInstantiations()\r\n{\r\n\tMD5 x;\r\n}\r\n",
        "answer": "/** @brief Create a doxygen comment for the following C++ Function.\n*/\nvoid MD5_TestInstantiations()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void reset() {\n    if (montage_width_ != 0) {\n      if (montage_buffer_ != nullptr) {\n        delete_buffer(device_, montage_buffer_);\n      }\n      montage_buffer_ =\n          new_buffer(device_, montage_width_ * montage_height_ * 3);\n      montage_image_ =\n          cv::Mat(montage_height_, montage_width_, CV_8UC3, montage_buffer_);\n      montage_image_.setTo(0);\n      frames_seen_ = 0;\n    }\n  }\n",
        "answer": "/** @brief Resets the kernel state.\n*\n*  This function resets the state of the kernel, clearing any logical state that may have been accumulated from previous inputs. It is called by the scanner when non-consecutive inputs or inputs from a different slice are provided, allowing unbounded or bounded state kernels to reset their state.\n*\n* @return void\n*/\nvoid reset() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    FB::PluginCorePtr createPlugin(const std::string& mimetype)\n    {\n        return boost::make_shared<PowderNPAPI>();\n    }\n",
        "answer": "/** @brief Creates a plugin object matching the provided mimetype.\n*\n*  This function creates a plugin object that matches the provided mimetype. If mimetype is empty, returns the default plugin.\n*\n* @param[in] mimetype The mimetype of the plugin to be created.\n* @return A shared pointer to the created plugin object.\n*/\nFB::PluginCorePtr createPlugin(const std::string& mimetype)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual size_t suggestBufferSize ()\n\t\t{\n\t\t\treturn Camera::suggestBufferSize () + 4;\n\t\t}\n",
        "answer": "/** @brief Suggest size of data buffer.\n*\n* This function suggests the size of the data buffer used to readout and send the data. It should be big enough to hold the largest element which is possible to get from the camera driver. The default return value is the full chip size, but it can be overwritten in descendants.\n*\n* @return The suggested buffer size.\n*/\nvirtual size_t suggestBufferSize ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual int isParking () { return isMoving (); };\n",
        "answer": "/** @brief Check if telescope is parking. Called during telescope park to detect if parking position was reached.\n*\n*  This function checks if the telescope is currently in the process of parking. It does this by calling the isMoving() function, which returns a boolean indicating whether the telescope is currently moving or not. If the telescope is moving, it means that it has not yet reached its parking position and therefore the function returns 1 to indicate that the telescope is still parking. If the telescope is not moving, it means that it has reached its parking position and the function returns 0 to indicate that the telescope is no longer parking.\n*\n* @return Returns 1 if the telescope is still parking, or 0 if the telescope has reached its parking position.\n*/\nvirtual int isParking () "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual long isClosed ()\n\t\t{\n\t\t\tif ((getState () & DOME_DOME_MASK) == DOME_OPENED)\n\t\t\t\treturn 0;\n\t\t \tif ((getState () & DOME_DOME_MASK) == DOME_CLOSED)\n\t\t\t\treturn -2;\n\t\t\treturn isMoving ();\n\t\t}\n",
        "answer": "/** @brief Check if dome is closed.\n*\n*  This function is called to check if the dome is closed. It is also called outside of the closing sequence, to check if the dome is closed when bad weather arrives. When implemented correctly, it should check the state of the dome end switches and return proper values.\n*\n* @return 0 if the dome is open, -2 if the dome is closed, or the result of isMoving() if the dome is moving.\n*/\nvirtual long isClosed ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual int isMovingFixed ()\n\t\t{\n\t\t\treturn isMoving ();\n\t\t}\n",
        "answer": "/** @brief Check if telescope is moving to fixed position. Called during telescope movement to detect if the target destination was reached.\n*\n*  This function checks if the telescope is moving to a fixed position. It is called during telescope movement to detect if the target destination has been reached.\n*\n* @return Returns 1 if the telescope is moving to a fixed position, and 0 otherwise.\n*/\nvirtual int isMovingFixed ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual bool isGoodWeather ()\n\t\t\t{\n\t\t\t\treturn goodWeather->getValueBool ();\n\t\t\t}\n",
        "answer": "/** @brief Checks if sensor does not block observing.\n*\n*  This function is called to check if the weather conditions are suitable for observations.\n*  It returns false if the weather does not allow observations to be performed.\n*\n* @return A boolean value indicating whether the weather is good for observing or not.\n*/\nvirtual bool isGoodWeather ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tstd::string help() { return std::string(\"Retrieve the help string for a named method\"); }\n",
        "answer": "/** @brief Retrieve the help string for a named method.\n*\n*  This function returns a help string for a named method. Subclasses should define this method if introspection is being used.\n*\n* @return A help string for the named method.\n*/\nstd::string help() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\t\tvirtual void postEvent (rts2core::Event *event)\n\t\t{\n\t\t\tswitch (event->getType ())\n\t\t\t{\n\t\t\t\tcase EVENT_TERMINATE_TEST:\n\t\t\t\t\tterminate ();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\trts2script::ConnExe::postEvent (event);\n\t\t}\n",
        "answer": "/** @brief Distribute event through class.\n*\n*  This method is hook for descendands to distribute Event. Every descendand overwriting it should call ancestor postEvent method at the end, so the event object will be deleted. Ussuall implementation looks like:\n*\n* @param event The event to be distributed.\n* @return Should not return\n*/\nvirtual void postEvent (rts2core::Event *event)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DWORD kexGetVersion()\r\n{\r\n\treturn GetVersion();\r\n}\r\n",
        "answer": "/** @brief Obtain original Windows version number. Refer to GetVersion API documentation for parameters and output.\n*\n* This function obtains the original Windows version number using the GetVersion API.\n*\n* @return The original Windows version number.\n*/\nDWORD kexGetVersion()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void sendNoteOn(uint8_t note, uint8_t velocity, uint8_t channel)\n    {\n    if (bypassOut) return;\n  \n#ifdef INCLUDE_OPTIONS_TRANSPOSE_AND_VOLUME\n    int16_t n = note + (uint16_t)options.transpose;\n    n = bound(n, 0, 127);\n    uint16_t v = velocity;\n    if (options.volume < 3)\n        v = v >> (3 - options.volume);\n    else if (options.volume > 3)\n        v = v << (options.volume - 3);\n    if (v > 127) v = 127;\n    MIDI.sendNoteOn((uint8_t) n, (uint8_t) v, channel);\n#else\n    MIDI.sendNoteOn(note, velocity, channel);\n#endif\n\n    TOGGLE_OUT_LED();\n    }\n",
        "answer": "/**\n* @brief Sends a note on, transposing as appropriate, and adjusting the velocity as appropriate. Also sends out CV.\n*\n* This function sends a MIDI note on message with the specified note, velocity, and channel. If the `bypassOut` flag is set, the function returns immediately without sending any messages.\n*\n* If the `INCLUDE_OPTIONS_TRANSPOSE_AND_VOLUME` macro is defined, the function will transpose the note by the value of `options.transpose`, bounding the result to the range 0-127. It will also adjust the velocity based on the value of `options.volume`, shifting it left or right by the difference between 3 and `options.volume`. The resulting velocity is then bounded to the range 0-127.\n*\n* Finally, the function sends a MIDI note on message with the transposed/adjusted note and velocity values, using the specified channel.\n*\n* @param[in] note The MIDI note number to send (0-127).\n* @param[in] velocity The velocity of the note (0-127).\n* @param[in] channel The MIDI channel to use for sending the message (0-15).\n*\n* @return None.\n*/\nvoid sendNoteOn(uint8_t note, uint8_t velocity, uint8_t channel)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void stopAudio( const SourceInfo &sourceInfo )\r\n{\r\n\tif( sourceInfo.isValid() )\r\n\t{\r\n\t\tQMutexLocker locker( &gMutex );\r\n\t\tPrivateImpl::applyThreadContext( sourceInfo.getOutputInfo() );\r\n\t\tPrivateImpl::updateSourceOptions( sourceInfo );\r\n\t\tProxies::alSourceStop( PrivateImpl::querySource( sourceInfo ) );\r\n\t}\r\n}\r\n",
        "answer": "/** @brief Stops audio playback.\n*\n* This function stops audio playback of a given audio source (e.g. if source is playing a looping audio data). Modifies also source's options if the source already exists.\n*\n* @param[in] sourceInfo The SourceInfo object containing information about the audio source to stop.\n* @return void\n*/\nvoid stopAudio( const SourceInfo &sourceInfo )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "CL_NS_USE(util)\nCL_NS_USE(store)\nCL_NS_DEF(index)\n\n\n  class IndexReaderFindSegmentsFile: public SegmentInfos::FindSegmentsFile<uint64_t>{\n  public:\n\t\tIndexReaderFindSegmentsFile( CL_NS(store)::Directory* dir ):\n\t\t\tSegmentInfos::FindSegmentsFile<uint64_t>(dir){\n\t\t}\n\t\tIndexReaderFindSegmentsFile( const char* dir ):\n\t\t\tSegmentInfos::FindSegmentsFile<uint64_t>(dir){\n\t\t}\n    uint64_t doBody(const char* segmentFileName){\n      return directory->fileModified(segmentFileName);\n    }\n  };\n",
        "answer": "/**\n* @brief A class that finds the segments file in a directory.\n*\n* This class is used to find the segments file in a directory, which contains information about the\n* segments in the index. It is used by the IndexReader class to load the segments file and retrieve\n* information about the segments.\n*/\n/**\n* @brief Constructs a new instance of this class with the specified directory.\n*\n* @param dir The directory to search for the segments file in.\n*/\n/**\n* @brief Constructs a new instance of this class with the specified directory path.\n*\n* @param dir The path to the directory to search for the segments file in.\n*/\n/**\n* @brief Performs the actual work of finding the segments file in the directory.\n*\n* This method is called by the `doBody` method and performs the actual work of finding the\n* segments file in the directory. It returns the modified time of the segments file, which can be\n* used to determine if the file has changed since it was last loaded.\n*\n* @param segmentFileName The name of the segments file to find.\n*\n* @return The modified time of the segments file, or 0 if the file could not be found.\n*/\nuint64_t doBody(const char* segmentFileName);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    virtual void copy(int32_t /*start*/, int32_t /*limit*/, int32_t /*dest*/) {\n        /* do nothing */\n    }\n",
        "answer": "/** @brief Copies a substring of this object, retaining metadata. This method is used to duplicate or reorder substrings. The destination index must not overlap the source range.\n*\n* @param start The starting index of the substring to copy.\n* @param limit The ending index of the substring to copy.\n* @param dest The destination index where the substring will be copied.\n*/\n/* do nothing */\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, const char* argv[]){\n    UErrorCode status = U_ZERO_ERROR;\n    ConverterPerformanceTest test(argc, argv, status);\n    if(U_FAILURE(status)){\n        return status;\n    }\n    if(test.run()==FALSE){\n        fprintf(stderr,\"FAILED: Tests could not be run please check the arguments.\\n\");\n        return -1;\n    }\n    return 0;\n}\n",
        "answer": "/**\n* @brief Main entrypoint of the program.\n*\n* This function serves as the main entrypoint of the program, and is responsible for parsing command line arguments and running the performance test.\n*\n* @param argc The number of command line arguments passed to the program.\n* @param argv An array of strings containing the command line arguments passed to the program.\n* @return 0 if the tests were run successfully, -1 if there was an error running the tests.\n*/\nint main(int argc, const char* argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void mergeFinalZone(const pair<string,FinalZone>& p) {\n    const string& id = p.first;\n    const FinalZone& fz = p.second;\n\n    mergeOne(id, fz);\n}\n",
        "answer": "/** @brief Visitor function that merges the final zone data into the main zone data structures.\n*\n*  This function calls mergeOne for each final zone and its list of aliases.\n*\n* @param p A pair containing the string ID of the final zone and the FinalZone object itself.\n*/\nvoid mergeFinalZone(const pair<string,FinalZone>& p) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Bool RegisterXPressoEffector() {\n    Bool ok = RegisterEffectorPlugin(\n            ID_XPRESSOEFFECTOR,\n            GeLoadString(IDC_XPRESSOEFFECTOR_NAME),\n            OBJECT_MODIFIER | PLUGINFLAG_HIDEPLUGINMENU | OBJECT_CALL_ADDEXECUTION,\n            XPressoEffectorData::Alloc,\n            \"Oxpressoeffector\",\n            AutoBitmap(\"Oxpressoeffector.tif\"),\n            XPRESSOEFFECTOR_VERSION);\n    if (!ok) {\n        GePrint(GeLoadString(IDC_MODATANODE_NOTREGISTERED));\n        return FALSE;\n    }\n    return TRUE;\n}\n",
        "answer": "/** @brief Registers the XPresso effector plugin.\n*\n*  This function registers the XPresso effector plugin with the system. It is called during the initialization of the plugin and should not be called directly by the user.\n*\n* @return TRUE if the plugin was registered successfully, FALSE otherwise.\n*/\nBool RegisterXPressoEffector() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "jint JNI_OnLoad(JavaVM *vm, void *reserved) {\n    LOGD(\"begin JNI_OnLoad\");\n    JNIEnv *env;\n    /* Get environment */\n    if ((vm)->GetEnv((void **) &env, JNI_VERSION_1_4) != JNI_OK) {\n        return JNI_FALSE;\n    }\n\n    sVm = vm;\n    jclass tempClass = env->FindClass(\n            \"com/taobao/weex/bridge/WXBridge\");\n    jBridgeClazz = (jclass) env->NewGlobalRef(tempClass);\n    env->DeleteLocalRef(tempClass);\n    LOGD(\"end JNI_OnLoad\");\n    return JNI_VERSION_1_4;\n}\n",
        "answer": ""
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void custom_reset_128bits_uuid_table() {\r\n    uuidTableEntries = 0;\r\n}\r\n",
        "answer": "/** @brief Resets the table of 128-bit UUIDs.\n*\n* This function resets the table of 128-bit UUIDs used to keep track of vendors' UUIDs added to the softdevice. It is important to reset it before disabling the softdevice otherwise the next time the softdevice will be enabled, this table will not be synchronized with the softdevice table.\n*\n* @return Should not return\n*/\nvoid custom_reset_128bits_uuid_table() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string pt_to_string(double value)\n\n  {\n    string result;\n    stringstream str_stream;\n\n    str_stream << value;\n\n    result = str_stream.str();\n    return result;\n  }\n",
        "answer": "/** @brief Converts double to string.\n*\n* This function converts a double value to a string. It works the same way as std::to_string but is used rather because to_string causes problems with MinGW.\n*\n* @param[in] value The double value to convert.\n* @return The converted string.\n*/\nstring pt_to_string(double value)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void i86_pit_send_command (uint8_t cmd) {\r\n\r\n\toutportb (I86_PIT_REG_COMMAND, cmd);\r\n}\r\n",
        "answer": "/** @brief Send operational command to PIT.\n*\n*  This function sets up the operational command by using the operational command bit masks and setting them with the control bits. It should not be used outside the interface.\n*\n* @param cmd The operational command to send to the PIT.\n*\n* @return None.\n*/\nvoid i86_pit_send_command (uint8_t cmd) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool CheckExceptionCode(DWORD exceptCode, DWORD expectedExceptCode)\n{\n    if (exceptCode != expectedExceptCode) \n    {\n        cout << \"Unexpected exception code \" << \n            hex << exceptCode << \". Should be \" << \n            hex << expectedExceptCode << endl; \n        return false;\n    }\n    return true;\n}\n",
        "answer": "/**\n* @brief Checks if the specified exception record represents an exception with the specified exception code.\n*\n* This function checks if the exception code in the specified exception record matches the expected exception code. If they do not match, it prints an error message to the console and returns false. Otherwise, it returns true.\n*\n* @param exceptCode The exception code to check.\n* @param expectedExceptCode The expected exception code.\n* @return True if the specified exception record represents an exception with the specified exception code, or false otherwise.\n*/\nstatic bool CheckExceptionCode(DWORD exceptCode, DWORD expectedExceptCode)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void CheckExceptionAddr(EXCEPTION_RECORD * pExceptRecord, \n                               void * insPtr,\n                               size_t insSize)\n{\n    ULONG_PTR exceptAddress = (ULONG_PTR)(pExceptRecord->ExceptionAddress);\n    ULONG_PTR insStart = (ULONG_PTR)insPtr;\n    ULONG_PTR insEnd = insStart + insSize;\n\n    if ((exceptAddress < insStart) || (exceptAddress > insEnd))\n    {\n        Abort(\"Incorrect exception address\");\n    }\n}\n",
        "answer": "/** @brief Checks the exception address.\n*\n*  This function checks if the specified exception record represents an exception that occurred in the specified instruction. The exception could be a trap reported after the instruction.\n*\n* @param pExceptRecord Pointer to the exception record.\n* @param insPtr Pointer to the instruction.\n* @param insSize Size of the instruction.\n* @return Should not return.\n*/\nvoid CheckExceptionAddr(EXCEPTION_RECORD * pExceptRecord, void * insPtr, size_t insSize)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void onMessage(struct mosquitto *mosq, void *userdata, const struct mosquitto_message *message) {\n\tif(message->payloadlen) {\n\t\tprintf(\"Topic: %s, Message: %s\\n\", (char*)message->topic, (char*)message->payload);\n\t} else {\n\t\tprintf(\"Topic: %s, Message: (null)\\n\", message->topic);\n\t}\n\tfflush(stdout);\n}\n",
        "answer": "/**\n* @brief Callback on receiving messages.\n*\n* This method is the callback on receiving messages. It is event-driven, meaning you don't call it in your code. Instead, it is called by the library when a message is received.\n*\n* The method prints the message topic and payload to the console. Other callback functions provided by this library include onConnect(), onDisconnect(), and onSubscribe().\n*\n* @param mosq A pointer to the mosquitto struct representing the MQTT client.\n* @param userdata A pointer to the user data associated with the MQTT client.\n* @param message A pointer to the received message.\n*/\nvoid onMessage(struct mosquitto *mosq, void *userdata, const struct mosquitto_message *message) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "ft_token_span::int_t max( FTTokenSpanSequenceType &seq,\n                          ft_token_span::start_end_ptr sep,\n                          ft_token_span::int_ptr ip ) {\n  typedef ft_token_span::int_t int_t;\n  int_t result = numeric_limits<int_t>::min();\n  FOR_EACH( typename FTTokenSpanSequenceType, ts, seq ) {\n    int_t const n = (*ts).*sep.*ip;\n    if ( n > result )\n      result = n;\n  }\n  return result;\n}\n",
        "answer": "/** @brief Computes the maximum value of N from a sequence of ft_token_spans.\n*\n* This function computes the maximum value of N from a sequence of ft_token_spans, where N is specified by the pointers-to-members.\n*\n* @param seq A reference to the sequence of ft_token_spans.\n* @param sep A pointer-to-member that specifies the start and end of each token span.\n* @param ip A pointer-to-member that specifies the integer value to be used for the computation.\n* @return The maximum value of N from the sequence of ft_token_spans.\n*/\nft_token_span::int_t max( FTTokenSpanSequenceType &seq,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned decode_base128( char const **p ) {\n  unsigned char const *&u = *reinterpret_cast<unsigned char const**>( p );\n  unsigned n = 0;\n  do {\n    n = (n << 7) | (*u & 0x7F);\n  } while ( *u++ & 0x80 );\n  return n;\n}\n",
        "answer": "/** @brief Decodes an unsigned integer from a base-128 binary-encoded representation (BER) from an encoded byte sequence.\n*\n* This function decodes an unsigned integer from a base-128 binary-encoded representation (BER) from an encoded byte sequence.\n* The function takes a pointer to the encoded data as input and returns the decoded unsigned integer.\n* The function uses a do-while loop to decode the data, shifting the bits of the current byte to the left by 7 positions and\n* ORing it with the next byte until the most significant bit (MSB) of the current byte is not set.\n*\n* @param p A pointer to the encoded data.\n* @return The decoded unsigned integer.\n*/\nunsigned decode_base128(char const **p) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static int Zorba_GetLocaleInfoEx( LPCWSTR lpLocaleName, LCTYPE LCType,\n                                  LPWSTR lpLCData, int cchData ) {\n  typedef int (WINAPI *GetLocaleInfoEx_type)( LPCWSTR, LCTYPE, LPWSTR, int );\n\n  static GetLocaleInfoEx_type GetLocaleInfoEx_ptr;\n  static bool init;\n\n  if ( !init ) {\n    GetLocaleInfoEx_ptr = (GetLocaleInfoEx_type)::GetProcAddress(\n      ::GetModuleHandle( TEXT( \"kernel32.dll\" ) ), \"GetLocaleInfoEx\"\n    );\n    init = true;\n  }\n\n  return GetLocaleInfoEx_ptr ?\n    GetLocaleInfoEx_ptr( lpLocaleName, LCType, lpLCData, cchData ) : 0;\n}\n",
        "answer": "/**\n* @brief Zorba_GetLocaleInfoEx is a wrapper function for GetLocaleInfoEx that checks if it's available on Windows Vista and later.\n*\n* This function checks if GetLocaleInfoEx is available by checking the version of Windows using GetVersionEx. If the version is Windows Vista or later, it calls GetLocaleInfoEx indirectly using GetProcAddress. Otherwise, it returns 0.\n*\n* @param lpLocaleName The locale name to retrieve information about.\n* @param LCType The type of locale information to retrieve.\n* @param lpLCData A pointer to a buffer in which this function retrieves the requested locale information.\n* @param cchData The size of the buffer pointed to by lpLCData, in characters.\n*\n* @return If the function succeeds, the return value is the number of characters retrieved. If the function fails, the return value is 0. To get extended error information, call GetLastError.\n*/\nstatic int Zorba_GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int cell_should_split(struct grid * g, Cell cell)\n{\n\tdouble r = base_radius;\n\n    double x = cell.RealArrayDF(g->c_tags.center)[0]; \n    double y = cell.RealArrayDF(g->c_tags.center)[1];\n    int c_level = cell.Integer(g->c_tags.level);\n\n\tif ((x-mx)*(x-mx)+(y-my)*(y-my) < r)\n    {\n        if (c_level < refine_depth) return 1;\n    }\n\n    for (int level = 2; level <= refine_depth; level++)\n    {\n\t    if ((x-mx)*(x-mx)+(y-my)*(y-my) < r*5*(level-1))\n            if (c_level < refine_depth - level + 1) return 1;\n    }\n    return 0;\n}\n",
        "answer": "/** @brief Determines whether a cell should be split.\n*\n*  This function is used by the octgrid algorithm to determine if a cell should be split based on its position and level.\n*\n* @param g Pointer to the grid structure.\n* @param cell The cell to check for splitting.\n* @return 1 if the cell should be split, 0 otherwise.\n*/\nint cell_should_split(struct grid *g, Cell cell)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int is_file_stale(FILE *tocheck_file) {\n#ifdef ENABLE_DETECT_FILE_STALE\n    assert(tocheck_file);\n    struct stat st_info;\n    return fstat(fileno(tocheck_file), &st_info) == -1 /*errno == 116, ESTALE*/;\n#else\n    return 0;\n#endif\n}\n",
        "answer": "/** @brief Checks if a file is stale.\n*\n*  This function checks if a file is stale by using fstat or access().\n*\n* @param tocheck_file The file to check.\n* @return 1 if the file is stale, 0 otherwise.\n*/\nint is_file_stale(FILE *tocheck_file) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  virtual void init() {\r\n    insert<System1>();\r\n    insert<System2>();\r\n    insert<System3>();\r\n    insert<System4>();\r\n    insert<System5>();\r\n    insert<System6>();\r\n    insert<System7>();\r\n    insert<System8>();\r\n    insert<System11>();\r\n    insert<BollingerBandSystem>();\r\n    insert<ExtTradesSystem>();\r\n    insert<SimpleTradingSystem>();\r\n    insert<BollingerBandClassicSystem>();\r\n    insert<MAMA_ttrcrep>();\r\n    insert<AdaptiveBBands>();\r\n    insert<LongShortKeltnerBands>();\r\n    insert<MFISystem>();\r\n    insert<CalendarSystem>();\r\n  }\r\n",
        "answer": "/** @brief Plugin startup initialization.\n*\n*  This method inserts all the available configuration in an internal collection. The method insert is called to do the actual initialization\n*\n* @return Should not return\n*/\nvirtual void init() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  bool preprocess(const Scene *scene, RenderQueue *queue,\n      const RenderJob *job, int sceneResID, int sensorResID,\n      int samplerResID) {\n    if(!m_twostepalgo)\n      m_subIntegrator->preprocess(scene, queue, job, sceneResID, sensorResID, samplerResID);\n    m_stop = false;\n    return true;\n  }\n",
        "answer": "/** @brief Preprocess the rendering queue before the main rendering process.\n*\n* This function is called automatically before the main rendering process; the default implementation does nothing. The last three parameters are resource IDs of the associated scene, sensor and sample generator, which have been made available to all local and remote workers.\n*\n* @param[in] scene The scene to be rendered.\n* @param[out] queue The render queue to be processed.\n* @param[in] job The render job to be processed.\n* @param[in] sceneResID The resource ID of the associated scene.\n* @param[in] sensorResID The resource ID of the associated sensor.\n* @param[in] samplerResID The resource ID of the associated sample generator.\n* @return Whether the preprocessing was successful or not.\n*/\nbool preprocess(const Scene *scene, RenderQueue *queue, const RenderJob *job, int sceneResID, int sensorResID, int samplerResID) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  bool preprocess(const Scene *scene, RenderQueue *queue,\n                  const RenderJob *job, int sceneResID, int sensorResID,\n                  int samplerResID) {\n    m_subIntegrator->preprocess(scene, queue, job, sceneResID, sensorResID, samplerResID);\n    m_stop = false;\n    return true;\n  }\n",
        "answer": "/** @brief Preprocess the rendering queue.\n*\n* This function is called automatically before the main rendering process; the default implementation does nothing. The last three parameters are resource IDs of the associated scene, sensor and sample generator, which have been made available to all local and remote workers.\n*\n* @param[in] scene The scene to preprocess.\n* @param[out] queue The rendering queue to populate.\n* @param[in] job The render job to process.\n* @param[in] sceneResID The resource ID of the associated scene.\n* @param[in] sensorResID The resource ID of the associated sensor.\n* @param[in] samplerResID The resource ID of the associated sample generator.\n* @return True if preprocessing was successful, false otherwise.\n*/\nbool preprocess(const Scene* scene, RenderQueue* queue, const RenderJob* job, int sceneResID, int sensorResID, int samplerResID) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Spectrum fresnelConductorExact(Float cosThetaI, const Spectrum &eta, const Spectrum &k) {\n\t/* Modified from \"Optics\" by K.D. Moeller, University Science Books, 1988 */\n\n\tFloat cosThetaI2 = cosThetaI*cosThetaI,\n\t      sinThetaI2 = 1-cosThetaI2,\n\t\t  sinThetaI4 = sinThetaI2*sinThetaI2;\n\n\tSpectrum temp1 = eta*eta - k*k - Spectrum(sinThetaI2),\n\t         a2pb2 = (temp1*temp1 + k*k*eta*eta*4).safe_sqrt(),\n\t         a     = ((a2pb2 + temp1) * 0.5f).safe_sqrt();\n\n\tSpectrum term1 = a2pb2 + Spectrum(cosThetaI2),\n\t         term2 = a*(2*cosThetaI);\n\n\tSpectrum Rs2 = (term1 - term2) / (term1 + term2);\n\n\tSpectrum term3 = a2pb2*cosThetaI2 + Spectrum(sinThetaI4),\n\t         term4 = term2*sinThetaI2;\n\n\tSpectrum Rp2 = Rs2 * (term3 - term4) / (term3 + term4);\n\n\treturn 0.5f * (Rp2 + Rs2);\n}\n",
        "answer": "/** @brief Spectrum fresnelConductorExact(Float cosThetaI, const Spectrum &eta, const Spectrum &k)\n* This function computes the exact unpolarized Fresnel reflectance for a complex index of refraction change. The name of this function is a slight misnomer, since it supports the general case of a complex-valued relative index of refraction (rather than being restricted to conductors)\n* @param cosThetaI  Float value of cos(theta_i), where theta_i is the angle between the input and normal vectors.\n* @param eta Spectrum value of the relative refractive index for each wavelength.\n* @param k Spectrum value of the imaginary part of the relative refractive index for each wavelength.\n* @return Spectrum value of the exact unpolarized Fresnel reflectance for a complex index of refraction change.\n*/\n/* Modified from \"Optics\" by K.D. Moeller, University Science Books, 1988 */\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int CPns_IsOutOfPhase(const CPnsData *pPnsData,\n                      const int group,\n                      const int band)\n{\n  CPnsInterChannelData *pInterChannelData = pPnsData->pPnsInterChannelData;\n  unsigned pns_band = group*16+band;\n\n  return (pInterChannelData->correlated[pns_band] & 0x02) ? 1 : 0;\n}\n",
        "answer": "/** @brief Checks if the noise correlation between channel pairs is activated in out-of-phase mode.\n*\n* This function checks if the noise correlation between channel pairs is activated in out-of-phase mode.\n* It takes a pointer to a CPnsData structure, a group number, and a band number as input.\n* The function returns 1 if the noise correlation is activated in out-of-phase mode, and 0 otherwise.\n*\n* @param pPnsData Pointer to a CPnsData structure.\n* @param group Group number.\n* @param band Band number.\n* @return 1 if the noise correlation is activated in out-of-phase mode, 0 otherwise.\n*/\nint CPns_IsOutOfPhase(const CPnsData *pPnsData, const int group, const int band) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "INT FDKcrcStartReg(\n        HANDLE_FDK_CRCINFO              hCrcInfo,\n        const HANDLE_FDK_BITSTREAM      hBs,\n        const INT                       mBits\n        )\n{\n  int reg = hCrcInfo->regStart;\n\n  FDK_ASSERT(hCrcInfo->crcRegData[reg].isActive==0);\n  hCrcInfo->crcRegData[reg].isActive      = 1;\n  hCrcInfo->crcRegData[reg].maxBits       = mBits;\n  hCrcInfo->crcRegData[reg].validBits     = FDKgetValidBits(hBs) ;\n  hCrcInfo->crcRegData[reg].bitBufCntBits = 0;\n\n  hCrcInfo->regStart = (hCrcInfo->regStart+1)%MAX_CRC_REGS;\n\n  return (reg);\n}\n",
        "answer": "/**\n* @brief Marks position in bitstream to be used as start point for crc calculation.\n*\n* This function marks position in bitstream to be used as start point for crc calculation. Bitstream range for crc calculation can be limited or kept dynamic depending on mBits parameter. The crc region has to be terminated with FDKcrcEndReg() in each case.\n*\n* @param hCrcInfo Handle to the CRC information structure.\n* @param hBs Handle to the bitstream.\n* @param mBits Maximum number of bits to use for crc calculation.\n*\n* @return The index of the start position in the bitstream.\n*/\nINT FDKcrcStartReg(HANDLE_FDK_CRCINFO hCrcInfo, const HANDLE_FDK_BITSTREAM hBs, const INT mBits)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void  FDKprintfErr( const char* szFmt, ...) {\n  va_list ap;\n  va_start(ap, szFmt);\n#if defined(ARCH_WA_SLOWCON)\n  vprintf(szFmt, ap);\n#else\n  vfprintf(stderr, szFmt, ap);\n#endif\n  va_end(ap);\n#ifdef ARCH_WA_FLUSH_CONSOLE\n  fflush(stderr);\n#endif\n}\n",
        "answer": "/** @brief Prints an error message to the console using stderr.\n*\n* This function is used to print error messages to the console using stderr. It takes a variable number of arguments, similar to printf().\n*\n* @param szFmt The format string for the error message.\n* @param ap The list of arguments for the format string.\n*\n* @return Should not return\n*/\nvoid FDKprintfErr( const char* szFmt, ...) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "TRANSPORTDEC_ERROR adtsRead_CrcCheck( HANDLE_ADTS pAdts )\n{\n  TRANSPORTDEC_ERROR ErrorStatus = TRANSPORTDEC_OK;\n  USHORT crc;\n\n  if (pAdts->bs.protection_absent)\n    return TRANSPORTDEC_OK;\n\n  crc = FDKcrcGetCRC(&pAdts->crcInfo);\n  if (crc != pAdts->crcReadValue)\n  {\n    return (TRANSPORTDEC_CRC_ERROR);\n  }\n\n  return (ErrorStatus);\n}\n",
        "answer": "/** @brief Checks if the currently calculated CRC matches the CRC field read from the bitstream.\n*\n*  This function checks if the currently calculated CRC matches the CRC field read from the bitstream. If they match, it returns TRANSPORTDEC_OK. Otherwise, it returns TRANSPORTDEC_CRC_ERROR.\n*\n* @param pAdts A handle to the ADTS object.\n* @return TRANSPORTDEC_OK if the CRCs match, TRANSPORTDEC_CRC_ERROR otherwise.\n*/\nTRANSPORTDEC_ERROR adtsRead_CrcCheck( HANDLE_ADTS pAdts )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "XN_C_API XnDumpFile* XN_C_DECL xnDumpFileOpenEx(const XnChar* strDumpName, XnBool bForce, XnBool bSessionDump, const XnChar* strNameFormat, ...)\r\n{\r\n\tif (strNameFormat == NULL)\r\n\t{\r\n\t\tXN_ASSERT(FALSE);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tva_list args;\r\n\tva_start(args, strNameFormat);\r\n\tXnDumpFile* pFile = xnDumpFileOpenImpl(strDumpName, bForce, bSessionDump, strNameFormat, args);\r\n\tva_end(args);\r\n\r\n\treturn pFile;\r\n}\r\n",
        "answer": "/**\n* @brief Opens a file for writing dump using some advanced options. You would usually prefer to use xnDumpFileOpen().\n*\n* This is what a Doxygen comment should look like\n* @param strDumpName The name of the dump file to open.\n* @param bForce If true, force the creation of the dump file even if it already exists.\n* @param bSessionDump If true, create a session dump file.\n* @param strNameFormat The format string for the name of the dump file.\n* @return A pointer to an XnDumpFile object representing the opened dump file.\n*/\nXN_C_API XnDumpFile* XN_C_DECL xnDumpFileOpenEx(const XnChar* strDumpName, XnBool bForce, XnBool bSessionDump, const XnChar* strNameFormat, ...);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void swap(int* lhs, int* rhs)\n{\n    int tmp;\n    tmp = *lhs;\n    *lhs = *rhs;\n    *rhs = tmp;\n}\n",
        "answer": "/** @brief Swap the values of two ints using pointers.\n*\n* This function takes two pointers to integers as arguments and swaps their values.\n*\n* @param lhs A pointer to an integer that will be swapped with rhs.\n* @param rhs A pointer to an integer that will be swapped with lhs.\n*/\n*lhs = *rhs;\n*rhs = tmp;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "IFXRESULT IFXAPI IFXRegisterComponent(\n\t\t\t\t\t\t\t\t\t  IFXComponentDescriptor* pComponentDescriptor )\n{\n\tIFXRESULT result = IFX_OK;\n\n\tif( 0 != gs_pComponentManager )\n\t{\n\t\tif( 0 != pComponentDescriptor )\n\t\t\tresult = gs_pComponentManager->RegisterComponent( pComponentDescriptor );\n\t\telse\n\t\t\tresult = IFX_E_INVALID_POINTER;\n\t}\n\telse\n\t\tresult = IFX_E_NOT_INITIALIZED;\n\n\treturn result;\n}\n",
        "answer": "/** @brief Register a component at runtime.\n*\n*  This function allows clients of IFXCOM to register components at run-time after IFXCOM has been successfully initialized with IFXCOMInitialize.\n*\n* @param pComponentDescriptor A pointer to an IFXComponentDescriptor structure that contains information about the component being registered.\n*\n* @return An IFXRESULT value indicating the result of the operation.\n*/\nIFXRESULT IFXAPI IFXRegisterComponent("
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "IFXRESULT IFXAPI IFXGetMemoryFunctions(    \n                            IFXAllocateFunction**\tppAllocateFunction,\n\t\t\t\t\t\t\tIFXDeallocateFunction**\tppDeallocateFunction,\n\t\t\t\t\t\t\tIFXReallocateFunction**\tppReallocateFunction )\n{\n\tif ( ppAllocateFunction )\n\t\t*ppAllocateFunction = gs_pAllocateFunction;\n\n\tif ( ppDeallocateFunction )\n\t\t*ppDeallocateFunction = gs_pDeallocateFunction;\n\n\tif ( ppReallocateFunction )\n\t\t*ppReallocateFunction = gs_pReallocateFunction;\n\n\treturn IFX_OK;\n}\n",
        "answer": "/** @brief Get memory functions.\n*\n*  This function is used to get pointers to the three main memory functions. Specify NULL for any function pointer that is not desired. IFX_OK is always returned.\n*\n* @param[out] ppAllocateFunction Pointer to the allocate function.\n* @param[out] ppDeallocateFunction Pointer to the deallocate function.\n* @param[out] ppReallocateFunction Pointer to the reallocate function.\n* @return IFX_OK is always returned.\n*/\n*ppAllocateFunction = gs_pAllocateFunction;\n*ppDeallocateFunction = gs_pDeallocateFunction;\n*ppReallocateFunction = gs_pReallocateFunction;\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void IFXAPI_CALLTYPE IFXOSInitialize( void )\n{\n#ifdef _DEBUG\n  g_bInitialized = TRUE;\n#endif\n}\n",
        "answer": "/** @brief Initializes any OS-specific subsystems.\n*\n*  This function initializes any OS-specific subsystems that are required by the IFXOS library. It must be called during system startup, before any of the other IFXOS functions are called.\n*\n* @return None\n*/\nvoid IFXAPI_CALLTYPE IFXOSInitialize( void )"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AudioProcessor* JUCE_CALLTYPE createPluginFilter ()\r\n{\r\n    return new EQPluginProcessor ();\r\n}\r\n",
        "answer": "/** @brief Creates a plugin filter.\n*\n*  This function creates and returns a new instance of the EQPluginProcessor class, which is a subclass of AudioProcessor.\n*\n* @return A pointer to a new instance of EQPluginProcessor.\n*/\nAudioProcessor* JUCE_CALLTYPE createPluginFilter ()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    void R_getPropertySDF(char **structures_file, char **property, int *useNameAsTitleInt) {\n        int structure, fileIter;\n        bool useNameAsTitle = (*useNameAsTitleInt!=0);\n        fileIter = indigoIterateSDFile(*structures_file);\n        int i = 0;\n        while ((structure = indigoNext(fileIter))) {\n            i++;\n                if (indigoHasProperty(structure, *property)) {\n                    indigoGetProperty(structure, *property);\n\t\t\t\t\tprintf(\"aa\");\n                }\n            indigoFree(structure);\n\t\t}\n        indigoFree(fileIter);\n       \n\t}\n",
        "answer": "/** @brief Retrieves a property from an SD file.\n*\n*  This function retrieves a property from an SD file using the Indigo API.\n*  It takes in a pointer to the SD file, a pointer to the property name, and\n*  a flag indicating whether to use the structure name as the title.\n*\n* @param structures_file Pointer to the SD file.\n* @param property Pointer to the property name.\n* @param useNameAsTitleInt Flag indicating whether to use the structure name as the title.\n*\n* @return The value of the property, or NULL if it does not exist.\n*/\nvoid R_getPropertySDF(char **structures_file, char **property, int *useNameAsTitleInt) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, const char **argv) {\n\tif(argc > 2 && strcmp(argv[1], \"-A\") == 0) {\n\t\tconst char *file = argv[2];\n\t\tifstream in;\n\t\tin.open(file);\n\t\tchar buf[4096];\n\t\tint lastret = -1;\n\t\twhile(in.getline(buf, 4095)) {\n\t\t\tEList<string> args;\n\t\t\targs.push_back(string(argv[0]));\n\t\t\ttokenize(buf, \" \\t\", args);\n\t\t\tconst char **myargs = (const char**)malloc(sizeof(char*)*args.size());\n\t\t\tfor(size_t i = 0; i < args.size(); i++) {\n\t\t\t\tmyargs[i] = args[i].c_str();\n\t\t\t}\n\t\t\tif(args.size() == 1) continue;\n\t\t\tlastret = bowtie((int)args.size(), myargs);\n\t\t\tfree(myargs);\n\t\t}\n\t\tif(lastret == -1) {\n\t\t\tcerr << \"Warning: No arg strings parsed from \" << file << endl;\n\t\t\treturn 0;\n\t\t}\n\t\treturn lastret;\n\t} else {\n\t\treturn bowtie(argc, argv);\n\t}\n}\n",
        "answer": "/** @brief Bowtie main function.\n*\n*  This is the entrypoint for your kernel.\n*  You will use this to test and debug your\n*  drivers and it will eventually hold the\n*  code for your game.  Right now, it is\n*  A tight while loop.\n*\n* @param argc The number of command-line arguments passed to the program.\n* @param argv An array of strings containing the command-line arguments.\n* @return Should not return\n*/\nint main(int argc, const char **argv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "double GetTouhouSeriesNumber()\r\n{\r\n\treturn TouhouProcessStats::Get().touhouSeriesNumber;\r\n}\r\n",
        "answer": "/** @brief Gets the Touhou series number of the current process in real number.\n*\n*  This function extracts the series number from the executable filename of the Touhou game.\n*  The filename must be in the format \"th<number><tr if demo>.exe\" or \".exe\". If the rule above is not applied, 0.0 is returned.\n*\n* @return The Touhou series number as a real number.\n*/\ndouble GetTouhouSeriesNumber()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "DLLPUBLIC CapResult Cap_getAutoProperty(CapContext ctx, CapStream stream, CapPropertyID propID, uint32_t *outValue)\n{\n    if (outValue == NULL)\n    {\n        return CAPRESULT_ERR;\n    }\n\n    if (ctx != 0)\n    {\n        Context *c = reinterpret_cast<Context*>(ctx);\n        bool enable = false;\n        if (!c->getStreamAutoProperty(stream, propID, enable))\n        {\n            return CAPRESULT_PROPERTYNOTSUPPORTED;\n        }\n        *outValue = enable ? 1 : 0;\n        return CAPRESULT_OK;\n    }\n    return CAPRESULT_ERR;\n}\n",
        "answer": "/** @brief Get the automatic flag of a camera/stream property (e.g. zoom, focus etc)\n*\n*  This function returns the automatic flag of a camera/stream property (e.g. zoom, focus etc).\n*\n* @param ctx The context of the camera/stream.\n* @param stream The stream to get the property from.\n* @param propID The ID of the property to get.\n* @param outValue A pointer to a uint32_t that will be set to the value of the property.\n*\n* @return CAPRESULT_OK if all is well, CAPRESULT_PROPERTYNOTSUPPORTED if the property is not available, and CAPRESULT_ERR if the context or stream are invalid.\n*/\nDLLPUBLIC CapResult Cap_getAutoProperty(CapContext ctx, CapStream stream, CapPropertyID propID, uint32_t *outValue)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool may_be_dispatch(const DexMethod* method) {\n  const auto& name = method->str();\n  if (name.find(DISPATCH_PREFIX) != 0) {\n    return false;\n  }\n  auto code = method->get_code();\n  uint32_t branches = 0;\n  for (auto& mie : InstructionIterable(code)) {\n    auto op = mie.insn->opcode();\n    if (is_switch(op)) {\n      return true;\n    }\n    branches += is_conditional_branch(op);\n    if (branches > 1) {\n      return true;\n    }\n  }\n  return false;\n}\n",
        "answer": "/**\n* @brief Determines whether a method may be a dispatch method.\n*\n* A method is considered to be a dispatch method if it starts with the\n* DISPATCH_PREFIX and contains at least one switch instruction or two\n* conditional branches. This is used in the method-merger service.\n*\n* @param method The method to check.\n* @return True if the method may be a dispatch method, false otherwise.\n*/\nbool may_be_dispatch(const DexMethod* method) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool parse_bool_anno_value(const DexMethod* method,\n                           const DexType* target_anno,\n                           std::string name) {\n  auto val = parse_anno_value(method, target_anno, DEVT_BOOLEAN, name);\n  return static_cast<bool>(val);\n}\n",
        "answer": "/** @brief Parses a boolean annotation value.\n*\n* This function parses the value of a boolean annotation on a method.\n*\n* @param method The method to parse the annotation from.\n* @param target_anno The type of the annotation to parse.\n* @param name The name of the annotation to parse.\n* @return The parsed boolean value, or false if parsing failed.\n*/\nbool parse_bool_anno_value(const DexMethod* method, const DexType* target_anno, std::string name) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void print_usage() {\n  fprintf(stderr, \"Usage: dexgrep <classname> <dexfile 1> <dexfile 2> ...\\n\");\n}\n",
        "answer": "/** @brief Prints the usage of the program.\n*\n* This function prints the usage of the program to stderr.\n* It is called when the user does not provide the required arguments.\n*\n* @param classname The name of the class to be searched for in the dex files.\n* @param dexfiles The list of dex files to search through.\n*\n* @return void\n*/\nvoid print_usage(const char *classname, const std::vector<std::string> &dexfiles) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool is_integer(const DexType* type) {\n  char sig = type->get_name()->c_str()[0];\n  switch (sig) {\n  case 'Z':\n  case 'B':\n  case 'S':\n  case 'C':\n  case 'I': {\n    return true;\n  }\n  default: { return false; }\n  }\n}\n",
        "answer": "/** @brief Checks if a type is an integer.\n*\n* This function checks if the given type is an integer by checking its signature.\n*\n* @param[in] type The type to check.\n*\n* @return True if the type is an integer, false otherwise.\n*/\nbool is_integer(const DexType* type) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool no_invoke_super(const DexMethod* method) {\n  auto code = method->get_code();\n  always_assert(code);\n\n  for (const auto& mie : InstructionIterable(code)) {\n    auto insn = mie.insn;\n    if (insn->opcode() == OPCODE_INVOKE_SUPER) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
        "answer": "/** @brief Checks whether a method contains no invoke-super instruction.\n*\n* This function checks if the given DexMethod contains any invoke-super instructions. If it does, it returns false. Otherwise, it returns true.\n*\n* @param method The DexMethod to check.\n* @return Whether the method contains no invoke-super instruction.\n*/\nbool no_invoke_super(const DexMethod* method) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void expect_class_have_num_init(DexClasses& classes,\n                                const char* name,\n                                int num_of_init) {\n  auto cls = find_class_named(classes, name);\n  ASSERT_NE(nullptr, cls);\n  auto ctors = cls->get_ctors();\n  EXPECT_EQ(ctors.size(), num_of_init);\n}\n",
        "answer": "/** @brief Test function for checking the number of constructors in a class.\n*\n* This function takes a list of classes, a class name, and an expected number of constructors as input. It finds the class with the given name in the list of classes, and then checks that the number of constructors in the class matches the expected number. If the class is not found or if the number of constructors does not match the expected number, the function will fail.\n*\n* @param classes A list of classes to search for the class with the given name.\n* @param name The name of the class to check the number of constructors for.\n* @param num_of_init The expected number of constructors in the class.\n*/\nvoid expect_class_have_num_init(DexClasses& classes, const char* name, int num_of_init) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void setup() {\n  ClassCreator cc(DexType::make_type(\"LFoo;\"));\n  cc.set_super(get_object_type());\n  auto field =\n      static_cast<DexField*>(DexField::make_field(\"LFoo;.table:[LBar;\"));\n  field->make_concrete(\n      ACC_PUBLIC | ACC_STATIC,\n      DexEncodedValue::zero_for_type(get_array_type(get_object_type())));\n  cc.add_field(field);\n  cc.create();\n}\n",
        "answer": "/** @brief Setup function for creating a class.\n*\n* This function creates a new class with the name \"LFoo;\" and sets its superclass to be the object type. It also adds a field named \"table\" of type \"[LBar;\" which is an array of objects. The field is marked as public and static, and its initial value is set to zero.\n*\n* @return void\n*/\nvoid setup() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string make_big_string(size_t len) {\n  always_assert(len > 4);\n  std::string result = \"aa\" + std::string(len - 4, 'x') + \"zz\";\n  return result;\n}\n",
        "answer": "/** @brief Creates a big string of length len.\n*\n* This function creates a string of length len by concatenating the strings \"aa\" and \"zz\" with a string of (len - 4) 'x' characters in between.\n* The resulting string will have the format \"aaxxxxxzz\", where xxxxx is a string of (len - 4) 'x' characters.\n*\n* @param len The length of the desired string. Must be greater than 4.\n* @return A string of length len with the format \"aaxxxxxzz\".\n*/\nstd::string make_big_string(size_t len) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void lowerFunctionArguments(Unit &unit, const std::string &functionName) {\n    FunctionArgumentLowerer lowerer(unit);\n    lowerer.lower(functionName);\n  }\n",
        "answer": "/** @brief Lower function arguments for the given function name.\n*\n* This function lowers the function arguments for the given function name.\n* It uses the FunctionArgumentLowerer class to perform the lowering.\n*\n* @param unit The LLVM IR unit.\n* @param functionName The name of the function.\n*/\nvoid lowerFunctionArguments(Unit &unit, const std::string &functionName) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: dobbscoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\" << strMsg;\n\n    return s.str();\n}\n",
        "answer": "/**\n* @brief Sends an HTTP POST request with a JSON message and custom headers.\n*\n* This function sends an HTTP POST request to the specified URL, with the provided JSON message as the request body, and any additional custom headers. The response from the server is returned as a string.\n*\n* @param strMsg The JSON message to send in the request body.\n* @param mapRequestHeaders A map of custom headers to include in the request.\n*\n* @return The response from the server, as a string.\n*/\nstring HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n{\n    const char* pszTimestamp = \"Monaco obtient officiellement son indpendance du Saint-Empire romain en 1524\";\n    const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n}\n",
        "answer": "/** @brief Build the genesis block.\n*\n*  This function creates a new block with the given parameters and returns it. The output of its generation transaction cannot be spent since it did not originally exist in the database.\n*\n* @param nTime The timestamp for when the block was created.\n* @param nNonce A random value used to satisfy the proof-of-work requirement.\n* @param nBits The target threshold for the proof-of-work algorithm.\n* @param nVersion The version number of the block.\n* @param genesisReward The amount of coins rewarded for solving the proof-of-work.\n* @return A new CBlock object representing the genesis block.\n*/\nstatic CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void beep(Const frequency, Const duration)\n{\n    g_task_handler.from<IdleTask>().to<BeepingTask>(frequency, duration);\n}\n",
        "answer": "/** @brief Generate sound using the motor windings.\n*\n*  This function generates a beep sound using the motor windings. The request will be ignored if the controller is not in the inactive state. Units are SI (Hertz, seconds).\n*\n* @param frequency The frequency of the beep sound in Hertz.\n* @param duration The duration of the beep sound in seconds.\n* @return None\n*/\nvoid beep(Const frequency, Const duration)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void gaussian_kernel(ntuple_list kernel, double sigma, double mean)\n{\n  double sum = 0.0;\n  double val;\n  unsigned int i;\n\n  /* check parameters */\n  if (kernel == NULL || kernel->values == NULL)\n    error(\"gaussian_kernel: invalid n-tuple 'kernel'.\");\n  if (sigma <= 0.0) error(\"gaussian_kernel: 'sigma' must be positive.\");\n\n  /* compute Gaussian kernel */\n  if (kernel->max_size < 1) enlarge_ntuple_list(kernel);\n  kernel->size = 1;\n  for (i = 0; i < kernel->dim; i++)\n  {\n    val = ((double)i - mean) / sigma;\n    kernel->values[i] = exp(-0.5 * val * val);\n    sum += kernel->values[i];\n  }\n\n  /* normalization */\n  if (sum >= 0.0) for (i = 0; i < kernel->dim; i++) kernel->values[i] /= sum;\n}\n",
        "answer": "/**\n* @brief Compute a Gaussian kernel of length 'kernel->dim', standard deviation 'sigma', and centered at value 'mean'. For example, if mean=0.5, the Gaussian will be centered in the middle point between values 'kernel->values[0]' and 'kernel->values[1]'.\n*\n* @param kernel The n-tuple list to store the computed Gaussian kernel.\n* @param sigma The standard deviation of the Gaussian distribution.\n* @param mean The center of the Gaussian distribution.\n*\n* @return void\n*/\nvoid gaussian_kernel(ntuple_list kernel, double sigma, double mean)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "            bool eval(uint8* image, uint32 const& x, uint32 const& y, uint32 const& pitch, float* response)\n            {\n                for (uint16 i = 0; i < WB_STAGE_COUNT; ++i)\n                {\n                    Stage stage = hostStages[i];\n                    *response += evalLBP(image, x, y, pitch, &stage);\n                    if (*response < stage.thetaB) {\n                        return false;\n                    }\n                }\n\n                return *response > WB_FINAL_THRESHOLD;\n            }\n",
        "answer": "/** @brief Evaluates a weak classifier for the given image and returns a strong classifier.\n*\n*  This function goes through all the stages of the classifier, evaluates weak classifiers, and returns a strong classifier.\n*\n* @param[in] image The input image to be evaluated.\n* @param[in] x The x-coordinate of the top-left corner of the region of interest in the input image.\n* @param[in] y The y-coordinate of the top-left corner of the region of interest in the input image.\n* @param[in] pitch The width of the input image in bytes.\n* @param[out] response The output response from the classifier.\n*\n* @return True if the strong classifier is positive, false otherwise.\n*/\n*response += evalLBP(image, x, y, pitch, &stage);\nif (*response < stage.thetaB) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool run()\n\t{\n\t\tsuccess = true;\n\t\tmutex.lock();\n\t\tcond.timedWaitSeconds(&mutex, 3);\n\t\tmutex.unlock();\n\t\tsuccess = false;\n\n\t\treturn false;\n\t}\n",
        "answer": "/** @brief Runnable's thread main loop.\n*\n* This function implements the main loop of the runnable's thread and has to be implemented by the derived class.\n*\n* @return Should not return\n*/\nbool run()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool run()\r\n\t{\r\n\t\tsuccess = true; \r\n\r\n\t\treturn false;\r\n\t}\r\n",
        "answer": "/** @brief Runnable's thread main loop.\n*\n*  This function implements the main loop of the runnable's thread and has to be implemented by the derived class.\n*\n* @return Should not return\n*/\nbool run()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool run()\r\n\t{\r\n\t\tsuccess = true;\r\n\t\tcancelableSleep(3000);\r\n\t\tsuccess = false;\r\n\r\n\t\treturn false;\r\n\t}\r\n",
        "answer": "/** @brief Runnable's thread main loop.\n*\n*  This function implements the main loop of the runnable's thread and has to be implemented by the derived class.\n*\n* @return Should not return\n*/\nbool run()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long pop3_message_size(char *user, long message)\n{\n\tlong\tretval;\n\temail\tm;\n\t\n\tretval = 0;\n\tmutex_lock(pop3_mutex);\n\tm = pop3_find_email(user, message);\n\tif(m)\n\t\tretval = m->size;\n\tmutex_unlock(pop3_mutex);\n\treturn retval;\n}\n",
        "answer": "/** @brief Returns the size in bytes of the user's message with the given number. (Deleted messages do not count). Shall return 0 if the message does not exist. This function has to be implemented by whatever uses this library. The string is null-terminated. The message value is a zero-based index.\n* @param user The username of the user whose email size is being queried.\n* @param message The message number of the email whose size is being queried.\n* @return The size in bytes of the email, or 0 if the email does not exist.\n*/\nlong pop3_message_size(char *user, long message)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void smtp_shutdown(void)\n{\n\tCLOSE_SOCKET(sock);\n\tsock = -1;\n\tif(client_socket != -1)\n\t\tCLOSE_SOCKET(client_socket);\n}\n",
        "answer": "/** @brief Closes the SMTP port opened using smtp_startup and shuts down the popd helper library.\n*\n*  This function closes the socket used for the SMTP connection and sets it to -1, indicating that it is no longer valid. It also checks if a client socket was created and closes it as well. The helper library can not be used further after calling this function.\n*\n* @return Should not return\n*/\nvoid smtp_shutdown(void)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int foo()\n   {\n   const std::map<std::string, int> bar =\n      {\n         { \"abcXYZ\", -13 },\n      };\n   return 5;\n   }\n",
        "answer": "/** @brief foo function.\n*\n* This is the description of the functionality of the function.\n* This is a really tough case - perhaps we shouldn't keep any #if crap unless they all end with the same stack? Multi-line comment\n*\n* @param bar A map of strings to integers.\n* @return The value 5.\n*/\nint foo()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int foo()\n{\n\tif (false) return 1;\n\tif (true) return 2;\n\tfloat a = 0;\n}\n",
        "answer": "/** @brief Function to determine the value of foo.\n*\n* This function returns the value of foo based on certain conditions.\n*\n* @return The value of foo.\n*/\nint foo()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void foo()\n{\nfor(int i = 0;i < 1;i++) {return (false);}\nfloat g = 0.13;\n}\n",
        "answer": "/** @brief A function that does nothing.\n*\n* This function does not do anything useful. It simply returns false and sets a variable to 0.13.\n*\n* @return False\n*/\nvoid foo()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string show_config()\n{\n   return(show_config(false, false));\n}\n",
        "answer": "/** @brief Returns the config file string with all options and without documentation based on the current configuration.\n*\n*  This function returns a string containing the configuration options for the program, without any documentation or comments.\n*\n* @param show_all If true, shows all options, even if they are not set.\n* @param show_doc If true, includes documentation in the output.\n* @return The config file string with all options and without documentation based on the current configuration.\n*/\nstring show_config(bool show_all = false, bool show_doc = false)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, const char **argv) {\n\tif(argc > 2 && strcmp(argv[1], \"-A\") == 0) {\n\t\tconst char *file = argv[2];\n\t\tifstream in;\n\t\tin.open(file);\n\t\tchar buf[4096];\n\t\tint lastret = -1;\n\t\twhile(in.getline(buf, 4095)) {\n\t\t\tvector<string> args;\n\t\t\targs.push_back(string(argv[0]));\n\t\t\ttokenize(buf, \" \\t\", args);\n\t\t\tconst char **myargs = (const char**)malloc(sizeof(char*)*args.size());\n\t\t\tfor(size_t i = 0; i < args.size(); i++) {\n\t\t\t\tmyargs[i] = args[i].c_str();\n\t\t\t}\n\t\t\tif(args.size() == 1) continue;\n\t\t\tlastret = bowtie_build(args.size(), myargs);\n\t\t\tfree(myargs);\n\t\t}\n\t\tif(lastret == -1) {\n\t\t\tcerr << \"Warning: No arg strings parsed from \" << file << endl;\n\t\t\treturn 0;\n\t\t}\n\t\treturn lastret;\n\t} else {\n\t\treturn bowtie_build(argc, argv);\n\t}\n}\n",
        "answer": "/** @brief Main function for the bowtie-build program.\n*\n* This function is responsible for parsing command line arguments and dispatching them to the bowtie_build function. If the user specifies -A <file> as the first two arguments, main will interpret that file as having one set of command-line arguments per line, and will dispatch each batch of arguments one at a time to bowtie_build.\n*\n* @param argc The number of command line arguments passed to the program.\n* @param argv An array of C strings containing the command line arguments.\n* @return The return value of the last call to bowtie_build, or 0 if no arguments were parsed from the file specified with -A.\n*/\nint main(int argc, const char **argv) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static double effective_opacity(const SPStyle *style)\r\n{\r\n    double val = 1.0;\r\n    for (SPObject const *obj = style->object; obj ; obj = obj->parent)\r\n        {\r\n        style = SP_OBJECT_STYLE(obj);\r\n        if (style)\r\n            val *= SP_SCALE24_TO_FLOAT(style->opacity.value);\r\n        }\r\n    return val;\r\n}\r\n",
        "answer": "/** @brief Calculates the effective opacity of a style object.\n*\n*  This function calculates the effective opacity of a style object by multiplying the opacity values of all its parent objects.\n*\n* @param[in] style The style object for which to calculate the effective opacity.\n* @return The effective opacity value.\n*/\nstatic double effective_opacity(const SPStyle *style)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void scale_bicubic(NRPixBlock *to, NRPixBlock *from)\n{\n    if (NR_PIXBLOCK_BPP(to) == 4 && NR_PIXBLOCK_BPP(from) == 4) {\n        scale_bicubic_rgba(to, from);\n    } else if (NR_PIXBLOCK_BPP(to) == 1 && NR_PIXBLOCK_BPP(from) == 1) {\n        scale_bicubic_alpha(to, from);\n    } else {\n        g_warning(\"NR::scale_bicubic: unsupported bitdepths for scaling: to %d, from %d\", NR_PIXBLOCK_BPP(to), NR_PIXBLOCK_BPP(from));\n    }\n}\n",
        "answer": "/** @brief Scale the second pixblock to the first using bicubic interpolation.\n*\n*  This function scales the image in the source pixblock to the size of the destination pixblock using bicubic interpolation. The source pixblock is not modified during the process. Only works for 32-bpp images.\n*\n* @param[in,out] to The destination pixblock.\n* @param[in] from The source pixblock.\n*/\nvoid scale_bicubic(NRPixBlock *to, NRPixBlock *from)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "SVGAnimatedLength getKernelUnitLengthX()\n{\n}\n",
        "answer": "/** @brief Get the value of the kernel unit length in the x direction.\n*\n*  This function returns the value of the kernel unit length in the x direction, which is used to specify the size of the convolution kernel in the x direction.\n*\n* @return The value of the kernel unit length in the x direction.\n*/\nSVGAnimatedLength getKernelUnitLengthX()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "unsigned long getPathSegAtLength(double distance)\n{\n}\n",
        "answer": "/** @brief Returns the index into pathSegList which is distance units along the path, utilizing the user agent's distance-along-a-path algorithm.\n*\n*  This function returns the index into pathSegList which is distance units along the path, utilizing the user agent's distance-along-a-path algorithm.\n*\n* @param distance The distance along the path to find the index of.\n* @return The index into pathSegList which is distance units along the path.\n*/\nunsigned long getPathSegAtLength(double distance)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool checkEnclosure(const SVGElementPtr element, const SVGRect &rect)\n{\n}\n",
        "answer": "/** @brief Checks if the rendered content of a given element is entirely contained within a supplied rectangle.\n*\n*  This function checks if the rendered content of an SVGElement is entirely contained within a supplied rectangle, honoring the 'pointer-events' property value on each candidate graphics element.\n*\n* @param[in] element The SVGElement to check for enclosure.\n* @param[in] rect The rectangle to check if the element is entirely contained within.\n* @return True if the rendered content of the given element is entirely contained within the supplied rectangle, false otherwise.\n*/\nbool checkEnclosure(const SVGElementPtr element, const SVGRect &rect)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void ege_adjustment_action_set_focuswidget( EgeAdjustmentAction* action, GtkWidget* widget )\n{\n    g_return_if_fail( IS_EGE_ADJUSTMENT_ACTION(action) );\n\n    /* TODO unhook prior */\n\n    action->private_data->focusWidget = widget;\n}\n",
        "answer": "/** @brief Sets the GtkWidget to return focus to. This is used to be able to transfer focus back out of a toolbar.\n*\n*  @param action The EgeAdjustmentAction object.\n*  @param widget The GtkWidget to set as the focus widget.\n*\n*  @return void\n*/\n/* TODO unhook prior */\n"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int gm_read(FILE *f, greymap_t **gmp) {\n  int magic[2];\n\n  /* read magic number. We ignore whitespace and comments before the\n     magic, for the benefit of concatenated files in P1-P3 format.\n     Multiple P1-P3 images in a single file are not formally allowed\n     by the PNM standard, but there is no harm in being lenient. */\n\n  magic[0] = fgetc_ws(f);\n  if (magic[0] == EOF) {\n    /* files which contain only comments and whitespace count as \"empty\" */\n    return -3;\n  } \n  magic[1] = fgetc(f);\n  if (magic[0] == 'P' && magic[1] >= '1' && magic[1] <= '6') {\n    return gm_readbody_pnm(f, gmp, magic[1]);\n  }\n  if (magic[0] == 'B' && magic[1] == 'M') {\n    return gm_readbody_bmp(f, gmp);\n  }\n  return -4;\n}\n",
        "answer": "/** @brief Read a PNM stream: P1-P6 format (see pnm(5)), or a BMP stream, and convert the output to a greymap. Return greymap in *gmp. Return 0 on success, -1 on error with errno set, -2 on bad file format (with error message in gm_read_error), and 1 on premature end of file, -3 on empty file (including files with only whitespace and comments), -4 if wrong magic number. If the return value is >=0, *gmp is valid.\n*\n* @param f The input stream to read from.\n* @param gmp A pointer to a greymap_t object that will be populated with the converted data.\n* @return 0 on success, -1 on error with errno set, -2 on bad file format (with error message in gm_read_error), and 1 on premature end of file, -3 on empty file (including files with only whitespace and comments), -4 if wrong magic number.\n*/\n/* read magic number. We ignore whitespace and comments before the\n/* files which contain only comments and whitespace count as \"empty\" */\nreturn -3;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static Glib::ustring win32_getExePath()\n{\n    char exeName[MAX_PATH+1];\n    GetModuleFileName(NULL, exeName, MAX_PATH);\n    char *slashPos = strrchr(exeName, '\\\\');\n    if (slashPos)\n        *slashPos = '\\0';\n    Glib::ustring s = exeName;\n    return s;\n}\n",
        "answer": "/** @brief Get the path of the current executable.\n*\n*  This function returns the directory of the .exe that is currently running.\n*\n* @return The directory of the .exe as a Glib::ustring.\n*/\n*slashPos = '\\0';\nGlib::ustring s = exeName;"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool doTest()\n{\n    org::w3c::dom::io::UriInputStream ins(\"file:work/test.odg\");\n\n    std::vector<unsigned char>inbuf;\n\n    while (true)\n        {\n        int ch = ins.get();\n        if (ch < 0)\n            break;\n        inbuf.push_back(ch);\n        }\n    ZipFile zf;\n    if (!zf.readBuffer(inbuf))\n        {\n        return false;\n        }\n    return true;\n}\n",
        "answer": "/**\n* @brief Tests the functionality of the Phoebe DOM Implementation.\n*\n* This function tests the functionality of the Phoebe DOM Implementation by\n* reading a file using the UriInputStream and then checking if it is a valid\n* Zip file.\n*\n* @return True if the test passes, false otherwise.\n*/\nbool doTest() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void NormalizeForXheight(int norm_multiplier,\n                           const uinT8* normalization_factors) {\n    for (int class_id = 0; class_id < max_classes_; class_id++) {\n      norm_count_[class_id] = class_count_[class_id] -\n          ((norm_multiplier * normalization_factors[class_id]) >> 8);\n    }\n  }\n",
        "answer": "/** @brief Normalizes the counts for xheight, putting the normalized result in norm_count_. Applies a simple subtractive penalty for incorrect vertical position provided by the normalization_factors array, indexed by character class, and scaled by the norm_multiplier.\n*\n*  @param[in] norm_multiplier The multiplier to use when applying the penalty.\n*  @param[in] normalization_factors An array of factors to use for each character class when applying the penalty.\n*\n*  @return None.\n*/\nvoid NormalizeForXheight(int norm_multiplier, const uinT8* normalization_factors) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uinT8 Bucket8For(FLOAT32 param, FLOAT32 offset, int num_buckets) {\n  int bucket = IntCastRounded(MapParam(param, offset, num_buckets));\n  return static_cast<uinT8>(ClipToRange(bucket, 0, num_buckets - 1));\n}\n",
        "answer": "/** @brief Quantizes a parameter into a bucket.\n*\n* This function takes in a parameter and an offset, shifts the parameter by the offset, multiplies it by the number of buckets, rounds the result to the nearest integer, clips it to the range [0, num_buckets - 1], and casts it to a uint8.\n*\n* @param param The input parameter to be quantized.\n* @param offset The offset to shift the parameter by before quantization.\n* @param num_buckets The number of buckets to quantize into.\n* @return A uint8 representing the quantized bucket for the given parameter and offset, clipped to the range [0, num_buckets - 1].\n*/\nuinT8 Bucket8For(FLOAT32 param, FLOAT32 offset, int num_buckets) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void osd_settextcolor(long fg, long bg) {\n  if (p_settextcolor) {\n    p_settextcolor(fg, bg);\n  }\n}\n",
        "answer": "/** @brief Sets the foreground and background color.\n*\n* This function sets the foreground and background color of the text output. If the color is greater than or equal to 0, the driver uses the standard 16 VGA colors. If the color is negative, the driver must use RGB (-color) color value. If the fg or bg has -1 value, the settextcolor must ignore them. (-1 means use the current color).\n*\n* @param fg The foreground color.\n* @param bg The background color.\n*/\nvoid osd_settextcolor(long fg, long bg) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void maSetClipRect(int left, int top, int width, int height) {\n  graphics->setClip(left, top, width, height);\n}\n",
        "answer": "/** @brief Sets the clipping rectangle for the current draw target.\n*\n* This function sets the clipping rectangle for the current draw target. The screen and every drawable image each maintains a clipping rectangle. Drawing operations have no effect outside the clipping rectangle. The default clipping rectangle covers the entire draw target, so that clipping occurs at the draw target's edges.\n*\n* @param left The x-coordinate of the top-left corner of the clipping rectangle.\n* @param top The y-coordinate of the top-left corner of the clipping rectangle.\n* @param width The width of the clipping rectangle.\n* @param height The height of the clipping rectangle.\n*/\nvoid maSetClipRect(int left, int top, int width, int height) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void osd_sound(int frq, int ms, int vol, int bgplay) {}\n",
        "answer": "/** @brief Produces a tone. If the driver has no sound, it can use an add-on driver like dev_oss, or do nothing. The background play means to store the tones on a queue and play them in its time.\n*\n* @param frq Frequency of the tone.\n* @param ms Duration of the tone in milliseconds.\n* @param vol Volume of the tone.\n* @param bgplay If non-zero, plays the tone in the background. If zero, plays the tone immediately.\n*/\nvoid osd_sound(int frq, int ms, int vol, int bgplay) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void osd_refresh(void) {\n  if (!g_system->isClosing()) {\n    g_system->getOutput()->flush(true);\n  }\n}\n",
        "answer": "/** @brief Refreshes the OSD.\n*\n* This routine is called by SB every ~50ms. If framebuffer technique is used, this routine must write buffer to video-ram.\n*\n* @return Should not return\n*/\nvoid osd_refresh(void) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void gcode_M150() {\n    set_led_color(\n      parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,\n      parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,\n      parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0\n      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)\n        , parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0\n      #endif\n    );\n  }\n",
        "answer": "/**\n* @brief Set Status LED Color - Use R-U-B-W for R-G-B-W Always sets all 3 or 4 components. If a component is left out, set to 0. Examples: M150 R255 ; Turn LED red M150 R255 U127 ; Turn LED orange (PWM only) M150 ; Turn LED off M150 R U B ; Turn LED white M150 W ; Turn LED white using a white LED\n*\n* @param parser The GCode parser object.\n* @return void\n*/\ninline void gcode_M150() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvec4 toPtn4(const vec3 &v) {\n\t\treturn vec4(v.x, v.y, v.z, 1);\n\t}\n",
        "answer": "/** @brief Convert a point to a vector with homogeneous component as one.\n*\n*  This function takes a point (represented by a vec3) and converts it to a vector\n*  with homogeneous component as one, using the vec4 data type.\n*\n* @param v A point represented by a vec3.\n* @return A vector with homogeneous component as one, represented by a vec4.\n*/\nvec4 toPtn4(const vec3 &v) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tfloat sqrLength(const vec3 &a) {\n\t\treturn dot(a, a);\n\t}\n",
        "answer": "/** @brief Calculates the squared length of a vector.\n*\n*  This function calculates the squared length of a vector 'a' using the dot product formula: |a|^2.\n*  It is cheaper to compute this value than the length of 'a'.\n*\n* @param[in] a The input vector.\n* @return The squared length of the input vector.\n*/\nfloat sqrLength(const vec3 &a) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tfloat sqrDistance(const float a, const float b) {\n\t\tfloat ab = b - a;\n\t\treturn ab * ab;\n\t}\n",
        "answer": "/** @brief Calculates the squared distance between two points.\n*\n*  This function calculates the squared distance between two points, without taking the square root.\n*  It is cheaper to compute this value than the distance from 'a' to 'b'.\n*\n* @param a The first point.\n* @param b The second point.\n* @return The squared distance between the two points.\n*/\nfloat sqrDistance(const float a, const float b) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tfloat distance(const vec4 &a, const vec4 &b) {\n\t\tvec4 ab = b - a;\n\t\treturn sqrtf(dot(ab, ab));\n\t}\n",
        "answer": "/** @brief Calculates the squared distance between two vectors.\n*\n*  This function calculates the squared distance between two vectors using the euclidian distance formula: |b-a|.\n*  The computation uses the sqrtf function, which consumes a lot of cycles to compute.\n*\n* @param[in] a First vector.\n* @param[in] b Second vector.\n* @return Squared distance between vectors a and b.\n*/\nfloat distance(const vec4 &a, const vec4 &b) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvec3 blerp(vec3 A, vec3 B, vec3 C, vec3 D,\n\t\tfloat dx, float dy) {\n\t\tfloat omdx = 1.0f - dx,\n\t\t\tomdy = 1.0f - dy;\n\t\treturn omdx * omdy*A + omdx * dy*D +\n\t\t\tdx * omdy*B + dx * dy*C;\n\t}\n",
        "answer": "/** @brief Bilinear interpolation between four points.\n*\n*  This function performs a bilinear interpolation between four points in a square area.\n*  The points are represented by their coordinates (x,y) and the resulting color is a vec3.\n*\n* @param A The coordinate of the first point.\n* @param B The coordinate of the second point.\n* @param C The coordinate of the third point.\n* @param D The coordinate of the fourth point.\n* @param dx The x-coordinate of the interpolation point.\n* @param dy The y-coordinate of the interpolation point.\n* @return The interpolated color at the given point.\n*/\nvec3 blerp(vec3 A, vec3 B, vec3 C, vec3 D,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static inline uint8_t fromBCD(uint8_t from, uint8_t mask)\n{\n    return ((from >> 4) & mask) * 10 + (from & 0b1111);\n}\n",
        "answer": "/** @brief Converts a binary coded decimal to normal representation.\n*\n* This function converts a binary coded decimal to normal representation, where the lower nibble represents 10^0 and the high nibble 10^1. The higher nibble may also represent further unrelated information, so it is masked using the provided mask parameter.\n*\n* @param from The binary coded decimal value to convert.\n* @param mask The mask to apply to the higher nibble of the input value.\n* @return The converted normal representation of the input value.\n*/\nstatic inline uint8_t fromBCD(uint8_t from, uint8_t mask)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool IsConfiguredDeployment(const Consensus::Params &consensusParams, const int bit)\n{\n    DbgAssert(bit >= 0 && bit <= (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS, return false);\n\n    const Consensus::ForkDeployment *vdeployments = consensusParams.vDeployments;\n    const struct ForkDeploymentInfo &vbinfo = VersionBitsDeploymentInfo[bit];\n\n    if (strlen(vbinfo.name) == 0)\n        return false;\n\n    return (vdeployments[bit].windowsize != 0 && vdeployments[bit].threshold != 0);\n}\n",
        "answer": "/** @brief Checks if a deployment is configured for the network.\n*\n*  This function checks if a deployment with the given bit index is considered to be configured. Deployments with a zero-length name, or a windowsize or threshold equal to zero are not considered to be configured, and will be reported as 'unknown' if signals are detected for them. Unconfigured deployments can be ignored to save processing time, e.g. in ComputeBlockVersion() when computing the default block version to emit.\n*\n* @param consensusParams The consensus parameters of the network.\n* @param bit The index of the deployment to check.\n* @return True if the deployment is considered to be configured, false otherwise.\n*/\nbool IsConfiguredDeployment(const Consensus::Params &consensusParams, const int bit)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool StartHTTPServer()\n{\n    LOG(HTTP, \"Starting HTTP server\\n\");\n    int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n    LOGA(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n    std::packaged_task<bool(event_base *, evhttp *)> task(ThreadHTTP);\n    threadResult = task.get_future();\n    threadHTTP = std::thread(std::move(task), eventBase, eventHTTP);\n\n    for (int i = 0; i < rpcThreads; i++)\n    {\n        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue);\n    }\n    return true;\n}\n",
        "answer": "/** @brief Start HTTP server.\n*\n*  This function starts the HTTP server, which is separate from InitHTTPServer to give users race-condition-free time to register their handlers between InitHTTPServer and StartHTTPServer.\n*\n* @return Returns true if the HTTP server was started successfully, false otherwise.\n*/\nbool StartHTTPServer()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "string JSONRPCRequest(const string &strMethod, const UniValue &params, const UniValue &id)\n{\n    UniValue request(UniValue::VOBJ);\n    request.push_back(Pair(\"method\", strMethod));\n    request.push_back(Pair(\"params\", params));\n    request.push_back(Pair(\"id\", id));\n    return request.write() + \"\\n\";\n}\n",
        "answer": "/** @brief Creates a JSON-RPC request object.\n*\n* This function creates a JSON-RPC request object with the specified method, parameters, and id.\n* The resulting object is returned as a string.\n*\n* @param strMethod The name of the RPC method to call.\n* @param params The parameters for the RPC method.\n* @param id A unique identifier for the request.\n* @return A JSON-RPC request object as a string.\n*/\nstring JSONRPCRequest(const string &strMethod, const UniValue &params, const UniValue &id)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "std::string formatInfoUnit(double value)\n{\n    static const char *units[] = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"};\n\n    size_t i = 0;\n    while ((value > 1000.0 || value < -1000.0) && i < (sizeof(units) / sizeof(units[0])) - 1)\n    {\n        value /= 1000.0;\n        i++;\n    }\n\n    ostringstream ss;\n    ss << fixed << setprecision(2);\n    ss << value << units[i];\n    return ss.str();\n}\n",
        "answer": "/**\n* @brief Format an amount of bytes with a unit symbol attached, such as MB, KB, GB. Uses Kilobytes x1000, not Kibibytes x1024. Output value has two digits after the dot. No space between unit symbol and amount. Also works for negative amounts. The maximum unit supported is 1 Exabyte (EB). This formatting is used by the thinblock statistics functions, and this is a factored-out utility function.\n*\n* @param value The value to be formatted.\n*\n* @return A string containing the formatted value with the appropriate unit symbol attached.\n*/\nstd::string formatInfoUnit(double value)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void PerformInitDelay() {\n    delay(delayAm * 30);\n}\n",
        "answer": "/** @brief Performs the initial delay.\n*\n* This function is used to give the microcontroller time to boot up and get itself situated. It is currently set to a value of 60, but feel free to change that if it feels too absurd.\n*\n* @param delayAm The amount of time to delay for, in seconds. Defaults to 60 if not specified.\n* @return None.\n*/\nvoid PerformInitDelay(int delayAm = 60) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc,char **)\n{\n  VectorXf a(10), b(10);\n#ifdef EIGEN_SHOULD_FAIL_TO_BUILD\n  b = argc>1 ? 2*a : a+a;\n#else\n  b = argc>1 ? VectorXf(2*a) : VectorXf(a+a);\n#endif\n}\n",
        "answer": "/** @brief Main entrypoint.\n*\n* This is the entrypoint for your program.\n* You will use this to test and debug your\n* code and it will eventually hold the\n* code for your game.  Right now, it is\n* A tight while loop.\n*\n* @param argc Number of command line arguments.\n* @param **argv Command line arguments.\n* @return Should not return.\n*/\nint main(int argc,char **)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  inline void manage_manual_move() {\n    if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {\n      #if ENABLED(DELTA)\n        inverse_kinematics(current_position);\n        planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);\n      #else\n        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);\n      #endif\n      manual_move_axis = (int8_t)NO_AXIS;\n    }\n  }\n",
        "answer": "/**\n* @brief Manages a manual move.\n*\n* If the most recent manual move hasn't been fed to the planner yet, and the planner can accept one, send it immediately.\n*\n* @return Should not return\n*/\ninline void manage_manual_move() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "OpndKind getOpndKind(const char * kindString)\n{\n    assert(kindString);\n    for (unsigned i = 0; i<COUNTOF(kinds); i++) {\n        if (!strcmpi(kindString, kinds[i].kindString)) {\n            return kinds[i].kind;\n        }\n    }\n    return OpndKind_Null;\n}\n",
        "answer": "/** @brief Returns the OpndKind found by its string representation (case insensitive).\n*\n*  This function returns the OpndKind corresponding to a given string representation.\n*  The search is case-insensitive, and if an invalid name is provided, OpndKind_Null is returned.\n*\n* @param kindString The string representation of the OpndKind to be found.\n* @return The OpndKind corresponding to the given string representation, or OpndKind_Null if the name is invalid.\n*/\nOpndKind getOpndKind(const char * kindString)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dvmThrowIncompatibleClassChangeErrorWithClassMessage(\n        const char* descriptor)\n{\n    dvmThrowExceptionWithClassMessage(\n            gDvm.exIncompatibleClassChangeError, descriptor);\n}\n",
        "answer": "/** @brief Throws an IncompatibleClassChangeError in the current thread with a human-readable form of the given descriptor as the detail message.\n*\n* This function is used to throw an IncompatibleClassChangeError exception in the current thread, with a human-readable form of the given descriptor as the detail message.\n* It takes a single parameter, \"descriptor\", which is a pointer to a null-terminated string containing the descriptor for the class that caused the error.\n* The function calls dvmThrowExceptionWithClassMessage() with gDvm.exIncompatibleClassChangeError and the descriptor as parameters.\n*\n* @param[in] descriptor A pointer to a null-terminated string containing the descriptor for the class that caused the error.\n* @return None.\n*/\nvoid dvmThrowIncompatibleClassChangeErrorWithClassMessage(const char* descriptor) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void dvmThrowStringIndexOutOfBoundsExceptionWithIndex(jsize stringLength,\n        jsize requestIndex) {\n    dvmThrowExceptionFmt(gDvm.exStringIndexOutOfBoundsException,\n            \"length=%d; index=%d\", stringLength, requestIndex);\n}\n",
        "answer": "/** @brief Throws a StringIndexOutOfBoundsException with the actual length and requested index.\n*\n* This function throws a StringIndexOutOfBoundsException with a detail message specifying an actual length as well as a requested index.\n*\n* @param stringLength The actual length of the string.\n* @param requestIndex The requested index in the string.\n*\n* @return Should not return.\n*/\nvoid dvmThrowStringIndexOutOfBoundsExceptionWithIndex(jsize stringLength, jsize requestIndex) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int get_currentpc(int reg, bool isPhysical) {\n    move_mem_to_reg(OpndSize_32, -sizeofStackSaveArea+offStackSaveArea_localRefTop, PhysicalReg_FP, true, reg, isPhysical);\n    return 1;\n}\n",
        "answer": "/** @brief Get the current program counter.\n*\n* This function returns the current program counter (PC) in the stack frame.\n* It does this by moving the memory at the top of the stack save area to a register, and then returning 1.\n* The isPhysical parameter determines whether the returned PC should be physical or virtual.\n*\n* @param reg The register to move the memory to.\n* @param isPhysical Whether the returned PC should be physical or virtual.\n* @return Should return 1.\n*/\nint get_currentpc(int reg, bool isPhysical) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "         static void validate_request_path(const fc::path& req, const string& method,\n                                           fc::variants& parameters)\n         {\n             static fc::path prefix(\"/rpc\");\n             if ( req.parent_path() == fc::path(\"/safebot\") || req == prefix )\n             {\n                 return;\n             }\n             if ( method == \"batch\" )\n             {\n                 FC_ASSERT( parameters.size() > 0 && parameters[0].is_string() && req == prefix / parameters[0].as_string() );\n             }\n             else\n             {\n                 FC_ASSERT( req == prefix / method );\n             }\n         }\n",
        "answer": "/**\n* @brief Validates the request path.\n*\n* This function validates the request path by checking if it is either `/req` or `/safebot/whatever`,\n* or of the form `/req/something` where `something == method`. If the request path does not meet these\n* conditions, an exception is thrown.\n*\n* @param req The request path to validate.\n* @param method The method to use for validation.\n* @param parameters The parameters to use for validation.\n*/\nstatic void validate_request_path(const fc::path& req, const string& method,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, char *argv[])\n{\n   QCoreApplication a(argc, argv);\n  \n   Tests tests;\n   return QTest::qExec(&tests, argc, argv);\n}\n",
        "answer": "/** @brief Main entrypoint for the program.\n*\n* This is the main entrypoint for the program, where the program starts executing.\n* It creates an instance of QCoreApplication and Tests classes, and then calls the qExec() function to execute the tests.\n*\n* @param argc Number of command-line arguments passed to the program.\n* @param argv Array of command-line argument strings passed to the program.\n* @return Should not return.\n*/\nint main(int argc, char *argv[])"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "  void join() {\n    if (!detached_ && getState() != uninitialized) {\n      thread_->join();\n    }\n  }\n",
        "answer": "/** @brief Join this thread.\n*\n* If this thread is joinable, the calling thread blocks until this thread completes. If the target thread is not joinable, then nothing happens.\n*\n* @return Should not return\n*/\nvoid join() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool setupStdio(Pid createdPid, Pid requesterPid, File_t *outStdin, File_t *outStdout, File_t *outStderr, File_t inStdin, File_t inStdout,File_t inStderr)\r\n{\r\n\tuint32_t thisPid = GetPid();\r\n\tif (!createPipe(thisPid, requesterPid, createdPid, inStdin, outStdin, STDIN_FILENO)) return false;\r\n\tif (!createPipe(thisPid, requesterPid, createdPid, inStdout, outStdout, STDOUT_FILENO)) return false;\r\n\tif (!createPipe(thisPid, requesterPid, createdPid, inStderr, outStderr, STDERR_FILENO)) return false;\r\n\r\n\treturn true;\r\n}\r\n",
        "answer": "/** @brief Setup standard input & output streams for a process.\n*\n*  This function creates the standard input and output streams for a process with the given pid,\n*  and writes the result to the output parameters.\n*\n* @param createdPid The pid of the process for which the stdio is being set up.\n* @param requesterPid The pid of the process that requested the stdio setup.\n* @param outStdin A pointer to a File_t object where the standard input stream will be written.\n* @param outStdout A pointer to a File_t object where the standard output stream will be written.\n* @param outStderr A pointer to a File_t object where the standard error stream will be written.\n* @param inStdin The standard input stream for the process.\n* @param inStdout The standard output stream for the process.\n* @param inStderr The standard error stream for the process.\n*\n* @return True if the stdio was set up successfully, false otherwise.\n*/\nbool setupStdio(Pid createdPid, Pid requesterPid, File_t *outStdin, File_t *outStdout, File_t *outStderr, File_t inStdin, File_t inStdout,File_t inStderr)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tint  SetSendCodec(int channel_id, const Sid::String& Name, int PacketSize, int BitRate, int PayloadType)\n\t{\n\t    SID_INFO(\"SetSendCodec: name %s(%d), PacketSize %d, Bitrate %d\", Name.data(), PayloadType, PacketSize, BitRate);\n\t    return 1;\n\t}\n",
        "answer": "/** @brief Set the codec and packet size used for recording.\n*\n*  This function is called before and during recording, but not before playback. SkypeKit can decide which codec to use for recording, but for playback the Voice Engine has to play whatever is in the RTP packets. It means when playing a voicemail, SetSendCodec will not be called. While the codec name and payload type is decided before starting recording and doesn't change during recording, the packet size will change during recording. Also for variable bitrate codecs, bitrate will change.\n*\n*  @param channel_id The ID of the channel to set the send codec for.\n*  @param Name The name of the codec to use.\n*  @param PacketSize The packet size to use.\n*  @param BitRate The bitrate to use.\n*  @param PayloadType The payload type to use.\n*\n*  @return 1 if successful, -1 otherwise.\n*/\nint SetSendCodec(int channel_id, const Sid::String& Name, int PacketSize, int BitRate, int PayloadType)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool RequestKeyFrame() {\n\t\tFUNCLOG;\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Requests a key frame from the codec.\n*\n*  This function requests that the codec generate an I-frame. For FORMAT_RTP SPS, PPS and IDR have to be inside same frame - all packets containing SPS, PPS and IDR will have same timestamp and final packet has marker bit set. In case of FORMAT_FRAMES they just need to be inside single annex-B frame and given to skypekit with one SendFrame call.\n*\n* @return true if the key frame was requested successfully, false otherwise.\n*/\nvirtual bool RequestKeyFrame() "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool StartRecording(int fourcc, int initial_max_packet_size, int initial_bitrate_bytes_sec, int width, int height, int initial_framerate_fps) {\n\t\tFUNCLOG;\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Start recording video, encoding it and sending RTP packets to the given transport.\n*\n*  This function starts recording video, encodes it and sends RTP packets to the given transport.\n*  The parameters are:\n*   - fourcc: defines the encoder\n*   - initial_max_packet_size: max packet size to use\n*   - initial_bitrate_bytes_sec: initial bitrate for video call\n*   - width: recording width\n*   - height: recording height\n*   - initial_framerate_fps: initial framerate for video call\n*\n*  @return true if the function was successful, false otherwise.\n*/\nvirtual bool StartRecording(int fourcc, int initial_max_packet_size, int initial_bitrate_bytes_sec, int width, int height, int initial_framerate_fps) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool GetCodec(int index, VideoCodec &codec ) {\n\t\tFUNCLOG;\n\t\tif ( index != 1 )\n\t\t\treturn false;\n\t\tcodec.fourcc = 1234;\n\t\tcodec.recording_capable = 1;\n\t\tcodec.payload_format = FORMAT_FRAMES;\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Get index-th codec that is supported by PVE.\n*\n*  This function returns the index-th codec that is supported by PVE. The index starts from 0 and may not exceed the value codec_count - 1, where codec_count is acquired with GetCodecCount function.\n*\n* @param index - index of the structure, index starts from 0 and may not exceed the value codec_count - 1 where codec_count is acquired with GetCodecCount function\n* @param codec - an empty VideoCodec structure that will be filled by PVE\n*\n* @return true if the index-th codec was found and returned, false otherwise\n*/\nbool GetCodec(int index, VideoCodec &codec ) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tbool CustomCommand(const Sid::String &cmd, Sid::String &result_str) {\n\t\tif ( cmd == \"command\" ) {\n\t\t\tresult_str = \"response\";\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
        "answer": "/** @brief Send custom string command to PVE from UI, and get an answer back. Can be used for example when UI wants to adjust camera specific settings like brightness or zoom.\n*\n*  This function sends a custom string command to the PVE (Physical View Engine) from the UI (User Interface), and gets an answer back. It can be used to adjust camera-specific settings such as brightness or zoom.\n*\n* @param cmd The custom string command to send to the PVE.\n* @param result_str The response from the PVE.\n*\n* @return True if the command was successful, false otherwise.\n*/\nbool CustomCommand(const Sid::String &cmd, Sid::String &result_str) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isStGraph(const Graph &G, node &s, node &t, edge &st)\n{\n\tst = 0;\n\n\thasSingleSource(G,s);\n\thasSingleSink  (G,t);\n\n\tif (s == 0 || t == 0 || isAcyclic(G) == false) {\n\t\ts = t = 0;\n\t\treturn false;\n\t}\n\n\tedge e;\n\tforall_adj_edges(e,s) {\n\t\tif (e->target() == t) {\n\t\t\tst = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (st != 0);\n}\n",
        "answer": "/** @brief Checks if a directed graph is an st-digraph.\n*\n*  An st-digraph is a directed graph that is acyclic, contains exactly one source s and one sink t, and the edge (s,t).\n*\n* @param G The input graph.\n* @param s The source node.\n* @param t The sink node.\n* @param st The edge from the source to the sink.\n*\n* @return True if the graph is an st-digraph, false otherwise.\n*/\nbool isStGraph(const Graph &G, node &s, node &t, edge &st)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "\tvirtual bool onDetectAtomicCycle(std::vector<size_t>& cycle)\n\t{\n\t\tif(cycle.size() == 3 && !m_three)\n\t\t\tm_three = true;\n\t\telse if(cycle.size() == 4 && !m_four)\n\t\t\tm_four = true;\n\t\telse if(cycle.size() == 5 && !m_five)\n\t\t\tm_five = true;\n\t\telse\n\t\t\tThrowError(\"Unexpected cycle\");\n\t\treturn true;\n\t}\n",
        "answer": "/** @brief Callback function for detecting atomic cycles.\n*\n*  This function is called whenever an atomic cycle is detected in the graph. The cycle is passed as a vector of vertex indices, and the function returns a boolean value indicating whether to continue finding more atomic cycles or stop immediately.\n*\n* @param[in] cycle A vector of vertex indices representing the atoms in the cycle.\n* @return True if the search should continue, false if it should stop immediately.\n*/\nvirtual bool onDetectAtomicCycle(std::vector<size_t>& cycle)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void embedScanTime(const string& idpDbFilepath,\r\n                   const string& sourceSearchPath,\r\n                   const map<int, QuantitationConfiguration>& quantitationMethodBySource,\r\n                   pwiz::util::IterationListenerRegistry* ilr)\r\n{\r\n    embedScanTime(idpDbFilepath, sourceSearchPath, defaultSourceExtensionPriorityList(), quantitationMethodBySource, ilr);\r\n}\r\n",
        "answer": "/** @brief Embed scan time in the idpDB.\n*\n*  This function searches for source files of the idpDB using the given search path, using the default source extensions, and embeds the scan start times of the source's spectra in the ScanTimeInSeconds column of the idpDB.\n*\n* @param[in] idpDbFilepath The filepath of the idpDB.\n* @param[in] sourceSearchPath The search path for the source files.\n* @param[in] quantitationMethodBySource A map of quantitation methods by source.\n* @param[in] ilr An iteration listener registry.\n* @return void\n*/\nvoid embedScanTime(const string& idpDbFilepath,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "PWIZ_API_DECL CVID pepXMLSoftwareNameToCVID(const std::string& softwareName)\r\n{\r\n    return AnalysisSoftwareTranslator::instance->translate(softwareName);\r\n}\r\n",
        "answer": "/** @brief Converts a software name stored in pepXML software element into its corresponding CVID, or CVID_Unknown if no mapping was found.\n*\n* This function converts a software name stored in pepXML software element into its corresponding CVID, or CVID_Unknown if no mapping was found.\n*\n* @param[in] softwareName The software name to be converted.\n*\n* @return The corresponding CVID, or CVID_Unknown if no mapping was found.\n*/\nPWIZ_API_DECL CVID pepXMLSoftwareNameToCVID(const std::string& softwareName)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void decodePic(\r\n        const std::vector<unsigned char> &data,  \r\n        std::vector<double> &result\r\n) {\r\n    size_t dataSize = data.size();\r\n    result.resize(dataSize * 2);\r\n    size_t decodedLength = decodePic(&data[0], dataSize, &result[0]);\r\n    result.resize(decodedLength);\r\n}\r\n",
        "answer": "/** @brief Decodes data encoded by encodePic result vector guaranteedly shorter than twice the data length (in nbr of values)\n*\n*  This function decodes data that was previously encoded using the encodePic function. The resulting vector is guaranteed to be shorter than twice the original data length, in number of values.\n*\n* @param[in] data The data to be decoded, represented as a vector of unsigned chars.\n* @param[out] result The decoded data, represented as a vector of doubles.\n*/\nvoid decodePic(const std::vector<unsigned char> &data, std::vector<double> &result) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void b2SetAllocFreeCallbacks(b2AllocFunction allocCallback,\n\t\t\t\t\t\t\t b2FreeFunction freeCallback, void* callbackData)\n{\n\tb2Assert((allocCallback && freeCallback) ||\n\t\t\t (!allocCallback && !freeCallback));\n\tb2Assert(0 == b2GetNumAllocs());\n\tif (allocCallback && freeCallback)\n\t{\n\t\tb2_allocCallback = allocCallback;\n\t\tb2_freeCallback = freeCallback;\n\t\tb2_callbackData = callbackData;\n\t}\n\telse\n\t{\n\t\tb2_allocCallback = b2AllocDefault;\n\t\tb2_freeCallback = b2FreeDefault;\n\t\tb2_callbackData = NULL;\n\t}\n}\n",
        "answer": "/** @brief Set alloc and free callbacks to override the default behavior of using malloc() and free() for dynamic memory allocation.\n*\n*  This function sets the alloc and free callbacks to override the default behavior of using malloc() and free() for dynamic memory allocation.\n*  The allocCallback and freeCallback parameters are used to specify the custom allocation and deallocation functions, respectively.\n*  If either parameter is NULL, the corresponding callback will be set to its default value (malloc() or free()).\n*\n* @param[in] allocCallback A pointer to a function that will be called when memory needs to be allocated.\n* @param[in] freeCallback A pointer to a function that will be called when memory needs to be deallocated.\n* @param[in] callbackData A pointer to data that will be passed to the allocation and deallocation functions.\n*\n* @return void\n*/\nvoid b2SetAllocFreeCallbacks(b2AllocFunction allocCallback,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int SocketInit()\n{\n#ifdef WIN32\n\n\tWSADATA wsaData;\n\tWORD versionRequested;\n\n\tversionRequested = MAKEWORD(2, 2);\n\n\tif (0 != WSAStartup(versionRequested, &wsaData))\n\t{\n\t\treturn -1;\n\t}\n\n#else\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n#endif\n\n\treturn 0;\n}\n",
        "answer": "/** @brief Initializes the socket library.\n*\n* This function initializes the socket library for use on Windows or Linux platforms. On Windows, it calls WSAStartup() to initialize the Winsock 2.2 library and sets up a signal handler for SIGPIPE. On Linux, it sets up a signal handler for SIGPIPE.\n*\n* @return Returns 0 if successful, -1 otherwise.\n*/\nint SocketInit()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "nsString ConvertRating(nsAString const & aRating) {\n  nsresult rv;\n  if (aRating.IsEmpty()) {\n    return nsString();\n  }\n  PRInt32 rating = aRating.ToInteger(&rv, 10);\n  nsString result;\n  if (NS_SUCCEEDED(rv)) {\n    result.AppendInt((rating + 10) / 20, 10);\n  }\n  return result;\n}\n",
        "answer": "/** @brief Convert the iTunes rating value specified by aITunesMetaValue to a Songbird rating property value and return the result. 1 star is the same as 20 in iTunes\n*\n* @param[in] aRating The iTunes rating value to convert\n* @return The converted Songbird rating property value\n*/\nnsString ConvertRating(nsAString const & aITunesMetaValue) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int sb_vscprintf(LPCWSTR aFormat,\n                 va_list aArgs)\n{\n  return _vscwprintf(aFormat, aArgs);\n}\n",
        "answer": "/** @brief Overloaded wrapper for the _vscwprintf function.\n*\n* This is needed by the sb_vprintf template so it can support CHAR and WCHAR types regardless of what type TCHAR is.\n*\n* @param aFormat The format string to use for printing.\n* @param aArgs The arguments to be printed.\n*\n* @return The number of characters that would have been written if the buffer had been large enough.\n*/\nint sb_vscprintf(LPCWSTR aFormat, va_list aArgs)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "U8 Souliss_RemoteInput(U16 addr, U8 slot, U8 command)\n{\n\tU8 cmd = command;\n\treturn MaCaco_send(addr, MaCaco_FORCEREGSTR, 0x00, MaCaco_IN_s + slot, 1, &cmd);\n}\n",
        "answer": "/** @brief Souliss Remote Input.\n*\n* This function acts as a remote input for the network node. It writes directly into the inputs map of another node, data are moved directly without a subscription, so no channel healthy is provided.\n*\n* @param addr The address of the node to write to.\n* @param slot The slot number to write to.\n* @param command The command to send.\n*\n* @return The result of the MaCaco_send function call.\n*/\nU8 Souliss_RemoteInput(U16 addr, U8 slot, U8 command)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "U16 Souliss_GetLocalAddress(U8 *memory_map)\n{\n\treturn C8TO16(memory_map);\n}\n",
        "answer": "/** @brief Get the addresses of local nodes from the memory map, identify if a node has been set as gateway at runtime.\n*\n*  This function retrieves the addresses of local nodes from the memory map and identifies if a node has been set as gateway at runtime.\n*\n* @param[in] memory_map The memory map to retrieve the addresses from.\n* @return The address of the local node, or 0 if no node is found.\n*/\nU16 Souliss_GetLocalAddress(U8 *memory_map)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "U8 Souliss_RemoteLowDigIn2State(U8 pin, U8 value_state_on, U8 value_state_off, U16 addr, U8 slot)\n{\n\ts_value = Souliss_LowDigIn2State(pin, value_state_on, value_state_off, 0, slot);\n\t\n\tif(s_value)\n\t\treturn MaCaco_send(addr, MaCaco_FORCEREGSTR, 0x00, MaCaco_IN_s + slot, 1, &s_value);\n\telse\n\t\treturn 0;\n}\n",
        "answer": "/** @brief Link an hardware pin to the shared memory map of another (remote node), use with latched two state pushbutton, active on falling edge.\n*\n* This function links a hardware pin to the shared memory map of another (remote) node, using a latched two-state pushbutton that is active on falling edge.\n*\n* @param[in] pin The hardware pin number to be linked.\n* @param[in] value_state_on The state value for when the button is pressed and released.\n* @param[in] value_state_off The state value for when the button is not pressed.\n* @param[in] addr The address of the remote node to be linked.\n* @param[in] slot The slot number in the shared memory map of the remote node.\n*\n* @return Returns 0 if successful, or an error code if unsuccessful.\n*/\nU8 Souliss_RemoteLowDigIn2State(U8 pin, U8 value_state_on, U8 value_state_off, U16 addr, U8 slot)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "uint16_t vNet_GetSourceAddress_M2()\n{\n\treturn 0;\n}\n",
        "answer": "/** @brief Get the source address of the last received frame.\n*\n* This function returns the source address of the last received frame.\n*\n* @return The source address of the last received frame.\n*/\nuint16_t vNet_GetSourceAddress_M2()"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "    close(fd_gyro);\n\n\t/* XXX add poll-rate tests here too */\n\terrx(0, \"PASS\");\n\treturn;\n}\n\n/**\n * Reset the driver.\n */\nvoid\nreset(int external_bus)\n{\n\tint fd = 0;\n\t\n\tif(external_bus)\n\t\tfd = open(I3G4250D_EXT_DEVICE_PATH, O_RDONLY);\n\telse\n\t\tfd = open(I3G4250D_DEVICE_PATH, O_RDONLY);\n\t\n\tif (fd < 0)\n    {\n\t\terr(1, \"failed \");\n\t\treturn;\n\t}\n\n\tif (ioctl(fd, SENSORIOCRESET, 0) < 0)\n    {\n\t\terr(1, \"driver reset failed\");\n\t\treturn;\n\t}\n\n\tif (ioctl(fd, SENSORIOCSPOLLRATE, SENSOR_POLLRATE_DEFAULT) < 0){\n\t\terr(1, \"accel pollrate reset failed\");\n\t\treturn;\n\t}\n    close(fd);\n\n\treturn;\n}\n\n/**\n * Print a little info about the driver.\n */\nvoid\n",
        "answer": ""
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int  orb_subscribe_multi(const struct orb_metadata *meta, unsigned instance)\n{\n\treturn uORB::Manager::get_instance()->orb_subscribe_multi(meta, instance);\n}\n",
        "answer": "/** @brief Subscribe to a multi-instance of a topic.\n*\n*  This function subscribes to a specific instance of a topic and returns a file descriptor that can be used to poll for updates, read the topic, check if it has been updated, and get information about the topic. If the topic has not been advertised yet, the subscription will succeed but the topic will have a timestamp of zero and will never signal a poll event or check as true. When the topic is subsequently advertised, poll, check, stat, and copy calls will react to the initial publication that is performed as part of the advertisement. Subscription will fail if the topic is not known to the system, i.e. there is nothing in the system that has declared the topic and thus it can never be published.\n*\n* @param meta The metadata for the topic to subscribe to.\n* @param instance The instance of the topic to subscribe to.\n* @return A file descriptor that can be used to poll, read, check, stat, and copy the topic.\n*/\nint  orb_subscribe_multi(const struct orb_metadata *meta, unsigned instance)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int setValue(PySideProperty* self, PyObject* source, PyObject* value)\n{\n    PyObject* fset = self->d->fset;\n    if (fset) {\n        Shiboken::AutoDecRef args(PyTuple_New(2));\n        PyTuple_SET_ITEM(args, 0, source);\n        PyTuple_SET_ITEM(args, 1, value);\n        Py_INCREF(source);\n        Py_INCREF(value);\n        Shiboken::AutoDecRef result(PyObject_CallObject(fset, args));\n        return (result.isNull() ? -1 : 0);\n    } else {\n        PyErr_SetString(PyExc_AttributeError, \"Attibute read only\");\n    }\n    return -1;\n}\n",
        "answer": "/**\n* @brief Set value of a property.\n*\n* This function sets the value of a property using the provided source and value objects.\n* If the property has a setter function, it will be called with the source and value as arguments.\n* Otherwise, an error will be raised.\n*\n* @param self The PySideProperty object to set the value for.\n* @param source The source object to use when calling the setter function.\n* @param value The value object to use when calling the setter function.\n* @return 0 if successful, -1 if an error occurred.\n*/\nint setValue(PySideProperty* self, PyObject* source, PyObject* value) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool isScriptable(const PySideProperty* self)\n{\n    return self->d->scriptable;\n}\n",
        "answer": "/** @brief Checks if property has the flag SCRIPTABLE setted.\n*\n*  This function does not check the property object type.\n*\n* @param self The PySideProperty to be checked.\n* @return True if the property has the flag SCRIPTABLE setted, false otherwise.\n*/\nbool isScriptable(const PySideProperty* self)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "int main(int argc, char **argv)\n{\n    QApplication app(argc, argv);\n    RSSListing *rsslisting = new RSSListing;\n    rsslisting->show();\n    return app.exec();\n}\n",
        "answer": "/** @brief Main function for the application.\n*\n* This is the entrypoint for the application, and it creates an instance of the QApplication class.\n* It also creates a new RSSListing widget and shows it to the user. Finally, it returns the result of the app.exec() function, which runs the event loop and handles user input.\n*\n* @param argc The number of command-line arguments passed to the application.\n* @param argv An array of strings containing the command-line arguments passed to the application.\n* @return The return value of the app.exec() function, which indicates whether the application exited successfully or not.\n*/\nint main(int argc, char **argv)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void print_util_putstring_length(byte_stream_t* out_stream, const char* s, unsigned long len)\r\n{\r\n    if ((out_stream == NULL) || (out_stream->put == NULL))\r\n    {\r\n        return;\r\n    }\r\n    while (len--)\r\n    {\r\n        out_stream->put(out_stream->data, *s);\r\n        s++;\r\n    }\r\n}\r\n",
        "answer": "/** @brief Prints a string of a given length to an output stream.\n*\n*  This function takes a byte stream and a character string as input, and prints the string to the stream up to the specified length.\n*\n* @param out_stream The output stream to print to.\n* @param s The character string to print.\n* @param len The maximum number of characters to print from the string.\n* @return Void.\n*/\nvoid print_util_putstring_length(byte_stream_t* out_stream, const char* s, unsigned long len)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void vmaGetMemoryProperties(\r\n                            VmaAllocator allocator,\r\n                            const VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)\r\n{\r\n    VMA_ASSERT(allocator && ppPhysicalDeviceMemoryProperties);\r\n    *ppPhysicalDeviceMemoryProperties = &allocator->m_MemProps;\r\n}\r\n",
        "answer": "/** @brief Retrieves the memory properties from a VmaAllocator.\n*\n* This function retrieves the physical device memory properties from a VmaAllocator, which can be used to allocate and manage memory on the device.\n*\n* @param allocator The VmaAllocator object to retrieve the memory properties from.\n* @param ppPhysicalDeviceMemoryProperties A pointer to a pointer to a VkPhysicalDeviceMemoryProperties structure, which will be filled with the physical device memory properties.\n*/\n*ppPhysicalDeviceMemoryProperties = &allocator->m_MemProps;\n}"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void vmaCreateLostAllocation(\r\n                             VmaAllocator allocator,\r\n                             VmaAllocation* pAllocation)\r\n{\r\n    VMA_ASSERT(allocator && pAllocation);\r\n    \r\n    VMA_DEBUG_GLOBAL_MUTEX_LOCK;\r\n    \r\n    allocator->CreateLostAllocation(pAllocation);\r\n    \r\n#if VMA_RECORDING_ENABLED\r\n    if(allocator->GetRecorder() != VMA_NULL)\r\n    {\r\n        allocator->GetRecorder()->RecordCreateLostAllocation(\r\n                                                             allocator->GetCurrentFrameIndex(),\r\n                                                             *pAllocation);\r\n    }\r\n#endif\r\n}\r\n",
        "answer": "/**\n* @brief Creates a lost allocation.\n*\n* This function creates a new VmaAllocation object that represents a lost allocation. A lost allocation is an allocation that has been marked as lost by the Vulkan device due to some error or other issue. It cannot be used for any purpose and must be destroyed using vmaFreeMemory().\n*\n* @param allocator The allocator to use for creating the lost allocation.\n* @param pAllocation A pointer to a VmaAllocation object that will be filled with information about the lost allocation.\n*/\nvoid vmaCreateLostAllocation(VmaAllocator allocator, VmaAllocation* pAllocation);"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool WINAPI tdSetProtocol(int intDeviceId, const char* strProtocol) {\n\tTelldusCore::Message msg(L\"tdSetProtocol\");\n\tmsg.addArgument(intDeviceId);\n\tmsg.addArgument(strProtocol);\n\treturn TelldusCore::Client::getBoolFromService(msg);\n}\n",
        "answer": "/** @brief Changes the current protocol used by a device.\n*\n*  This function changes the current protocol used by a device. After changing the protocol, setting new parameters is required.\n*\n* @param intDeviceId The ID of the device to change the protocol for.\n* @param strProtocol The new protocol to use.\n*\n* @return True if the protocol was changed successfully, false otherwise.\n*/\nbool WINAPI tdSetProtocol(int intDeviceId, const char* strProtocol) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "void cCreateCylinder(cMesh* a_mesh, \n    const double& a_height,  \n    const double& a_radius,\n    const unsigned int a_numSides,\n    const unsigned int a_numHeightSegments,\n    const unsigned int a_numRings,\n    const bool a_includeTop,\n    const bool a_includeBottom,\n    const cVector3d& a_pos,\n    const cMatrix3d& a_rot,\n    const cColorf& a_color)\n{\n    cCreateCone(a_mesh, \n                a_height,  \n                a_radius,\n                a_radius,\n                a_numSides,\n                a_numHeightSegments,\n                a_numRings,\n                a_includeBottom,\n                a_includeTop,\n                a_pos,\n                a_rot,\n                a_color);\n}\n",
        "answer": "/** @brief Create a cylinder by defining its radius and height.\n*\n*  This function creates a cylinder by defining its radius and height. The user may also decide if the top and bottom discs should be included. Texture coordinates are defined so that the bitmap image wraps around the cylinder. The texture coordinates for the top part of the cylinder are set to (0.0, 0.0, 0.0). The texture coordinates for the bottom part of the cylinder are set to (1.0, 1.0, 0.0). When texture is enabled, the colors defining the top and bottoms sections of the cylinder are defined by both texels.\n*\n* @param a_mesh A pointer to the mesh object that will be used to create the cylinder.\n* @param a_height The height of the cylinder.\n* @param a_radius The radius of the cylinder.\n* @param a_numSides The number of sides of the cylinder.\n* @param a_numHeightSegments The number of height segments of the cylinder.\n* @param a_numRings The number of rings of the cylinder.\n* @param a_includeTop A boolean value indicating whether to include the top disc of the cylinder.\n* @param a_includeBottom A boolean value indicating whether to include the bottom disc of the cylinder.\n* @param a_pos The position of the center of the cylinder.\n* @param a_rot The rotation matrix for the cylinder.\n* @param a_color The color of the cylinder.\n*/\nvoid cCreateCylinder(cMesh* a_mesh,"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "AttributeList cleanAttributes(AttributeList AS, unsigned Idx, LLVMContext &C) {\n    AttributeList result = AS;\n    result = result.removeAttribute(C, Idx, Attribute::AttrKind::AlwaysInline);\n    result = result.removeAttribute(C, Idx, Attribute::AttrKind::InlineHint);\n    result = result.removeAttribute(C, Idx, Attribute::AttrKind::NoInline);\n    return result;\n}\n",
        "answer": "/** @brief Remove chosen attributes from the attribute set at the given index of the given attribute list.\n*\n*  Since attribute lists are immutable, they must be copied all over.\n*\n* @param AS The attribute list to remove attributes from.\n* @param Idx The index of the attribute to remove.\n* @param C The LLVM context.\n* @return The updated attribute list with the chosen attributes removed.\n*/\nAttributeList cleanAttributes(AttributeList AS, unsigned Idx, LLVMContext &C) "
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "tresult getSpeakerChannelIndex (SpeakerArrangement arrangement, uint64 speaker, int32& channel)\n{\n\tchannel = SpeakerArr::getSpeakerIndex (speaker, arrangement);\n\treturn channel < 0 ? kResultFalse : kResultTrue;\n}\n",
        "answer": "/** @brief Gets the channel index of a given speaker in a arrangement.\n*\n* This function takes in a SpeakerArrangement and a uint64 speaker as input, and returns the channel index of the speaker in the arrangement. If the speaker is not part of the arrangement, it returns kResultFalse.\n*\n* @param[in] arrangement The SpeakerArrangement to search for the speaker in.\n* @param[in] speaker The uint64 speaker to get the channel index for.\n* @param[out] channel The int32 channel index of the speaker in the arrangement.\n* @return kResultTrue if the speaker is part of the arrangement, kResultFalse otherwise.\n*/\ntresult getSpeakerChannelIndex (SpeakerArrangement arrangement, uint64 speaker, int32& channel)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static void printDocMetadata(const Tree expr, ostream& docout)\n{\n\tif (gGlobal->gMetaDataSet.count(expr)) {\n\t\tstring sep = \"\";\n\t\tset<Tree> mset = gGlobal->gMetaDataSet[expr];\n\t\t\n\t\tfor (set<Tree>::iterator j = mset.begin(); j != mset.end(); j++) {\n\t\t\tdocout << sep << unquote(tree2str(*j));\n\t\t\tsep = \", \";\n\t\t}\n\t}\n}\n",
        "answer": "/** @brief Print a metadata set. Each metadata is a set, in order to handle multiple items, like multiple authors, even if most of metadatas have unique items.\n*\n*  This function prints a metadata set. It takes the expression and an output stream as input, and it uses the global meta data set to print the metadata for that expression. If there is no metadata for the given expression, nothing is printed.\n*\n* @param expr The expression for which to print the metadata.\n* @param docout The output stream to use for printing the metadata.\n*/\nstatic void printDocMetadata(const Tree expr, ostream& docout)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static bool isPureRouting(Tree t)\n{\n    bool    r;\n    int     ID;\n    Tree    x,y;\n\n    if (gGlobal->gPureRoutingProperty->get(t,r)) {\n        return r;\n    } else if (    isBoxCut(t)\n                || isBoxWire(t)\n                || isInverter(t)\n                || isBoxSlot(t, &ID)\n                || (isBoxPar(t,x,y) && isPureRouting(x) && isPureRouting(y))\n                || (isBoxSeq(t,x,y) && isPureRouting(x) && isPureRouting(y))\n                || (isBoxSplit(t,x,y) && isPureRouting(x) && isPureRouting(y))\n                || (isBoxMerge(t,x,y) && isPureRouting(x) && isPureRouting(y))\n              ) {\n        gGlobal->gPureRoutingProperty->set(t,true);\n        return true;\n    } else {\n        gGlobal->gPureRoutingProperty->set(t,false);\n        return false;\n    }\n}\n",
        "answer": "/** @brief Check if a tree is a pure routing expression.\n*\n*  This function checks if a given tree is a pure routing expression, which means it only contains cut, wires and slots. No labels will be displayed for pure routing expressions.\n*\n* @param t The tree to check.\n* @return true if the tree is a pure routing expression, false otherwise.\n*/\nstatic bool isPureRouting(Tree t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "static Tree buildPowTerm(Tree f, int q)\n{\n\tassert(f);\n\tassert(q>0);\n\tif (q>1) {\n\t\treturn sigPow(f, q);\n\t} else {\n\t\treturn f;\n\t}\n}\n",
        "answer": "/** @brief Build a power term of type f**q -> (((f.f).f)..f) with q>0\n*\n*  This function builds a power term of type f**q, where q is a positive integer.\n*  The resulting term is constructed by applying the sigPow function to the input tree f and the power q.\n*  If q=1, the function returns the original input tree f.\n*\n* @param[in] f The input tree to be raised to the power of q.\n* @param[in] q The positive integer power to which the input tree should be raised.\n* @return A new tree representing the power term f**q.\n*/\nstatic Tree buildPowTerm(Tree f, int q)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "Tree codeAudioType(AudioType* t)\n{\n    SimpleType \t*st;\n    TableType   *tt;\n    TupletType\t*nt;\n\n    Tree        r;\n\n    if ((r=t->getCode())) return r;\n\n    if ((st = isSimpleType(t))) {\n        r = codeSimpleType(st);\n    } else if ((tt = isTableType(t))) {\n        r = codeTableType(tt);\n    } else if ((nt = isTupletType(t))) {\n        r = codeTupletType(nt);\n    } else {\n        stringstream error;\n        error << \"ERROR in codeAudioType() : invalide pointer \" << t << endl;\n        throw faustexception(error.str());\n    }\n\n    r->setType(t);\n    return r;\n}\n",
        "answer": "/** @brief Code an audio type as a tree in order to benefit from memoization.\n*  The type field (of the coded type) is used to store the audio type.\n*\n*  @param t Pointer to the audio type to be coded.\n*  @return A tree representing the audio type.\n*/\nTree codeAudioType(AudioType* t)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "bool SelectParamsFromCommandLine()\n{\n    bool fRegTest = GetBoolArg(\"-regtest\", false);\n    bool fTestNet = GetBoolArg(\"-testnet\", false);\n\n    if (fTestNet && fRegTest)\n    {\n        return false;\n    };\n\n    if (fRegTest)\n    {\n        SelectParams(CChainParams::REGTEST);\n    } else\n    if (fTestNet)\n    {\n        SelectParams(CChainParams::TESTNET);\n    } else\n    {\n        SelectParams(CChainParams::MAIN);\n    };\n\n    return true;\n}\n",
        "answer": "/** @brief Selects parameters from the command line.\n*\n*  This function looks for -regtest or -testnet and then calls SelectParams as appropriate. Returns false if an invalid combination is given.\n*\n* @param fRegTest A boolean indicating whether the regtest parameter was passed.\n* @param fTestNet A boolean indicating whether the testnet parameter was passed.\n* @return true if the parameters were selected successfully, false otherwise.\n*/\nbool SelectParamsFromCommandLine(bool fRegTest, bool fTestNet)"
    },
    {
        "question": "Create a doxygen comment for the following C++ Function.",
        "context": "long nec_gn_card(nec_context* in_context, int iperf, int nradl, \n                 double epse, double sig, double tmp3, double tmp4, double tmp5, double tmp6) {\n  NEC_ERROR_HANDLE(in_context->gn_card(iperf, nradl, epse, sig, tmp3, tmp4, tmp5, tmp6));\n}\n",
        "answer": "/**\n* @brief NEC ground plane card function.\n*\n* This function calculates the ground plane card for a given set of parameters.\n*\n* @param in_context The NEC context object.\n* @param iperf The number of periods per foot.\n* @param nradl The number of radials.\n* @param epse The permittivity of the surrounding medium.\n* @param sig The conductivity of the ground plane.\n* @param tmp3 Unused parameter.\n* @param tmp4 Unused parameter.\n* @param tmp5 Unused parameter.\n* @param tmp6 Unused parameter.\n* @return The calculated ground plane card.\n*/\nlong nec_gn_card(nec_context* in_context, int iperf, int nradl,"
    }
]